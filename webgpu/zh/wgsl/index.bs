<pre class='metadata'>
Title: WebGPU Shading Language
Shortname: WGSL
Level: None
Status: LD
ED:  
Text Macro: INT i32 or u32
Text Macro: UNSIGNEDINTEGRAL u32 or vec|N|&lt;u32&gt;
Text Macro: SIGNEDINTEGRAL i32 or vec|N|&lt;i32&gt;
Text Macro: INTEGRAL i32, u32, vec|N|&lt;i32&gt;, or vec|N|&lt;u32&gt;
Text Macro: FLOATING f32 or vec|N|&lt;f32&gt;
Ignored Vars: i, e, e1, e2, e3, eN, N, M, v, Stride, Offset, Align, Extent, S, T, T1

Editor: 赵凌云，lingyun.zhao@orillusion.com
Editor: 薛沛，pei.xue@orillusion.com

Abstract: WGSL 翻译文档。本翻译非官方翻译。
Markup Shorthands: markdown yes
Markup Shorthands: dfn yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
Boilerplate: omit conformance
</pre>

<style>
tr:nth-child(2n) {
  background-color: #b0b0b050;
}
thead {
  background-color: #b0b0b050;
  font-weight: bold;
}
.nowrap {
  white-space:nowrap;
}
.small {
  font-size: smaller;
}
div.syntax {
  display: block;
  page-break-before: avoid;
  padding: .5em 1em;
  background: var(--def-bg);
  border-left: 0.5em solid var(--def-border);
  color: black;
  color: var(--def-text);
  margin-block-start: 1em;
  margin-block-end: 1em;
}
div.syntax > p {
  margin-block-start: 0em;
  margin-block-end: 0em;
  margin-inline-start: 1em;
  margin-inline-end: 0em;
}
div.syntax > p::first-letter {
  letter-spacing: 0.5em;
}
div.syntax > p > a {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
}
div.syntax > p > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
}
</style>

<pre class=biblio>
{
  "WebGPU": {
    "authors": [
      "Dzmitry Malyshau",
      "Justin Fan",
      "Kai Ninomiya"
    ],
    "href": "https://gpuweb.github.io/gpuweb/",
    "title": "WebGPU",
    "status": "Editor's Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "IEEE-754":{
    "href":"http://ieeexplore.ieee.org/servlet/opac?punumber=4610933",
    "title":"IEEE Standard for Floating-Point Arithmetic",
    "publisher":"Institute of Electrical and Electronics Engineers",
    "isbn":"978-0-7381-5752-8",
    "versions":["IEEE-754-2008","IEEE-754-1985"],
    "id":"IEEE-754",
    "date":"29 August 2008"
  },
  "SPIR-V": {
    "authors": [
      "John Kessenich",
      "Boaz Ouriel",
      "Raun Krisch"
    ],
    "href": "https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html",
    "title": "SPIR-V Specification",
    "publisher": "Khronos Group"
  },
  "VulkanMemoryModel": {
    "authors": [
      "Jeff Bolz",
      "Alan Baker",
      "Tobias Hector",
      "David Neto",
      "Robert Simpson",
      "Brian Sumner"
    ],
    "href": "https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model",
    "title": "Vulkan Memory Model",
    "publisher": "Khronos Group"
  }
}
</pre>

<pre class='anchors'>
spec: SPIR-V; urlPrefix: https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#
    type: dfn
        text: image formats; url: _a_id_image_format_a_image_format
</pre>

# 介绍 # {#intro}

WebGPU Shading Language ([SHORTNAME])是为 [[!WebGPU]] 设计的着色器语言。
也就是说，使用 WebGPU API 的应用程序使用 [SHORTNAME] 来表达在 GPU 上运行的程序（称为着色器）。

<div class='example wgsl global-scope'>
  <xmp highlight='rust'>
    [[stage(fragment)]]
    fn main() -> [[location(0)]] vec4<f32> {
        return vec4<f32>(0.4, 0.4, 0.8, 1.0);
    }
  </xmp>
</div>


## 目标 ## {#goals}

 * 可轻松转换为 [[!SPIR-V]]
 * 构造被定义为其对应 [[!SPIR-V]] 的规范参考
 * WGSL 中的所有功能都可以直接转换为 [[!SPIR-V]]。（没有多态，没有通用指针，没有重载等）
 * 特性和语法完全同[[!SPIR-V]]
 * 本规范中的每一项都必须为构造提供到 [[!SPIR-V]] 的映射。

## 技术概览 ## {#technical-overview}

WebGPU 以[[WebGPU#gpu-command|GPU command]]的形式向 GPU 发出一个工作单元。 [SHORTNAME] 关注两种 GPU 命令：
* <dfn noexport>draw command</dfn>在[=pipeline input|inputs=]、[=pipeline output|outputs=]和附加[=resources=]的上下文中执行[=GPUComputePipeline|compute pipeline=]。
* <dfn noexport>dispatch command</dfn>在[=GPUComputePipeline|compute pipeline=]和附加[=resources=]的上下文中执行[=GPUComputePipeline|compute pipeline=]。

这两种管线都使用以[SHORTNAME]编写的着色器。

<dfn noexport>shader</dfn>是WGSL程序的一部分，用于在管线中执行[=shader stage=]。着色器包括：
* 一个[=entry point=] [=function/function=]。
* 所有被调用函数的传递闭包，从入口点开始。该集合包括[=user-defined function|user-defined=]和[=built-in function|built-in=]函数。（有关更严格的定义，请参阅“[=functions in a shader stage=]”。）
* 所有这些函数静态访问（[=statically accessed=]）的一组变量和常量。
* 用于定义或分析所有这些函数、变量和常量的类型集。

执行着色器阶段时，实现：
* 将资源（[=resources=]）绑定到着色器资源接口([=resource interface of a shader|resource interface=])中的变量，使这些资源的内容在执行期间可供着色器使用。
* 为其他模块范围([=module scope|module-scope=])的变量分配内存，并使用指定的初始值填充该内存。
* 使用阶段的管线输入填充入口点的形式参数（如果存在）。
* 将入口点返回值([=return value=])（如果存在）连接到阶段的管线输出。
* 然后它调用入口点。

一个 [SHORTNAME] 程序被组织成：
* 函数，指定执行行为。
* 语句，是可执行行为的声明或单元。
* 文字，是纯数学值的文本表示。
* 常量，每个常量都为在特定时间计算的值提供一个名称。
* 变量，每个变量都为用于保存值的内存存储提供名称。
* 表达式，每个表达式组合一组值以生成结果值。
* 类型，每个类型描述：
    * 一组值。
    * 对受支持表达式的限制。
    * 这些表达式的语义。

[SHORTNAME]是一种命令式语言：行为被指定为要执行的语句序列。声明：
* 声明常量或变量
* 修改变量内容
* 使用结构化编程结构修改执行顺序：
    * 选择：if/else/elseif, switch
    * 重复：loop, for
    * 跳出：break, continue
    * 重构：函数调用和返回
    * 丢弃（仅限片元着色器）：终止调用并丢弃输出

* 评估表达式以计算值作为上述行为的一部分。

[SHORTNAME]是静态类型的：由特定表达式计算的每个值都属于特定类型，仅通过检查程序源来确定。

[SHORTNAME具有以数组和结构的形式描述布尔值、数字、向量、矩阵和它们的聚合的类型。其他类型描述内存。

[SHORTNAME]没有数字或布尔类型之间的隐式转换或提升。 将值从一种数字或布尔类型转换为另一种需要显式转换([[#conversion-expr|conversion]])、构造([[#type-constructor-expr|construction]])或重新解释位([[#bitcast-expr|reinterpretation of bits]])。这也适用于向量类型。

[SHORTNAME]有纹理和采样器类型。连同相关的内置函数，这些支持通常用于图形渲染的功能，并且通常由GPU提供。

着色器阶段的工作被划分为一个或多个调用（<dfn noexport>invocations</dfn>），每个调用都执行入口点，但条件略有不同。着色器阶段中的调用共享对某些变量的访问：
* 阶段中的所有调用共享着色器接口中的资源。
* 在计算着色器（[=compute shader stage|compute shader=]）中，同一工作组（[=compute shader stage/workgroup=]）中的调用共享工作组（[=storage classes/workgroup=]）存储类（[=storage class=]）中的变量。不同工作组中的调用不共享这些变量。

但是，调用作用于不同的管线输入集，包括提供识别值以将调用与其对等调用区分开的内置输入。此外，每个调用在私有（[=storage classes/private=]）和函数（[=storage classes/function=]）存储类中以变量的形式拥有自己独立的内存存储空间。

着色器阶段中的调用并发执行，并且通常可能并行执行。着色器作者负责确保着色器阶段调用的动态行为：

* 满足某些图元操作的一致性要求，包括纹理采样和控制屏障。
* 协调对共享变量的潜在冲突访问，以避免竞争条件。

[SHORTNAME]有时允许给定特征的几种可能行为。这是一种可移植性危害，因为不同的实现可能会表现出不同的行为。WGSL的设计旨在最大限度地减少此类情况，但受到可行性和在各种设备上实现高性能的目标的限制。

## 符号 ## {#notation}

<dfn noexport>floor expression</dfn>在实数|x|上定义：

* &lfloor;|x|&rfloor; = |k|, 其中|k|是一个唯一整数，使得|k| &le; |x| &lt; |k|+1

<dfn noexport>ceiling expression</dfn>在实数|x|上定义：

* &lceil;|x|&rceil; = |k|, 其中|k|是一个唯一整数，使得|k|-1 &lt; |x| &le; |k|

<dfn noexport>roundUp</dfn>函数在正整数|k|和|n|上定义：

* roundUp(|k|, |n|) = &lceil;|n| &div; |k|&rceil; &times; |k|

|n|列|m|行矩阵|A|的转置（<dfn noexport>transpose</dfn>）是将|A|的行复制为|A|<sup>T</sup>的列形成的|m|列|n|行矩阵|A|<sup>T</sup>：

* transpose(|A|) = |A|<sup>T</sup>
* transpose(|A|)<sub>|i|,|j|</sub> = |A|<sub>|j|,|i|</sub>

列向量的转置是通过将列向量解释为1行矩阵来定义的。类似地，行向量的转置是通过将行向量解释为1列矩阵来定义的。

# 着色器生命周期 # {#program-lifecycle}

[SHORTNAME]程序及其可能包含的着色器生命周期中有四个关键事件。前两个对应于用于准备[SHORTNAME]程序以供执行的WebGPU API方法。最后两个是着色器执行的开始和结束。

事件为：

1. <dfn noexport>Shader module creation</dfn>
    * 当[[WebGPU#dom-gpudevice-createshadermodule|WebGPU createShaderModule]]方法被调用后发生。此时[SHORTNAME]程序的源文件被提供。
2. <dfn noexport>Pipeline creation</dfn>
    * 当[[WebGPU#dom-gpudevice-createcomputepipeline|WebGPU createComputePipeline]]或[[WebGPU#dom-gpudevice-createrenderpipeline|WebGPU createRenderPipeline]]方法被调用时发生。这些方法使用一个或更多先前被创建的着色器模块，以及其他配置信息。
3. <dfn noexport>Shader execution start</dfn>
    * 当向GPU发出[=draw command|draw=]或[=dispatch command=]命令、开始执行管线并调用[=shader stage=] [=entry point=]函数时发生。
4. <dfn noexport>Shader execution end</dfn>
    * 当所有着色器中的工作被完成时发生：
        * 所有调用（[=invocations=]）完结。
        * 所有对资源（[=resources=]）的访问完结。
        * 输出（如果有）已经传递给下游管线阶段。

事件按照以下方式排序：
*  数据依赖：着色器执行需要一个管线，一个管线同样需要一个着色器模块。
*  因果关系：着色器必须开始执行才能完成执行。

## 处理错误 ## {#processing-errors}

一个WebGPU实现可能由于两个原因对着色器处理失败：

* 程序错误（<dfn export>program error</dfn>）当着色器不满足[SHORTNAME]或WebGPU规范要求时发生。
* 未分类错误（<dfn noexport>uncategorized error</dfn>）当所有[SHORTNAME]和WebGPU需求都被满足时可能发生，可能的原因包括：
    * 着色器太复杂，超出了实现的能力，但在某种程度上不容易被规定的限制（[[#limits|limits]]）捕获。 简化着色器可能会解决此问题。
    * WebGPU实现中的缺陷。

处理错误可能会发生在着色器生命周期的三个阶段：

* <dfn export>shader-creation error</dfn>是在着色器模块创建时可行检测到的错误。检测必须仅依赖于[SHORTNAME]程序源文本和其他可用于 `createShaderModule` API 方法的信息。

* <dfn export>pipeline-creation error</dfn>是在管线创建时可检测到的错误。检测必须仅依赖于特定管线创建API方法可用的[SHORTNAME]程序源文本和其他信息。

* <dfn export>dynamic error</dfn>是在着色器执行期间发生的错误。这些错误可能会也可能不会被检测到。

注意：比如，一个竞争条件可能不会被检测到。

每个要求将被尽早检查。也就是：
* 当未能满足着色器创建时可检测到的要求，会导致shader-creation错误。
* 当未能满足管线创建时可检测到的要求，但更早无法检测到，会导致pipeline-creation错误。

当上下文不清楚时，本规范会指出未能满足特定要求是否会导致着色器创建、管线创建或动态错误。

WebGPU规范描述了每种错误的后果。

TODO：更新WebGPU规范，参考这里定义的三种错误。

## 限制 ## {#limits}

一个程序必须满足以下限制：

<table class='data'>
  <caption>Quantifiable shader complexity limits</caption>
  <thead>
    <tr><th>Limit<th>Maximum value
  </thead>
    <tr><td>[=structure=]类型中的成员数量<td>16383
    <tr><td>[=composite=]类型中的[=Nesting depth=]<td>255
    <tr><td>一个函数[=formal parameter|parameters=]的数量<td>255
    <tr><td>[=statement/switch=]语句中条件选择值的数量<td>16383
</table>

# 纹理结构 # {#textual-structure}

[SHORTNAME]程序为文本。本规范并未规定该文本的特定编码。但是，UTF-8始终是[SHORTNAME]程序的有效编码。

注意：像这样推广 UTF-8 的目的是为了简化[SHORTNAME]程序的交换并鼓励工具之间的互操作性。

[SHORTNAME]程序文本由一系列字符组成，分组为连续的非空集形成：

* [=comments=]
* [=tokens=]
* [=blankspace=]

<dfn>Blankspace</dfn>是以下一个或多个字符的任意组合：
* space
* horizontal tab
* linefeed
* vertical tab
* formfeed
* carriage return

<div class='syntax' noexport='true'>
  <dfn for=syntax>_space</dfn> :

    | `/\s/`
</div>

问题：还有什么应该是blankspace？Unicode分隔符类别中的一些内容？

要解析一个[SHORTNAME]程序：
1. 去掉注释：
    * 用一个space字符替换第一个注释。
    * 重复直到没有注释。
2. 从头到尾扫描，以贪心的方式将剩余的字符分组为标记和空格：
    * 下一组由剩余未分组字符的最长非空前缀组成，即：
        * 一个有效的token, 或者
        * blankspace
    * 重复直到没有未分组的字符剩余。
3. 去掉blankspace，只留下tokens。
3. 解析token序列，尝试匹配 `translation_unit` 语法规则。

<div class='syntax' noexport='true'>
  <dfn for=syntax>translation_unit</dfn> :

    | [=syntax/global_decl_or_directive=] *
</div>

在以下情况下会导致[=shader-creation error=]：
* 整个源文本无法转换为有限的有效tokens序列，或
* `translation_unit` 语法规则与整个token序列不匹配。

## 注释 ## {#comments}

注释（<dfn>comment</dfn>）是一块不影响[SHORTNAME]程序有效性和含义的文本，只是注释可以分隔[=tokens=]。着色器作者可以使用注释去给程序添加文档信息。

行尾注释（<dfn noexport>line-ending comment</dfn>）是一种由两个字符 // 和后面的字符组成的注释，直到但不包括：
* 除[=blankspace=]或水平制表符之外的下一个空格字符，或
* 程序结尾

TODO(dneto)：合并块注释，per https://github.com/gpuweb/gpuweb/pull/1470

## 标记 ## {#tokens}

一个标记（<dfn>token</dfn>）是一系列连续字符构成以下内容：
* 一个[=literal=].
* 一个[=keyword=].
* 一个[=reserved word=].
* 一个[=syntactic token=].
* 一个[=identifier=].

## 文字 ## {#literals}

文字（<dfn>literal</dfn>）为一下之一：
* 用作表达数字的<dfn>numeric literal</dfn>
* 为 `true` 或 `false` 的<dfn noexport>boolean literal</dfn>

[=numeric literal=]的形式是通过模式匹配定义的：

<div class='syntax' noexport='true'>
  <dfn for=syntax>decimal_float_literal</dfn> :

    | `/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+)/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>hex_float_literal</dfn> :

    | `/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+))/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>int_literal</dfn> :

    | `/-?0x[0-9a-fA-F]+|0|-?[1-9][0-9]*/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>uint_literal</dfn> :

    | `/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/`
</div>

注意：文字被贪心解析。这意味着对于像 `a -5` 这样的语句，这*不会*解析为 `a` `减` `5`，而是解析为 `a` `-5`，这可能是意外的。如果需要第一个表达式，则必须在 `-` 之后插入一个空格。

TODO(dneto)：描述数字文字标记如何映射到理想化值，然后映射到类型化值。

<div class='syntax' noexport='true'>
  <dfn for=syntax>const_literal</dfn> :

    | [=syntax/int_literal=]

    | [=syntax/uint_literal=]

    | [=syntax/float_literal=]

    | [=syntax/true=]

    | [=syntax/false=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>float_literal</dfn> :

    | [=syntax/decimal_float_literal=]

    | [=syntax/hex_float_literal=]
</div>


## 关键字 ## {#keywords}

一个关键字(<dfn>keyword</dfn>)是一个[=token=]，总是指代被预定义的语言概念。有关[SHORTNAME]关键字列表，请参阅[[#keyword-summary]]。

## 标识符 ## {#identifiers}

标识符（<dfn>identifier</dfn>）是一种用作名称的[=token=]，请参阅[[#declaration-and-scope]]和[[#directives]]。

标识符的形式是通过模式匹配定义的，但标识符不能与关键字（[=keyword=]）或保留字（[=reserved word=]）具有相同的拼写。

<div class='syntax' noexport='true'>
  <dfn for=syntax>ident</dfn> :

    | `/[a-zA-Z][0-9a-zA-Z_]*/`
</div>

## 属性 ## {#attributes}

属性（<dfn noexport>attribute</dfn>）修改对象或类型。[SHORTNAME]为应用属性提供了统一的语法。属性用于多种目的，例如指定带有API的接口。一般来说，从语言的角度来看，出于类型和语义检查的目的，可以忽略属性。

对每个对象或类型，属性不能被多次指定。

<div class='syntax' noexport='true'>
  <dfn for=syntax>attribute_list</dfn> :

    | [=syntax/attr_left=] ( [=syntax/attribute=] [=syntax/comma=] ) * [=syntax/attribute=] [=syntax/attr_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>attribute</dfn> :

    | [=syntax/ident=] [=syntax/paren_left=] ( [=syntax/literal_or_ident=] [=syntax/comma=] ) * [=syntax/literal_or_ident=] [=syntax/paren_right=]

    | [=syntax/ident=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>literal_or_ident</dfn> :

    | [=syntax/float_literal=]

    | [=syntax/int_literal=]

    | [=syntax/uint_literal=]

    | [=syntax/ident=]
</div>

<table class='data'>
  <caption>Attributes defined in [SHORTNAME]</caption>
  <thead>
    <tr><th>Attribute<th>Valid Values<th>Description
  </thead>

  <tr><td><dfn noexport dfn-for="attribute">`align`</dfn>
    <td>正i32文字
    <td>必须仅应用于结构（[=structure=]）类型的成员。

    必须是2的幂。

    见内存布局[alignment and size](#alignment-and-size)。

  <tr><td><dfn noexport dfn-for="attribute">`binding`
    <td>非负i32文字
    <td>必须仅应用于资源（[=resource=]）变量。

    指定绑定组（[=attribute/group=]）中资源的绑定号。见[[#resource-interface]]。

  <tr><td><dfn noexport dfn-for="attribute">`block`</dfn>
    <td>*None*
    <td>必须仅应用于结构（[=structure=]）类型。

    表示这个结构类型代表了在着色器的资源接口（[=resource interface of a
    shader|shader's resource interface=]）中占用单个绑定槽的缓冲区资源的内容。

    `block` 属性必须应用于用作统一缓冲区（[=uniform buffer=]）或存储缓冲区（[=storage buffer=]）变量的存储类型（[=store type=]）的结构类型。

    具有 `block` 属性的结构类型不得为：
    * 数组（[=array=]）类型的元素类型
    * 另一个结构中的成员类型

  <tr><td><dfn noexport dfn-for="attribute">`builtin`
    <td>一个内置变量标识符
    <td>只能应用于入口点函数参数、入口点返回类型或结构（[=structure=]）成员。

    声明一个内置变量。见[[#builtin-variables]]。

  <tr><td><dfn noexport dfn-for="attribute">`group`
    <td>非负i32文字
    <td>必须仅应用于资源（[=resource=]）变量。

    指定资源的绑定组。见[[#resource-interface]]。

  <tr><td><dfn noexport dfn-for="attribute">`interpolate`
    <td>一个或两个参数。

    第一个参数必须是插值类型（[=interpolation type=]）。 第二个参数（如果存在）必须指定插值采样（[=interpolation sampling=]）。

    <td>

    只能应用于入口点函数参数、入口点返回类型或结构（[=structure=]）类型的成员。只能应用于浮点类型的标量或向量的声明。不得与计算（[=compute=]）着色器阶段一起使用。

    指定用户定义的IO如何必须插入。该属性仅对用户定义的顶点（[=vertex=]）输出和片元（[=fragment=]）输入有意义。见[[#interpolation]]。

  <tr><td><dfn noexport dfn-for="attribute"> `invariant`
    <td>*None*
    <td>

    仅应用于 `position` 内置变量。

    当应用于顶点着色器的位置内置输出变量（`position` [=built-in output variable=]）时，结果的计算在不同程序和同一入口点的不同调用之间是不变的。 也就是说，如果数据和控制流在不同入口点的两个位置输出匹配，则结果值保证相同。对位置内置输入变量（`position` [=built-in input variable=]）没有影响。

    注意：此属性映射到 SPIR-V 中的 `Invariant` 修饰、HLSL 中的 `precise` 限定符和GLSL中的 `invariant` 限定符。

  <tr><td><dfn noexport dfn-for="attribute">`location`
    <td>非负i32文字
    <td>仅应用于入口点函数参数、入口点返回类型或结构（[=structure=]）类型的成员。只能应用于数值标量（[=numeric scalar=]）或数值向量（[=numeric
    vector=]）类型的声明。不得与计算（[=compute=]）着色器阶段一起使用。

    指定入口点的用户定义IO的一部分。见[[#input-output-locations]]。

  <tr><td><dfn noexport dfn-for="attribute">`override`
    <td>一个可选的，非负i32文字
    <td>仅应用于标量（[=scalar=]）类型的模块范围常量声明。

    指定管线可覆盖（[=pipeline-overridable=]）的常量。在WebGPU API中，管线可覆盖常量由应用该属性的常量的标识符指定。 如果指定了可选参数，则管道可覆盖常量由指定的数字id引用。

  <tr><td><dfn noexport dfn-for="attribute">`size`</dfn>
    <td>正i32文字
    <td>
    仅应用于结构（[=structure=]）类型的成员。

    在结构中为此成员保留的字节数。

  <tr><td><dfn noexport dfn-for="attribute">`stage`</dfn>
    <td>`compute`, `vertex`, or `fragment`
    <td>

    仅应用于函数声明。
    通过指定其管线阶段声明入口点。

  <tr><td><dfn noexport dfn-for="attribute">`stride`</dfn>
    <td>正i32文字
    <td>

    仅应用于数组（[=array=]）类型。

    从数组的一个元素的开头到下一个元素的开头的字节数。

  <tr><td><dfn noexport dfn-for="attribute">`workgroup_size`</dfn>
    <td>

    一个，两个，或三个参数。

    每个参数是文字常量或模块范围常量（[[#module-constants|module-scope constant]]）。所有参数的类型必须相同，i32或u32。

    <td>

    必须应用于计算着色器（[=compute shader stage|compute shader=]）入口点函数。不得应用于任何其他对象。

    指定计算着色器的工作组网格（[=workgroup grid=]）的x、y和z维度。

    第一个参数指定x维度。第二个参数（如果提供）指定y维度，否则假设为1。第三个参数（如果提供）指定z维度，否则假设为1。每个维度必须至少为 1，最多为一个上限由WebGPU API指定的边界。

</table>


## 指令 ## {#directives}

指令（<dfn noexport>directive</dfn>）是一个[=token=]序列，它修改了WebGPU实现对[SHORTNAME]程序的处理方式。见[[#enable-directive-section]]。

## 声明和范围 ## {#declaration-and-scope}

声明（<dfn noexport>declaration</dfn>）将标识符（[=identifier=]）与以下类型的对象之一相关联：
* a type
* a value
* a variable
* a function
* a formal parameter

换句话说，声明引入了对象的名称（<dfn noexport>name</dfn>）。名称不能在在声明之前使用。

声明的范围（<dfn noexport>scope</dfn>）是一组程序位置，其中使用声明的标识符可能表示其关联对象。我们说标识符在那些源位置的（声明的）范围内（<dfn noexport>in scope</dfn>）。

每种声明都有自己的规则来确定其范围。通常，范围是在声明结束后立即开始的一段文本。

某些对象由WebGPU实现提供，并被视为已在[SHORTNAME]程序开始时声明。我们说这样的对象是预先声明的（<dfn noexport>predeclared</dfn>）。他们的范围是整个[SHORTNAME]程序。预先声明的对象的示例为：
* [=built-in functions=], and
* built-in types.

当该标识符已经在与该名称的另一个实例具有相同结束范围的范围内时，声明不得引入名称。 当标识符用于该名称的一个或多个声明的范围内时，标识符将表示最接近该用途的声明对象。我们说标识符使用解析（<dfn noexport>resolves</dfn>）为该声明。

注意：声明总是在其标识符的作用域之前。因此，最近的标识符作用域声明总是在标识符的使用之前。

<div class='example' heading='Valid and invalid declarations'>
  <xmp>
    // Invalid, cannot reuse built-in function names.
    var<private> modf: f32 = 0.0;

    // Valid, foo_1 is in scope until the end of the program.
    var<private> foo: f32 = 0.0; // foo_1

    // Valid, bar_1 is in scope until the end of the program.
    var<private> bar: u32 = 0u; // bar_1

    // Valid, my_func_1 is in scope until the end of the program.
    // Valid, foo_2 is in scope until the end of the function.
    fn my_func(foo: f32) { // my_func_1, foo_2
      // Any reference to 'foo' resolves to the function parameter.

      // Invalid, the scope of foo_2 ends at the of the function.
      var foo: f32; // foo_3

      // Valid, bar_2 is in scope until the end of the function.
      var bar: u32; // bar_2
      // References to 'bar' resolve to bar_2
      {
        // Valid, bar_3 is in scope until the end of the compound statement.
        var bar: u32; // bar_3
        // References to 'bar' resolve to bar_3

        // Invalid, bar_4 has the same end scope as bar_3.
        var bar: i32; // bar_4

        // Valid, i_1 is in scope until the end of the for loop
        for (var i: i32 = 0; i < 10; i = i + 1) { // i_1
          // Invalid, i_2 has the same end scope as i_1.
          var i: i32 = 1; // i_2.
        }
      }

      // Invalid, bar_5 has the same end scope as bar_2.
      var bar: u32; // bar_5
    }

    // Invalid, bar_6 has the same end scope as bar_1.
    var<private> bar: u32 = 1u; // bar_6

    // Invalid, my_func_2 has the same end scope as my_func_1.
    fn my_func() { } // my_func_2

    // Valid, my_foo_1 is in scope until the end of the program.
    fn my_foo(
      // Valid, my_foo_2 is in scope until the end of the function.
      my_foo: i32 // my_foo_2
    ) { }
  </xmp>
</div>

根据声明的方式和位置，有多个级别的范围。

使用标识符时，它必须在某些声明的范围内，或作为指令的一部分。

如果声明出现在任何其他声明的文本之外，则声明在模块范围（<dfn noexport>module scope</dfn>）内。

Note: 只有[=function declaration=]可以包含其他声明。

# 类型 # {#types}

程序计算值。

在[SHORTNAME]中，类型（<dfn noexport>type</dfn>）是一组值，每个值都属于一种类型。值的类型决定了可以对该值执行的操作的语法和语义。

例如，数学数字1对应于[SHORTNAME]中的三个不同值：
* 32-位有符号整数 `1`，
* 32-位无符号整数 `1u`，和
* 32-位浮点型数值 `1.0`。

[SHORTNAME]将它们视为不同的值，因为它们的机器表示和操作不同。

类型要么是预声明（[=predeclared=]）的，要么是通过声明（[=declaration=]）在WGSL源代码中创建的。

我们区分类型的*概念*和[SHORTNAME]中表示该类型的*语法*。在许多情况下，本规范中类型的拼写与其[SHORTNAME]语法相同。例如：
* 32-位无符号整数值的集合在本规范中拼写为 `u32`，在[SHORTNAME]程序中也一样。
* 结构类型或包含结构的类型的拼写不同。

一些[SHORTNAME]类型仅用于分析源程序和确定程序的运行时行为。本规范将描述此类类型，但它们不会出现在[SHORTNAME]源文本中。

注意：[SHORTNAME] [=reference types=]未写在[SHORTNAME]程序中。见[[#memory-view-types]]。

## 类型检查 ## {#type-checking-section}

[SHORTNAME]值是通过计算表达式来计算的。表达式（<dfn noexport>expression</dfn>）是解析为[SHORTNAME]语法规则之一的源文本片段，其名称以“`_expression`”结尾。表达式*E*可以包含子表达式（<dfn noexport>subexpressions</dfn>），这些子表达式是正确包含在外部表达式*E*中的表达式。

表达式求值产生的特定值取决于：
* <dfn noexport>static context</dfn>:
    表达式周围的源文本，以及
* <dfn noexport>dynamic context</dfn>:
    计算表达式的调用状态，以及调用在运行时的执行上下文。

计算特定表达式可能产生的值将始终属于特定的[SHORTNAME]类型，称为表达式的静态类型（<dfn noexport>static type</dfn>）。[SHORTNAME]的规则被设计为表达式的静态类型仅取决于表达式的静态上下文。

语句通常使用表达式，并且可能对这些表达式的静态类型提出要求。例如：
* `if` 语句的条件表达式必须为布尔（[=bool=]）类型。
* 在 `let` 声明中，初始值必须评估为常量的声明类型。

类型检查（<dfn noexport>Type checking</dfn>）成功解析[SHORTNAME]程序是将每个表达式映射至其静态类型，并确定每个语句的类型要求是否满足的过程。

类型断言（<dfn noexport>type assertion</dfn>）是从一些[SHORTNAME]源表达式到[SHORTNAME]类型的映射。符号

> *e* : *T*

是一个意思为*T*为[SHORTNAME]表达式*e*的静态类型的断言。

注意：类型断言是关于程序文本的事实陈述。它不是运行时的检查。

可以通过递归应用类型规则来查找表达式的静态类型。类型规则（<dfn noexport>type rule</dfn>）有两部分：
* 声明为对一个表达式的类型断言的结论。类型断言中的表达式是示意性指定的，使用*斜体*名称表示子表达式或其他语法确定的参数。
* 先决条件，包括：
    * 子表达式的类型断言，当有子表达式时。
    * 其他语义参数的条件，如果有的话。
    * 语句中表达是如何使用。
    * 可选择地，其他静态上下文。

一个类型规则适用于一个表达式（<dfn noexport>type rule applies to an expression</dfn>）当：
* 规则的结论与一个有效解析的表达式匹配，和
* 规则的先决条件被满足。

TODO：写一个例子，例如 `1+2` 或 `3 - a`，其中 `a` 在 `i32` 类型的let声明的范围内。

类型规则被设计成如果解析成功，最多一个类型规则将应用于每个表达式。如果类型规则适用于表达式，则结论被断言，从而确定表达式的静态类型。

一个[SHORTNAME]源程序为<dfn noexport>well-typed</dfn>当：
* 可以通过应用类型规则为程序中的每个表达式确定静态类型，并且
* 满足每个语句的类型要求

否则会出现类型错误（<dfn noexport>type error</dfn>）并且源程序不是有效的[SHORTNAME]程序。

[SHORTNAME]是一种静态类型语言（<dfn noexport>statically typed language</dfn>），因为 WGSL 程序的类型检查要么成功要么发现类型错误，而只需要检查程序源文本。

TODO(dneto): Lazy-decay是一个tie-breaking规则。上面的描述可以通过在潜在匹配类型规则上使用优先级来适应它。

### 类型规则表 ### {#typing-tables-section}

[SHORTNAME]类型规则（[=type rules=]）被组织成类型规则表（<dfn noexport>type rule tables</dfn>），每个类型规则占一行。

表达式的语义（<dfn noexport>semantics of an expression</dfn>）是对表达式求值的结果，主要是结果值的产生。 适用于表达式的类型规则的*描述*列将指定表达式的语义。语义通常取决于类型规则参数的值，包括任何子表达式的假定值。 有时，表达式的语义包括产生结果值以外的效果，例如其子表达式的非结果值效果。

TODO：示例：非结果值效应是函数调用子表达式的任何副作用。

## 普通类型 ## {#plain-types-section}

普通类型（[=Plain types=]）是用于表示布尔值、数字、向量、矩阵或这些值的聚合的类型。

普通类型（<dfn>plain type</dfn>）是一个标量（[=scalar=]）类型，一个原子（[=atomic type|atomic=]）类型，或一个复合（[=composite=]）类型。

注意：[SHORTNAME]中的普通类型类似于C++中的Plain-Old-Data类型，但也包括原子类型。

### 布尔类型 ### {#bool-type}

布尔（<dfn dfn noexport>bool</dfn>）类型包括值 `true` 和 `false`。

### 整数类型 ### {#integer-types}

<dfn dfn noexport>u32</dfn>类型为一组32-位无符号整数的集合。

<dfn noexport>i32</dfn>类型为一组32-位有符号整数的集合。它使用二进制补码表示，符号位位于最高有效位的位置。

### 浮点类型 ### {#floating-point-types}

<dfn noexport>f32</dfn>类型是一组[[!IEEE-754|IEEE-754]] binary32 （单精度）格式的32-位浮点型数值。详见[[#floating-point-evaluation]]。

### 标量类型 ### {#scalar-types}

标量（<dfn dfn noexport>scalar</dfn>）类型有[=bool=], [=i32=], [=u32=], 和[=f32=]。

数字标量（<dfn dfn noexport>numeric scalar</dfn>）类型有[=i32=], [=u32=], 和[=f32=]。

整数标量（<dfn dfn noexport>integer scalar</dfn>）有[=i32=]和[=u32=]。

### 向量类型 ### {#vector-types}

向量（<dfn noexport>vector</dfn>）是一组由2，3，或4个标量（[=scalar=]）组件构成的序列。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr><td>vec*N*<*T*><td>
  *N*个类型*T*元素构成的向量。*N*必须为{2, 3, 4}中的值，*T*必须为一种标量（[=scalar=]）类型。我们称*T*为向量的组件类型（<dfn noexport>component type</dfn>）。
</table>

当一个向量组件类型为数字标量（[=numeric scalar=]）时，我们称之为数字向量（<dfn dfn>numeric vector</dfn>）。

向量的关健用例包括：

* 同时表示方向和大小。
* 表示空间中的位置。
* 在某个颜色空间中表达一种颜色。例如，分量可以是红色、绿色和蓝色的强度，而第四个分量可以是alpha（不透明度）值。

向量上的许多操作都是按组件（<dfn noexport>component-wise</dfn>）进行的，即结果向量是通过对每个组件独立操作而形成的。

<div class='example wgsl type-scope' heading='Vector'>
  <xmp highlight='rust'>
    vec2<f32>  // 两个f32组成的向量。
  </xmp>
</div>

<div class='example component-wise addition' heading='Component-wise addition'>
  <xmp highlight='rust'>
    let x : vec3<f32> = a + b; // a 和 b 为 vec3<f32>
    // x[0] = a[0] + b[0]
    // x[1] = a[1] + b[1]
    // x[2] = a[2] + b[2]
  </xmp>
</div>

### 矩阵类型 ### {#matrix-types}

矩阵（<dfn noexport>matrix</dfn>）是一组由2，3，或4个浮点型向量组成的序列，

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="matrix type">
    <td>mat|N|x|M|&lt;f32&gt;
    <td>
        |N|列|M|行矩阵，|N|和|M|都为{2, 3, 4}中的值。等价地，它同样可以被看作|N|列vec|M|&lt;f32&gt;类型的向量。
</table>

矩阵的关键用例是体现线性变换。在这种解释中，矩阵的向量被视为列向量。

乘积操作符(`*`)可用于：

* 按标量大小缩放变换。
* 对一个向量应用变换。
* 与另一个矩阵组合变换。

见[[#arithmetic-expr]]。

<div class='example wgsl type-scope' heading='Matrix'>
  <xmp highlight='rust'>
    mat2x3<f32>  // 此为 2 列 3 行的 32-位浮点数矩阵。
                 // 等价地，此为 2 列类型 vec3<f32> 构成的向量。
  </xmp>
</div>

### 原子类型 ### {#atomic-types}

原子类型（<dfn noexport>atomic type</dfn>）封装了一个标量类型，使得：
* 原子对象为并发观察者提供了一定的保证，并且
* 对原子对象唯一有效的操作是原子内置函数（[[#atomic-builtin-functions|atomic builtin functions]]）。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="atomic type"><td>atomic&lt;|T|&gt;
    <td>类型|T|的原子。|T|必须为[=u32=]或[=i32=]。
</table>

表达式不得计算为原子类型。

原子类型只能由[=storage classes/workgroup=]存储类中的变量或具有[=access/read_write=]访问模式的存储缓冲区（[=storage buffer=]）变量实例化。

原子修改（<dfn noexport>atomic modification</dfn>）是对原子对象的任何设置对象内容的操作。即使新值与对象的现有值相同，该操作也算作修改。

在[SHORTNAME]中，对于每个对象，原子修改是相互排序的。也就是说，在着色器阶段的执行期间，对于每个原子对象*A*，所有代理都观察应用于*A* 的相同修改操作顺序。不同原子对象的顺序可能没有任何关系；没有任何因果关系。注意，工作组（[=storage classes/workgroup=]）存储中的变量在一个工作组（[=compute shader stage/workgroup=]）内共享，但在不同工作组之间不共享。

TODO: 添加链接最终的内存模型描述。

<div class='example storage atomic' heading='Mapping atomics in a storage variable to SPIR-V'>
  <xmp>
    [[block]] struct S {
      a: atomic<i32>;
      b: atomic<u32>;
    };

    [[group(0), binding(0)]]
    var<storage,read_write> x: S;

    // Maps to the following SPIR-V:
    // - When atomic types are members of a struct, the Volatile decoration
    //   is annotated on the member.
    // OpDecorate %S Block
    // OpMemberDecorate %S 0 Volatile
    // OpMemberDecorate %S 1 Volatile
    // ...
    // %i32 = OpTypeInt 32 1
    // %u32 = OpTypeInt 32 0
    // %S = OpTypeStruct %i32 %u32
    // %ptr_storage_S = OpTypePointer StorageBuffer %S
    // %x = OpVariable %ptr_storage_S StorageBuffer
  </xmp>
</div>

<div class='example workgroup atomic' heading='Mapping atomics in a workgroup variable to SPIR-V'>
  <xmp>
    var<workgroup> x: atomic<u32>;

    // Maps to the following SPIR-V:
    // - When atomic types are directly instantiated by a variable,  the Volatile
    //   decoration is annotated on the OpVariable.
    // OpDecorate %x Volatile
    // ...
    // %u32 = OpTypeInt 32 0
    // %ptr_workgroup_u32 = OpTypePointer Workgroup %S
    // %x = OpVariable %ptr_workgroup_u32 Workgroup
  </xmp>
</div>


### 数组类型 ### {#array-types}

数组（<dfn noexport>array</dfn>）是一组可索引的元素值。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr><td algorithm="fixed-size array type">array&lt;|E|,|N|&gt;
      <td>
          |N|个类型为|E|的元素组成的固定大小数组（<dfn>fixed-size array</dfn>。
          <br>
          |N|被称为数组的元素计数（<dfn noexport>element count</dfn>）。
  <tr><td algorithm="runtime-sized array type">array&lt;|E|&gt;
      <td>
          由类型|E|元素构成的<dfn noexport>runtime-sized</dfn>数组。它们仅出现在特定上下文中。
          <br>
</table>

当被指定，元素计数表达式|N|必须：
* 是一个文字，或者为不[=pipeline-overridable=]的[[#module-constants|module-scope constant]]的名称，以及
* 计算为一个大于零的整数标量（[=integer scalar=]）。

注意：元素计数在[=shader module creation=]时已被完全确定。

当且仅当以下所有条件都为真时，两种数组类型是相同的：
* 它们拥有相同的元素类型。
* 它们的元素计数规范匹配，即以下任一情况为真：
    * 它们都是runtime-sized。
    * 它们都是fixed-sized，具有等值的元素计数，即使一个是有符号的，另外是无符号的。（在这种情况下，有符号和无符号值是可比较的，因为元素计数必须大于零。）

问题：如果数组类型具有不同的元素步幅，则它们应该不同。见https://github.com/gpuweb/gpuweb/issues/1534

<div class='example fixed-size array types' heading='Example fixed-size array types'>
  <xmp>
    // array<f32,8> and array<i32,8> are different types:
    // different element types
    var<private> a: array<f32,8>;
    var<private> b: array<i32,8>;
    var<private> c: array<i32,8u>;  // array<i32,8> and array<i32,8u> are the same type

    let width = 8;
    let height = 8;

    // array<i32,8>, array<i32,8u>, and array<i32,width> are the same type.
    // Their element counts evaluate to 8.
    var<private> d: array<i32,width>;

    // array<i32,height> and array<i32,width> are the same type.
    var<private> e: array<i32,width>;
    var<private> f: array<i32,height>;
  </xmp>
</div>

数组中的第一个元素位于索引 0 处，每个后续元素位于下一个整数索引处。见[[#array-access-expr]]。

一个数组元素类型必须为以下之一：
* 标量（[=scalar=]）类型
* 向量类型
* 矩阵类型
* 原子（[=atomic type|atomic=]）类型
* 数组类型
* 结构（[=structure=]）类型

注意：也就是说，元素类型必须为普通类型（[=plain type=]）。

[SHORTNAME]定义了以下可应用于数组类型的属性：
* [=attribute/stride=]

runtime-sized数组局限：
* 定义[=storage classes/storage=]存储类中变量的存储类型（[=store type=]）的结构类型的最后一个成员可能是runtime-sized数组。
* 在任何其他情况下，不得将runtime-sized数组用作存储类型或包含在存储类型中。
* 一个表达式不能计算为一个runtime-sized数组类型。

<div class='syntax' noexport='true'>
  <dfn for=syntax>array_type_decl</dfn> :

    | [=syntax/attribute_list=] * [=syntax/array=] [=syntax/less_than=] [=syntax/type_decl=] ( [=syntax/comma=] [=syntax/element_count_expression=] ) ? [=syntax/greater_than=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>element_count_expression</dfn> :

    | [=syntax/int_literal=]

    | [=syntax/uint_literal=]

    | [=syntax/ident=]
</div>

### 结构类型 ### {#struct-types}

<dfn noexport>structure</dfn>是一组已命名的成员值。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="structure type">
      <td>struct&lt;|T|<sub>1</sub>,...,|T|<sub>N</sub>&gt;
      <td>
          类型为|T|<sub>1</sub>到|T|<sub>N</sub>的*N*个成员的有序元组，其中*N*是大于0的整数。结构类型声明为每个成员指定标识符（[=identifier=]）名称。相同结构类型的两个成员不得具有相同的名称。
</table>

一个结构成员类型必须为以下之一：
* 标量（[=scalar=]）类型
* 向量类型
* 矩阵类型
* 原子（[=atomic type|atomic=]）类型
* 数组类型
* 结构（[=structure=]）类型

注意：也就是说，任何成员类型必须为普通类型（[=plain type=]）。

注意：结构成员类型限制和数组元素类型限制是相辅相成的。 结合起来，它们意味着指针可能不会出现在数组或结构内的任何嵌套级别中。 同样，相同的限制也适用于纹理和采样器。

<div class='example wgsl global-scope' heading="Structure">
  <xmp highlight='rust'>
    // 拥有两个成员的结构
    struct Data {
      a: i32;
      b: vec2<f32>;
    };
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_decl</dfn> :

    | [=syntax/attribute_list=] * [=syntax/struct=] [=syntax/ident=] [=syntax/struct_body_decl=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_body_decl</dfn> :

    | [=syntax/brace_left=] [=syntax/struct_member=] * [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_member</dfn> :

    | [=syntax/attribute_list=] * [=syntax/variable_ident_decl=] [=syntax/semicolon=]
</div>

[SHORTNAME]定义了以下可应用于结构类型的属性：
 * [=attribute/block=]

[SHORTNAME]定义了以下可应用于结构成员的属性：
 * [=attribute/builtin=]
 * [=attribute/location=]
 * [=attribute/stride=]
 * [=attribute/align=]
 * [=attribute/size=]

注意：如果结构类型用于定义统一缓冲区（[=uniform buffer=]）或存储缓冲区（[=storage buffer=]），则可能需要布局属性。见[[#memory-layouts]]。

<div class='example wgsl global-scope' heading='Structure WGSL'>
  <xmp>
    struct my_struct {
      a: f32;
      b: vec4<f32>;
    };
  </xmp>
</div>

<div class='example spirv' heading='Structure SPIR-V'>
  <xmp>
                  OpName %my_struct "my_struct"
                  OpMemberName %my_struct 0 "a"
                  OpMemberDecorate %my_struct 0 Offset 0
                  OpMemberName %my_struct 1 "b"
                  OpMemberDecorate %my_struct 1 Offset 4
     %my_struct = OpTypeStruct %float %v4float
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Structure WGSL'>
  <xmp>
    // Runtime Array
    type RTArr = [[stride(16)]] array<vec4<f32>>;
    [[block]] struct S {
      a: f32;
      b: f32;
      data: RTArr;
    };
  </xmp>
</div>

<div class='example spirv' heading='Structure SPIR-V'>
  <xmp>
                  OpName %my_struct "my_struct"
                  OpMemberName %my_struct 0 "a"
                  OpMemberDecorate %my_struct 0 Offset 0
                  OpMemberName %my_struct 1 "b"
                  OpMemberDecorate %my_struct 1 Offset 4
                  OpMemberName %my_struct 2 "data"
                  OpMemberDecorate %my_struct 2 Offset 16
                  OpDecorate %rt_arr ArrayStride 16
        %rt_arr = OpTypeRuntimeArray %v4float
     %my_struct = OpTypeStruct %float %v4float %rt_arr
  </xmp>
</div>

### 复合类型 ### {#composite-types}

如果一个类型内部结构表达为其他类型的复合，则其为复合的（<dfn noexport>composite</dfn>）。内部部分不重叠，并称为组件（<dfn noexport>components</dfn>）。

复合类型为：

* [=vector=]类型
* [=matrix=]类型
* [=array=]类型
* [=structure=]类型

对于一个复合类型|T|，|T|的<dfn>nesting depth</dfn>，写作*NestDepth*(|T|)为：
* 对向量类型，为1
* 对矩阵类型，为2
* 对类型为|E|的数组类型，1 + *NestDepth*(|E|)
* 成员类型为*M*<sub>1</sub>,...,*M*<sub>1</sub>的结构类型|T|，1 + max(*NestDepth*(*M*<sub>1</sub>),..., *NestDepth*(*M*<sub>N</sub>))


### 可构造类型 ### {#constructible-types}

多种类型的数值可以被创建，加载，存储，传递至函数，以及作为函数返回值。
我们称之为可构造的（[=constructible=]）。

一个类型为可构造的（<dfn>constructible</dfn>）如果其为以下之一：
* [=scalar=]类型
* [=vector=]类型
* [=matrix=]类型
* [=fixed-size array=]类型，如果其元素类型为可构造的。
* [=structure=]类型, 如果它的全部成员都为可构造的。

注意：所有可构造类型为普通类型（[=plain types|plain=]）。

注意：原子类型和runtime-sized数组类型是不可构造的。包含原子和runtime-sized数组的复合类型是不可构造的。

## 内存 ## {#memory}

[SHORTNAME]中，可存储类型的值可以存储在内存中，以供以后检索。本节介绍内存的结构，以及如何使用[SHORTNAME]类型来描述内存的内容。

一般来说，[SHORTNAME]遵循[[!VulkanMemoryModel|Vulkan Memory Model]]。

### 内存位置 ### {#memory-locations-section}

内存由一组不同的内存位置（<dfn noexport>memory locations</dfn>）组成。每个内存位置的大小为8位。影响内存的操作与一组由一个或多个组成的内存位置交互。

如果两组存储器位置的交集非空，则两组存储器位置重叠（<dfn noexport>overlap</dfn>）。每个变量声明都有一组内存位置，不会与任何其他变量声明的内存位置集重叠。对结构和数组的内存操作可以访问元素之间的填充，但不得访问结构或数组末尾的填充。

### 内存访问模式 ### {#memory-access-mode}

内存访问（<dfn noexport>memory access</dfn>）是一种作用于内存位置的操作。

* 读操作（<dfn noexport>read access</dfn>）观察内存位置的内容。
* 写操作（<dfn noexport>write access</dfn>）设置内存位置的内容。

单个操作可以为读，写，或读与写。

特定的内存位置可能只支持某些类型的访问，表示为内存的访问模式（<dfn noexport>access mode</dfn>）：

: <dfn noexport dfn-for="access">read</dfn>
:: 支持读访问，但不是写。
: <dfn noexport dfn-for="access">write</dfn>
:: 支持写访问，但不是读。
: <dfn noexport dfn-for="access">read_write</dfn>
:: 读写访问都支持。

<div class='syntax' noexport='true'>
  <dfn for=syntax>access_mode</dfn> :

    | [=syntax/read=]

    | [=syntax/write=]

    | [=syntax/read_write=]
</div>

### 可存储类型 ### {#storable-types}

变量（[=variable=]）中包含的值必须是可存储（[=storable=]）类型。可存储类型可能具有WGSL定义的显式表示，如[[#internal-value-layout]]中所述，或者它可能是不透明的，例如纹理和采样器。

如果一个类型为以下之一，其为可存储的（<dfn dfn noexport>storable</dfn>）

* 标量（[=scalar=]）类型
* 向量（[=vector=]）类型
* 矩阵（[=matrix=]）类型
* 原子（[=atomic type|atomic=]）类型
* 数组（[=array=]）类型
* 结构（[=structure=]）类型
* 纹理（[=texture=]）类型
* 采样器（[=sampler=]）类型

注意：也就是说，可存储类型是普通类型（[=plain types=]）、纹理类型和采样器类型。

### IO可共享类型 ### {#io-shareable-types}

管线输入和输出值必须为IO可共享类型。

一个类型是IO可共享的（<dfn dfn noexport>IO-shareable</dfn>）当其为以下之一：

* 标量（[=scalar=]）类型
* 数值向量（[=numeric vector=]）类型
* 结构（[=structure=]）类型，如果其成员全部为标量（[=scalars=]）或数值向量（[=numeric vectors=]）。

以下类型的值必须是IO可共享类型：

* 从内置变量读取或写入的值。
* 接受作为来自上游管线阶段的输入的值。
* 作为管线中下游处理的输出或输出附件写入的值。

注意：只有内置管线输入可能具有布尔类型。用户输入或输出数据属性不得为[=bool=]类型或包含[=bool=]类型。见[[#pipeline-inputs-outputs]]。

### 主机可共享类型 ### {#host-shareable-types}

主机可共享类型用于描述在主机和GPU之间共享的缓冲区内容，或者在主机和GPU之间复制而无需格式转换的内容。 用于此目的时，该类型必须额外使用布局属性进行修饰，如[[#memory-layouts]]中所述。 我们将在[[#module-scope-variables]]中看到统一缓冲区（[=uniform buffer=]）和存储缓冲区（[=storage buffer=]）变量的存储类型（[=store type=]）必须是主机可共享的。

类型为主机可共享的（<dfn dfn noexport>host-shareable</dfn>）当其为以下之一：

* 数值标量（[=numeric scalar=]）类型
* 数值向量（[=numeric vector=]）类型
* 矩阵（[=matrix=]）类型
* 原子（[=atomic type|atomic=]）类型
* [=fixed-size array=]类型，如果其元素类型为主机可共享的
* [=runtime-sized=]数组类型，如果其元素类型为主机可共享的
* 结构（[=structure=]）类型，如果其所有元素为主机可共享的。

[SHORTNAME]定义了以下影响内存布局的属性：
 * [=attribute/stride=]
 * [=attribute/align=]
 * [=attribute/size=]

注意：当[=IO-shareable=]类型*T*不是[=bool=]并且不包含[=bool=]时，其为主机可共享的。许多类型为主机可共享的，但不是IO可共享的，包括原子类型（[=atomic types=]），[=runtime-sized=]数组，以及任何包含它们的复合类型。


注意：IO可共享类型和主机可共享类型都具有具体大小，但是各自计数。IO可共享类型的大小由位置计数指标决定，见[[#input-output-locations]]。主机可共享类型的大小由字节计数指标决定，见[[#memory-layouts]]。

### 存储类 ### {#storage-class}

内存位置被划分为存储类（<dfn noexport>storage classes</dfn>）。每个存储类都具有确定可变性、可见性、它可能包含的值以及如何使用变量的单独属性。

<table class='data' id="storage-class-table">
  <caption>Storage Classes</caption>
  <thead>
    <tr><th>Storage class
        <th>Sharing among invocations
        <th>Supported access modes
        <th>Variable scope
        <th>Restrictions on stored values
        <th>Notes
  </thead>
  <tr><td><dfn noexport dfn-for="storage classes">function</dfn>
      <td>仅相同调用
      <td>[=access/read_write=]
      <td>[=Function scope=]
      <td>[=Constructible=]类型
      <td>
  <tr><td><dfn noexport dfn-for="storage classes">private</dfn>
      <td>仅相同调用
      <td>[=access/read_write=]
      <td>[=Module scope=]
      <td>[=Constructible=]类型
      <td>
      <td>
  <tr><td><dfn noexport dfn-for="storage classes">workgroup</dfn>
      <td>相同[=compute shader stage|compute shader=] [=compute shader stage/workgroup=]中的调用
      <td>[=access/read_write=]
      <td>[=Module scope=]
      <td>[=Plain type=]，不包括[=runtime-sized=]数组，或包含runtime-sized数组的[=composite=]类型。
      <td>
  <tr><td><dfn noexport dfn-for="storage classes">uniform</dfn>
      <td>相同[=shader stage=]中的调用
      <td>[=access/read=]
      <td>[=Module scope=]
      <td>[=Constructible=] [=host-shareable=]类型
      <td>对[=uniform buffer=]变量
  <tr><td><dfn noexport dfn-for="storage classes">storage</dfn>
      <td>相同[=shader stage=]中的调用
      <td> [=access/read_write=], [=access/read=] (default)
      <td>[=Module scope=]
      <td>[=Host-shareable=]
      <td>对[=storage buffer=]变量
  <tr><td><dfn noexport dfn-for="storage classes">handle</dfn>
      <td>相同着色器阶段中的调用
      <td>[=access/read=]
      <td>[=Module scope=]
      <td>[=Sampler=]类型或[=texture=]类型
      <td>对[=sampler=]和纹理变量<br>
</table>

注意：标记 `handle` 被保留：它在[SHORTNAME]程序中从不被使用。

注意：纹理变量包含一个不透明的句柄，用于访问底层的纹素网格。句柄本身始终是只读的。在大多数情况下，底层纹素是只读的。对于只写存储纹理，底层纹素是只写的。

<div class='syntax' noexport='true'>
  <dfn for=syntax>storage_class</dfn> :

    | [=syntax/function=]

    | [=syntax/private=]

    | [=syntax/workgroup=]

    | [=syntax/uniform=]

    | [=syntax/storage=]
</div>

<table class='data'>
  <thead>
    <tr><th>WGSL storage class<th>SPIR-V storage class
  </thead>
  <tr><td>uniform<td>Uniform
  <tr><td>workgroup<td>Workgroup
  <tr><td>handle<td>UniformConstant
  <tr><td>storage<td>StorageBuffer
  <tr><td>private<td>Private
  <tr><td>function<td>Function
</table>


### 内存布局 ### {#memory-layouts}

统一缓冲区（[=Uniform buffer=]）和存储缓冲区（[=storage buffer=]）变量用于共享在内存中组织为字节序列的批量数据。缓冲区在 CPU 和 GPU 之间共享，或在管线中的不同着色器阶段之间，或在不同管线之间共享。

由于缓冲区数据无需重新格式化或转换即可共享，缓冲区生产者和消费者必须就<dfn noexport>memory layout</dfn>达成一致，
这是如何将缓冲区中的字节组织成类型化的[SHORTNAME]值的描述。

缓冲区变量的存储类型（[=store type=]）必须是主机可共享的（[=host-shareable=]），具有完全详细的内存布局，如下所述。

每个缓冲区变量必须在[=storage classes/uniform=]或[=storage classes/storage=]存储类中声明。

类型的内存布局仅在评估具有以下内容的表达式时才有意义：
* [=storage classes/uniform=]或[=storage classes/storage=]存储类中的变量，或
* 指向[=storage classes/uniform=]或[=storage classes/storage=]存储类的指针。

一个8位字节是[=host-shareable=]内存的最基本单位。本节中定义的术语表示 8 位字节的计数。

我们将使用以下符号：
* <dfn noexport>AlignOf</dfn>(|T|)是主机共享类型|T|的对齐方式。
* <dfn noexport>AlignOfMember</dfn>(|S|，|M|) 是主机共享结构|S|的成员|M|的对齐方式。
* <dfn noexport>SizeOf</dfn>(|T|) 是主机共享类型|T|的大小。
* <dfn noexport>SizeOfMember</dfn>(|S|，|M|) 是主机共享结构|S|的成员|M|的大小。
* <dfn noexport>StrideOf</dfn>(|A|) 是主机可共享数组类型|A|的[=element stride=]。
* <dfn noexport>OffsetOfMember</dfn>(|S|，|M|) 是成员|M|从主机共享结构|S|开始的偏移量。

#### 对齐和大小 ####  {#alignment-and-size}

每个[=host-shareable=]数据类型|T|有一个对齐和大小值，分别用[=AlignOf=](|T|)和[=SizeOf=](|T|)表示。

对齐保证值在内存中的地址将是指定值的倍数。 这可以启用更高效的硬件指令来访问值或满足对某些存储类的更严格的硬件要求。（见[存储类布局约束](#storage-class-layout-constraints)）。

注意：根据构造，每个对齐值始终是2的幂。

类型或结构成员的大小是主机可共享内存中为存储类型或结构成员的值而保留的连续字节数。大小可能包括类型末尾的不可寻址填充。 因此，值的加载和存储访问的内存位置可能少于值的大小。

主机可共享类型的对齐方式和大小在下表中递归定义：

<table class='data'>
  <caption>
    Alignment and size for host-shareable types<br>
  </caption>
  <thead>
    <tr><th>Host-shareable type |T|
        <th>[=AlignOf=](|T|)
        <th>[=SizeOf=](|T|)
  </thead>
  <tr><td>[=i32=], [=u32=], or [=f32=]
      <td>4
      <td>4
  <tr><td>atomic&lt;|T|&gt;
      <td>4
      <td>4
  <tr><td>vec2&lt;|T|&gt;
      <td>8
      <td>8
  <tr><td>vec3&lt;|T|&gt;
      <td>16
      <td>12
  <tr><td>vec4&lt;|T|&gt;
      <td>16
      <td>16
  <tr><td>mat|N|x|M| (col-major)<br>
      <p class="small">(General form)</p>
      <td>[=AlignOf=](vec|M|)
      <td>[=SizeOf=](array&lt;vec|M|, |N|&gt;)
  <tr><td>mat2x2&lt;f32&gt;
      <td>8
      <td>16
  <tr><td>mat3x2&lt;f32&gt;
      <td>8
      <td>24
  <tr><td>mat4x2&lt;f32&gt;
      <td>8
      <td>32
  <tr><td>mat2x3&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat3x3&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat4x3&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat2x4&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat3x4&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat4x4&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>struct |S|
      <td>max([=AlignOfMember=](S, M<sub>1</sub>), ... , [=AlignOfMember=](S, M<sub>N</sub>))<br>
      <td>[=roundUp=]([=AlignOf=](|S|), [=OffsetOfMember=](|S|, |L|) + [=SizeOfMember=](|S|, |L|))<br><br>
          其中|L|是结构中的最后一个成员
  <tr><td>array<|E|, |N|><br>
      <p class="small">(Implicit stride)</p>
      <td>[=AlignOf=](|E|)
      <td>|N| * [=roundUp=]([=AlignOf=](|E|), [=SizeOf=](|E|))
  <tr><td>array<|E|><br>
      <p class="small">(Implicit stride)</p>
      <td>[=AlignOf=](|E|)
      <td>N<sub>runtime</sub> * [=roundUp=]([=AlignOf=](|E|), [=SizeOf=](|E|))<br><br>
          其中N<sub>runtime</sub>是运行时确定的|T|元素数。
  <tr><td>[[[=attribute/stride=](|Q|)]]<br> array<|E|, |N|>
      <td>[=AlignOf=](|E|)
      <td>|N| * |Q|
  <tr><td>[[[=attribute/stride=](|Q|)]]<br> array<|E|>
      <td>[=AlignOf=](|E|)
      <td>N<sub>runtime</sub> * |Q|
</table>


#### 结构布局规则 ####  {#structure-layout-rules}

每个结构|S|成员M<sub>N</sub>都有一个大小和对齐值，分别由[=SizeOfMember=](|S|, M<sub>N</sub>)和[=AlignOfMember=](|S|, M<sub>N</sub>)表示。成员大小和对齐方式用于计算每个成员从结构开始的字节偏移量。

结构成员大小和对齐值默认为成员类型 `T` 的[=SizeOf=](T)和[=AlignOf=](T)值。

如果结构成员使用[=attribute/size=]装饰进行装饰，则结构成员将使用装饰的值作为其大小而不是其类型的大小。

如果结构成员使用[=attribute/align=]装饰进行装饰，则结构成员将使用装饰的值进行对齐而不是类型的对齐。

第一个结构成员从结构开头的偏移量始终为零字节。

后续成员从结构的开头具有以下字节偏移量：
<p algorithm="structure member offset">
  [=OffsetOfMember=](|S|, M<sub>N</sub>) = [=roundUp=]([=AlignOfMember=](|S|, M<sub>N</sub>), [=OffsetOfMember=](|S|, M<sub>N-1</sub>) + [=SizeOfMember=](|S|, M<sub>N-1</sub>)<br>
  其中M<sub>N</sub>为当前成员，M<sub>N-1</sub>为前一个成员。
</p>

结构成员不能重叠。如果一个结构成员被[=attribute/size=]属性装饰，值必须至少和成员类型的大小一样大。

<p algorithm="member size constraint">
  [=SizeOfMember=](|S|, M<sub>N</sub>) &ge; [=SizeOf=](T)<br>
  其中|T|为成员M<sub>N</sub>的类型。
</p>

结构的对齐等于其所有成员的最大对齐：
<p algorithm="structure alignment">
  [=AlignOf=](|S|) = max([=AlignOfMember=](|S|, M<sub>1</sub>), ... , [=AlignOfMember=](|S|, M<sub>N</sub>))
</p>

结构的大小等于偏移量加上其最后一个成员的大小，四舍五入为结构对齐的下一个倍数：
<p algorithm="structure size">
  [=SizeOf=](|S|) = [=roundUp=]([=AlignOf=](|S|), [=OffsetOfMember=](|S|, |L|) + [=SizeOfMember=](|S|, |L|))<br>
  其中|L|是结构的最后一个成员
</p>

<div class='example wgsl' heading='Layout of structures using implicit member sizes, alignments and strides'>
  <xmp highlight='rust'>
    struct A {                                     //             align(8)  size(24)
        u: f32;                                    // offset(0)   align(4)  size(4)
        v: f32;                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>;                              // offset(8)   align(8)  size(8)
        x: f32;                                    // offset(16)  align(4)  size(4)
        // -- implicit struct size padding --      // offset(20)            size(4)
    };

    [[block]] struct B {                           //             align(16) size(160)
        a: vec2<f32>;                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>;                              // offset(16)  align(16) size(12)
        c: f32;                                    // offset(28)  align(4)  size(4)
        d: f32;                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(12)
        e: A;                                      // offset(40)  align(8)  size(24)
        f: vec3<f32>;                              // offset(64)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(76)            size(4)
        g: array<A, 3>;                            // offset(80)  align(8)  size(72) stride(24)
        h: i32;                                    // offset(152) align(4)  size(4)
        // -- implicit struct size padding --      // offset(156)           size(4)
    };

    [[group(0), binding(0)]]
    var<storage,read_write> storage_buffer: B;
  </xmp>
</div>

<div class='example wgsl' heading='Layout of structures with explicit member sizes, alignments and strides'>
  <xmp highlight='rust'>
    struct A {                                     //             align(8)  size(32)
        u: f32;                                    // offset(0)   align(4)  size(4)
        v: f32;                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>;                              // offset(8)   align(8)  size(8)
        [[size(16)]] x: f32;                       // offset(16)  align(4)  size(16)
    };

    [[block]] struct B {                           //             align(16) size(208)
        a: vec2<f32>;                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>;                              // offset(16)  align(16) size(12)
        c: f32;                                    // offset(28)  align(4)  size(4)
        d: f32;                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(12)
        [[align(16)]] e: A;                        // offset(48)  align(16) size(32)
        f: vec3<f32>;                              // offset(80)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(92)            size(4)
        g: [[stride(32)]] array<A, 3>;             // offset(96)  align(8)  size(96)
        h: i32;                                    // offset(192) align(4)  size(4)
        // -- implicit struct size padding --      // offset(196)           size(12)
    };

    [[group(0), binding(0)]]
    var<uniform> uniform_buffer: B;
  </xmp>
</div>

#### 数组布局规则 ####  {#array-layout-rules}

第一个数组元素从数组开头的偏移量始终为零字节。

数组的元素步幅（<dfn noexport>element stride</dfn>）是从一个数组元素的开头到下一个元素的开头的字节数。 确定如下：
* 如果指定，它是类型上显式步幅（[=attribute/stride=]）属性的值。
* 否则，它是隐式步幅，等于数组元素类型的大小，四舍五入到元素类型的对齐方式：

<p algorithm="array implicit element stride">
  [=StrideOf=](array<|T|[, |N|]>) = [=roundUp=]([=AlignOf=](T), [=SizeOf=](T))
</p>

在所有情况下，数组元素步幅必须是元素对齐的倍数。

<div class='example wgsl' heading='Implicit / explicit array element strides'>
  <xmp highlight='rust'>
    // 具有 16 字节隐式元素步幅的数组
    var implicit_stride: array<vec3<f32>, 8>;

    // 具有 32 字节显式元素步幅的数组
    var explicit_stride: [[stride(32)]] array<vec3<f32>, 8>;
  </xmp>
</div>

用[=attribute/stride=]属性修饰的数组的步幅必须至少是元素类型的大小，并且是元素类型对齐值的倍数。

数组大小（以字节为单位）等于数组的元素步幅乘以元素数：
<p algorithm="array element stride">
  [=SizeOf=](array<|T|, |N|>) = [=StrideOf=](array<|T|, |N|>) &times; |N|<br>
  [=SizeOf=](array<|T|>) = [=StrideOf=](array<|T|>) &times; N<sub>runtime</sub>
</p>

数组对齐等于元素对齐：
<p algorithm="array alignment">
  [=AlignOf=](array<|T|[, N]>) = [=AlignOf=](|T|)
</p>

例如，`[[stride(S)]] array<T, 3>` 类型的布局等效于以下结构：

<div class='example wgsl global-scope' heading='Structure equivalent of a three element array'>
  <xmp highlight='rust'>
    struct Array {
      [[size(S)]] element_0: T;
      [[size(S)]] element_1: T;
      [[size(S)]] element_2: T;
    };
  </xmp>
</div>

#### 值的内部布局 ####  {#internal-value-layout}

本节描述了如何将值的内部结构放置在缓冲区的字节位置中，给定一个假设的整个值的位置。这些布局取决于值的类型、数组类型的步幅（[=attribute/stride=]）属性以及结构类型成员的对齐（[=attribute/align=]）和大小（[=attribute/size=]）属性。

无论存储类别如何，数据都将显示相同。

当[=u32=]或[=i32=]类型的值|V|放置在主机共享缓冲区的字节偏移量|k|处时，则：
   * 字节|k|包含|V|的0-7位
   * 字节|k|+1包含|V|的8-15位
   * 字节|k|+2包含|V|的16-23位
   * 字节|k|+3包含|V|的24-31位

注意：回想一下，[=i32=]使用二进制补码表示，因此符号位位于第31位。

[=f32=]类型的值|V|以[[!IEEE-754|IEEE-754]] binary32格式表示。它有1个符号位、8个指数位和23个分数位。当|V|被放置在主机共享缓冲区的字节偏移 k处时，则：
   * 字节|k|包含分数位的0-7位。
   * 字节|k|+1包含分数位的8-15位。
   * 字节|k|+2的0-6位包含分数位的16-23位。
   * 字节|k|+2的第7位包含指数位的第0位。
   * 字节|k|+3的第0-6位包含指数位的1-7位。
   * 字节|k|+3的第7位包含符号位。

注意：上述规则隐含表明主机共享缓冲区中的数值以little-endian格式存储。

当原子类型（[=atomic type=]） `atomic`&lt;|T|&gt; 的值|V|放置在主机共享缓冲区中时，它具有与基础类型|T|的值相同的内部布局。

当向量类型 vec|N|&lt;|T|&gt; 的值 |V| 放置在主机共享缓冲区的字节偏移量 |k| 处时，则：

   * |V|.x 被放置在字节偏移量 |k| 处
   * |V|.y 被放置在字节偏移量 |k|+4 处
   * 如果 |N| &ge; 3，则|V|.z被放置在字节偏移量 |k|+8 处
   * 如果 |N| &ge; 4，则|V|.w被放置在字节偏移量 |k|+12 处

当矩阵值 |M| 放置在主机共享内存缓冲区的字节偏移量 k 处时，则：
   * 如果|M|有两行，则：
      * |M| 的列向量 |i| 被放置在字节偏移量 |k| + 8 &times; |i| 处
   * 如果|M|有3或4行，则：
      * |M| 的列向量 |i| 被放置在字节偏移量 k| + 16 &times; |i| 处

当数组类型 |A| 的值放置在主机共享内存缓冲区的字节偏移量 |k| 处时，则：
   * 数组的元素 |i| 被放置在字节偏移量 k| + |i| &times; [=StrideOf=](|A|) 处

当结构类型 |S| 的值被放置在主机共享内存缓冲区的字节偏移量 |k| 处时，则：
   * 结构值的第 |i| 个成员被放置在字节偏移量 |k| + [=OffsetOfMember=](|S|,|i|) 处


#### 存储类布局约束 ####  {#storage-class-layout-constraints}

存储类（[=storage classes/storage=]）和统一存储类（[=storage classes/uniform=]）具有不同的缓冲区布局约束，本节将对此进行介绍。

变量直接或间接引用的所有结构和数组类型必须遵守变量存储类的约束。违反存储类约束会导致编译时错误。

在本节中，我们将<dfn noexport>RequiredAlignOf</dfn>(|S|, |C|)定义为当存储类 |C| 使用主机可共享类型 |S| 的值时所需的字节偏移对齐。

<table class='data'>
  <caption>
    对[=storage classes/storage=]和[=storage classes/uniform=]存储类的主机可共享类型的对齐要求。
  </caption>
  <thead>
    <tr><th>Host-shareable type |S|
        <th>[=RequiredAlignOf=](|S|, [=storage classes/storage=])
        <th>[=RequiredAlignOf=](|S|, [=storage classes/uniform=])
  </thead>
  <tr><td>[=i32=], [=u32=], or [=f32=]
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>atomic&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>vecN&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of a matrix with N columns and M rows">
      <td>matNxM&lt;f32&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of an array">
      <td>array&lt;T, N&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of an runtime-sized array">
      <td>array&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of a structure">
      <td>struct |S|
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))<br>
</table>

类型 |T| 的结构成员必须从结构的开头有一个字节偏移量，该偏移量是对存储类 |C| 的 [=RequiredAlignOf=](|T|, |C|) 的倍数：

<p algorithm="structure member minimum alignment">
    [=OffsetOfMember=](|S|, |M|) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    其中 |k| 为一个正整数，且 |M| 为具有类型 |T| 的结构 |S| 的成员。
</p>

元素类型 |T| 的数组的元素步幅（[=element stride=]）必须是对存储类 |C| 的 [=RequiredAlignOf=](|T|, |C|) 的倍数：

<p algorithm="array element minimum alignment">
    [=StrideOf=](array<|T|[, |N|]>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    其中 |k| 是一个正整数
</p>

注意：[=RequiredAlignOf=](|T|, |C|) 不会对对齐（[=attribute/align=]）修饰允许的值施加任何额外限制，也不会影响 [=AlignOf=](|T|) 的规则。数据按照前面部分中定义的规则进行布局，然后根据 [=RequiredAlignOf=](|T|, |C|) 规则验证生成的布局。

统一（[=storage classes/uniform=]）存储类还要求：
* 数组元素对齐到 16 字节边界。也就是说，对于某个正整数 k'，[=StrideOf=](array&lt;|T|,|N|&gt;) = 16 &times; |k|'。
* 如果结构成员本身具有结构类型 `S`，则该成员的开头和任何后续成员的开头之间的字节数必须至少为 [=roundUp=](16, [=SizeOf=](S))。

<div class='example wgsl global-scope' heading='invalid structure layout for uniform storage class'>
  <xmp highlight='rust'>
    struct S {
      x: f32;
    };
    struct Invalid {
      a: S;
      b: f32; // 无效：a 和 b 之间的偏移量为 4 字节，但必须至少为 16
    };
    struct Valid {
      a: S;
      [[align(16)]] b: f32; // 有效：a 和 b 之间的偏移量为 16 字节
    };
    [[group(0), binding(0)]] var<uniform> invalid: Invalid;
    [[group(0), binding(1)]] var<uniform> valid: Valid;
  </xmp>
</div>

## 内存视图类型 ## {#memory-view-types}

除了使用普通（[=plain types|plain=]）值进行计算之外，[SHORTNAME]程序还经常通过内存访问（[=memory access=]）操作从内存中读取值或将值写入内存。 每个内存访问都是通过内存视图（[=memory view=]）执行的。

内存视图（<dfn noexport>memory view</dfn>）由以下内容组成：
* 特定存储类（[=storage class=]）中的一组内存位置（[=memory locations=]），
* 将这些位置的内容解释为 [SHORTNAME] 类型（[=type=]），以及
* 一个访问模式（[=access mode=]）。

内存视图的访问方式必须被存储类支持。见[[#storage-class]]。

[SHORTNAME] 有两种表示内存视图的类型：引用类型（[=reference types=]）和指针类型（[=pointer types=]）。

<table class='data'>
  <thead>
    <tr><th>Constraint<th>Type<th>Description
  </thead>
  <tr algorithm="memory reference type">
    <td style="width:25%">|SC| 是一个存储类（[=storage class=]）,<br>|T|是一个可存储（[=storable=]）类型,<br>|A| 是访问模式（[=access mode=]）
    <td>ref&lt;|SC|,|T|,|A|&gt;
    <td>
        引用类型（<dfn noexport>reference type</dfn>）由一组对 |SC| 中的内存位置持有类型 |T| 的值的内存视图（[=memory views=]）标识，支持模式 |A| 中描述的内存访问。<br>在这种情况下，|T| 被称为存储类型（<dfn noexport>store type</dfn>）。<br>参考类型没有写在 [SHORTNAME] 源程序中；相反它们用于分析 [SHORTNAME] 程序。
  <tr algorithm="pointer type">
    <td>|SC|是一个存储类（[=storage class=]）,<br>|T|是一个可存储（[=storable=]）类型,<br>|A| 是一个访问模式（[=access mode=]）
    <td>ptr&lt;|SC|,|T|,|A|&gt;
    <td>
        指针类型（<dfn noexport>pointer type</dfn>）由一组对 |SC| 中内存位置持有类型 |T| 的值的内存视图（[=memory views=]）标识，支持模式 |A| 中描述的内存访问。<br>在这种情况下，|T| 被称为指针类型（<dfn noexport>pointee type</dfn>）。<br>指针类型可能出现在 [SHORTNAME] 程序源中。
</table>

在*分析* WGSL 程序时，引用和指针类型完全由存储类、可存储类型和访问模式参数化。在本规范的代码示例中，注释显示了这种完全参数化的形式。

但是，在 [SHORTNAME] *源*文本中：
* 引用类型必须不能出现。
* 指针类型可能出现。一个参数化的指针类型通过以下内容拼写：
    * 存储类，
    * 存储类型，以及
    * 有时通过访问模式，如[[#access-mode-defaults]]中所述。

<div class='example wgsl' heading='Pointer type'>
  <xmp highlight='rust'>
    fn my_function(
      // 'ptr<function,i32,read_write>' 是一个指针类型，引用存储保持 'i32' 值，使用函数存储类中的内存位置
      // 这里 'i32' 是指针类型。
      // 隐含的访问模式为 'read_write' ，访问模式的默认值见下文。
      ptr_int: ptr<function,i32>,

      // 'ptr<private,array<f32,50>,read_write>' 是指针值的类型，
      // 它指的是使用 'private' 存储类中的内存位置保存 50 个类型为 'f32' 元素的数组的存储。
      // 这里的指针类型是'array<f32,50>'。 隐含的访问模式是“read_write”。见下面的访问模式默认值。
      ptr_array: ptr<private, array<f32, 50>>
    ) { }
  </xmp>
</div>

引用类型和指针类型都是内存视图的集合：特定的内存视图与唯一的引用值和唯一的指针值相关联：

<blockquote algorithm="pointer reference correspondence">
每个类型ptr&lt;|SC|,|T|,|A|&gt;的指针值 |p| 对应于一个类型ref&lt;|SC|,|T|,|A|&gt;的单独参考值|r|，反之亦然，其中 |p| 和 |r| 描述相同的内存视图。
</blockquote>

### 访问模式默认值 ### {#access-mode-defaults}

内存视图的访问模式通常由上下文决定：

* [=storage classes/storage=] 存储类支持 [=access/read=] 和 [=access/read_write=] 两种访问模式。
* 每个其他存储类仅支持一种访问模式，如<a href="#storage-class-table">存储类</a>表中所述。

当在 [SHORTNAME] 源码中写入变量声明（[=variable declaration=]）或指针类型（[=pointer type=]）时：
* 对 [=storage classes/storage=] 存储类，访问模式是可选的，默认为 [=access/read=]。
* 对其他存储类，访问模式必须不填写。

### 原始变量 ### {#originating-variable-section}

在 [SHORTNAME] 中，参考值始终对应于某些变量的部分或全部内存位置的内存视图。这定义了参考值的原始变量（<dfn noexport>originating variable</dfn>）。

一个指针值总是对应一个引用值，因此指针的原始变量与相应引用的原始变量相同。

注意：原始变量是一个动态概念。函数形式参数的原始变量取决于函数的调用位置（[=call site|call sites=]）。 不同的调用位置可以提供指向不同起始变量的指针。

如果一个引用或指针访问出界，则产生一个无效内存引用（<dfn noexport>invalid
memory reference</dfn>）。

从无效引用中加载（[=Load Rule|Loads=]）返回以下内容之一：
    * 来自绑定到原始变量（[=originating variable=]）的 WebGPU 缓冲区（[[WebGPU#buffers|WebGPU buffer]]）的任何内存位置（[=memory locations|memory location(s)=]）的值
    * 引用的存储类型的零值（[=zero value=]）。
    * 如果加载的值是向量，则值 (0, 0, 0, x)，其中 x 是：
        * 0、1 或最大正值对整数分量
        * 0.0 或 1.0 对浮点分量
对无效引用的存储（[=statement/assignment|Stores=]）可能：
    * 将值存储到绑定到原始变量的 WebGPU 缓冲区（[[WebGPU#buffers|WebGPU buffer]]）的任何内存位置（[=memory locations|memory location(s)=]）
    * 没有被执行

对无效内存引用进行操作的读-修改-写原子（[[#atomic-rmw|Read-modify-write atomics]]）必须从相同的内存位置（[=memory locations|memory
locations=]）加载和存储，如果它们访问内存。

### 引用和指针用例 ### {#ref-ptr-use-cases}

引用和指针通过使用方法来区分：

* 一个变量（[=variable=]）的类型为一个引用类型。
* 寻址（[=address-of=]）操作（unary `&`）将一个引用值转换为其对应的指针值。
* 间接寻址（[=indirection=]）操作（unary *）将指针值转换为其对应的引用值。
* let声明（[=let declaration=]）可以为指针类型，但是不能为引用类型。
* 形式参数（[=formal parameter=]）可以是指针类型，但是不能为引用类型。
* 赋值语句（[=statement/assignment=]）执行写访问（[=write access=]）以通过引用更新内存内容，其中：
    * 赋值语句的左侧必须是引用类型，访问模式为 [=access/write=] 或 [=access/read_write=]。
    * 赋值语句的右侧必须计算为左侧的存储类型。
* 加载规则（<dfn noexport>Load Rule</dfn>）：在函数内部，引用会自动解除引用（读取）以满足类型规则：
    * 在函数中，当在语句或表达式中使用存储类型为 |T| 的引用表达式 |r| 时，其中
    * |r| 具有访问模式 [=access/read=] 或 [=access/read_write=]，且
    * 唯一可能匹配的类型规则要求 |r| 具有类型 |T| 的值，然后
    * 此类型规则的要求视作被满足，且
    * 在该上下文中，表达式 |r| 的计算结果为存储在计算时被 |r| 引用的内存位置的值（类型为|T|）。也就是说，执行读取访问（[=read access=]）以产生结果值。

以这种方式定义引用可以简单地惯用变量：

<div class='example wgsl' heading='Reference types enable simple use of variables'>
  <xmp highlight='rust'>
    [[stage(compute)]]
    fn main() {
      // 'i' 具有引用类型 ref<function,i32,read_write>。
      // 'i' 的内存位置存储 i32 值 0。
      var i: i32 = 0;

      // 'i + 1'只能匹配'i'子表达式为 i32 类型的类型规则。
      // 因此，表达式'i + 1'的类型为 i32，并且在计算时，'i'子表达式的计算结果为计算时存储在'i'的内存位置中的 i32 值。
      let one: i32 = i + 1;

      // 更新 'i' 引用的位置中的值，使它们保持值 2。
      i = one + 1;

      // 更新 'i' 引用的位置中的值，使它们保持值 5。
      // 右侧的计算发生在分配生效之前。
      i = i + 3;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Returning a reference returns the value loaded via the reference'>
  <xmp highlight='rust'>
    var<private> age: i32;
    fn get_age() -> i32 {
      // return 语句中的表达式类型必须是“i32”，因为它必须与函数声明的返回类型匹配。
      // 'age' 表达式的类型为 ref<private,i32,read_write>。
      // 应用加载规则，因为引用的存储类型与所需的表达式类型匹配，并且不应用其他类型规则。
      // 在此上下文中对'age'的计算是在执行 return 语句时从'age'引用的内存位置加载的 i32 值。
      return age;
    }

    fn caller() {
      age = 21;
      // copy_age 常量将获得 i32 值 21。
      let copy_age: i32 = get_age();
    }
  </xmp>
</div>

以这种方式定义指针可以实现两个关键用例：

* 使用带指针类型的 let 声明，为变量的部分内容形成一个短名称。
* 使用函数的形式参数来引用调用函数（[=calling function=]）可访问变量的存储。
    * 对此类函数的调用必须为该操作数提供一个指针值。这通常需要使用寻址（[=address-of=]）操作（unary `&`）来获取指向变量内容的指针。

注意：以下示例使用了本规范稍后解释的 [SHORTNAME] 功能。

<div class='example wgsl' heading='Using a pointer as a short name for part of a variable'>
  <xmp highlight='rust'>
    struct Particle {
      position: vec3<f32>;
      velocity: vec3<f32>;
    };
    [[block]] struct System {
      active_index: i32;
      timestep: f32;
      particles: array<Particle,100>;
    };
    [[group(0), binding(0)]] var<storage,read_write> system: System;

    [[stage(compute)]]
    fn main() {
      // 在存储内存中形成一个指向特定粒子的指针。
      let active_particle: ptr<storage,Particle> =
          &system.particles[system.active_index];

      let delta_position: vec3<f32> = (*active_particle).velocity * system.timestep;
      let current_position: vec3<f32>  = (*active_particle).position;
      (*active_particle).position = delta_position + current_position;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Using a pointer as a formal parameter'>
  <xmp highlight='rust'>
    fn add_one(x: ptr<function,i32>) {
      // 更新 'x' 的位置以包含下一个更高的整数值，（或环绕到最大的负 i32 值）。
      // 在左侧，一元“*”将指针转换为随后可以分配给的引用。
      // 默认情况下，它具有 read_write 访问模式。
      // 在右侧：
      // - 一元'*'将指针转换为引用，具有 read_write 访问模式。
      // - 唯一匹配的类型规则是加法 (+) 并且要求 '*x' 具有类型 i32，这是 '*x' 的存储类型。
      //   所以负载规则应用并且 '*x' 计算为在计算时为 '*x' 存储在内存中的值，即 0 的 i32 值。
      // - 将 1 添加到 0，以生成右侧的最终值 1 - 手边。 将 1 存储到 '*x' 的内存中。
      *x = *x + 1;
    }

    [[stage(compute)]]
    fn main() {
      var i: i32 = 0;

      // 修改'i' 的内容，使其包含1。使用一元'&' 获取'i' 的指针值。
      // 这是一个明确的信号，表明被调用的函数可以访问 'i' 的存储，并且可以修改它。
      add_one(&i);
      let one: i32 = i;  // 'one' has value 1.
    }
  </xmp>
</div>

### 形成引用和指针值 ### {#forming-references-and-pointers}

引用值通过以下方式之一形成：

* 解析为范围内（[=in scope|in-scope=]）变量 *v* 的标识符（[=identifier=]）表示 *v* 存储的引用值。
    * 解析成的变量是对引用的原始变量（[=originating variable=]）。
* 对一个指针使用间接寻址（[=indirection=] (unary `*`)）操作。
    * 结果的原始变量被定义为指针的原始变量。
* 使用一个复合参考元件表达式（<dfn noexport>composite reference component expression</dfn>）。
    在每种情况下，结果的原始变量都被定义为原始引用的原始变量。
    * 给定具有向量存储类型的引用，附加单字母向量访问短语会产生对向量的命名组件的引用。见[[#component-reference-from-vector-reference]]。
    * 给定具有向量存储类型的引用，附加数组索引访问短语会产生对向量的索引组件的引用。见[[#component-reference-from-vector-reference]]。
    * 给定具有矩阵存储类型的引用，附加数组索引访问短语会产生对矩阵的索引列向量的引用。见[[#matrix-access-expr]]。
    * 给定具有数组存储类型的引用，附加数组索引访问短语会产生对数组索引元素的引用。见[[#array-access-expr]]。
    * 给定具有结构存储类型的引用，附加成员访问短语会产生对结构的命名成员的引用。见[[#struct-access-expr]]。

在所有情况下，结果的访问模式与原始引用的访问模式相同。
<div class='example wgsl' heading='Component reference from a composite reference'>
  <xmp highlight='rust'>
    struct S {
        age: i32;
        weight: f32;
    };
    var<private> person: S;
    // 'person' 的使用表示对变量底层存储的引用，并且类型为 ref<private,S,read_write>。

    fn f() {
        var uv: vec2<f32>;
        // 'uv' 的使用表示对变量底层存储的引用，并且类型为 ref<function,vec2<f32>,read_write>。
        // 计算赋值的左侧： 计算 'uv.x' 以产生引用：
        // 1. 首先计算 'uv'，产生对 'uv' 变量存储的引用。结果的类型为 ref<function,vec2<f32>,read_write>。
        // 2. 然后应用'.x'向量访问短语，产生对由上一步中的引用值指向的向量的第一个分量的存储的引用。
        //    结果的类型为 ref<function,f32,read_write>。
        //    计算赋值的右侧会产生 f32 值 1.0。 将 f32 值 1.0 存储到 uv.x 引用的存储内存位置。
        uv.x = 1.0;

        // 计算赋值的左侧： 计算 'uv[1]' 以产生引用：
        // 1. 首先计算 'uv'，产生对 'uv' 变量存储的引用。 结果的类型为 ref<function,vec2<f32>,read_write>。
        // 2. 然后应用'[1]'数组索引短语，产生对上一步引用的向量的第二个组件的存储的引用。
        //    结果的类型为 ref<function,f32,read_write>。
        //    计算赋值的右侧会产生 f32 值 2.0。
        //    将 f32 值 2.0 存储到 uv[1] 引用的存储内存位置。
        uv[1] = 2.0;

        var m: mat3x2<f32>;
        // 计算'm[2]'时：
        // 1. 首先计算'm'，产生对“m”变量存储的引用。结果的类型为 ref<function,mat3x2<f32>,read_write>。
        // 2. 然后应用 '[2]' 数组索引短语，产生对存储由上一步中的参考值指向的第三列向量。
        //    因此，'m[2]' 表达式的类型为 ref<function,vec2<f32>,read_write>。
        //    'let' 声明是针对 vec2<f32> 类型的，因此声明语句要求初始化程序的类型为 vec2<f32>。
        //    加载规则适用（因为没有其他类型规则可以适用），以及初始化器的计算产生 vec2<f32> 值，
        //    该值是在执行声明时从 'm[2]' 引用的内存位置加载的。
        let p_m_col2: vec2<f32> = m[2];

        var A: array<i32,5>;
        // 计算'A[4]'时
        // 1. 首先计算“A”，产生对“A”变量存储的引用。
        //    结果的类型为 ref<function,array<i32,5>,read_write>。
        // 2. 然后应用'[4]'数组索引短语，产生对由上一步中的引用值引用的数组的第五个元素的存储的引用。
        //    结果值的类型为 ref<function,i32,read_write>。 他让声明要求右手边是 i32 类型。
        //    加载规则适用（因为没有其他类型规则可以应用），并且初始化器的计算产生从执行声明时由 'A[5]' 引用的内存位置加载的 i32 值。
        let A_4_value: i32 = A[4];

        // 计算'person.weight'时：
        // 1. 首先计算'person'，产生对在模块范围内声明的“person”变量的存储的引用。
        //    结果的类型为 ref<private,S,read_write>。
        // 2. 然后应用'.weight'成员访问短语，产生对存储器的第二个成员的存储器的引用，该存储器由上一步中的引用值引用。
        //    结果的类型为 ref<private,f32,read_write>。
        //    let 声明要求右侧的类型为 f32。
        //    加载规则适用（因为没有其他类型规则可以应用），并且初始化器的计算产生从执行声明时'person.weight'引用的内存位置加载的 f32 值。

        let person_weight: f32 = person.weight;
    }
  </xmp>
</div>

指针值以下列方式之一形成：

* 对引用使用寻址（[=address-of=] (unary '&')）操作。
    * 结果的原始变量被定义为引用的原始变量。
* 如果函数形式参数（[=formal parameter=]）具有指针类型，则在运行时调用该函数时，形参的使用表示在调用函数（[=calling function=]）的调用位置（[=call site=]）处提供给相应操作数的指针值。
    * 形式参数（在运行时）的原始变量被定义为在调用位置处指针操作数的原始变量。

在所有情况下，结果的访问模式与原始指针的访问模式相同。

<div class='example wgsl' heading='Pointer from a variable'>
  <xmp highlight='rust'>
    // 在私有存储类中声明一个变量，用于存储 f32 值。
    var<private> x: f32;

    fn f() {
        // 在函数存储类中声明一个变量，用于存储 i32 值。
        var y: i32;

        // 名称'x'解析为模块范围变量'x'，并且具有引用类型 ref<private,f32,read_write>。
        // 应用一元“&”运算符将引用转换为指针。
        // 访问方式与原变量的访问方式相同，所以完全指定的类型为ptr<private,f32,read_write>。
        // 但是read_write是函数存储类的默认访问方式，所以这种情况下不需要拼写read_write
        let x_ptr: ptr<private,f32> = &x;

        // 名称'y'解析为函数范围变量'y'，并且具有引用类型 ref<private,i32,read_write>。
        // 应用一元“&”运算符将引用转换为指针。 访问模式默认为“read_write”。
        let y_ptr: ptr<function,i32> = &y;

        // 一个新变量，不同于在模块范围内声明的变量。
        var x: u32;

        // 此处，名称'x'解析为前一条语句中声明的函数作用域变量'x'，其类型为 ref<function,u32,read_write>。
        // 应用一元'&'运算符将引用转换为指针。 访问模式默认为'read_write'。
        let inner_x_ptr: ptr<function,u32> = &x;
    }
  </xmp>
</div>

### 与其他语言中引用和指针的比较 ### {#pointers-other-languages}

本节是信息性的，是不规范的。

[SHORTNAME]中的引用和指针相较于其他语言受更多的限制。具体为：

* 在 [SHORTNAME] 中，不能将引用直接声明为另一个引用或变量的别名，无论是变量还是形式参数。
* 在 [SHORTNAME] 中，指针和引用不可存储（[=storable=]）。也就是说，[SHORTNAME] 变量的内容可能不包含指针或引用。
* 在 [SHORTNAME] 中，函数必须不返回指针或引用。
* 在 [SHORTNAME] 中，无法在整数值和指针值之间进行转换。
* 在 [SHORTNAME] 中，无法将指针值的类型强制更改为另一种指针类型。
    * 复合组件引用表达式是不同的：它获取对复合值的引用，并产生对复合值内的组件或元素之一的引用。这些在 [SHORTNAME] 中被认为是不同的引用，即使它们在实现抽象级别的较低级别可能具有相同的机器地址。
* 在 [SHORTNAME] 中，无法将引用值的类型强制更改为另一种引用类型
* 在 [SHORTNAME] 中，无法更改指针或引用的访问模式。
    * 相比之下，C++ 会自动将非常量指针转换为 const 指针，并有一个 const_cast 将一个 const 值转换为一个非常量值。
* 在 [SHORTNAME] 中，无法从“堆”分配新的存储空间。
* 在 [SHORTNAME] 中，无法显式销毁变量。 只有当变量超出范围时，[SHORTNAME] 变量的存储才会变得不可访问。

注意：根据上述规则，不可能形成“悬空”指针，即不引用有效的（或“活动的”）原始变量的存储的指针。

## 纹理和采样器类型 ## {#texture-types}

纹素（<dfn noexport>texel</dfn>）是用作纹理的最小可独立访问元素的标量或向量。*texel*这个词是*纹理元素*的缩写。

纹理（<dfn noexport>texture</dfn>）是支持对渲染有用的特殊操作的纹素集合。 在 [SHORTNAME] 中，这些操作是通过纹理内置函数调用的。 有关完整列表，见[[#texture-builtin-functions]]。

[SHORTNAME] 纹理对应于 [[WebGPU#gputexture|WebGPU GPUTexture]]。

纹理可以是数组形式的，也可以是非数组的：

* 非数组纹理（<dfn noexport>non-arrayed texture</dfn>）是一个纹素网格，每个纹素有单独的网格坐标。
* 数组纹理（<dfn noexport>arrayed texture</dfn>）是纹素网格的齐次数组。在数组纹理中，每个纹素通过其唯一的数组索引和网格坐标组合来标识。

纹理具有以下特性：
: 纹素格式
:: 每个纹素中的数据，见[[#texel-formats]]。
: 维度
:: 网格坐标中的维数，以及坐标的解释方式。维度数为 1、2 或 3。大多数纹理使用笛卡尔坐标。立方体纹理有六个方形面，并使用三维坐标进行采样，该坐标解释为从原点到以原点为中心的立方体的方向向量。
: 大小
:: 沿每个维度的网格坐标的范围
: mip 级别计数
:: 采样纹理的 mip 级别计数至少为 1，存储纹理的 mip 级别计数至少为 1。Mip 级别 0 包含纹理的全尺寸版本。每个连续的 mip 级别都包含前一个 mip 级别的过滤版本，大小为前一个 mip 级别的一半（在舍入范围内）。在对纹理进行采样时，使用显式或隐式计算的细节级别来选择从中读取纹素数据的 mip 级别。 然后通过过滤将它们组合起来以产生采样值。
: 数组化
:: 纹理是否为数组化
: 数组大小（<dfn noexport>array size</dfn>）
:: 齐次网格的数量，如果纹理为数组化的

纹理的表示通常针对渲染操作进行优化。为了实现这一点，许多细节对程序员是隐藏的，包括无法直接用着色器语言表达的数据布局、数据类型和内部操作。

因此，着色器无法直接访问纹理变量中的纹素存储。相反，访问是通过一个不透明的句柄来调解的：

* 在着色器内：
    * 声明一个模块范围变量，其中存储类型（[=store type=]）是后面部分中描述的纹理类型之一。 该变量存储底层纹理内存的不透明句柄，并自动放置在句柄（[=storage classes/handle=]）存储类中。
    * 在函数内部，调用其中一个纹理内置函数，并提供纹理变量作为第一个参数。
* 在构建 WebGPU 管道时，纹理变量的存储类型和绑定必须与相应的绑定组布局条目兼容。

TODO：更新此处以描述处理纹理或采样器函数参数。

这样，纹理类型支持的操作集由接受该纹理类型作为第一个参数的纹理内置函数的可用性决定。

注意：着色器无法更改纹理变量存储的句柄。也就是说，该变量是只读的，即使它提供访问的底层纹理可能是可变的（例如，只写存储纹理）。

TODO：在相同的广框架中描述采样器的使用。

### 纹素格式 ### {#texel-formats}

在 [SHORTNAME] 中，某些纹理类型由纹素格式参数化。

纹素格式（<dfn noexport>texel format</dfn>）被归类为：

: 频道（<dfn noexport>channels</dfn>）
:: 每个频道包含一个标量。纹素格式最多有四个通道：r、g、b 和 a，通常对应于红色、绿色、蓝色和 alpha 通道的概念。
: 频道格式（<dfn noexport>channel format</dfn>）
:: 通道中的位数，以及如何解释这些位。

[SHORTNAME] 中的每个纹素格式都对应一个同名的 [[WebGPU#enumdef-gputextureformat|WebGPU GPUTextureFormat]]。

[SHORTNAME] 源代码中仅使用某些纹素格式。用于定义这些纹素格式的频道格式在频道格式（<dfn dfn>Channel Formats</dfn>）表中列出。 最后一列指定从存储的频道位到着色器中使用的值的转换。这也称为频道传递函数（<dfn noexport>channel transfer function</dfn>）或 CTF。

<table class='data'>
  <caption>Channel Formats</caption>
  <thead>
    <tr><th>Channel format
        <th>Number of stored bits
        <th>Interpetation of stored bits
        <th>Shader type<td style="width:25%">Shader value
(Channel Transfer Function)
  </thead>
  <tr><td>8unorm<td>8<td>无符号整数 |v| &isinv; {0,...,255}<td>f32<td> |v| &div; 255
  <tr><td>8snorm<td>8<td>有符号整数 |v| &isinv; {-128,...,127}<td>f32<td> max(-1, |v| &div; 127)
  <tr><td>8uint<td>8<td>无符号整数 |v| &isinv; {0,...,255}<td>u32<td> |v|
  <tr><td>8sint<td>8<td>有符号整数 |v| &isinv; {-128,...,127}<td>i32<td> |v|
  <tr><td>16uint<td>16<td>无符号整数 |v| &isinv; {0,...,65535}<td>u32<td> |v|
  <tr><td>16sint<td>16<td>有符号整数 |v| &isinv; {-32768,...,32767}<td>i32<td> |v|
  <tr><td>16float<td>16<td>[[!IEEE-754|IEEE-754]] binary16 16-位浮点值 |v|, 1 符号位，5指数位，10尾数位<td>f32<td>|v|
  <tr><td>32uint<td>32<td>32-位无符号整数值 |v|<td>u32<td>|v|
  <tr><td>32sint<td>32<td>32-位有符号整数值 |v|<td>i32<td>|v|
  <tr><td>32float<td>32<td>[[!IEEE-754|IEEE-754]] binary32 32-位浮点值 |v|<td>f32<td>|v|
</table>

存储纹理的纹素格式（<dfn dfn lt="storage-texel-formats">Texel Formats for Storage Textures</dfn>）表中列出的纹素格式对应于支持 [[WebGPU#dom-gputextureusage-storage|WebGPU STORAGE]] 使用的 WebGPU 纯色格式（[[WebGPU#plain-color-formats|WebGPU plain color formats]]）。这些纹素格式用于参数化在[[#texture-storage]]中定义的存储纹理类型。

当纹素格式没有所有四个频道时，则：

* 当读取纹素时：
    * 如果纹素格式没有绿色频道，则着色器值的第二个分量为 0。
    * 如果纹素格式没有蓝色频道，则着色器值的第三个分量为 0。
    * 如果纹素格式没有 Alpha 频道，则着色器值的第四个分量为 1。
* 写入纹素时，缺失频道的着色器值组件将被忽略。

下表中的最后一列使用了频道格式（[=channel formats=]）表中特定于格式的频道传输函数（[=channel transfer function=]）。

<table class='data'>
  <caption>存储纹理的纹素格式</caption>
  <thead>
    <tr><th>Texel format
        <th>Channel format
        <th>Channels in memory order
        <th style="width:50%">Corresponding shader value
  </thead>
  <tr><td>rgba8unorm<td>8unorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8snorm<td>8snorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8uint<td>8uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8sint<td>8sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16uint<td>16uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16sint<td>16sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16float<td>16float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>r32uint<td>32uint<td>r<td>vec4&lt;u32&gt;(CTF(r), 0u, 0u, 1u)
  <tr><td>r32sint<td>32sint<td>r<td>vec4&lt;i32&gt;(CTF(r), 0, 0, 1)
  <tr><td>r32float<td>32float<td>r<td>vec4&lt;f32&gt;(CTF(r), 0.0, 0.0, 1.0)
  <tr><td>rg32uint<td>32uint<td>r, g<td>vec4&lt;u32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rg32sint<td>32sint<td>r, g<td>vec4&lt;i32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rg32float<td>32float<td>r, g<td>vec4&lt;f32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rgba32uint<td>32uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba32sint<td>32sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba32float<td>32float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
</table>

下表列出了 WGSL 纹素格式和 SPIR-V 图像格式（[=image formats=]）之间的对应关系。

<table class='data'>
  <caption>映射纹素格式至SPIR-V</caption>
  <thead>
    <tr><th>Texel format
        <th>SPIR-V Image Format
        <th>SPIR-V Enabling Capability
  </thead>
  <tr><td>rgba8unorm<td>Rgba8<td>Shader
  <tr><td>rgba8snorm<td>Rgba8Snorm<td>Shader
  <tr><td>rgba8uint<td>Rgba8ui<td>Shader
  <tr><td>rgba8sint<td>Rgba8i<td>Shader
  <tr><td>rgba16uint<td>Rgba16ui<td>Shader
  <tr><td>rgba16sint<td>Rgba16i<td>Shader
  <tr><td>rgba16float<td>Rgba16f<td>Shader
  <tr><td>r32uint<td>R32ui<td>Shader
  <tr><td>r32sint<td>R32i<td>Shader
  <tr><td>r32float<td>R32f<td>Shader
  <tr><td>rg32uint<td>Rg32ui<td>StorageImageExtendedFormats
  <tr><td>rg32sint<td>Rg32i<td>StorageImageExtendedFormats
  <tr><td>rg32float<td>Rg32f<td>StorageImageExtendedFormats
  <tr><td>rgba32uint<td>Rgba32ui<td>Shader
  <tr><td>rgba32sint<td>Rgba32i<td>Shader
  <tr><td>rgba32float<td>Rgba32f<td>Shader
</table>

### 采样纹理类型 ### {#sampled-texture-type}

<pre class='def'>
`texture_1d<type>`
  %1 = OpTypeImage %type 1D 0 0 0 1 Unknown

`texture_2d<type>`
  %1 = OpTypeImage %type 2D 0 0 0 1 Unknown

`texture_2d_array<type>`
  %1 = OpTypeImage %type 2D 0 1 0 1 Unknown

`texture_3d<type>`
  %1 = OpTypeImage %type 3D 0 0 0 1 Unknown

`texture_cube<type>`
  %1 = OpTypeImage %type Cube 0 0 0 1 Unknown

`texture_cube_array<type>`
  %1 = OpTypeImage %type Cube 0 1 0 1 Unknown
</pre>
* 类型必须为 `f32`, `i32` 或 `u32`
* 图像的参数化类型是采样转换后的类型。例如：你可以使用带有 8 位 unorm 组件的纹素图像，但是当您对它们进行采样时，您会得到 32 位浮点结果（或 vec-of-f32）。

### 多重采样纹理类型 ### {#multisampled-texture-type}

<pre class='def'>
`texture_multisampled_2d<type>`
  %1 = OpTypeImage %type 2D 0 0 1 1 Unknown
</pre>
* 类型必须为 `f32`, `i32` 或 `u32`

### 外部采样纹理类型 ### {#external-texture-type}

<pre class='def'>
`texture_external`
</pre>

`texture_external` 是一种类似于 `texture_2d<f32>` 的不透明 2d 浮点采样纹理类型，但可能具有不同的表示。可以使用 `textureLoad` 或 `textureSampleLevel` 读取它，它们不透明地处理这些不同的表示。

详见[`GPUExternalTexture`](https://gpuweb.github.io/gpuweb/#gpu-external-texture)。

### 存储纹理类型 ### {#texture-storage}

存储纹理（<dfn noexport>storage texture</dfn）支持在不使用采样器的情况下访问单个纹素。

* 只写存储纹理（A <dfn noexport>write-only storage texture</dfn>）支持写入单个纹素，并自动将着色器值转换为存储的纹素值。

存储纹理类型必须由一种存储纹理的纹素格式（[=storage-texel-format|texel formats for storage textures=]）进行参数化。纹素格式决定了 [[#texel-formats]] 中指定的转换函数。

对于只写存储纹理，转换函数的*逆*函数用于将着色器值转换为存储的纹素。

见[[#texture-builtin-functions]]。

TODO(dentro)：将转换的描述移动到实际进行读取的内置函数中。

<pre class='def'>
`texture_storage_1d<texel_format,access>`
  // %1 = OpTypeImage sampled_type 1D 0 0 0 2 image_format

`texture_storage_2d<texel_format,access>`
  // %1 = OpTypeImage sampled_type 2D 0 0 0 2 image_format

`texture_storage_2d_array<texel_format,access>`
  // %1 = OpTypeImage sampled_type 2D 0 1 0 2 image_format

`texture_storage_3d<texel_format,access>`
  // %1 = OpTypeImage sampled_type 3D 0 0 0 2 image_format
</pre>

* `texel format` 必须为存储纹素格式（[=storage-texel-formats=]）中指定的纹素类型之一
* `access` 必须为 [=access/write=]

在 SPIR-V 映射中：
* 图像类型声明的*图像格式*参数按照[[#texel-formats]]中SPIR-V 纹素格式对应表的规定。
* 图像类型声明的*采样类型*参数为纹素格式的频道格式对应的SPIR-V标量类型。

映射到 SPIR-V 时，只写存储纹理变量必须具有 `NonReadable` 修饰。

例如：

<div class='example wgsl global-scope' heading='Mapping a writable texture_storage_1d variable to SPIR-V'>
  <xmp>
      var tbuf: texture_storage_1d<rgba8unorm,write>;

      // Maps to the following SPIR-V:
      //  OpDecorate %tbuf NonReadable
      //  ...
      //  %float = OpTypeFloat 32
      //  %image_type = OpTypeImage %float 1D 0 0 0 2 Rgba8
      //  %image_ptr_type = OpTypePointer UniformConstant %image_type
      //  %tbuf = OpVariable %image_ptr_type UniformConstant
  </xmp>
</div>

### 深度纹理类型 ### {#texture-depth}
<pre class='def'>
`texture_depth_2d`
  %1 = OpTypeImage %f32 2D 1 0 0 1 Unknown

`texture_depth_2d_array`
  %1 = OpTypeImage %f32 2D 1 1 0 1 Unknown

`texture_depth_cube`
  %1 = OpTypeImage %f32 Cube 1 0 0 1 Unknown

`texture_depth_cube_array`
  %1 = OpTypeImage %f32 Cube 1 1 0 1 Unknown

`texture_depth_multisampled_2d`
  %1 = OpTypeImage %f32 2D 1 0 1 1 Unknown
</pre>

### 采样器类型 ### {#sampler-type}

采样器（<dfn>sampler</dfn>）通过执行以下组合来调节对采样纹理或深度纹理的访问：
* 坐标转换。
* 可选地修改 mip-level 选择。
* 对于采样纹理，可选择过滤检索到的纹素值。
* 对于深度纹理，确定应用于检索到的纹素的比较函数。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="sampler type">
    <td>sampler
    <td>采样器。调节对采样纹理的访问。</td>
  <tr algorithm="comparison sampler type">
    <td>sampler_comparison
    <td>比较采样器。调节对深度纹理的访问。</td>
</table>

采样器在被 WebGPU API 创建时参数化。它们在 [SHORTNAME] 程序中不能被修改。

采样器仅能通过[[#texture-builtin-functions|texture builtin functions]]被使用。

<pre class='def'>
sampler
  OpTypeSampler

sampler_comparison
  OpTypeSampler
</pre>

### 纹理类型语法 ### {#texture-types-grammar}
TODO: 添加纹理使用校验规则。

<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_sampler_types</dfn> :

    | [=syntax/sampler_type=]

    | [=syntax/depth_texture_type=]

    | [=syntax/sampled_texture_type=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/multisampled_texture_type=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/storage_texture_type=] [=syntax/less_than=] [=syntax/texel_format=] [=syntax/comma=] [=syntax/access_mode=] [=syntax/greater_than=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler_type</dfn> :

    | [=syntax/sampler=]

    | [=syntax/sampler_comparison=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampled_texture_type</dfn> :

    | [=syntax/texture_1d=]

    | [=syntax/texture_2d=]

    | [=syntax/texture_2d_array=]

    | [=syntax/texture_3d=]

    | [=syntax/texture_cube=]

    | [=syntax/texture_cube_array=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>multisampled_texture_type</dfn> :

    | [=syntax/texture_multisampled_2d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>storage_texture_type</dfn> :

    | [=syntax/texture_storage_1d=]

    | [=syntax/texture_storage_2d=]

    | [=syntax/texture_storage_2d_array=]

    | [=syntax/texture_storage_3d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>depth_texture_type</dfn> :

    | [=syntax/texture_depth_2d=]

    | [=syntax/texture_depth_2d_array=]

    | [=syntax/texture_depth_cube=]

    | [=syntax/texture_depth_cube_array=]

    | [=syntax/texture_depth_multisampled_2d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texel_format</dfn> :

    | [=syntax/r8unorm=]

    | [=syntax/r8snorm=]

    | [=syntax/r8uint=]

    | [=syntax/r8sint=]

    | [=syntax/r16uint=]

    | [=syntax/r16sint=]

    | [=syntax/r16float=]

    | [=syntax/rg8unorm=]

    | [=syntax/rg8snorm=]

    | [=syntax/rg8uint=]

    | [=syntax/rg8sint=]

    | [=syntax/r32uint=]

    | [=syntax/r32sint=]

    | [=syntax/r32float=]

    | [=syntax/rg16uint=]

    | [=syntax/rg16sint=]

    | [=syntax/rg16float=]

    | [=syntax/rgba8unorm=]

    | [=syntax/rgba8unorm_srgb=]

    | [=syntax/rgba8snorm=]

    | [=syntax/rgba8uint=]

    | [=syntax/rgba8sint=]

    | [=syntax/bgra8unorm=]

    | [=syntax/bgra8unorm_srgb=]

    | [=syntax/rgb10a2unorm=]

    | [=syntax/rg11b10float=]

    | [=syntax/rg32uint=]

    | [=syntax/rg32sint=]

    | [=syntax/rg32float=]

    | [=syntax/rgba16uint=]

    | [=syntax/rgba16sint=]

    | [=syntax/rgba16float=]

    | [=syntax/rgba32uint=]

    | [=syntax/rgba32sint=]

    | [=syntax/rgba32float=]
</div>

## 类型别名 TODO ## {#type-aliases}

<div class='syntax' noexport='true'>
  <dfn for=syntax>type_alias</dfn> :

    | [=syntax/type=] [=syntax/ident=] [=syntax/equal=] [=syntax/type_decl=]
</div>

<div class='example wgsl global-scope' heading='Type Alias'>
  <xmp>
    type Arr = array<i32, 5>;

    type RTArr = [[stride(16)]] array<vec4<f32>>;
  </xmp>
</div>

## 类型声明语法 ## {#type-declarations}

<div class='syntax' noexport='true'>
  <dfn for=syntax>type_decl</dfn> :

    | [=syntax/ident=]

    | [=syntax/bool=]

    | [=syntax/float32=]

    | [=syntax/int32=]

    | [=syntax/uint32=]

    | [=syntax/vec2=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/vec3=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/vec4=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/pointer=] [=syntax/less_than=] [=syntax/storage_class=] [=syntax/comma=] [=syntax/type_decl=] ( [=syntax/comma=] [=syntax/access_mode=] ) ? [=syntax/greater_than=]

    | [=syntax/array_type_decl=]

    | [=syntax/mat2x2=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat2x3=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat2x4=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat3x2=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat3x3=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat3x4=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat4x2=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat4x3=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat4x4=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/atomic=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/texture_sampler_types=]
</div>

当类型声明是标识符（[=identifier=]）时，表达式必须在标识符声明（[=declaration=]）的范围内，作为类型别名或结构类型。

<div class='example' heading="Type Declarations">
  <xmp>
    identifier
      Allows to specify types created by the type command

    bool
       %1 = OpTypeBool

    f32
       %2 = OpTypeFloat 32

    i32
       %3 = OpTypeInt 32 1

    u32
       %4 = OpTypeInt 32 0

    vec2<f32>
        %7 = OpTypeVector %float 2

    array<f32, 4>
       %uint_4 = OpConstant %uint 4
            %9 = OpTypeArray %float %uint_4

    [[stride(32)]] array<f32, 4>
                 OpDecorate %9 ArrayStride 32
       %uint_4 = OpConstant %uint 4
            %9 = OpTypeArray %float %uint_4

    array<f32>
       %rtarr = OpTypeRuntimeArray %float

    mat2x3<f32>
       %vec = OpTypeVector %float 3
         %6 = OpTypeMatrix %vec 2
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Access modes for buffers'>
  <xmp>
    // Storage buffers
    [[group(0), binding(0)]]
    var<storage,read> buf1: Buffer;       // Can read, cannot write.
    [[group(0), binding(0)]]
    var<storage> buf2: Buffer;            // Can read, cannot write.
    [[group(0), binding(1)]]
    var<storage,read_write> buf3: Buffer; // Can both read and write.

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    struct ParamsTable {};
    [[group(0), binding(2)]]
    var<uniform> params: ParamsTable;     // Can read, cannot write.
  </xmp>
</div>

# `var` 和 `let` # {#var-and-let}

let 声明（<dfn noexport>let declaration</dfn>）指定值的名称。一旦计算出 let 声明的值，它就是不可变的。当标识符（[=identifier=]） 使用[=resolves=]至一个let-声明，该标识符表示该值。

当在没有明确指定类型的情况下声明 `let` 标识符时，例如 `let foo = 4`，类型是从等号 (`=`) 右边的表达式自动推断出来的。 当指定类型时，例如 `let foo: i32 = 4`，初始化表达式必须计算为该类型。

关于 `let`-声明的一些规则取决于声明出现的位置。见[[#module-constants]]与[[#function-scope-variables]]。

<div class='example let declaration at module-scope' heading='let-declared constants at module scope'>
  <xmp highlight='rust'>
    // 'blockSize' 表示 i32 值 1024。
    let blockSize: i32 = 1024;

    // 'row_size' 表示 u32 值 16u。类型被指定。
    let row_size = 16u;
  </xmp>
</div>

变量（<dfn dfn noexport>variable</dfn>）是对内存的命名引用，可以包含特定可存储（[=storable=]）类型的值。

有两种类型与变量相关联：它的存储类型（[=store type=]）（可以放置在被引用内存中的值的类型）和它的引用类型（[=reference type=]）（变量本身的类型）。 如果变量具有存储类型 *T*、存储类（[=storage class=]） *S* 和访问模式 *A*，则其引用类型为 ref&lt;*S*,*T*,*A*&gt;。

变量声明（<dfn dfn noexport>variable declaration</dfn>）：

* 指定变量名称。
* 指定[=storage class=], [=store type=], 和 [=access mode=]。这些一同构成变量的引用类型（[=reference type=]）。
* 确保执行环境在指定的存储类中为存储类型的值分配内存，对变量的生命周期（[=lifetime=]）支持给定的访问模式。
* 如果变量在私有（[=storage classes/private=]）或函数（[=storage classes/function=]）存储类中，可选择地有一个*初始化*表达式。 如果存在，初始化表达式必须计算为变量的存储类型。

当标识符（[=identifier=]）对变量声明使用[=resolves=]时，标识符是表示变量内存的引用内存视图（[=memory view=]）的表达式，其类型是变量的引用类型。见[[#var-identifier-expr]]。

有关可以在何处声明特定存储类中的变量以及何时需要、可选或禁止存储类修饰的规则，见[[#module-scope-variables]]和[[#function-scope-variables]]。

访问方式总是有默认的，除了[=storage classes/storage=]存储类中的变量，不得写入[SHORTNAME]源文本。见[[#access-mode-defaults]]。

<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_statement</dfn> :

    | [=syntax/variable_decl=]

    | [=syntax/variable_decl=] [=syntax/equal=] [=syntax/short_circuit_or_expression=]

    | [=syntax/let=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/equal=] [=syntax/short_circuit_or_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_decl</dfn> :

    | [=syntax/var=] [=syntax/variable_qualifier=] ? ( [=syntax/ident=] | [=syntax/variable_ident_decl=] )
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_ident_decl</dfn> :

    | [=syntax/ident=] [=syntax/colon=] [=syntax/attribute_list=] * [=syntax/type_decl=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_qualifier</dfn> :

    | [=syntax/less_than=] [=syntax/storage_class=] ( [=syntax/comma=] [=syntax/access_mode=] ) ? [=syntax/greater_than=]
</div>

一个变量的生命周期（<dfn noexport>lifetime</dfn>）为该变量存在时进行着色器处理的期间。模块范围（[=module scope=]）变量的生命周期为着色器阶段的全部执行时间。

对于函数作用域（[=function scope=]）变量，每个调用都有其自己的独立变量版本。变量的生存周期取决于其作用域：
* 当控制写入变量声明时，它就开始了。
* 它包括从变量作用域内调用的任何函数的整个执行过程。
* 它在控制离开变量的作用域时结束，而不是从变量的作用域内调用函数。

两个生命周期重叠的变量不会有重叠的内存（[=overlap|overlapping memory=]）。当一个变量的生命周期结束时，它的内存可能会被另一个变量使用。

当一个变量被创建时，它的内存包含一个初始值，如下所示：

* 对于在私有（[=storage classes/private=]）或函数（[=storage classes/function=]）存储类中的变量：
    * 如果变量声明没有初始化表达式，存储类型为零值（[=zero value=]）。
    * 否则它是对初始化表达式在程序执行处计算求值后的结果。
* 对于其他存储类中的变量，执行环境提供初始值。

考虑如下WGSL片段：
<div class='example wsgl function-scope' heading='Variable initial values'>
  <xmp highlight='rust'>
    var i: i32;         // 初始值为 0。不是推荐的方式。
    loop {
      var twice: i32 = 2 * i;   // 重新计算每次迭代。
      i = i + 1;
      if (i == 5) { break; }
    }
  </xmp>
</div>
循环体会执行 5 次，变量 `i` 会具有值0, 1, 2, 3, 4, 5, 且变量 `twice` 会具有值0, 2, 4, 6, 8。

考虑如下WGSL片段：
<div class='example wsgl function-scope' heading='Reading a variable multiple times'>
  <xmp highlight='rust'>
    var x: f32 = 1.0;
    let y = x * x + x + 1;
  </xmp>
</div>
由于 `x` 为一个变量，所有对齐的访问都变成了加载和存储操作。如果这段代码被编译为 SPIR-V ，它将表示为：
<div class='example spirv' heading='Sample translation for reading a variable multiple times'>
  <xmp highlight='asm'>
    %temp_1 = OpLoad %float %x
    %temp_2 = OpLoad %float %x
    %temp_3 = OpFMul %float %temp_1 %temp_2
    %temp_4 = OpLoad %float %x
    %temp_5 = OpFAdd %float %temp_3 %temp_4
    %y      = OpFAdd %float %temp_5 %one
  </xmp>
</div>

然而，期望浏览器或驱动程序优化此中间表示，从而消除冗余负载。

## 模块作用域变量 ## {#module-scope-variables}

在所有函数之外声明的变量在模块作用域（[=module scope=]）内。变量名在其声明语句之后立即可用，直到程序结束。

模块作用域（[=module scope=]）内的变量被限制如下：

* 变量不能在函数（[=storage classes/function=]）存储类中。
* 变量在[=storage classes/private=], [=storage classes/workgroup=], [=storage classes/uniform=], 或 [=storage classes/storage=] 存储类中：
    * 必须使用显式存储类修饰声明。
    * 必须使用[[#storage-class]]中所描述的存储类型（[=store type=]）。
* 如果存储类型（[=store type=]）是纹理类型或采样器类型，则变量声明不得具有存储类修饰。存储类将始终是句柄（[=storage classes/handle=]）。

统一（[=storage classes/uniform=]）存储类中的变量是统一缓冲区（<dfn noexport>uniform buffer</dfn>）变量。 其存储类型（[=store type=]）必须是具有块（[=attribute/block=]）属性的主机可共享（[=host-shareable=]）结构类型，满足存储类布局约束（[storage class layout constraints](#storage-class-layout-constraints)）。

[=storage classes/storage=]存储类中的变量是存储缓冲区（<dfn noexport>storage buffer</dfn>）变量。其存储类型（[=store type=]）必须是具有块（[=attribute/block=]）属性的主机可共享（[=host-shareable=]）结构类型，满足存储类布局约束（[storage class layout constraints](#storage-class-layout-constraints)）。它可以声明为 [=access/read=] 或 [=access/read_write=] 访问模式； 默认为 [=access/read=] 。

如[[#resource-interface]]中所述，统一缓冲区、存储缓冲区、纹理和采样器构成了着色器的资源接口（[=resource interface of a shader=]）。 此类变量使用组（[=attribute/group=]）和绑定（[=attribute/binding=]）修饰声明。

<div class='example wgsl global-scope' heading="Module scope variable declarations">
  <xmp>
    var<private> decibels: f32;
    var<workgroup> worklist: array<i32,10>;

    [[block]] struct Params {
      specular: f32;
      count: i32;
    };
    [[group(0), binding(2)]]
    var<uniform> param: Params;    // A uniform buffer

    [[block]] struct PositionsBuffer {
      pos: array<vec2<f32>>;
    };
    // A storage buffer, for reading and writing
    [[group(0), binding(0)]]
    var<storage,read_write> pbuf: PositionsBuffer;

    // Textures and samplers are always in "handle" storage.
    [[group(0), binding(1)]]
    var filter_params: sampler;
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_variable_decl</dfn> :

    | [=syntax/attribute_list=] * [=syntax/variable_decl=] ( [=syntax/equal=] [=syntax/const_expression=] ) ?
</div>

<div class='example' heading="Variable Decorations">
  <xmp>
    [[group(4), binding(3)]]
       OpDecorate %variable DescriptorSet 4
       OpDecorate %variable Binding 3
  </xmp>
</div>

[SHORTNAME] 定义了以下可应用于全局变量的属性：
 * [=attribute/binding=]
 * [=attribute/group=]

## 模块常量 ## {#module-constants}

一个在所有函数外声明的 `let`-声明声明了一个模块作用域（[=module scope|module-scope=]）常量。该名称可在声明结束后使用，直到 [SHORTNAME] 程序结束。

模块作用域 let-声明的常量必须是可构造（[=constructible=]）的类型。

当声明没有属性时，必须存在初始化表达式，名称表示该表达式的值。

<div class='example wgsl global-scope' heading='Module constants'>
  <xmp>
    // The golden ratio.
    let golden: f32 = 1.61803398875;

    // The second unit vector for three dimensions, with inferred type.
    let e2 = vec3<i32>(0,1,0);
  </xmp>
</div>

当声明使用 [=attribute/override=] 属性时，常量是管线可覆盖的（<dfn noexport>pipeline-overridable</dfn>）。在这种情况下：

  * 类型必须为 [=scalar=] 类型中的一种。
  * 初始化表达式是可选的。
  * 属性的文字操作数（如果存在）称为管线常量 ID（<dfn noexport>pipeline constant ID</dfn>），并且必须是 0 到 65535 之间的整数值。
  * [SHORTNAME] 程序中的管线常量 ID 必须是唯一的：两个模块常量不得使用相同的管线常量 ID。
  * 应用程序可以在管线创建时为常量指定其自己的值。管线创建 API 接受从可覆盖常量到常量类型值的映射。 常量由管线可覆盖常量标识符字符串（<dfn export>pipeline-overridable constant identifier string</dfn>）标识，如果指定，它是管线常量 ID （[=pipeline constant ID=]）的基数为 10 的表示，否则为常量的声明名称（[=name=]）。
  * 如果管线可覆盖常量的声明具有初始化表达式，则其具有默认值（<dfn export>pipeline-overridable constant has a default value</dfn>）。 如果没有，则必须在管线创建时提供一个值。

<div class='example wgsl global-scope' heading='Module constants, pipeline-overrideable'>
  <xmp>
    [[override(0)]]    let has_point_light: bool = true;  // Algorithmic control
    [[override(1200)]] let specular_param: f32 = 2.3;     // Numeric control
    [[override(1300)]] let gain: f32;                     // Must be overridden
    [[override]]       let width: f32 = 0.0;              // Specifed at the API level using
                                                          // the name "width".
    [[override]]       let depth: f32;                    // Specifed at the API level using
                                                          // the name "depth".
                                                          // Must be overridden.
  </xmp>
</div>

当在依赖于常量值的控制流中使用变量或特性时，则认为该变量或特性被程序使用。 无论常量的值如何，无论该值是来自常量声明的值还是来自管线覆盖的值，都是如此。

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_constant_decl</dfn> :

    | [=syntax/attribute_list=] * [=syntax/let=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/global_const_initializer=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>global_const_initializer</dfn> :

    | [=syntax/equal=] [=syntax/const_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>const_expression</dfn> :

    | [=syntax/type_decl=] [=syntax/paren_left=] ( ( [=syntax/const_expression=] [=syntax/comma=] ) * [=syntax/const_expression=] [=syntax/comma=] ? ) ? [=syntax/paren_right=]

    | [=syntax/const_literal=]
</div>

<div class='example' heading='Constants'>
  <xmp>
    -1
       %a = OpConstant %int -1

    2
       %b = OpConstant %uint 2

    3.2
       %c = OpConstant %float 3.2

    true
        %d = OpConstantTrue

    false
        %e = OpConstant False

    vec4<f32>(1.2, 2.3, 3.4, 2.3)
        %f0 = OpConstant %float 1.2
        %f1 = OpConstant %float 2.3
        %f2 = OpConstant %float 3.4
         %f = OpConstantComposite %v4float %f0 %f1 %f2 %f1
  </xmp>
</div>

Issue(dneto): WebGPU 管线创建 API 必须指定 API 提供的值如何映射到着色器标量值。对于布尔值，我建议使用 32 位整数，其中只有 0 映射到 `false`。 如果 [SHORTNAME] 获得非 32 位数字标量，我建议可覆盖的常量继续是 32 位数字类型。

## 函数作用域变量和常量 ## {#function-scope-variables}

在函数体中的声明语句中声明的变量或常量在函数作用域（<dfn noexport>function scope</dfn>）内。该名称可在其声明语句之后立即使用，直到紧随声明的括号分隔语句列表的末尾。

函数范围的 let 声明常量必须是可构造（[=constructible=]）类型或指针类型（[=pointer type=]）。

对于在函数作用域中声明的变量：
* 变量总是在函数（[=storage classes/function=]）存储类中。
* 存储修饰是可选的。
* 存储类型（[=store type=]）必须为可构造（[=constructible=]）类型。
* 当指定了初始化表达式时，可以从声明中省略存储类型。在这种情况下，存储类型是初始化表达式的计算结果的类型。

<div class='example wgsl global-scope' heading="Function scope variables and constants">
  <xmp highlight='rust'>
    fn f() {
       var<function> count: u32;  // 函数存储类中的变量。
       var delta: i32;            // 函数存储类中的另一个变量。
       var sum: f32 = 0.0;        // 拥有初始化值的函数存储类变量。
       var pi = 3.14159;          // 从初始化值推断出 f32 存储类型。
       let unit: i32 = 1;         // 未使用存储类的let-声明常量。
    }
  </xmp>
</div>

在 `for` 语句的第一个子句中声明的变量或常量可用于第二个和第三个子句以及 `for` 语句的主体中。

函数作用域变量的实例是动态上下文（[=dynamic context=]）。每个一些调用范围内的变量都有一个重叠的生命周期（[=lifetime=]），因此，具有不重叠的内存。生命周期不重叠的变量可能会重用之前变量的内存；但是，不能保证同一变量的新实例使用相同的内存。

# 表达式 # {#expressions}

表达式指定值如何被计算。

## 文字表达式 ## {#literal-expressions}

<table class='data'>
  <caption>标量文字类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td><td>`true`: bool<td>`true` 布尔值。 (OpConstantTrue)
  <tr><td><td>`false`: bool<td>`false` 布尔值。 (OpConstantFalse)
  <tr><td><td>*INT_LITERAL*: i32<td>有符号整数值。 (OpConstant)
  <tr><td><td>*UINT_LITERAL*: u32<td>无符号整数值。 (OpConstant)
  <tr><td><td>*FLOAT_LITERAL*: f32<td>浮点值。 (OpConstant)
</table>

## 括号表达式 ## {#parenthesized-expressions}

<table class='data'>
  <caption>括号表达式类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="parenthesized expression">
      <td>|e| : |T|
      <td>`(` |e| `)` : |T|
      <td>计算为 |e| 。<br>
          使用括号与表达式周围文本分隔。
</table>

## 类型构造函数表达式 ## {#type-constructor-expr}

类型构造函数表达式显式地创建给定类型的值。

标量形式是多余的，但提供标量转换表达式（[[#conversion-expr|conversion expressions]]）的对称性，并可用于增强可读性。

向量形式从具有匹配组件类型的组件和子向量的各种组合中构造向量值。

另见[[#zero-value-expr]] 和 [[#conversion-expr]]。

<table class='data'>
  <caption>标量构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td>*e*: bool<td>`bool(e)`: bool<td>本体。<br>在SPIR-V翻译中，表达式 ID 重用了操作数的 ID。
  <tr><td>*e*: i32<td>`i32(e)`: i32<td>本体。<br>在SPIR-V翻译中，表达式 ID 重用了操作数的 ID。
  <tr><td>*e*: u32<td>`u32(e)`: u32<td>本体。<br>在SPIR-V翻译中，表达式 ID 重用了操作数的 ID。
  <tr><td>*e*: f32<td>`f32(e)`: f32<td>本体。<br>在SPIR-V翻译中，表达式 ID 重用了操作数的 ID。
</table>

<table class='data'>
  <caption>向量构造函数类型规则，其中 *T* 为标量类型。</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="construct a vector from copies of a single scalar">
    <td>|e|: |T|
    <td>`vec`|N|`<`|T|`>(`|e|`)`: vec|N|&lt;|T|&gt;
    <td>计算 |e| 一次。结果为一个有 |N| 个元素的向量，每个向量分量值为 |e|。
  <tr>
    <td>*e1*: *T*<br>
        *e2*: *T*
    <td>`vec2<T>(e1,e2)`: vec2<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e*: vec2&lt;T&gt;
    <td>`vec2<T>(e)`: vec2<*T*>
    <td>本体。结果为 |e|。
  <tr>
    <td>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: *T*
    <td>`vec3<T>(e1,e2,e3)`: vec3<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e1*: *T*<br>
        *e2*: vec2<*T*>
    <td>`vec3<T>(e1,e2)`: vec3<*T*><br>
        `vec3<T>(e2,e1)`: vec3<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e*: vec3&lt;T&gt;
    <td>`vec3<T>(e)`: vec3<*T*>
    <td>本体。结果为 |e|。
  <tr>
    <td>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: *T*<br>
        *e4*: *T*
    <td>`vec4<T>(e1,e2,e3,e4)`: vec4<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: vec2<*T*>
    <td>`vec4<T>(e1,e2,e3)`: vec4<*T*><br>
        `vec4<T>(e1,e3,e2)`: vec4<*T*><br>
        `vec4<T>(e3,e1,e2)`: vec4<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e1*: vec2<*T*><br>
        *e2*: vec2<*T*>
    <td>`vec4<T>(e1,e2)`: vec4<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e1*: *T*<br>
        *e2*: vec3<*T*>
    <td>`vec4<T>(e1,e2)`: vec4<*T*><br>
        `vec4<T>(e2,e1)`: vec4<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e*: vec4&lt;T&gt;
    <td>`vec4<T>(e)`: vec4<*T*>
    <td>本体。结果为 |e|。
</table>

<table class='data'>
  <caption>矩阵构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>|e1|: |f32|<br>
        ...<br>
        |eN|: |f32|
    <td>`mat2x2<f32>(e1,e2,e3,e4)`: mat2x2&lt;f32&gt;<br>
        `mat3x2<f32>(e1,...,e6)`: mat3x2&lt;f32&gt;<br>
        `mat2x3<f32>(e1,...,e6)`: mat2x3&lt;f32&gt;<br>
        `mat4x2<f32>(e1,...,e8)`: mat4x2&lt;f32&gt;<br>
        `mat2x4<f32>(e1,...,e8)`: mat2x4&lt;f32&gt;<br>
        `mat3x3<f32>(e1,...,e9)`: mat3x3&lt;f32&gt;<br>
        `mat4x3<f32>(e1,...,e12)`: mat4x3&lt;f32&gt;<br>
        `mat3x4<f32>(e1,...,e12)`: mat3x4&lt;f32&gt;<br>
        `mat4x4<f32>(e1,...,e16)`: mat4x4&lt;f32&gt;
    <td>通过元素列主序构造。<br>
        OpCompositeConstruct
  <tr>
    <td>*e1*: vec2&lt;f32&gt;<br>
        *e2*: vec2&lt;f32&gt;<br>
        *e3*: vec2&lt;f32&gt;<br>
        *e4*: vec2&lt;f32&gt;
    <td>`mat2x2<f32>(e1,e2)`: mat2x2&lt;f32&gt;<br>
        `mat3x2<f32>(e1,e2,e3)`: mat3x2&lt;f32&gt;<br>
        `mat4x2<f32>(e1,e2,e3,e4)`: mat4x2&lt;f32&gt;
    <td>一列一列构造。<br>
        OpCompositeConstruct
  <tr>
    <td>*e1*: vec3&lt;f32&gt;<br>
        *e2*: vec3&lt;f32&gt;<br>
        *e3*: vec3&lt;f32&gt;<br>
        *e4*: vec3&lt;f32&gt;
    <td>`mat2x3<f32>(e1,e2)`: mat2x3&lt;f32&gt;<br>
        `mat3x3<f32>(e1,e2,e3)`: mat3x3&lt;f32&gt;<br>
        `mat4x3<f32>(e1,e2,e3,e4)`: mat4x3&lt;f32&gt;
    <td>一列一列构造。<br>
        OpCompositeConstruct
  <tr>
    <td>*e1*: vec4&lt;f32&gt;<br>
        *e2*: vec4&lt;f32&gt;<br>
        *e3*: vec4&lt;f32&gt;<br>
        *e4*: vec4&lt;f32&gt;
    <td>`mat2x4<f32>(e1,e2)`: mat2x4&lt;f32&gt;<br>
        `mat3x4<f32>(e1,e2,e3)`: mat3x4&lt;f32&gt;<br>
        `mat4x4<f32>(e1,e2,e3,e4)`: mat4x4&lt;f32&gt;
    <td>一列一列构造。<br>
        OpCompositeConstruct
</table>

<table class='data'>
  <caption>数组构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="array value construction">
    <td>|e1|: |T|<br>
        ...<br>
        |eN|: |T|,<br>
        |T| is a [=constructible=] type.
    <td>`array<`|T|,|N|`>(`|e1|,...,|eN|`)` : array&lt;|T|,|N|&gt;
    <td>从元素进行的数组构造。
</table>

<table class='data'>
  <caption>结构构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="structure value construction">
    <td>|e1|: |T1|<br>
        ...<br>
        |eN|: |TN|,<br>
        |S| is a [=constructible=] structure type with members having types |T1| ... |TN|.<br>
        The expression is in the scope of declaration of |S|.
    <td>|S|`(`|e1|,...,|eN|`)`: |S|
    <td>从成员进行的结构构造。
</table>

## 零值表达式 ## {#zero-value-expr}

每个可构造的（[=constructible=]） *T* 都有一个唯一的零值（<dfn noexport>zero value</dfn>），在 WGSL 中编写为，类型后面跟一对空括号：*T* `()`。

零值如下：

* `bool()` 为 `false`
* `i32()` 为 0
* `u32()` 为 0
* `f32()` 为 0.0
* 具有 *N* 个类型 *T* 元素的向量的零值为一个 *N*-元素向量，每个分量值为 *T* 的零值。
* *N*-列 *M*行类型为 `f32` 的矩阵的零值为该维度向量被0.0项填充。
* 具有可构造（[=constructible=]）元素类型 *E* 的 *N*-元素向量的零值为一个有 *N* 个元素的数组，数组的每个分量为 *E* 的零值。
* 可构造（[=constructible=]）类型 *S* 的零值为构造值 *S* 的零值成员。

注意：WGSL中原子类型（[=atomic types=]），[=runtime-sized=]数组，以及其他非可构造（[=constructible=]）类型没有零值表达式。

<table class='data'>
  <caption>标量零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td><td>`bool()`: bool<td>false<br>零值 (OpConstantNull for bool)
  <tr><td><td>`i32()`: i32<td>0<br>零值 (OpConstantNull for i32)
  <tr><td><td>`u32()`: u32<td>0u<br>零值 (OpConstantNull for u32)
  <tr><td><td>`f32()`: f32<td>0.0<br>零值 (OpConstantNull for f32)
</table>

<table class='data'>
  <caption>向量零值类型规则，其中 *T* 为标量类型</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>
    <td>`vec2<T>()`: vec2<*T*>
    <td>零值 (OpConstantNull)
  <tr>
    <td>
    <td>`vec3<T>()`: vec3<*T*>
    <td>零值 (OpConstantNull)
  <tr>
    <td>
    <td>`vec4<T>()`: vec4<*T*>
    <td>零值 (OpConstantNull)
</table>


<div class='example' heading="Zero-valued vectors">
  <xmp highlight='rust'>
    vec2<f32>()                 // 两个 f32 元素的零值向量。
    vec2<f32>(0.0, 0.0)         // 相同的值，明确写入。

    vec3<i32>()                 // 三个 i32 元素的零值向量。
    vec3<i32>(0, 0, 0)          // 相同的值，明确写入。
  </xmp>
</div>

<table class='data'>
  <caption>向量零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>
    <td>`mat2x2<f32>()`: mat2x2&lt;f32&gt;<br>
        `mat3x2<f32>()`: mat3x2&lt;f32&gt;<br>
        `mat4x2<f32>()`: mat4x2&lt;f32&gt;
    <td>零值 (OpConstantNull)
  <tr>
    <td>
    <td>`mat2x3<f32>()`: mat2x3&lt;f32&gt;<br>
        `mat3x3<f32>()`: mat3x3&lt;f32&gt;<br>
        `mat4x3<f32>()`: mat4x3&lt;f32&gt;
    <td>零值 (OpConstantNull)
  <tr>
    <td>
    <td>`mat2x4<f32>()`: mat2x4&lt;f32&gt;<br>
        `mat3x4<f32>()`: mat3x4&lt;f32&gt;<br>
        `mat4x4<f32>()`: mat4x4&lt;f32&gt;
    <td>零值 (OpConstantNull)
</table>

<table class='data'>
  <caption>数组零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="array zero value">
    <td>|T| is a [=constructible=]
    <td>`array<`|T|,|N|`>()`: array&lt;|T|,|N|&gt;
    <td>零值数组 (OpConstantNull)
</table>

<div class='example' heading="Zero-valued arrays">
  <xmp highlight='rust'>
    array<bool, 2>()               // 两个布尔值的零值数组。
    array<bool, 2>(false, false)   // 相同的值，明确写入。
  </xmp>
</div>

<table class='data'>
  <caption>结构零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="structure zero value">
    <td>|S| is a [=constructible=] structure type.<br>
         The expression is in the scope of declaration of |S|.
    <td>|S|`()`: |S|
    <td>零值结构：类型为 |S| 的结构，每个成员为其成员类型的零值。
<br>
 (OpConstantNull)
</table>

<div class='example wgsl global-scope' heading="Zero-valued structures">
  <xmp highlight='rust'>
    struct Student {
      grade: i32;
      GPA: f32;
      attendance: array<bool,4>;
    };

    fn func() {
      var s: Student;

      // Student 的零值。
      s = Student();

      // 相同的值，明确写入。
      s = Student(0, 0.0, array<bool,4>(false, false, false, false));

      // 相同的值，用零值成员写入。
      s = Student(i32(), f32(), array<bool,4>());
    }
  </xmp>
</div>


## 转换表达式 ## {#conversion-expr}

[SHORTNAME] 不隐式转换或提升一个数值或布尔值为另外的类型。而是使用以下表格中描述的转换表达式。

另见[[#type-constructor-expr]]。

<table class='data'>
  <caption>标量转换类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="coercion to boolean from unsigned">
      <td>|e|: u32<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 为 0 则结果值为假，否则为真。<br>
          （使用 OpINotEqual 去对比 |e| 和 0。）
  <tr algorithm="coercion to boolean from signed">
      <td>|e|: i32<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 为 0 则结果值为假，否则为真。<br>
          （使用 OpINotEqual 去对比 |e| 和 0。）
  <tr algorithm="coercion to boolean from floating point">
      <td>|e|: f32<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 为 0.0 或 -0.0 则结果值为假，否则为真。特殊地，NaN 和 infinity 值映射为真。<br>
          （使用 OpFUnordNotEqual 去对比 |e| 和 `0.0`。）
  <tr algorithm="conversion from boolean to signed">
      <td>|e|: bool<td>`i32(`|e|`)`: i32
      <td>转换一个布尔值至一个有符号整数<br>
          当 |e| 为真时结果为 1，否则结果为 0。<br>
          （使 |e| 为条件使用 OpSelect，选择 1 至 0。）
  <tr algorithm="scalar reinterpretation from unsigned to signed">
      <td>|e|: u32<td>`i32(`|e|`)`: i32
      <td>位的重新解释。<br>
          结果是类型为 [=i32=] 的唯一值，等于 (|e| mod 2<sup>32</sup>)。<br>
          (OpBitcast)
  <tr algorithm="scalar conversion from floating point to signed integer">
      <td>|e|: f32<td>`i32(`|e|`)`: i32<td>
      数值转换，包括无效数值。（OpConvertFToS）
  <tr algorithm="conversion from boolean to unsigned">
      <td>|e|: bool<td>`u32(`|e|`)`: u32
      <td>
      转换布尔值为无符号整数<br>
      |e| 为真时结果为 1u，否则为 0u。<br>
      （使 |e| 为条件使用 OpSelect，选择 1 至 0。）
  <tr algorithm="scalar conversion from signed integer to unsigned integer">
      <td>|e|: i32<td>`u32(`|e|`)`: u32
      <td>位的重新解释。<br>
          结果是类型为 [=u32=] 的唯一值，等于 (|e| mod 2<sup>32</sup>)。<br>
          (OpBitcast)
  <tr algorithm="scalar conversion from floating point to unsigned integer">
      <td>|e|: f32<td>`u32(`|e|`)`: u32
      <td>值的转换，包括无效例。(OpConvertFToU)
  <tr algorithm="conversion from boolean to floating point">
      <td>|e|: bool<td>`f32(`|e|`)`: f32
      <td>
      转换布尔值至浮点值。<br>
      |e| 为真时结果为 1.0，否则为 0.0。<br>
      （使 |e| 为条件对其使用 OpSelect，选择 1.0 至 0.0。）
  <tr algorithm="scalar conversion from signed integer to floating point">
      <td>|e|: i32<td>`f32(`|e|`)`: f32<td>值的转换，包括无效例。(OpConvertSToF)
  <tr algorithm="scalar conversion from unsigned integer to floating point">
      <td>|e|: u32<td>`f32(`|e|`)`: f32<td>值的转换，包括无效例。(OpConvertUToF)
</table>

[[#floating-point-conversion]]中解释了与浮点之间的转换细节。

<table class='data'>
  <caption>向量转换类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="vector coercion of unsigned integer to boolean">
     <td>|e|: vec|N|&lt;u32&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>无符号整数向量至布尔向量的[=Component-wise=]强制转换。<br>
     （使用 OpINotEqual 去比较 |e| 和零向量）

  <tr algorithm="vector coercion of signed integer to boolean">
     <td>|e|: vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>有符号整数向量至布尔向量的[=Component-wise=]强制转换。<br>
     （使用 OpINotEqual 去比较 |e| 和零向量）

  <tr algorithm="vector coercion of floating point to boolean">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>浮点型向量至布尔向量的[=Component-wise=]强制转换。<br>
     （使用 OpFUnordNotEqual 去比较 |e| 和零向量）

  <tr algorithm="vector conversion from bool to signed">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt
     <td>布尔向量至有符号向量的[=Component-wise=]强制转换。<br>
     结果的分量 |i| 为 `i32(`|e|`[`|i|`])`<br>
     （使 |e| 为条件，与其一起使用 OpSelect，选择 `vec`|N|(1) 至 `vec`|N|(0) 区间。）

  <tr algorithm="vector reinterpretation from unsigned to signed">
     <td>|e|: vec|N|&lt;u32&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt
     <td>位的[=Component-wise=]重新解释。
     结果的分量 |i| 为 `i32(`|e|`[`|i|`])`<br>
     (OpBitcast)

  <tr algorithm="vector conversion from floating point to signed integer">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt;
     <td>值的[=Component-wise=]转换至有符号整数，包括无效例。<br>
     (OpConvertFToS)

  <tr algorithm="vector conversion from bool to unsigned">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt
     <td>布尔向量至无符号向量的[=Component-wise=]转换。<br>
     结果的分量 |i| 为 `u32(`|e|`[`|i|`])`<br>
     （使 |e| 为条件，与其一起使用 OpSelect，选择 `vec`|N|(1u) 至 `vec`|N|(0u) 区间。）

  <tr algorithm="vector reinterpretation from signed to unsigned">
     <td>|e|: vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>位的[=Component-wise=]重新解释。<br>
        (OpBitcast)

  <tr algorithm="vector conversion from floating point to unsigned integer">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>值的[=Component-wise=]转换至无符号整数，包括无效例。<br>
        (OpConvertFToU)

  <tr algorithm="vector conversion from bool to floating point">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt
     <td>布尔向量至浮点型的[=Component-wise=]转换。<br>
     结果的分量 |i| 为 `f32(`|e|`[`|i|`])`<br>
     使 |e| 为条件，使用 OpSelect，选择 `vec`|N|(1.0) 至 `vec`|N|(0.0) 区间。

  <tr algorithm="vector conversion from signed integer to floating point">
     <td>|e|: vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>值的[=Component-wise=]转换至浮点型，包括无效例。<br>
     (OpConvertSToF)

  <tr algorithm="vector conversion from unsigned integer to floating point">
     <td>|e|: vec|N|&lt;u32&gt;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>值的[=Component-wise=]转换至浮点型，包括无效例。<br>
     (ConvertUToF)
</table>

## 表示表达式的重新解释 ## {#bitcast-expr}

`bitcast`表达式用于将一种类型中的值的位表示重新解释为另一种类型中的值。

<table class='data'>
  <caption>Bitcast类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="identity reinterpretation">
    <td>|e|: |T|<br>
    |T| 为一个数值标量（[=numeric scalar=]）或数值向量（[=numeric vector=]）类型
    <td class="nowrap">bitcast&lt;|T|&gt;(|e|): |T|
    <td>本体变换。当 |T| 为向量时[=Component-wise=]。<br>
    结果为 |e|。<br>
    在 SPIR-V 翻译中，此表达式的 ID 重用了操作数的 ID。

  <tr algorithm="general reinterpretation">
    <td>|e|: |T1|<br>
    |T1| 为一个数值标量（[=numeric scalar=]）或数值向量（[=numeric vector=]）类型<br>
    |T2| 不为 |T1|，并且当 |T1| 为标量时，|T2|为一个数值标量类型。当 |T1| 为向量时，为数值向量类型。
    <td class="nowrap">bitcast&lt;|T2|&gt;(|e|): |T2|
    <td>将位重新解释为 |T2|。当 |T1| 为向量是，|T2| 为 [=Component-wise=]。<br>
    结果为将 |e| 中的位重新解释为 |T2| 值。<br>
    (OpBitcast)
</table>

## 复合值分解表达式 ## {#composite-value-decomposition-expr}

### 向量访问表达式 ### {#vector-access-expr}

访问向量的成员可以使用数组下标（例如 `a[2]`）或使用一系列便名，每个成员都映射到源向量的一个元素。

<ul>
  <li>颜色的便名集合为 `r`, `g`, `b`, `a` ，分别对应向量元素 0, 1, 2, 和 3。
  <li>维度的便名集合为 `x`, `y`, `z`, `w` ，分别对应向量元素 0, 1, 2, 和 3。
</ul>

便名访问通过 `.` 符号。（比如，`color.bgra`）

注意：便名字母不能倍混合使用。（即，你不能使用 `rybw`）

使用便名字母，或数组下标，访问超过向量末尾的元素会出现错误。

便名字母可以按任何顺序应用，包括根据需要复制字母。从向量中提取分量时，你可以提供 1 到 4 个字母。提供超过 4 个字母是错误的。

结果类型取决于提供的字母。假设为一个 `vec4<f32>`
<table>
  <thead>
    <tr><th>Accessor<th>Result type
  </thead>
  <tr><td>r<td>`f32`
  <tr><td>rg<td>`vec2<f32>`
  <tr><td>rgb<td>`vec3<f32>`
  <tr><td>rgba<td>`vec4<f32>`
</table>

<div class='example wgsl function-scope'>
  <xmp highlight='rust'>
    var a: vec3<f32> = vec3<f32>(1., 2., 3.);
    var b: f32 = a.y;          // b = 2.0
    var c: vec2<f32> = a.bb;   // c = (3.0, 3.0)
    var d: vec3<f32> = a.zyx;  // d = (3.0, 2.0, 1.0)
    var e: f32 = a[1];         // e = 2.0
  </xmp>
</div>

#### 向量单分量选择 #### {#vector-single-component}

<table class='data'>
  <caption>向量分解：单分量选择</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.x`: |T|<br>
           |e|`.r`: |T|
       <td>选择 |e| 的第一个分量<br>
           (选择索引为 0 的 OpCompositeExtract)
  <tr algorithm="second vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.y`: |T|<br>
           |e|`.g`: |T|
       <td>选择 |e| 的第二个分量<br>
           (选择索引为 1 的 OpCompositeExtract)
  <tr algorithm="third vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
          |N| is 3 or 4
       <td class="nowrap">
           |e|`.z`: |T|<br>
           |e|`.b`: |T|
       <td>选择 |e| 的第三个分量<br>
           (选择索引为 2 的 OpCompositeExtract)
  <tr algorithm="fourth vector component selection"><td>|e|: vec4&lt;|T|&gt;
       <td class="nowrap">
           |e|`.w`: |T|<br>
           |e|`.a`: |T|
       <td>选择 |e| 的第四个分量<br>
           (选择索引为 3 的 OpCompositeExtract)
  <tr algorithm="vector indexed component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |e|[|i|]: |T|
       <td>选择 |e| 的第 |i| 个分量<br>
           第一个分量在 |i|=0 处。
           如果 |i| 在区间 [0,|N|-1] 外，那么 |T| 的任何值都可能被返回。
           （OpVectorExtractDynamic）
</table>

#### 向量多分量选择 #### {#vector-multi-component}

<table class='data'>
  <caption>向量分解：多分量选择
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="two component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |J| 为字母 `x`, `y`, `z`, 或 `w`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J| 来计算2-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `z` 有效。<br>
       仅当 |N| 为 4 时，字母 `w` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="two component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |J| 为字母 `r`, `g`, `b`, 或 `a`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J| 来计算2-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `b` 有效。<br>
       仅当 |N| 为 4 时，字母 `a` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="three component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |J| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |K| 为字母 `x`, `y`, `z`, 或 `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，以及第三个分量 |e|.|K| 来计算3-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `z` 有效。<br>
       仅当 |N| 为 4 时，字母 `w` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="three component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |J| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |K| 为字母 `r`, `g`, `b`, 或 `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，以及第三个分量 |e|.|K| 来计算3-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `b` 有效。<br>
       仅当 |N| 为 4 时，字母 `a` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="four component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |J| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |K| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |L| 为字母 `x`, `y`, `z`, 或 `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，第三个分量 |e|.|K|，以及第四个分量 |e|.|L| 来计算4-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `z` 有效。<br>
       仅当 |N| 为 4 时，字母 `w` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="four component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |J| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |K| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |L| 为字母 `r`, `g`, `b`, 或 `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，第三个分量 |e|.|K|，以及第四个分量 |e|.|L| 来计算4-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `b` 有效。<br>
       仅当 |N| 为 4 时，字母 `a` 有效。<br>
       （OpVectorShuffle）
</table>

#### 来自向量引用的分量引用 #### {#component-reference-from-vector-reference}

对向量的分量的写访问（[=write access=]）**可能** 访问与该向量相关联的所有内存位置（[=memory
location|memory locations=]）。

注意：这意味着如果至少一个访问是写访问，则通过不同调用对向量的不同组件的访问必须被同步。见[[#sync-builtin-functions]]。

<table class='data'>
  <caption>从对向量的引用获取对分量的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component reference selection">
       <td>|r|: ref&lt;|SC|,vec|N|&lt;|T|&gt;&gt;<br>
       <td class="nowrap">
           |r|`.x`: ref&lt;|SC|,|T|&gt;<br>
           |r|`.r`: ref&lt;|SC|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第一个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （索引值为 0 的 OpAccessChain）
  <tr algorithm="second vector component reference selection">
       <td>|r|: ref&lt;|SC|,vec|N|&lt;|T|&gt;&gt;<br>
       <td class="nowrap">
           |r|`.y`: ref&lt;|SC|,|T|&gt;<br>
           |r|`.g`: ref&lt;|SC|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第二个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （索引值为 1 的 OpAccessChain）
  <tr algorithm="third vector component reference selection">
       <td>|r|: ref&lt;|SC|,vec|N|&lt;|T|&gt;&gt;<br>
           |N| is 3 or 4
       <td class="nowrap">
           |r|`.z`: ref&lt;|SC|,|T|&gt;<br>
           |r|`.b`: ref&lt;|SC|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第三个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （索引值为 2 的 OpAccessChain）
  <tr algorithm="fourth vector component reference selection">
       <td>|r|: ref&lt;|SC|,vec4&lt;|T|&gt;&gt;<br>
       <td class="nowrap">
           |r|`.w`: ref&lt;|SC|,|T|&gt;<br>
           |r|`.a`: ref&lt;|SC|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第四个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （索引值为 3 的 OpAccessChain）
  <tr algorithm="vector indexed component reference selection">
       <td>|r|: ref&lt;|SC|,vec|N|&lt;|T|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|SC|,|T|&gt;
       <td>计算引用 |r| 所引用的向量的第 |i| 个分量的引用。
       如果 |i| 在区间 [0,|N|-1] 外，则表达式计算为 [=invalid memory reference=]。
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （OpAccessChain）
</table>

### 矩阵访问表达式 ### {#matrix-access-expr}

<table class='data'>
  <caption>列向量提取</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector selection">
       <td class="nowrap">
          |e|: mat|N|x|M|&lt;|T|&gt;<br>
          |i|: [INT]<br>
          |i| 为一个 `const_expression` 表达式
       <td class="nowrap">
           |e|[|i|]: vec|M|&lt;|T|&gt;
       <td>结果为向量 |e| 的第 |i| 列。如果 |i| 在区间 [0,|N|-1]，则可能返回 vec|M|&lt;|T|&gt; 的无效值。
       （OpCompositeExtract）
</table>

<table class='data'>
  <caption>从对矩阵的引用获取对列向量的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector reference selection">
       <td class="nowrap">
          |r|: ref&lt;|SC|,mat|N|x|M|&lt;|T|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;vec|M|&lt;|SC|,|T|&gt;&gt;
       <td>通过引用 |r| 计算矩阵第 |i| 个列向量的引用。
       如果 |i| 在区间 [0,|N|-1] 外，则表达式计算为无效内存引用（[=invalid memory reference=]）。
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （OpAccessChain）
</table>

注意：反映 WGSL 旨在翻译成的语言的限制，只能使用动态计算的索引来标注对矩阵的引用。不在引用后面的矩阵只能由 `const_expression` 进行标注索引。要解决此限制，请考虑将矩阵存储在临时变量中，然后为变量添加下标：[[#var-identifier-expr|variable identifier expression]根据需要生成对变量值的引用。

### 数组访问表达式 ### {#array-access-expr}

<table class='data'>
  <caption>数组元素提取</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed element selection">
       <td class="nowrap">
          |e|: array&lt;|T|,|N|&gt;<br>
          |i|: [INT]<br>
          |i| 为 `const_expression` 表达式
       <td class="nowrap">
           |e|[|i|] : |T|
       <td>结果为数组值 |e| 的第 |i| 个元素的值。
       如果 |i| 在区间 [0,|N|-1] 外，则任何 |T| 的有效值可能被返回。
       （OpCompositeExtract）
</table>

<table class='data'>
  <caption>从对数组的引用获取对数组元素的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed reference selection">
       <td class="nowrap">
          |r|: ref&lt;|SC|,array&lt;|T|,|N|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|SC|,|T|&gt;
       <td>计算对由引用 |r| 引用的数组的第 |i| 个元素的引用。

       如果 |i| 在区间 [0,|N|-1] 外，则表达式计算为一个无效内存引用（[=invalid memory reference=]）。

       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。
       （OpAccessChain）
  <tr algorithm="array indexed reference selection">
       <td>|r|: ref&lt;|SC|,array&lt;|T|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|SC|,|T|&gt;
       <td>计算对由引用 |r| 引用的runtime-sized数组的第 |i| 个元素的引用。

       如果在运行时数组有 |N| 个元素，且 |i| 在区间 [0,|N|-1] 外，则表达式计算为一个无效内存引用（[=invalid memory reference=]）。

       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。
       （OpAccessChain）
</table>

注意：反映 WGSL 旨在翻译成的语言的限制，只能使用动态计算的索引来下标对数组的引用。不在引用后面的数组只能由 `const_expression` 索引。

### 结构访问表达式 ### {#struct-access-expr}

<table class='data'>
  <caption>结构成员提取</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member extraction">
       <td class="nowrap">
          |S| 为一个结构类型<br>
          |M| 为类型为 |T| 的 |S| 中成员的标识符名称。<br>
          |e|: |S|<br>
       <td class="nowrap">
           |e|.|M|: |T|
       <td>结果是结构值 |e| 中名称为 |M| 的成员的值。

       （OpCompositeExtract，使用成员索引）
</table>

<table class='data'>
  <caption>从对结构的引用获取对结构成员的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member reference selection">
       <td class="nowrap">
          |S| 为一个结构类型<br>
          |M| 为类型为 |T| 的 |S| 中的成员名称。<br>
          |r|: ref&lt;|SC|,|S|&gt;<br>
       <td class="nowrap">
           |r|.|M|: ref&lt;|SC|,|T|&gt;
       <td>给定对结构的引用，结果是对标识符名称为 |M| 的结构成员的引用。结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。

       （OpAccessChain，使用结构成员的索引）
</table>

## 逻辑表达式 ## {#logical-expr}
<table class='data'>
  <caption>一元逻辑运算</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="boolean negation"><td>|e|: bool<br>|T| 为布尔值或 vec|N|&lt;bool&gt;
  <td>`!`|e|: |T|
  <td>逻辑否定。

  当 |e| 为 `false` 时结果为 `true`，当 |e| 为 `true` 是结果为 `false`。

  当 |T| 为向量时，[=Component-wise=]。

  （OpLogicalNot）
</table>

<table class='data'>
  <caption>二元逻辑表达式</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="short-circuiting or"><td>|e1|: bool<br>|e2|: bool<td>|e1| `||` |e2|`: bool`
  <td>短路“或”。如果 |e1| 或 |e2| 为真，则为真； 仅当 |e1| 为假时才计算 |e2|。

  <tr algorithm="short-circuiting and"><td>|e1|: bool<br>|e2|: bool
  <td>|e1| `&&` |e2|`: bool`
  <td>短路“与”。 如果 |e1| 和 |e2| 都为真，则为真； 仅当 |e1| 为真时才计算 |e2|。

  <tr algorithm="logical or"><td>|e1|: |T|<br>|e2|: |T|<br>|T| 为布尔值或 vec|N|&lt;bool&gt;
  <td>|e1| `|` |e2|`:` |T|
  <td>逻辑“或”。

  当 |T| 是向量时，[=Component-wise=]。

  计算 |e1| 和 |e2|。
  Logical "or". [=Component-wise=] when |T| is a vector. Evaluates both |e1| and |e2|.

  <tr algorithm="logical and"><td>|e1|: |T|<br>|e2|: |T|<br>|T| 为布尔值或 vec|N|&lt;bool&gt;
  <td>|e1| `&` |e2|`:` |T|
  <td>逻辑“与”。

  当 |T| 是向量时，[=Component-wise=]。

  计算 |e1| 和 |e2|。
</table>


## 算术表达式 ## {#arithmetic-expr}

<table class='data'>
  <caption>一元算术表达式</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="integer negation"><td>|e|: |T|<br>
  |T| 为 [SIGNEDINTEGRAL]
  <td>`-`|e|`:` |T|
  <td>有符号整数否定。

  当 |T| 是向量时，[=Component-wise=]。

  如果 |e| 计算为最大的负值，则结果为 |e|。

  （OpSNegate）

  <tr algorithm="floating point negation"><td>|e|: |T|<br>|T| 为 [FLOATING]
  <td>`-`|e|`:` |T|
  <td>浮点否定。

  当 |T| 是向量时，[=Component-wise=]。

  （OpFNegate）
</table>

<table class='data'>
  <caption>Binary arithmetic expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="integer addition">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [INTEGRAL]
    <td>|e1| `+` |e2| : |T|
    <td>整数加法，模2<sup>32</sup>。

    当 |T| 是向量时，[=Component-wise=]。

    （OpIAdd）
  <tr algorithm="floating point addition">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [FLOATING]
    <td>|e1| `+` |e2| : |T|
    <td>浮点加法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpFAdd）

  <tr algorithm="integer subtraction">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [INTEGRAL]
    <td>|e1| `-` |e2| : |T|
    <td>整数减法，模2<sup>32</sup>。

    当 |T| 是向量时，[=Component-wise=]。

    （OpISub）
  <tr algorithm="floating point subtraction">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [FLOATING]
    <td>|e1| `-` |e2| : |T|
    <td>浮点减法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpFSub）

  <tr algorithm="integer multiplication">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [INTEGRAL]
    <td>|e1| `*` |e2| : |T|
    <td>整数乘法，模2<sup>32</sup>。

    当 |T| 是向量时，[=Component-wise=]。

    （OpIMul）
  <tr algorithm="floating point multiplication">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| is [FLOATING]
    <td>|e1| `*` |e2| : |T|
    <td>浮点乘法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpFMul）

  <tr algorithm="signed integer division">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [SIGNEDINTEGRAL]
    <td>|e1| `/` |e2| : |T|
    <td>有符号整数除法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpSDiv）
  <tr algorithm="unsigned integer division">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [UNSIGNEDINTEGRAL]
    <td>|e1| `/` |e2| : |T|
    <td>无符号整数除法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpUDiv）
  <tr algorithm="floating point division">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [FLOATING]
    <td>|e1| `/` |e2| : |T|
    <td>浮点除法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpFDiv）

  <tr algorithm="signed integer remainder">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [SIGNEDINTEGRAL]
    <td>|e1| `%` |e2| : |T|
    <td>有符号整数取余。

    当 |T| 是向量时，[=Component-wise=]。

    （OpSMod）
  <tr algorithm="unsigned integer modulus">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [UNSIGNEDINTEGRAL]
    <td>|e1| `%` |e2| : |T|
    <td>无符号整数取余。

    当 |T| 是向量时，[=Component-wise=]。

    （OpUMod）
  <tr algorithm="floating point remainder">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [FLOATING]
    <td>|e1| `%` |e2| : |T|
    <td>浮点取余。非零结果的符号与 |e1| 的符号相匹配。

    当 |T| 是向量时，[=Component-wise=]。

    结果等于：|e1| - |e2| * trunc(|e1| / |e2|)<br>

    （OpFRem）

</table>

<table class='data'>
  <caption>具有混合标量和向量操作数的二元算术表达式</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
  <tr algorithm="vector-scalar arithmetic, any scalar type">
    <td rowspan="8">|S| 为 f32, i32, u32 之一<br>
        |V| 为 vec|N|&lt;|S|&gt<br>
        |es|: |S|<br>
        |ev|: |V|
    <td>|ev| `+` |es|: |V|
    <td>|ev| `+` |V|(|es|)
  <tr>
    <td>|es| `+` |ev|: |V|
    <td>|V|(|es|) `+` |ev|
  <tr>
    <td>|ev| `-` |es|: |V|
    <td>|ev| `-` |V|(|es|)
  <tr>
    <td>|es| `-` |ev|: |V|
    <td>|V|(|es|) `-` |ev|
  <tr>
    <td>|ev| `*` |es|: |V|
    <td>|ev| `*` |V|(|es|)
  <tr>
    <td>|es| `*` |ev|: |V|
    <td>|V|(|es|) `*` |ev|
  <tr>
    <td>|ev| `/` |es|: |V|
    <td>|ev| `/` |V|(|es|)
  <tr>
    <td>|es| `/` |ev|: |V|
    <td>|V|(|es|) `/` |ev|
  <tr algorithm="vector-scalar integer arithmetic">
    <td rowspan="2">|S| 为 i32, u32 之一<br>
        |V| 为 vec|N|&lt;|S|&gt<br>
        |es|: |S|<br>
        |ev|: |V|
    <td>|ev| `%` |es|: |V|
    <td>|ev| `%` |V|(|es|)
  <tr>
    <td>|es| `%` |ev|: |V|
    <td>|V|(|es|) `%` |ev|
</table>

<table class='data'>
  <caption>矩阵运算</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
  <tr algorithm="matrix addition">
    <td rowspan=2>|e1|, |e2|: mat|M|x|N|&lt;f32&gt
    <td>|e1| `+` |e2|: mat|M|x|N|&lt;f32&gt<br>
    <td>矩阵加法，结果的第 |i| 列为 |e1|[i] + |e2|[i]。
  <tr algorithm="matrix subtraction">
    <td>|e1| `-` |e2|: mat|M|x|N|&lt;f32&gt
    <td>矩阵减法，结果的第 |i| 列为 |e1|[|i|] - |e2|[|i|]。
  <tr algorithm="matrix-scalar multiply">
    <td rowspan=2>|m|: mat|M|x|N|&lt;f32&gt<br>
        |s|: f32
    <td>|m| `*` |s|:  mat|M|x|N|&lt;f32&gt<br>
    <td>Component-wise 缩放: (|m| `*` |s|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="scalar-matrix multiply">
    <td>|s| `*` |m|:  mat|M|x|N|&lt;f32&gt<br>
    <td>Component-wise 缩放: (|s| `*` |m|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="matrix-column-vector multiply">
    <td>|m|: mat|M|x|N|&lt;f32&gt<br>
        |v|: vec|M|&lt;f32&gt
    <td>|m| `*` |v|:  vec|N|&lt;f32&gt<br>
    <td>线性代数矩阵-列-向量乘积：

    结果的 |i| 分量为 `dot`(|m|[|i|],|v|)。

    <br>OpMatrixTimesVector
  <tr algorithm="matrix-row-vector multiply">
    <td>
        |m|: mat|M|x|N|&lt;f32&gt<br>
        |v|: vec|N|&lt;f32&gt
    <td>|v| `*` |m|:  vec|M|&lt;f32&gt<br>
    <td>线性代数行-向量-矩阵乘积：<br>
        [=transpose=](transpose(|m|) `*` transpose(|v|))
       <br>OpVectorTimesMatrix
  <tr algorithm="matrix-matrix multiply">
    <td>|e1|: mat|K|x|N|&lt;f32&gt<br>
        |e2|: mat|M|x|K|&lt;f32&gt
    <td>|e1| `*` |e2|:  mat|M|x|N|&lt;f32&gt<br>
    <td>线性代数矩阵乘积。<br>OpMatrixTimesMatrix

</table>

## 比较表达式 ## {#comparison-expr}

<table class='data'>
  <caption>比较</caption>
  <thead>
    <tr><th>Precondtion<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="bool equality">
    <td>|e1|: |T|<br>|e2|: |T|<br>|T| is bool or vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `==` |e2|`:` |T|
    <td>等价。

    当 |T| 是向量时，[=Component-wise=]。

    （OpLogicalEqual）
  <tr algorithm="bool inequality">
    <td>|e1|: |T|<br>|e2|: |T|<br>|T| is bool or vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `!=` |e2|`:` |T|
    <td>不等价。

    当 |T| 是向量时，[=Component-wise=]。

    （OpLogicalNotEqual）

  <tr algorithm="integer equality">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>
    |TI| 为 [INTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `==` |e2|`:` |TB|
    <td>等价。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpIEqual）
  <tr algorithm="integer inequality">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>
    |TI| 为 [INTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `!=` |e2|`:` |TB|
    <td>不等价。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpINotEqual）

  <tr algorithm="signed integer less than">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [SIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `<` |e2|`:` |TB|
    <td>小于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpSLessThan）
  <tr algorithm="signed integer less than equal">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [SIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `<=` |e2|`:` |TB|
    <td>小于等于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpSLessThanEqual）
  <tr algorithm="signed integer greater than">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [SIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `>` |e2|`:` |TB|
    <td>大于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpSGreaterThan）
  <tr algorithm="signed integer greater than equal">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [SIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `>=` |e2|`:` |TB|
    <td>大于等于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpSGreaterThanEqual）

  <tr algorithm="unsigned integer less than">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [UNSIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `<` |e2|`:` |TB|
    <td>小于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpULessThan）
  <tr algorithm="unsigned integer less than equal">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [UNSIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `<=` |e2|`:` |TB|
    <td>小于等于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpULessThanEqual）
  <tr algorithm="unsigned integer greater than">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [UNSIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `>` |e2|`:` |TB|
    <td>大于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpUGreaterThan）
  <tr algorithm="unsigned integer greater than equal">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [UNSIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `>=` |e2|`:` |TB|
    <td>大于等于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpUGreaterThanEqual）

  <tr algorithm="floating point equality">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| == |e2|: |TB|
    <td>等价。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdEqual）

  <tr algorithm="floating point inequality">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| != |e2|: |TB|
    <td>不等价。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdEqual）
  <tr algorithm="floating point less than">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| < |e2|: |TB|
    <td>小于。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdLessThan）
  <tr algorithm="floating point less than equal">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| <= |e2|: |TB|
    <td>小于等于。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdLessThanEqual）
  <tr algorithm="floating point greater than">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| > |e2|: |TB|
    <td>大于。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdGreaterThan）
    Greater than. [=Component-wise=] when |TF| is a vector. (OpFOrdGreaterThan)
  <tr algorithm="floating point greater than equal">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| >= |e2|: |TB|
    <td>大于等于。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdGreaterThanEqual）

</table>

## 位表达式 ## {#bit-expr}

<table class='data'>
  <caption>一元按位运算</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="complement">
    <td>|e|: |T|<br>
    |T| 为 [INTEGRAL]
    <td class="nowrap">`~`|e| : |T|
    <td>|e| 上的按位补码。

    结果中的每一位都与 |e| 中的相应位相反。

    当 T 是向量时，[=Component-wise=]。

    （OpNot）
</table>

<table class='data'>
  <caption>二元按位运算</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="bitwise or">
    <td>*e1*: *T*<br>
       *e2*: *T*<br>
       *T* 为 [INTEGRAL]
    <td class="nowrap">`e1 | e2`: *T*
    <td>按位-或。当 |T| 是向量时，[=Component-wise=]。
  <tr algorithm="bitwise and">
    <td>*e1*: *T*<br>
       *e2*: *T*<br>
       *T* 为 [INTEGRAL]
    <td class="nowrap">`e1 & e2`: *T*
    <td>按位-与。当 |T| 是向量时，[=Component-wise=]。
  <tr algorithm="bitwise exclusive or">
    <td>*e1*: *T*<br>
       *e2*: *T*<br>
       *T* 为 [INTEGRAL]
    <td class="nowrap">`e1 ^ e2`: *T*
    <td>按位-异或。当 |T| 是向量时，[=Component-wise=]。
</table>


<table class='data'>
  <caption>位移表达式</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="shift left">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |T| 为 [INTEGRAL]<br>
    如果 |e1| 为标量，则 |TS| 为 u32<br>
    vec|N|&lt;u32&gt;.
    <td class="nowrap">|e1| `<<` |e2|: |T|
    <td>左移：<br>
    将 |e1| 左移，在最低有效位置插入零，并丢弃最高有效位。要移位的位数是 |e2| 的值 modulo |e1| 的位宽。

    当 T 是向量时，[=Component-wise=]。

    （OpShiftLeftLogical）

  <tr algorithm="logical shift right">
    <td>|e1|: |T|<br>
    |e2|: |T|<br>
    |T| is [UNSIGNEDINTEGRAL]
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>逻辑右移：<br>

    将 |e1| 右移，在最高有效位置插入零，并丢弃最低有效位。要移位的位数是 |e2| 的值 modulo |e1| 的位宽。

    当 T 是向量时，[=Component-wise=]。

    （OpShiftRightLogical）

  <tr algorithm="arithmetic shift right">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |T| is [SIGNEDINTEGRAL]<br>
    |TS| is u32 if |e1| is a scalar, or<br>
    vec|N|&lt;u32&gt;.
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>算术右移：<br>

    将 |e1| 右移，在最高有效位置插入符号位的副本，并丢弃最低有效位。要移位的位数是 |e2| 的值 modulo |e1| 的位宽。

    当 T 是向量时，[=Component-wise=]。

    （OpShiftRightArithmetic）
</table>

## 函数调用表达式 ## {#function-call-expr}

函数调用表达式执行函数调用（[=function call=]），其中被调用函数具有返回类型（[=return type=]）。 如果被调用的函数没有返回值，则应使用函数调用语句代替。见[[#function-call-statement]]。

## 变量标识符表达式 ## {#var-identifier-expr}

<table class='data'>
  <caption>从变量名获取引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="variable reference">
       <td>
       |v| 是解析（[=resolves|resolving=]）为 [=storage class=] |SC| 中声明的 [=in scope|in-scope=] 变量的标识符（[=identifier=]），存储类型（[=store type=]）为 |T|
       <td class="nowrap">
          |v|: ref&lt;|SC|,|T|&gt;
       <td>结果是对命名变量 |v| 的存储的引用。
</table>

## 形式参数表达式  ## {#formal-parameter-expr}

<table class='data'>
  <caption>获取声明为函数形式参数的标识符的值</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="formal parameter value">
       <td>
          |a| 是解析（[=resolves|resolving=]）为类型 |T| 的 [=in scope|in-scope=] 形式参数声明的标识符（[=identifier=]）
       <td class="nowrap">
          |a|: |T|
       <td>结果是在调用此函数实例的调用位置（[=call site=]）为相应函数调用操作数提供的值。
</table>

## 寻址表达式  ## {#address-of-expr}

寻址（<dfn noexport>address-of</dfn>）操作符将一个引用转换为其对应的指针。

<table class='data'>
  <caption>从引用获取指针</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="address-of expression">
       <td>
          |r|: ref&lt;|SC|,|T|,|A|&gt;
       <td class="nowrap">
          `&`|r|: ptr&lt;|SC|,|T|,|A|&gt;
       <td>结果是与引用值 |r| 相同的内存视图（[=memory view=]）对应的指针值。

       如果 |r| 是一个无效内存引用（[=invalid memory reference=]），作为结果的指针同样是无效内存引用。

       如果 |SC| 为 [=storage classes/handle=] 存储类，则为一个着色器创建错误（[=shader-creation error=]）。

</table>

## 间接寻址表达式  ## {#indirection-expr}

间接寻址运算符（<dfn noexport>indirection</dfn>）将指针转换为其相应的引用。

<table class='data'>
  <caption>从指针获取引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="indirection expression">
       <td>
          |p|: ptr&lt;|SC|,|T|,|A|&gt;
       <td class="nowrap">
          `*`|p|: ref&lt;|SC|,|T|,|A|&gt;
       <td>结果是与指针值 |p| 相同的内存视图（[=memory view=]）对应的引用值。

       如果 |p| 是一个无效内存引用（[=invalid memory reference=]），作为结果的指针同样是无效内存引用。

</table>

## 常量标识符表达式  ## {#constant-identifier-expr}

<table class='data'>
  <caption>获取 `let`-声明标识符的值</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="pipeline-overridable constant value">
       <td>
          |c| 是解析（[=resolves|resolving=]）为类型 |T| 的[=in scope|in-scope=]管线可覆盖（[=pipeline-overridable=]）的 `let` 声明的标识符（[=identifier=]）。
       <td class="nowrap">
          |c|: |T|
       <td>如果管线创建为常量 ID （[=pipeline constant ID|constant ID=]）指定了一个值，那么结果就是该值。对于不同的管线实例，此值可能不同。<br>

      否则，结果是为初始化表达式计算的值。管线可覆盖常量出现在模块范围内，因此在着色器开始执行之前进行计算。<br>

      注意：如果在 API 调用中没有指定初始值并且 `let`-声明没有初始化表达式，则管线创建将失败。
  <tr algorithm="constant value">
       <td>
          |c| 是解析（[=resolves|resolving=]）为类型 |T| 的[=in scope|in-scope=] `let` 声明的标识符（[=identifier=]），并且不为管线可覆盖（[=pipeline-overridable=]）的。
       <td class="nowrap">
          |c|: |T|
       <td>结果是为初始化表达式计算出的值。<br>

       对于模块范围内的 `let` 声明，计算发生在着色器开始执行之前。

       对于函数内部的 `let` 声明，每次控制到达声明时都会进行计算。<br>
</table>


## 表达式语法总结 ## {#expression-grammar}

<div class='syntax' noexport='true'>
  <dfn for=syntax>primary_expression</dfn> :

    | [=syntax/ident=] [=syntax/argument_expression_list=] ?

    | [=syntax/type_decl=] [=syntax/argument_expression_list=]

    | [=syntax/const_literal=]

    | [=syntax/paren_expression=]

    | [=syntax/bitcast=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=] [=syntax/paren_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_expression</dfn> :

    | [=syntax/paren_left=] [=syntax/short_circuit_or_expression=] [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>argument_expression_list</dfn> :

    | [=syntax/paren_left=] ( ( [=syntax/short_circuit_or_expression=] [=syntax/comma=] ) * [=syntax/short_circuit_or_expression=] [=syntax/comma=] ? ) ? [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>postfix_expression</dfn> :

    | [=syntax/bracket_left=] [=syntax/short_circuit_or_expression=] [=syntax/bracket_right=] [=syntax/postfix_expression=] ?

    | [=syntax/period=] [=syntax/ident=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>unary_expression</dfn> :

    | [=syntax/singular_expression=]

    | [=syntax/minus=] [=syntax/unary_expression=]

    | [=syntax/bang=] [=syntax/unary_expression=]

    | [=syntax/tilde=] [=syntax/unary_expression=]

    | [=syntax/star=] [=syntax/unary_expression=]

    | [=syntax/and=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>singular_expression</dfn> :

    | [=syntax/primary_expression=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>multiplicative_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/star=] [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/forward_slash=] [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/modulo=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>additive_expression</dfn> :

    | [=syntax/multiplicative_expression=]

    | [=syntax/additive_expression=] [=syntax/plus=] [=syntax/multiplicative_expression=]

    | [=syntax/additive_expression=] [=syntax/minus=] [=syntax/multiplicative_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>shift_expression</dfn> :

    | [=syntax/additive_expression=]

    | [=syntax/shift_expression=] [=syntax/shift_left=] [=syntax/additive_expression=]

    | [=syntax/shift_expression=] [=syntax/shift_right=] [=syntax/additive_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>relational_expression</dfn> :

    | [=syntax/shift_expression=]

    | [=syntax/relational_expression=] [=syntax/less_than=] [=syntax/shift_expression=]

    | [=syntax/relational_expression=] [=syntax/greater_than=] [=syntax/shift_expression=]

    | [=syntax/relational_expression=] [=syntax/less_than_equal=] [=syntax/shift_expression=]

    | [=syntax/relational_expression=] [=syntax/greater_than_equal=] [=syntax/shift_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>equality_expression</dfn> :

    | [=syntax/relational_expression=]

    | [=syntax/relational_expression=] [=syntax/equal_equal=] [=syntax/relational_expression=]

    | [=syntax/relational_expression=] [=syntax/not_equal=] [=syntax/relational_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>and_expression</dfn> :

    | [=syntax/equality_expression=]

    | [=syntax/and_expression=] [=syntax/and=] [=syntax/equality_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>exclusive_or_expression</dfn> :

    | [=syntax/and_expression=]

    | [=syntax/exclusive_or_expression=] [=syntax/xor=] [=syntax/and_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>inclusive_or_expression</dfn> :

    | [=syntax/exclusive_or_expression=]

    | [=syntax/inclusive_or_expression=] [=syntax/or=] [=syntax/exclusive_or_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>short_circuit_and_expression</dfn> :

    | [=syntax/inclusive_or_expression=]

    | [=syntax/short_circuit_and_expression=] [=syntax/and_and=] [=syntax/inclusive_or_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>short_circuit_or_expression</dfn> :

    | [=syntax/short_circuit_and_expression=]

    | [=syntax/short_circuit_or_expression=] [=syntax/or_or=] [=syntax/short_circuit_and_expression=]
</div>


# Statements # {#statements}

Statements are program fragments that control its execution.
Statements are generally executed in sequential order; however,
[[#control-flow|control flow statements]] may cause a program to execute in
non-sequential order.

## Compound Statement ## {#compound-statement-section}

A <dfn>compound statement</dfn> is a brace-enclosed sequence of zero or more statements.
When a [=declaration=] is one of those statements, its [=identifier=] is [=in scope=]
from the start of the next statement until the end of the compound statement.

<div class='syntax' noexport='true'>
  <dfn for=syntax>compound_statement</dfn> :

    | [=syntax/brace_left=] [=syntax/statement=] * [=syntax/brace_right=]
</div>

## Assignment Statement ## {#assignment}

An <dfn noexport dfn-for="statement">assignment</dfn> evaluates an expression,
and optionally stores it in memory (thus updating the contents of a variable).


<div class='syntax' noexport='true'>
  <dfn for=syntax>assignment_statement</dfn> :

    | ( [=syntax/unary_expression=] | [=syntax/underscore=] ) [=syntax/equal=] [=syntax/short_circuit_or_expression=]
</div>


The text to the left of the equals token is the <dfn noexport>left-hand side</dfn>,
and the
expression to the right of the equals token is the <dfn noexport>right-hand side</dfn>.

### Updating Assignment ### {#updating-assignment-section}

When the [=left-hand side=] of an assignment is an expression, the assignment is an <dfn noexport>updating assignment</dfn>:
The value of the right-hand side is written to the memory referenced by the left-hand side.

<table class='data'>
  <thead>
    <tr><th style="width:40%">Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="updating assignment">
    <td>|r|: ref<|SC|,|T|,|A|>,<br>
        |A| is [=access/write=] or [=access/read_write=]<br>
        |e|: |T|,<br>
        |T| is a [=constructible=] type,<br>
        |SC| is a writable [=storage class=]
    <td class="nowrap">|r| = |e|
    <td>Evaluates |e|, evaluates |r|, then writes the value computed for |e| into
        the [=memory locations=] referenced by |r|.
        Note: if the reference is an [=invalid memory reference=], the write
        may not execute, or may write to a different memory location than
        expected.

        (OpStore)
</table>

In the simplest case, the left hand side is the name of a variable.
See [[#forming-references-and-pointers]] for other cases.

    <div class='example wgsl' heading='Assignments'>
      <xmp highlight='rust'>
        struct S {
            age: i32;
            weight: f32;
        };
        var<private> person: S;

        fn f() {
            var a: i32 = 20;
            a = 30;           // Replace the contents of 'a' with 30.

            person.age = 31;  // Write 31 into the age field of the person variable.

            var uv: vec2<f32>;
            uv.y = 1.25;      // Place 1.25 into the second component of uv.

            let uv_x_ptr: ptr<function,f32> = &uv.x;
            *uv_x_ptr = 2.5;   // Place 2.5 into the first component of uv.

            var friend: S;
            // Copy the contents of the 'person' variable into the 'friend' variable.
            friend = person;
        }
      </xmp>
    </div>

### Phony Assignment ### {#phony-assignment-section}

When the [=left-hand side=] of an assignment is an underscore token,
the assignment is an <dfn noexport>phony assignment</dfn>:
The right-hand side is evaluated, and then ignored.

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="phony-assignment">
    <td>|e|: |T|,<br>
        |T| is [=constructible=], a [=pointer type=], a [=texture=] type, or a [=sampler=] type
    <td class="nowrap">_ = |e|
    <td>Evaluates |e|.

        Note: The resulting value is not stored.
        The `_` token is not an identifier, and therefore cannot be used in an expression.
</table>

A phony-assignment is useful for:
* Calling a function that returns a value, but clearly expressing that the resulting value
    is not needed.
* [=statically accessed|Statically accessing=] a variable, thus establishing it as a part of
    the [=resource interface of a shader|shader's resource interface=].

    Note: A buffer variable's store type may not be constructible, e.g. it contains an atomic type, or a runtime-sized array.
    In these cases, use a pointer to the variable's contents instead.

<div class='example wgsl global-scope' heading='Using phony-assignment to throw away an un-needed function result'>
  <xmp highlight=rust>
    var<private> counter: i32;

    fn increment_and_yield_previous() -> i32 {
      let previous = counter;
      counter = counter + 1;
      return previous;
    }

    fn user() {
      // Increment the counter, but don't use the result.
      _ = increment_and_yield_previous();
    }
  </xmp>
</div>


<div class='example wgsl global-scope' heading='Using phony-assignment to occupy bindings without using them'>
  <xmp highlight=rust>
    [[block]] struct BufferContents {
        counter: atomic<u32>;
        data: array<vec4<f32>>;
    };
    [[group(0),binding(0)]] var<storage> buf: BufferContents;
    [[group(0),binding(1)]] var t: texture_2d<f32>;
    [[group(0),binding(2)]] var s: sampler;

    [[stage(fragment)]]
    fn shade_it() -> [[location(0)]] vec4<f32> {
      // Declare that buf, t, and s are part of the shader interface, without
      // using them for anything.
      _ = &buf;
      _ = t;
      _ = s;
      return vec4<f32>();
    }
  </xmp>
</div>

## Control flow ## {#control-flow}

Control flow statements may cause the program to execute in non-sequential order.

### If Statement ### {#if-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>if_statement</dfn> :

    | [=syntax/if=] [=syntax/paren_expression=] [=syntax/compound_statement=] [=syntax/elseif_statement=] ? [=syntax/else_statement=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>elseif_statement</dfn> :

    | [=syntax/else_if=] [=syntax/paren_expression=] [=syntax/compound_statement=] [=syntax/elseif_statement=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>else_statement</dfn> :

    | [=syntax/else=] [=syntax/compound_statement=]
</div>

An <dfn noexport dfn-for="statement">if</dfn> statement conditionally executes at most one [=compound statement=] based on
the evaluation of the condition expressions.

The `if` statements in [SHORTNAME] use an if/elseif/else structure, that contains a single required
`if` clause, zero or more `elseif` clauses and a single optional `else` clause.
Each of the expressions for the `if` and `elseif` clause conditions must be a scalar boolean expression.

An `if` statement is executed as follows:
* The condition associated with the `if` clause is evaluated.
    If the result is `true`,
    control transfers to the first compound statement (immediately after the parenthesized condition experession).
* Otherwise, the condition of the next `elseif` clause in textual order (if one exists) is evaluated
     and, if the result is `true`, control transfers to the associated compound statement.
     * This behavior is repeated for all `elseif` clauses until one of the conditions evaluates to `true`.
* If no condition evaluates to `true`, then control transfers to the compound statement
    associated with the `else` clause (if it exists).

### Switch Statement ### {#switch-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>switch_statement</dfn> :

    | [=syntax/switch=] [=syntax/paren_expression=] [=syntax/brace_left=] [=syntax/switch_body=] + [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>switch_body</dfn> :

    | [=syntax/case=] [=syntax/case_selectors=] [=syntax/colon=] [=syntax/brace_left=] [=syntax/case_body=] ? [=syntax/brace_right=]

    | [=syntax/default=] [=syntax/colon=] [=syntax/brace_left=] [=syntax/case_body=] ? [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>case_selectors</dfn> :

    | [=syntax/const_literal=] ( [=syntax/comma=] [=syntax/const_literal=] ) * [=syntax/comma=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>case_body</dfn> :

    | [=syntax/statement=] [=syntax/case_body=] ?

    | [=syntax/fallthrough=] [=syntax/semicolon=]
</div>

A <dfn noexport dfn-for="statement">switch</dfn> statement transfers control to one of a set of case clauses, or to the `default` clause,
depending on the evaluation of a selector expression.

The selector expression must be of a scalar integer type.
If the selector value equals a value in a case selector list, then control is transferred to
the body of that case clause.
If the selector value does not equal any of the case selector values, then control is
transferred to the `default` clause.

Each switch statement must have exactly one default clause.

The case selector values must have the same type as the result of evaluating the selector expression.

A literal value must not appear more than once in the case selectors for a switch statement.

Note: The value of the literal is what matters, not the spelling.
For example `0`, `00`, and `0x0000` all denote the zero value.

When control reaches the end of a case body, control normally transfers to the first statement
after the switch statement.
Alternately, executing a <dfn noexport dfn-for="statement">fallthrough</dfn> statement
transfers control to the body of the next case clause or
default clause, whichever appears next in the switch body.
A `fallthrough` statement must not appear as the last statement in the last clause of a switch.
When a [=declaration=] appears in a case body, its [=identifier=] is [=in scope=] from
the start of the next statement until the end of the case body.

Note: Identifiers declared in a case body are not [=in scope=] of case bodies
which are reachable via a `fallthrough` statement.


### Loop Statement ### {#loop-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>loop_statement</dfn> :

    | [=syntax/loop=] [=syntax/brace_left=] [=syntax/statement=] * [=syntax/continuing_statement=] ? [=syntax/brace_right=]
</div>

A <dfn noexport dfn-for="statement">loop</dfn> statement repeatedly executes a <dfn noexport>loop body</dfn>;
the loop body is specified as a [=compound statement=].
Each execution of the loop body is called an <dfn noexport>iteration</dfn>.

The [=identifier=] of a [=declaration=] in a loop is [=in scope=] from the start of the
next statement until the end of the loop body.
The declaration is executed each time it is reached, so each new iteration
creates a new instance of the variable or constant, and re-initializes it.

This repetition can be interrupted by a [=statement/break=], [=statement/return=], or
[=statement/discard=] statement.

Optionally, the last statement in the loop body may be a
[=statement/continuing=] statement.

Note: The loop statement is one of the biggest differences from other shader
languages.

This design directly expresses loop idioms commonly found in compiled code.
In particular, placing the loop update statements at the end of the loop body
allows them to naturally use values defined in the loop body.

<div class='example glsl' heading='GLSL Loop'>
  <xmp>
    int a = 2;
    for (int i = 0; i < 4; i++) {
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="[SHORTNAME] Loop">
  <xmp>
    let a: i32 = 2;
    var i: i32 = 0;      // <1>
    loop {
      if (i >= 4) { break; }

      a = a * 2;

      i = i + 1;
    }
  </xmp>
</div>
* <1> The initialization is listed before the loop.

<div class='example glsl' heading='GLSL Loop with continue'>
  <xmp>
    int a = 2;
    let int step = 1;
    for (int i = 0; i < 4; i += step) {
      if (i % 2 == 0) continue;
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="[SHORTNAME] Loop with continue">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if (i >= 4) { break; }

      let step: i32 = 1;

      i = i + step;
      if (i % 2 == 0) { continue; }

      a = a * 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="[SHORTNAME] Loop with continue and continuing">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if (i >= 4) { break; }

      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {   // <2>
        i = i + step;
      }
    }
  </xmp>
</div>
* <2> The continue construct is placed at the end of the `loop`

### For Statement ### {#for-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>for_statement</dfn> :

    | [=syntax/for=] [=syntax/paren_left=] [=syntax/for_header=] [=syntax/paren_right=] [=syntax/compound_statement=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>for_header</dfn> :

    | ( [=syntax/variable_statement=] | [=syntax/assignment_statement=] | [=syntax/func_call_statement=] ) ? [=syntax/semicolon=] [=syntax/short_circuit_or_expression=] ? [=syntax/semicolon=] ( [=syntax/assignment_statement=] | [=syntax/func_call_statement=] ) ?
</div>

The <dfn dfn-for="statement">for</dfn> statement takes the form
`for(initializer; condition; continuing_part) { body }` and is syntactic sugar on top of a [=statement/loop=] statement with the same `body`.
Additionally:
* If `initializer` is non-empty, it is executed inside an additional scope before the first [=iteration=].
* If `condition` is non-empty, it is checked at the beginning of the loop body and if unsatisfied then a [[#break-statement]] is executed.
* If `continuing_part` is non-empty, it becomes a [=statement/continuing=] statement at the end of the loop body.

The `initializer` of a for loop is executed once prior to executing the loop.
When a [=declaration=] appears in the initializer, its [=identifier=] is [=in scope=] until the end of the `body`.
Unlike declarations in the `body`, the declaration is not re-initialized each iteration.

The `condition`, `body` and `continuing_part` execute in that order to form a loop [=iteration=].
The `body` is a special form of [=compound statement=].
The identifier of a declaration in the `body` is [=in scope=] from the start of
the next statement until the end of the `body`.
The declaration is executed each time it is reached, so each new iteration
creates a new instance of the variable or constant, and re-intializes it.

<div class='example glsl' heading="For to Loop transformation">
  <xmp>
    for(var i: i32 = 0; i < 4; i = i + 1) {
      if (a == 0) {
        continue;
      }
      a = a + 2;
    }
  </xmp>
</div>

Converts to:

<div class='example wgsl function-scope' heading="For to Loop transformation">
  <xmp>
    { // Introduce new scope for loop variable i
      var i: i32 = 0;
      var a: i32 = 0;
      loop {
        if (!(i < 4)) {
          break;
        }

        if (a == 0) {
          continue;
        }
        a = a + 2;

        continuing {
          i = i + 1;
        }
      }
    }
  </xmp>
</div>


### Break Statement ### {#break-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>break_statement</dfn> :

    | [=syntax/break=]
</div>

A <dfn noexport dfn-for="statement">break</dfn> statement transfers control to the first statement
after the body of the nearest-enclosing [=statement/loop=]
or [=statement/switch=] statement.
A `break` statement must only be used within [=statement/loop=], [=statement/for=], and [=statement/switch=] statements.

When a `break` statement is placed such that it would exit from a loop's [=statement/continuing=] statement,
then:

* The `break` statement must appear as either:
    * The only statement in the `if` clause of an `if` statement that has:
        * no `else` clause or an empty `else` clause
        * no `elseif` clauses
    * The only statement in the `else` clause of an `if` statement that has an empty `if` clause and no `elseif` clauses.
* That `if` statement must appear last in the `continuing` clause.

<div class='example wgsl function-scope' heading="[SHORTNAME] Valid loop if-break from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        if (i >= 4) { break; }
      }
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="[SHORTNAME] Valid loop if-else-break from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        if (i < 4) {} else { break; }
      }
    }
  </xmp>
</div>

<div class='example wgsl function-scope expect-error' heading="[SHORTNAME] Invalid breaks from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;

    loop {
      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        break;                                     // Invalid: too early
        if (i < 4) { i = i + 1; } else { break; }  // Invalid: if is too complex, and too early
        if (i >= 4) { break; } else { i = i + 1; } // Invalid: if is too complex
      }
    }
  </xmp>
</div>

### Continue Statement ### {#continue-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>continue_statement</dfn> :

    | [=syntax/continue=]
</div>

A <dfn noexport dfn-for="statement">continue</dfn> statement transfers control in the nearest-enclosing [=statement/loop=]:

*  forward to the [=statement/continuing=] statement at the end of the body of that loop, if it exists.
*  otherwise backward to the first statement in the loop body, starting the next [=iteration=].

A `continue` statement must only be used in a [=statement/loop=] or [=statement/for=] statement.
A `continue` statement must not be placed such that it would transfer
control to an enclosing [=statement/continuing=] statement.
(It is a *forward* branch when branching to a `continuing` statement.)

A `continue` statement must not be placed such that it would transfer
control past a declaration used in the targeted [=statement/continuing=] statement.

<div class='example wgsl function-scope expect-error' heading="Invalid continue bypasses declaration">
  <xmp>
    var i: i32 = 0;
    loop {
      if (i >= 4) { break; }
      if (i % 2 == 0) { continue; } // <3>

      let step: i32 = 2;

      continuing {
        i = i + step;
      }
    }
  </xmp>
</div>
* <3> The `continue` is invalid because it bypasses the declaration of `step` used in the `continuing` construct

### Continuing Statement ### {#continuing-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>continuing_statement</dfn> :

    | [=syntax/continuing=] [=syntax/compound_statement=]
</div>

A <dfn dfn-for="statement">continuing</dfn> statement specifies a [=compound statement=] to be executed at the end of a loop [=iteration=].
The construct is optional.

The compound statement must not contain a [=statement/return=] or [=statement/discard=] statement, at any compound statement nesting level.

### Return Statement ### {#return-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>return_statement</dfn> :

    | [=syntax/return=] [=syntax/short_circuit_or_expression=] ?
</div>

A <dfn noexport dfn-for="statement">return</dfn> statement ends execution of the current function.
If the function is an [=entry point=], then the current shader invocation
is terminated.
Otherwise, evaluation continues with the next expression or statement after
the evaluation of the [=call site=] of the current function invocation.

If the function does not have a [=return type=], then the [=statement/return=] statement is
optional. If the return statement is provided for such a function, it must not
supply a value.
Otherwise the expression must be present, and is called the <dfn>return value</dfn>.
In this case the call site of this function invocation evaluates to the return value.
The type of the return value must match the return type of the function.

### Discard Statement ### {#discard-statement}

A <dfn dfn-for="statement">discard</dfn> statement immediately ends execution of a fragment shader invocation and throws away the fragment.
The `discard` statement must only be used in a [=fragment=] shader stage.

More precisely, executing a `discard` statement will:

* immediately terminate the current invocation, and
* prevent evaluation and generation of a [=return value=] for the [=entry point=], and
* prevent the current fragment from being processed downstream in the [=GPURenderPipeline=].

Only statements
executed prior to the `discard` statement will have observable effects.

Note: A `discard` statement may be executed by any
[=functions in a shader stage|function in a fragment stage=] and the effect is the same:
immediate termination of the invocation.

After a `discard` statement is executed, control flow is non-uniform for the
duration of the entry point.

Issue: [[#uniform-control-flow]] needs to state whether all invocations being discarded maintains uniform control flow.

<div class='example' heading='Using the discard statement to throw away a fragment'>
  <xmp>
  var<private> will_emit_color: bool = false;

  fn discard_if_shallow(pos: vec4<f32>) {
    if (pos.z < 0.001) {
      // If this is executed, then the will_emit_color flag will
      // never be set to true.
      discard;
    }
    will_emit_color = true;
  }

  [[stage(fragment)]]
  fn main([[builtin(position)]] coord_in: vec4<f32>)
    -> [[location(0)]] vec4<f32>
  {
    discard_if_shallow(coord_in);

    // Set the flag and emit red, but only if the helper function
    // did not execute the discard statement.
    will_emit_color = true;
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
  }
  </xmp>
</div>

## Function Call Statement ## {#function-call-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>func_call_statement</dfn> :

    | [=syntax/ident=] [=syntax/argument_expression_list=]
</div>

A function call statement executes a [=function call=].

Note: If the function [=return value|returns a value=], that value is ignored.

## Statements Grammar Summary ## {#statements-summary}

<div class='syntax' noexport='true'>
  <dfn for=syntax>statement</dfn> :

    | [=syntax/semicolon=]

    | [=syntax/return_statement=] [=syntax/semicolon=]

    | [=syntax/if_statement=]

    | [=syntax/switch_statement=]

    | [=syntax/loop_statement=]

    | [=syntax/for_statement=]

    | [=syntax/func_call_statement=] [=syntax/semicolon=]

    | [=syntax/variable_statement=] [=syntax/semicolon=]

    | [=syntax/break_statement=] [=syntax/semicolon=]

    | [=syntax/continue_statement=] [=syntax/semicolon=]

    | [=syntax/discard=] [=syntax/semicolon=]

    | [=syntax/assignment_statement=] [=syntax/semicolon=]

    | [=syntax/compound_statement=]
</div>


# Functions # {#functions}

A <dfn dfn-for="function" noexport>function</dfn> performs computational work when invoked.

A function is invoked in one of the following ways:
* By evaluating a function call expression. See [[#function-call-expr]].
* By executing a function call statement. See [[#function-call-statement]].
* An [=entry point=] function is invoked by the WebGPU implementation to perform
    the work of a [=shader stage=] in a [=pipeline=]. See [[#entry-points]]

There are two kinds of functions:
* A [=built-in function=] is provided by the [SHORTNAME] implementation,
    and is always available to a [SHORTNAME] program.
    See [[#builtin-functions]].
* A <dfn noexport>user-defined function</dfn> is declared in a [SHORTNAME] program.

## Declaring a user-defined function ## {#function-declaration-sec}

A <dfn noexport>function declaration</dfn> creates a user-defined function, by specifying:
* An optional set of attributes.
* The name of the function.
* The formal parameter list: an ordered sequence of zero
    or more [=formal parameter=] declarations,
    separated by commas, and
    surrounded by parentheses.
* An optional, possibly decorated, <dfn noexport>return type</dfn>.
* The <dfn noexport>function body</dfn>.
    This is the set of statements to be executed when the function is [=function call|called=].

A function declaration must only occur at [=module scope=].
The function name is [=in scope=] from the start of the formal parameter list
until the end of the program.

A <dfn noexport>formal parameter</dfn> [=declaration=] specifies an [=identifier=] name and a type for a value that must be
provided when invoking the function.
A formal parameter may have attributes.
See [[#function-calls]].
The identifier is [=in scope=] until the end of the function.
Two formal parameters for a given function must not have the same name.

If the return type is specified, then:
* The return type must be [=constructible=].
* The last statement in the function body must be a [=statement/return=] statement.

<div class='syntax' noexport='true'>
  <dfn for=syntax>function_decl</dfn> :

    | [=syntax/attribute_list=] * [=syntax/function_header=] [=syntax/compound_statement=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>function_header</dfn> :

    | [=syntax/fn=] [=syntax/ident=] [=syntax/paren_left=] [=syntax/param_list=] ? [=syntax/paren_right=] ( [=syntax/arrow=] [=syntax/attribute_list=] * [=syntax/type_decl=] ) ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>param_list</dfn> :

    | ( [=syntax/param=] [=syntax/comma=] ) * [=syntax/param=] [=syntax/comma=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>param</dfn> :

    | [=syntax/attribute_list=] * [=syntax/variable_ident_decl=]
</div>

[SHORTNAME] defines the following attributes that can be applied to function declarations:
 * [=attribute/stage=]
 * [=attribute/workgroup_size=]

[SHORTNAME] defines the following attributes that can be applied to function
parameters and return types:
 * [=attribute/builtin=]
 * [=attribute/location=]

<div class='example' heading='Simple functions'>
  <xmp>
    // Declare the add_two function.
    // It has two formal paramters, i and b.
    // It has a return type of i32.
    // It has a body with a return statement.
    fn add_two(i: i32, b: f32) -> i32 {
      return i + 2;  // A formal parameter is available for use in the body.
    }

    // A compute shader entry point function, 'main'.
    // It has no specified return type.
    // It invokes the ordinary_two function, and captures
    // the resulting value in the named value 'two'.
    [[stage(compute)]] fn main() {
       let six: i32 = add_two(4, 5.0);
    }
  </xmp>
</div>

## Function Calls ## {#function-calls}

A <dfn noexport>function call</dfn> is a statement or expression which invokes a function.

The function containing the function call is the <dfn>calling function</dfn>, or <dfn noexport>caller</dfn>.
The function being invoked is the <dfn>called function</dfn>, or <dfn noexport>callee</dfn>.

The function call:
* Names the [=called function=], and
* Provides a parenthesized, comma-separated list of argument value expressions.

The function call must supply the same number of argument values as there are
[=formal parameter|formal parameters=] in the [=called function=].
Each argument value must evaluate to the same type as the corresponding formal
parameter, by position.

In summary, when calling a function:
1. Execution of the [=calling function=] is suspended.
2. The [=called function=] executes until it [=returns=].
3. Execution of the [=calling function=] resumes.

A called function <dfn>returns</dfn> as follows:
* A [=built-in function=] returns when its work has completed.
* A [=user-defined function=] with a [=return type=] returns when it executes a [=statement/return=] statement.
* A [=user-defined function=] with no [=return type=] returns when it executes a [=statement/return=] statement,
    or when execution reaches the end of its [=function body=].

In detail, when a function call is executed the following steps occur:
1. Function call argument values are evaluated.
    The relative order of evaluation is not specified.
2. Execution of the [=calling function=] is suspended.
    All [=function scope=] variables and constants maintain their current values.
3. If the called function is [=user-defined function|user-defined=],
    storage is allocated for each function scope variable in the called function.
    * Initialization occurs as described in [[#var-and-let]].
4. Values for the formal parameters of the called function are determined
    by matching the function call argument values by position.
    For example, in the body of the called function the first formal parameter will denote
    the value of the first argument at the [=call site=].
5. If the called function is [=user-defined function|user-defined=],
    control is transferred to the first statement in its [=function body|body=].
6. The called function is executed, until it [=returns=].
7. Control is transferred back to the calling function, and the called function's execution is
    unsuspended.
    If the called function [=return value|returns a value=], that value is supplied for the
    value of the function call expression.

Note: The current function will not resume execution if the called function or
any descendent called function executes a [=statement/discard=] statement.

The location of a function call is referred to as a <dfn noexport>call site</dfn>.
Call sites are a [=dynamic context=].
As such, the same textual location may represent multiple call sites.

## Restrictions on functions ## {#function-restriction}

* Recursion is not permitted.
    That is, there must be no cycles in the call graph.
* A [=vertex=] shader must return the `position` [=built-in output variable|built-in variable=].
    See [[#builtin-variables]].
* An entry point must never be the target of a [=function call=].
* If a function has a return type, it must be a [=constructible=] type.
* A [=formal parameter|function parameter=] must one the following types:
    * a constructible type
    * a pointer type
    * a texture type
    * a sampler type
* Each function call argument must evaluate to the type of the corresponding
    function parameter.
    * In particular, an argument that is a pointer must agree with the formal parameter
        on storage class, pointee type, and access mode.
* For [=user-defined functions=], a parameter of pointer type must be in one of
    the following storage classes:
    * [=storage classes/function=]
    * [=storage classes/private=]
    * [=storage classes/workgroup=]
* For [=built-in functions=], a parameter of pointer type must be in one of
    the following storage classes:
    * [=storage classes/function=]
    * [=storage classes/private=]
    * [=storage classes/workgroup=]
    * [=storage classes/storage=]
* Each argument of pointer type to a [=user-defined function=] must be one of:
    * An [[#address-of-expr|address-of expression]] of a
        [[#var-identifier-expr|variable identifier expression]]
    * A function parameter
* [SHORTNAME] assumes no aliasing is present between any combination of
    function parameters and variables.
    As such, a function parameter of pointer type must not be used to read or
    write to any [=memory locations=] of its [=originating variable=] that are
    also written via:
    * Another function parameter in the same function
    * A statement or expression in the function using the originating variable directly

Note: The aliasing restriction applies to memory location written by function
calls in the function.

Issue: Revisit aliasing rules for clarity.

# Entry Points TODO # {#entry-points}

## Shader Stages ## {#shader-stages-sec}

WebGPU issues work to the GPU in the form of [=draw command|draw=] or [=dispatch commands=].
These commands execute a pipeline in the context of a set of
[=pipeline input|inputs=], [=pipeline output|outputs=], and attached [=resources=].

A <dfn noexport>pipeline</dfn> describes the behaviour to be performed on the GPU, as a sequence
of stages, some of which are programmable.
In WebGPU, a pipeline is created before scheduling a draw or dispatch command for execution.
There are two kinds of pipelines: GPUComputePipeline, and GPURenderPipeline.

A [=dispatch command=] uses a <dfn noexport>GPUComputePipeline</dfn> to run a
<dfn noexport>compute shader stage</dfn> over a logical
grid of points with a controllable amount of parallelism,
while reading and possibly updating buffer and image resources.

A [=draw command=] uses a <dfn noexport>GPURenderPipeline</dfn> to run a multi-stage process with
two programmable stages among other fixed-function stages:

* A <dfn noexport>vertex shader stage</dfn> maps input attributes for a single vertex into
    output attributes for the vertex.
* Fixed-function stages map vertices into graphic primitives (such as triangles)
    which are then rasterized to produce fragments.
* A <dfn noexport>fragment shader stage</dfn> processes each fragment,
    possibly producing a fragment output.
* Fixed-function stages consume a fragment output, possibly updating external state
    such as color attachments and depth and stencil buffers.

The WebGPU specification describes pipelines in greater detail.

[SHORTNAME] defines three <dfn noexport>shader stages</dfn>, corresponding to the
programmable parts of pipelines:

* <dfn noexport>compute</dfn>
* <dfn noexport>vertex</dfn>
* <dfn noexport>fragment</dfn>

Each shader stage has its own set of features and constraints, described elsewhere.

## Entry point declaration ## {#entry-point-decl}

An <dfn noexport>entry point</dfn> is a [=user-defined function=] that is invoked to perform
the work for a particular [=shader stage=].

Specify a `stage` attribute on a [=function declaration=] to declare that function
as an entry point.

When configuring the stage in the pipeline, the entry point is specified by providing
the [SHORTNAME] module and the entry point's function name.

The parameters of an entry point have to be within [=Entry point IO type=]s.
The return type of an entry point has to be of an [=Entry point IO type=], if specified.

Note: compute entry points never have a return type.

<div class='example wgsl global-scope' heading='Entry Point'>
  <xmp>
    [[stage(vertex)]]
    fn vert_main() -> [[builtin(position)]] vec4<f32> {
      return vec4<f32>(0.0, 0.0, 0.0, 1.0);
    }
       // OpEntryPoint Vertex %vert_main "vert_main" %return_value
       // OpDecorate %return_value BuiltIn Position
       // %float = OpTypeFloat 32
       // %v4float = OpTypeVector %float 4
       // %ptr = OpTypePointer Output %v4float
       // %return_value = OpVariable %ptr Output

    [[stage(fragment)]]
    fn frag_main([[builtin(position)]] coord_in: vec4<f32>) -> [[location(0)]] vec4<f32> {
      return vec4<f32>(coord_in.x, coord_in.y, 0.0, 1.0);
    }
       // OpEntryPoint Fragment %frag_main "frag_main" %return_value %coord_in
       // OpDecorate %return_value Location 0
       // %float = OpTypeFloat 32
       // %v4float = OpTypeVector %float 4
       // %ptr = OpTypePointer Output %v4float
       // %return_value = OpVariable %ptr Output

    [[stage(compute)]]
    fn comp_main() { }
       // OpEntryPoint GLCompute %comp_main "comp_main"
  </xmp>
</div>

The set of <dfn noexport>functions in a shader stage</dfn> is the union of:

* The entry point function for the stage.
* The targets of function calls from within the body of a function
    in the shader stage, whether or not that call is executed.

The union is applied repeatedly until it stabilizes.
It will stabilize in a finite number of steps.

### Function attributes for entry points ### {#entry-point-attributes}

[SHORTNAME] defines the following attributes that can be applied to entry point declarations:
 * [=attribute/stage=]
 * [=attribute/workgroup_size=]

ISSUE: Can we query upper bounds on workgroup size dimensions?  Is it independent of the shader, or
  a property to be queried after creating the shader module?

<div class='example wgsl global-scope' heading='workgroup_size Attribute'>
  <xmp>
    [[ stage(compute), workgroup_size(8,4,1) ]]
    fn sorter() { }
       // OpEntryPoint GLCompute %sorter "sorter"
       // OpExecutionMode %sorter LocalSize 8 4 1

    [[ stage(compute), workgroup_size(8u) ]]
    fn reverser() { }
       // OpEntryPoint GLCompute %reverser "reverser"
       // OpExecutionMode %reverser LocalSize 8 1 1

    // Using an pipeline-overridable constant.
    [[override(42)]] let block_width = 12u;
    [[ stage(compute), workgroup_size(block_width) ]]
    fn shuffler() { }
       // The SPIR-V translation uses a WorkgroupSize-decorated constant,
       // where the first component is an OpSpecConstant decorated with
       // SpecID 42, and with default value 12, and second and third components
       // use defaulted values of 1.

    // Error: workgroup_size must be specified on compute shader
    [[ stage(compute) ]]
    fn bad_shader() { }
  </xmp>
</div>

## Shader Interface ## {#shader-interface}

The shader interface is the set of objects
through which the shader accesses data external to the [=shader stage=],
either for reading or writing.
The interface includes:

* Pipeline inputs and outputs
* Buffer resources
* Texture resources
* Sampler resources

These objects are represented by module-scope variables in certain [=storage classes=].

We say a variable is <dfn noexport>statically accessed</dfn> by a function if any subexpression
in the body of the function uses the variable's [=identifier=],
and that subexpression is [=in scope=] of the variable's declaration.
Static access of a `let`-declared constant is defined similarly.
Note that being statically accessed is independent of whether an execution of the shader
will actually evaluate the subexpression, or even execute the enclosing statement.

More precisely, the <dfn noexport>interface of a shader stage</dfn> consists of:
  - all parameters of the entry point
  - the result value of the entry point
  - all [=module scope=] variables that are [=statically accessed=] by [=functions in a shader stage|functions in the shader stage=],
    and which are in storage classes [=storage classes/uniform=], [=storage classes/storage=], or [=storage classes/handle=].

### Pipeline Input and Output Interface ### {#pipeline-inputs-outputs}

The <dfn dfn>Entry point IO type</dfn>s include the following:
  - Built-in variables. See [[#builtin-inputs-outputs]].
  - User-defined IO. See [[#user-defined-inputs-outputs]]
  - Structures containing only built-in variables and user-defined IO.
    The structure must not contain a nested structure.

A <dfn noexport>pipeline input</dfn> is data provided to the shader stage from upstream in the pipeline.
A pipeline input is denoted by the arguments of the entry point.

A <dfn noexport>pipeline output</dfn> is data the shader provides for further processing downstream in the pipeline.
A pipeline output is denoted by the return type of the entry point.

Each pipeline input or output is one of:

* A built-in variable. See [[#builtin-inputs-outputs]].
* A user-defined value. See [[#user-defined-inputs-outputs]].

#### Built-in Inputs and Outputs #### {#builtin-inputs-outputs}

A <dfn noexport>built-in input variable</dfn> provides access to system-generated control information.
The set of built-in inputs are listed in [[#builtin-variables]].

To declare a variable for accessing a particular input built-in *X* from an entry point:

* Declare a parameter of the entry point function,
    where the [=store type=] is the listed store type for *X*.
* Apply a `builtin(`*X*`)` attribute to the parameter.

A <dfn noexport>built-in output variable</dfn> is used by the shader to convey
control information to later processing steps in the pipeline.
The set of built-in outputs are listed in [[#builtin-variables]].

To declare a variable for accessing a particular output built-in *Y* from an entry point:

* Add a variable to the result of the entry point, where [=store type=] is the listed store type for *Y*:
  * If there is no result type for the entry point, change it to the variable type.
  * Otherwise, make the result type to be a structure, where one of the fields is the new variable.
* Apply a `builtin(`*Y*`)` attribute to the result variable.

Both input and output built-in variables may also be declared as members of
structures that are either entry point function parameters (for inputs) or the
return type of an entry point (for outputs).
The type of the structure member must match the type specified for the built-in variable.

The `builtin` attribute must not be applied to a variables in [=module scope=],
or the local variables in the function scope.

A variable must not have more than one `builtin` attribute.

Each built-in variable has an associated shader stage, as described in [[#builtin-variables]].
If a built-in variable has stage *S* and is used by a function *F*, as either an argument or the
result type, then *F* must be a [=functions in a shader stage|function in a shader=] for stage *S*.

Issue: in Vulkan, builtin variables occoupy I/O location slots counting toward limits.

#### User-defined Inputs and Outputs #### {#user-defined-inputs-outputs}

User-defined data can be passed as input to the start of a pipeline, passed
between stages of a pipeline or output from the end of a pipeline.
User-defined IO must not be passed to [=compute=] shader entry points.
User-defined IO must be of [=numeric scalar=] or [=numeric vector=] type,
or of a structure type whose members are numeric scalars or vectors.
All user-defined IO must be assigned locations (See [[#input-output-locations]]).

#### Interpolation #### {#interpolation}

Authors can control how user-defined IO data is interpolated through the use of
the [=attribute/interpolate=] attribute.
[SHORTNAME] offers two aspects of interpolation to control: the type of
interpolation, and the sampling of the interpolation.

The <dfn noexport>interpolation type</dfn> must be one of:
* `perspective` - Values are interpolated in a perspective correct manner.
* `linear` - Values are interpolated in a linear, non-perspective correct manner.
* `flat` - Values are not interpolated.
    Interpolation sampling is not used with `flat` interpolation.

The <dfn noexport>interpolation sampling</dfn> must be one of:
* `center` - Interpolation is performed at the center of the pixel.
* `centroid` - Interpolation is performed at a point that lies within all the
    samples covered by the fragment within the current primitive.
    This value is the same for all samples in the primitive.
* `sample` - Interpolation is performed per sample.
    The [=fragment=] shader is invoked once per sample when this attribute is
    applied.

For user-defined IO of scalar or vector floating-point type:
* If the interpolation attribute is not specified, then `[[interpolate(perspective, center)]]` is assumed.
* If the interpolation attribute is specified with an interpolation type:
    * If the interpolation type is `flat`, then interpolation sampling must not be specified.
    * If the interpolation type is `perspective` or `linear`, then:
         * Any interpolation sampling is valid.
         * If interpolation sampling is not specified, `center` is assumed.

User-defined IO of scalar or vector integer type must always be specified as
`[[interpolate(flat)]]`.

Interpolation attributes must match between [=vertex=] outputs and [=fragment=]
inputs with the same [=attribute/location=] assignment within the same [=pipeline=].

#### Input-output Locations #### {#input-output-locations}

Each location can store a value up to 16 bytes in size.
The byte size of a type is defined using the *SizeOf* column in [[#alignment-and-size]].
For example, a four-element vector of floating-point values occupies a single location.

Locations are specified via the [=attribute/location=] attribute.

Every user-defined input and output must have a fully specified set of
locations.
Each structure member in the entry point IO must be one of either a builtin variable
(see [[#builtin-inputs-outputs]]), or assigned a location.

Locations must not overlap within each of the following sets:
* Members within a structure type.
    This applies to any structure, not just those used in pipeline inputs or outputs.
* An entry point's pipeline inputs,
    i.e. locations for its formal parameters, or for the members of its formal parameters of structure type.

Note: Location numbering is distinct between inputs and outputs:
Location numbers for an entry point's pipeline inputs do not conflict with location numbers for the entry point's pipeline outputs.

Note: No additional rule is required to prevent location overlap within an entry point's outputs.
When the outptut is a structure, the first rule above prevents overlap.
Otherwise, the output is a scalar or a vector, and can have only a single location assigned to it.

Note: The number of available locations for an entry point is defined by the WebGPU API.

<div class='example applying location attribute' heading='Applying location attributes'>
  <xmp>
    struct A {
      [[location(0)]] x: f32;
      // Despite locations being 16-bytes, x and y cannot share a location
      [[location(1)]] y: f32;
    };

    // in1 occupies locations 0 and 1.
    // in2 occupies location 2.
    // The return value occupies location 0.
    [[stage(fragment)]]
    fn fragShader(in1: A, [[location(2)]] in2: f32) -> [[location(0)]] vec4<f32> {
     // ...
    }
  </xmp>
</div>

User-defined IO can be mixed with builtin variables in the same structure. For example,

<div class='example mixing builtins and user-defined IO' heading='Mixing builtins and user-defined IO'>
  <xmp>
    // Mixed builtins and user-defined inputs.
    struct MyInputs {
      [[location(0)]] x: vec4<f32>;
      [[builtin(front_facing)]] y: bool;
      [[location(1),interpolate(flat)]] z: u32;
    };

    struct MyOutputs {
      [[builtin(frag_depth)]] x: f32;
      [[location(0)]] y: vec4<f32>;
    };

    [[stage(fragment)]]
    fn fragShader(in1: MyInputs) -> MyOutputs {
      // ...
    }
  </xmp>
</div>

<div class='example invalid locations' heading='Invalid location assignments'>
  <xmp>
    struct A {
      [[location(0)]] x: f32;
      // Invalid, x and y cannot share a location.
      [[location(0)]] y: f32;
    };

    struct B {
      [location(0)]] x: f32;
    };

    struct C {
      // Invalid, structures with user-defined IO cannot be nested.
      b: B;
    };

    struct D {
      x: vec4<f32>;
    };

    [[stage(fragment)]]
    // Invalid, location cannot be applied to a structure type.
    fn fragShader1([[location(0)]] in1: D) {
      // ...
    }

    [[stage(fragment)]]
    // Invalid, in1 and in2 cannot share a location.
    fn fragShader2([location(0)]] in1: f32, [[location(0)]] in2: f32) {
      // ...
    }

    [[stage(fragment)]]
    // Invalid, location cannot be applied to a structure.
    fn fragShader3([[location(0)]] in1: vec4<f32>) -> [[location(0)]] D {
      // ...
    }
  </xmp>
</div>

### Resource interface ### {#resource-interface}

A <dfn noexport>resource</dfn> is an object,
other than a [[#pipeline-inputs-outputs|pipeline input or output]],
which provides access to data external to a [=shader stage=].
Resources are shared by all invocations of the shader.

There are four kinds of resources:

* [=uniform buffers=]
* [=storage buffers=]
* textures
* samplers

The <dfn noexport>resource interface of a shader</dfn> is the set of module-scope
resource variables [=statically accessed=] by
[=functions in a shader stage|functions in the shader stage=].

Each resource variable must be declared with both [=attribute/group=] and [=attribute/binding=]
attributes.
Together with the shader's stage, these identify the binding address
of the resource on the shader's pipeline.
See [[WebGPU#pipeline-layout|WebGPU &sect; GPUPipelineLayout]].

Bindings must not alias within a shader stage:
two different variables in the resource interface of a given
shader must not have the same group and binding values, when considered as a pair of values.

### Resource layout compatibility ### {#resource-layout-compatibility}

WebGPU requires that a shader's resource interface match the [[WebGPU#pipeline-layout|layout of the pipeline]]
using the shader.

Each [SHORTNAME] variable in a resource interface must be bound to a WebGPU resource with
a compatible
[[WebGPU#binding-resource-type|resource type]] and
[[WebGPU#binding-type|binding type]],
where compatibility is defined by the following table.
<table class='data'>
  <caption>WebGPU binding type compatibility</caption>
  <thead>
    <tr><th>[SHORTNAME] resource
        <th>WebGPU<br>[[WebGPU#binding-resource-type|Resource type]]
        <th colspan=2>WebGPU [[WebGPU#binding-type|Binding type]]
  </thead>
  <tr><td>[=uniform buffer=]
      <td rowspan=3>[[WebGPU#dictdef-gpubufferbinding|GPUBufferBinding]]
      <td rowspan=3>GPUBufferBindingType
      <td>[[WebGPU#dom-gpubufferbindingtype-uniform|uniform]]
  <tr><td>[=storage buffer=] with [=access/read_write=] access
      <td>[[WebGPU#dom-gpubufferbindingtype-storage|storage]]
  <tr><td>[=storage buffer=] with [=access/read=] access
      <td>[[WebGPU#dom-gpubufferbindingtype-read-only-storage|read-only-storage]]
  <tr><td rowspan=2>sampler
      <td rowspan=3>[[WebGPU#gpusampler|GPUSampler]]
      <td rowspan=3>GPUSamplerBindingType
      <td>[[WebGPU#dom-gpusamplerbindingtype-filtering|filtering]]
  <tr>
      <td>[[WebGPU#dom-gpusamplerbindingtype-non-filtering|non-filtering]]
  <tr><td>sampler_comparison
      <td>[[WebGPU#dom-gpusamplerbindingtype-comparison|comparison]]
  <tr><td rowspan=5>sampled texture
      <td rowspan=5>[[WebGPU#gputextureview|GPUTextureView]]
      <td rowspan=5>GPUTextureSampleType
      <td>[[WebGPU#dom-gputexturesampletype-float|float]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-unfilterable-float|unfilterable-float]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-sint|sint]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-uint|uint]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-depth|depth]]
  <tr><td>[=write-only storage texture=]
      <td>[[WebGPU#gputextureview|GPUTextureView]]
      <td>GPUStorageTextureAccess
      <td>[[WebGPU#dom-gpustoragetextureaccess-write-only|write-only]]
</table>

TODO: Describe when filtering or non-filtering samplers are valid.

TODO: Describe when float vs. unfilterable float sampled textures are valid.

If |B| is a [=uniform buffer=] variable in a resource interface,
and |WB| is the [[WebGPU#buffer-interface|WebGPU GPUBuffer]] bound to |B|, then:
* The size of |WB| must be at least as large as the size of the [=store type=]
    of |B| in the [=storage classes/storage=] storage class.

If |B| is a [=storage buffer=] variable in a resource interface,
and |WB| is the [[WebGPU#buffer-interface|WebGPU GPUBuffer]] bound to |B|, then:
* If the [=store type=] |S| of |B| does not contain a [=runtime-sized=] array, then
    the size of |WB| must be at least as large as the size
    of |S| in the [=storage classes/storage=] storage class.
* If the [=store type=] |S| of |B| contains a [=runtime-sized=] array as its last member,
    then:
    * The runtime-determined array length of that member must be at least 1.
    * The size of |WB| must be at least as large as the size in
        storage class [=storage classes/storage=] of the value stored in |B|.

Note: Recall that a [=runtime-sized=] array may only appear as the last element in the structure
type that is the store type of a storage buffer variable.

TODO: Describe other interface matching requirements, e.g. for images?

# Language extensions # {#language-extensions}

The [SHORTNAME] language is expected to evolve over time.

An <dfn noexport>extension</dfn> is a named grouping for a coherent
set of modifications to a particular version of the [SHORTNAME] specification, consisting of any combination of:
* Addition of new concepts and behaviours via new syntax, including:
    * declarations, statements, attributes, and built-in functions.
* Removal of restrictions in the current specification or in previously published extensions.
* Syntax for reducing the set of permissible behaviours.
* Syntax for limiting the features available to a part of the program.
* A description of how the extension interacts with the existing specification, and optionally with other extensions.

Hypothetically, extensions could be used to:
* Add numeric scalar types, such as 16-bit integers.
* Add syntax to constrain floating point rounding mode.
* Add syntax to signal that a shader does not use atomic types.
* Add new kinds of statements.
* Add new built-in functions.
* Add constraints on how shader invocations execute.
* Add new shader stages.

## Enable Directive ## {#enable-directive-section}

An <dfn noexport>enable directive</dfn> indicates that the functionality
described by a particular named
[=extension=] may be used in the source text after the directive itself.
That is, language functionality described by the extension may be used in any
source text after the `enable` directive.

The directive must not appear inside the text of any [=declaration=].
(If it were a declaration, it would be at [=module scope=].)

The directive uses an [=identifier=] to name the extension, but does not
create a [=scope=] for the identifier.
Use of the identifier by the directive does not conflict with the
use of that identifier as the name in any [=declaration=].

<div class='syntax' noexport='true'>
  <dfn for=syntax>enable_directive</dfn> :

    | [=syntax/enable=] [=syntax/ident=] [=syntax/semicolon=]
</div>

Note: The grammar rule includes the terminating semicolon token,
ensuring the additional functionality is usable only after that semicolon.
Therefore any [SHORTNAME] implementation can parse the entire `enable` directive.
When an implementation encounters an enable directive for an unsupported extension,
the implementation can issue a clear diagnostic.

<div class='example using extensions' heading="Using hypothetical extensions">
  <xmp>
    // Enable a hypothetical IEEE-754 binary16 floating point extension.
    enable f16;

    // Assuming the f16 extension enables use of the f16 type:
    //    - as function return value
    //    - as the type for let declaration
    //    - as a type constructor, with an i32 argument
    //    - as operands to the division operator: /
    fn halve_it(x: f16) -> f16 {
       let two: f16 = f16(2);
       return x / two;
    };

    enable f16; // A redundant enable directive is ok.
    // Enable a hypothetical extension adding syntax for controlling
    // the rounding mode on f16 arithmetic.
    enable rounding_mode_f16;

    [[round_to_even_f16]] // Attribute enabled by the rounding_mode_f16 extension
    fn triple_it(x: f16) -> f16 {
       return x * f16(3); // Uses round-to-even.
    };
  </xmp>
</div>


# WGSL program TODO # {#wgsl-module}

TODO: *Stub* A WGSL program is a sequence of [=directives=] and [=module scope=] [=declarations=].

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_decl_or_directive</dfn> :

    | [=syntax/semicolon=]

    | [=syntax/global_variable_decl=] [=syntax/semicolon=]

    | [=syntax/global_constant_decl=] [=syntax/semicolon=]

    | [=syntax/type_alias=] [=syntax/semicolon=]

    | [=syntax/struct_decl=] [=syntax/semicolon=]

    | [=syntax/function_decl=]

    | [=syntax/enable_directive=]
</div>

# Execution TODO # {#execution}

## Invocation of an entry point TODO ## {#invocation-of-an-entry-point}

### Before an entry point begins TODO ### {#before-entry-point-begins}

TODO: *Stub*

* Setting values of builtin variables
* External-interface variables have initialized backing storage
* Internal module-scope variables have backing storage
  * Initializers evaluated in textual order

### Program order (within an invocation) TODO ### {#program-order}

#### Function-scope variable lifetime and initialization TODO #### {#function-scope-variable-lifetime}

#### Statement order TODO #### {#statement-order}

#### Intra-statement order (or lack) TODO #### {#intra-statement-order}

TODO: *Stub*: Expression evaluation

## Uniformity TODO ## {#uniformity}

### Uniform control flow TODO ### {#uniform-control-flow}

### Divergence and reconvergence TODO ### {#divergence-reconvergence}

### Uniformity restrictions TODO ### {#uniformity-restrictions}

## Compute Shaders and Workgroups ## {#compute-shader-workgroups}

A <dfn noexport for="compute shader stage">workgroup</dfn> is a set of invocations which
concurrently execute a [=compute shader stage=] [=entry point=],
and share access to shader variables in the [=storage classes/workgroup=] storage class.

The <dfn noexport>workgroup grid</dfn> for a compute shader is the set of points
with integer coordinates *(i,j,k)* with:

*  0 &leq; i &lt; workgroup_size_x
*  0 &leq; j &lt; workgroup_size_y
*  0 &leq; k &lt; workgroup_size_z

where *(workgroup_size_x, workgroup_size_y, workgroup_size_z)* is
the value specified for the [=attribute/workgroup_size=] attribute of the
entry point.

There is exactly one invocation in a workgroup for each point in the workgroup grid.

An invocation's <dfn noexport>local invocation ID</dfn> is the coordinate
triple for the invocation's corresponding workgroup grid point.

When an invocation has [=local invocation ID=] (i,j,k), then its
<dfn noexport>local invocation index</dfn> is

  i +
  (j * workgroup_size_x) +
  (k * workgroup_size_x * workgroup_size_y)

<p algorithm="local index range">Note that if a workgroup has |W| invocations,
then each invocation |I| the workgroup has a unique local invocation index |L|(|I|)
such that 0 &le; |L|(|I|) &lt; |W|,
and that entire range is covered.</p>

A compute shader begins execution when a WebGPU implementation
removes a dispatch command from a queue and begins the specified work on the GPU.
The dispatch command specifies a <dfn noexport>dispatch size</dfn>,
which is an integer triple *(group_count_x, group_count_y, group_count_z)*
indicating the number of workgroups to be executed, as described in the following.

The <dfn noexport>compute shader grid</dfn> for a particular dispatch
is the set of points with integer coordinates *(CSi,CSj,CSk)* with:

*  0 &leq; CSi &lt; workgroup_size_x &times; group_count_x
*  0 &leq; CSj &lt; workgroup_size_y &times; group_count_y
*  0 &leq; CSk &lt; workgroup_size_z &times; group_count_z

where *workgroup_size_x*,
*workgroup_size_y*, and
*workgroup_size_z* are as above for the compute shader entry point.

The work to be performed by a compute shader dispatch is to execute exactly one
invocation of the entry point for each point in the compute shader grid.

An invocation's <dfn noexport>global invocation ID</dfn> is the coordinate
triple for the invocation's corresponding compute shader grid point.

The invocations are organized into workgroups, so that each invocation
*(CSi, CSj, CSk)* is identified with the workgroup grid point

   ( *CSi* mod workgroup_size_x ,
     *CSj* mod workgroup_size_y ,
     *CSk* mod workgroup_size_z )

in <dfn noexport>workgroup ID</dfn>

   ( &lfloor; *CSi* &div; workgroup_size_x &rfloor;,
     &lfloor; *CSj* &div; workgroup_size_y &rfloor;,
     &lfloor; *CSk* &div; workgroup_size_z &rfloor;).

WebGPU provides no guarantees about:

* Whether invocations from different workgroups execute concurrently.
    That is, you cannot assume more than one workgroup executes at a time.
* Whether, once invocations from a workgroup begin executing, that other workgroups
    are blocked from execution.
    That is, you cannot assume that only one workgroup executes at a time.
    While a workgroup is executing, the implementation may choose to
    concurrently execute other workgroups as well, or other queued but unblocked work.
* Whether invocations from one particular workgroup begin executing before
    the invocations of another workgroup.
    That is, you cannot assume that workgroups are launched in a particular order.

Issue: [WebGPU issue 1045](https://github.com/gpuweb/gpuweb/issues/1045):
Dispatch group counts must be positive.
However, how do we handle an indirect dispatch that specifies a group count of zero.

## Collective operations TODO ## {#collective-operations}

### Barrier TODO ### {#barrier}

### Derivatives ### {#derivatives}

A <dfn noexport>partial derivative</dfn> is the rate of change of a value along an axis.

Fragment shader invocations operating on neighbouring fragments (in screen-space coordinates)
collaborate to compute approximate partial derivatives.

Partial derivatives of the *fragment coordinate* are computed implicitly as part
of operation of the following built-in functions:
* [[#texturesample|textureSample]],
* [[#texturesamplebias|textureSampleBias]], and
* [[#texturesamplecompare|textureSampleCompare]].

For these, the derivatives help determine the mip levels of texels to be sampled, or in the case of
`textureSampleCompare`, sampled and compared against a reference value.

Partial derivatives of *invocation-specified* values are computed by the
built-in functions described in [[#derivative-builtin-functions]]:
* dpdx, dpdxCoarse, and dpdxFine compute partial derivatives along the x axis.
* dpdy, dpdyCoarse, and dpdyFine compute partial derivatives along the y axis.
* fwidth, fwidthCoarse, and fwidthFine compute the Manhattan metric over the associated x and y partial derivatives.

Because neighbouring invocations must collaborate to compute derivatives,
these functions must only be invoked in uniform control flow in a fragment shader.

### Arrayed resource access TODO ### {#arrayed-resource-access}

## Floating Point Evaluation ## {#floating-point-evaluation}

[SHORTNAME] follows the [[!IEEE-754|IEEE-754]] standard for floating point computation with
the following exceptions:
* No floating point exceptions are generated.
* Signaling NaNs may not be generated.
    Any signaling NaN may be converted to a quiet NaN.
* Implementations may assume that NaNs, inifinities are not present
    * Note: This means some functions (e.g. `isInf`, `isNan`, `min` and `max`)
        may not return the expected result due to optimizations about the presence
        of NaNs and infinities.
* Implementations may ignore the sign of a zero.
    That is, a zero with a positive sign may behave like a zero a with a negative sign, and vice versa.
* No rounding mode is specified.
* Implementations may flush denormalized value on the input and/or output of
    any operation listed in [[#floating-point-accuracy]].
    * Other operations are required to preserve denormalized numbers.
* The accuracy of operations is given in [[#floating-point-accuracy]].

### Floating Point Accuracy ### {#floating-point-accuracy}

<div algorithm="correctly rounded">
Let |x| be the exact real-valued or infinite result of an operation when computed with unbounded precision.
The <dfn>correctly rounded</dfn> result of the operation for floating point type |T| is:
* |x|, when |x| is in |T|,
* Otherwise:
    * the smallest value in |T| greater than |x|, or
    * the largest value in |T| less than |x|.

</div>

That is, the result may be rounded up or down:
[SHORTNAME] does not specify a rounding mode.

Note: Floating point types include positive and negative infinity, so
the correctly rounded result may be finite or infinite.

The units in the last place, <dfn noexport>ULP</dfn>, for a floating point
number `x` is the minimum distance between two non-equal floating point numbers
`a` and `b` such that `a` &le; `x` &le; `b` (i.e. `ulp(x) =
min`<sub>`a,b`</sub>`|b - a|`).

In the following tables, the accuracy of an operation is provided among five
possibilities:
* Correct result (for non-floating point return values)
* [=Correctly rounded=]
* A relative error bound expressed as [=ULP=]
* A function that the accuracy is <dfn noexport>inherited from</dfn>.
    That is, the accuracy is equal to implementing the operation in terms of the derived function.
* An absolute error bound

For any accuracy values specified over a range, the accuracy is undefined for
results outside that range.

If an allowable return value for any operation is greater in magnitude than the
largest representable finite floating-point value, then that operation may additionally
return either the infinity with the same sign or the largest finite
value with the same sign.

<table class='data'>
  <caption>Accuracy of expressions</caption>
  <thead>
    <tr><th>Expression<th>Accuracy<th>
  </thead>

  <tr><td>`x + y`<td>Correctly rounded
  <tr><td>`x - y`<td>Correctly rounded
  <tr><td>`x * y`<td>Correctly rounded
  <tr><td>`x / y`<td>2.5 ULP for `|y|` in the range [2<sup>-126</sup>, 2<sup>126</sup>]
  <tr><td>`x % y`<td>Derived from `x - y * trunc(x/y)`
  <tr><td>`-x`<td>Correctly rounded

  <tr><td>`x == y`<td>Correct result
  <tr><td>`x != y`<td>Correct result
  <tr><td>`x < y`<td>Correct result
  <tr><td>`x <= y`<td>Correct result
  <tr><td>`x > y`<td>Correct result
  <tr><td>`x >= y`<td>Correct result
</table>

<table class='data'>
  <caption>Accuracy of built-in functions</caption>
  <thead>
    <tr><th>Built-in Function<th>Accuracy
  </thead>

  <tr><td>`abs(x)`<td>Correctly rounded
  <tr><td>`acos(x)`<td>Inherited from `atan2(sqrt(1.0 - x * x), x)`
  <tr><td>`asin(x)`<td>Inherited from `atan2(x, sqrt(1.0 - x * x))`
  <tr><td>`atan(x)`<td>4096 ULP
  <tr><td>`atan2(y, x)`<td>4096 ULP
  <tr><td>`ceil(x)`<td>Correctly rounded
  <tr><td>`clamp(x)`<td>Correctly rounded
  <tr><td>`cos(x)`<td>Absolute error &le; 2<sup>-11</sup> inside the range of [-&pi;, &pi;]
  <tr><td>`cosh(x)`<td>Inherited from `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`cross(x, y)`<td>Inherited from `(x[i] * y[j] - x[j] * y[i])`
  <tr><td>`distance(x, y)`<td>Inherited from `length(x - y)`
  <tr><td>`exp(x)`<td>3 + 2 * |x| ULP
  <tr><td>`exp2(x)`<td>3 + 2 * |x| ULP
  <tr><td class="nowrap">`faceForward(x, y, z)`<td>Inherited from `select(-x, x, dot(z, y) < 0.0)`
  <tr><td>`floor(x)`<td>Correctly rounded
  <tr><td>`fma(x, y, z)`<td>Inherited from `x * y + z`
  <tr><td>`fract(x)`<td>Correctly rounded
  <tr><td>`frexp(x)`<td>Correctly rounded
  <tr><td>`inverseSqrt(x)`<td>2 ULP
  <tr><td>`ldexp(x, y)`<td>Correctly rounded
  <tr><td>`length(x)`<td>Inherited from `sqrt(dot(x, x))`
  <tr><td>`log(x)`<td>3 ULP outside the range [0.5, 2.0].<br>Absolute error &lt; 2<sup>-21</sup> inside the range [0.5, 2.0]
  <tr><td>`log2(x)`<td>3 ULP outside the range [0.5, 2.0].<br>Absolute error &lt; 2<sup>-21</sup> inside the range [0.5, 2.0]
  <tr><td>`max(x, y)`<td>Correctly rounded
  <tr><td>`min(x, y)`<td>Correctly rounded
  <tr><td>`mix(x, y, z)`<td>Inherited from `x * (1.0 - z) + y * z`
  <tr><td>`modf(x)`<td>Correctly rounded
  <tr><td>`normalize(x)`<td>Inherited from `x / length(x)`
  <tr><td>`pow(x, y)`<td>Inherited from `exp2(y * log2(x))`
  <tr><td>`reflect(x, y)`<td>Inherited from `x - 2.0 * dot(x, y) * y`
  <tr><td>`refract(x, y, z)`<td>Inherited from `z * x - (z * dot(y, x) + sqrt(k)) * y`,<br>where `k = 1.0 - z * z * (1.0 - dot(y, x) * dot(y, x))`<br>If `k < 0.0` the result is precisely 0.0
  <tr><td>`round(x)`<td>Correctly rounded
  <tr><td>`sign(x)`<td>Correctly rounded
  <tr><td>`sin(x)`<td>Absolute error &le; 2<sup>-11</sup> inside the range [-&pi;, &pi;]
  <tr><td>`sinh(x)`<td>Inherited from `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`smoothStep(x, y, z)`<td>Inherited from `t * t * (3.0 - 2.0 * t)`,<br>where `t = clamp((z - x) / (y - x), 0.0, 1.0)`
  <tr><td>`sqrt(x)`<td>Inherited from `1.0 / inverseSqrt(x)`
  <tr><td>`step(x, y)`<td>Correctly rounded
  <tr><td>`tan(x)`<td>Inherited from `sin(x) / cos(x)`
  <tr><td>`tanh(x)`<td>Inherited from `sinh(x) / cosh(x)`
  <tr><td>`trunc(x)`<td>Correctly rounded

</table>

<dfn noexport>Reassociation</dfn> is the reordering of operations in an
expression such that the answer is the same if computed exactly. For example:
* `(a + b) + c` reassociates to `a + (b + c)`
* `(a - b) + c` reassociates to `(a + c) - b`
* `(a * b) / c` reassociates to `(a / c) * b`

However, the result may not be the same when computed in floating point.
The reassociated result may be inaccurate due to approximation, or may trigger
an overflow or NaN when computing intermediate results.

An implementation may reassociate and/or fuse operations if the optimization is
at least as accurate as the original formulation.

### Floating point conversion ### {#floating-point-conversion}

In this section, a floating point type may be any of:
* The [=f32=] type in WGSL.
* A hypothetical type corresponding to a binary format defined by the [[!IEEE-754|IEEE-754]]
    floating point standard.

    Note: The binary16 format is referenced in this way.

Note: Recall that the [=f32=] WGSL type corresponds to the IEEE-754 binary32 format.

When converting a floating point scalar value to an integral type:
* If the original value is exactly representable in the destination type, then the result is that value.
* If the original value has a fractional component, then it cannot be represented exactly in the destination type, and the result is TODO
* If the original value is out of range of the destination type, then TODO.

When converting a value to a floating point type:
* If the original value is exactly representable in the destination type, then the result is that value.
    * If the original value is zero and of integral type, then the resulting value has a zero sign bit.
* Otherwise, the original value is not exactly representable.
    * If the original value is different from but lies between two adjacent values representable in the destination type,
         then the result is one of those two values.
         [SHORTNAME] does not specify whether the larger or smaller representable
         value is chosen, and different instances of such a conversion may choose differently.
    * Otherwise, if the original value lies outside the range of the destination type.
         * This does not occur when the original types is one of [=i32=] or [=u32=] and the destination type is [=f32=].
         * This does not occur when the source type is a floating point type with fewer exponent and mantissa bits.
         * If the source type is a floating point type with more mantissa bits than the destination type, then:
             * The extra mantissa bits of the source value may be discarded (treated as if they are 0).
                 * If the resulting value is the maximum normal value of the destination type, then that is the result.
             * Otherwise the result is the infinity value with the same sign as the source value.
    * Otherwise, if the original value is a NaN for the source type, then the result is a NaN in the destination type.

NOTE: An integer value may lie between two adjacent representable floating point values.
In particular, the [=f32=] type uses 23 explicit fractional bits.
Additionally, when the floating point value is in the normal range (the exponent is neither extreme value), then the mantissa is
the set of fractional bits together with an extra 1-bit at the most significant position at bit position 23.
Then, for example, integers 2<sup>28</sup> and 1+2<sup>28</sup> both map to the same floating point value: the difference in the
least significant 1 bit is not representable by the floating point format.
This kind of collision occurs for pairs of adjacent integers with a magnitude of at least 2<sup>25</sup>.

Issue: (dneto) Default rounding mode is an implementation choice.  Is that what we want?

Issue: Check behaviour of the f32 to f16 conversion for numbers just beyond the max normal f16 values.
I've written what an NVIDIA GPU does.  See https://github.com/google/amber/pull/918 for an executable test case.

# Memory Model TODO # {#memory-model}

# Keyword and Token Summary # {#grammar}

## Keyword Summary ## {#keyword-summary}

### Type-defining Keywords ### {#type-defining-keywords}

<div class='syntax' noexport='true'>
  <dfn for=syntax>array</dfn> :

    | `/array/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>atomic</dfn> :

    | `/atomic/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bool</dfn> :

    | `/bool/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>float32</dfn> :

    | `/f32/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>int32</dfn> :

    | `/i32/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat2x2</dfn> :

    | `/mat2x2/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat2x3</dfn> :

    | `/mat2x3/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat2x4</dfn> :

    | `/mat2x4/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat3x2</dfn> :

    | `/mat3x2/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat3x3</dfn> :

    | `/mat3x3/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat3x4</dfn> :

    | `/mat3x4/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat4x2</dfn> :

    | `/mat4x2/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat4x3</dfn> :

    | `/mat4x3/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat4x4</dfn> :

    | `/mat4x4/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>pointer</dfn> :

    | `/ptr/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler</dfn> :

    | `/sampler/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler_comparison</dfn> :

    | `/sampler_comparison/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct</dfn> :

    | `/struct/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_1d</dfn> :

    | `/texture_1d/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_2d</dfn> :

    | `/texture_2d/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_2d_array</dfn> :

    | `/texture_2d_array/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_3d</dfn> :

    | `/texture_3d/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_cube</dfn> :

    | `/texture_cube/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_cube_array</dfn> :

    | `/texture_cube_array/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_multisampled_2d</dfn> :

    | `/texture_multisampled_2d/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_1d</dfn> :

    | `/texture_storage_1d/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_2d</dfn> :

    | `/texture_storage_2d/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_2d_array</dfn> :

    | `/texture_storage_2d_array/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_3d</dfn> :

    | `/texture_storage_3d/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_2d</dfn> :

    | `/texture_depth_2d/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_2d_array</dfn> :

    | `/texture_depth_2d_array/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_cube</dfn> :

    | `/texture_depth_cube/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_cube_array</dfn> :

    | `/texture_depth_cube_array/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_multisampled_2d</dfn> :

    | `/texture_depth_multisampled_2d/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>uint32</dfn> :

    | `/u32/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec2</dfn> :

    | `/vec2/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec3</dfn> :

    | `/vec3/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec4</dfn> :

    | `/vec4/`
</div>

### Other Keywords ### {#other-keywords}

<div class='syntax' noexport='true'>
  <dfn for=syntax>bitcast</dfn> :

    | `/bitcast/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>block</dfn> :

    | `/block/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>break</dfn> :

    | `/break/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>case</dfn> :

    | `/case/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>continue</dfn> :

    | `/continue/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>continuing</dfn> :

    | `/continuing/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>default</dfn> :

    | `/default/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>discard</dfn> :

    | `/discard/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>else</dfn> :

    | `/else/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>else_if</dfn> :

    | `/elseif/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>enable</dfn> :

    | `/enable/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>fallthrough</dfn> :

    | `/fallthrough/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>false</dfn> :

    | `/false/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>fn</dfn> :

    | `/fn/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>for</dfn> :

    | `/for/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>function</dfn> :

    | `/function/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>if</dfn> :

    | `/if/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>let</dfn> :

    | `/let/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>loop</dfn> :

    | `/loop/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>private</dfn> :

    | `/private/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>read</dfn> :

    | `/read/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>read_write</dfn> :

    | `/read_write/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>return</dfn> :

    | `/return/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>storage</dfn> :

    | `/storage/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>switch</dfn> :

    | `/switch/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>true</dfn> :

    | `/true/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>type</dfn> :

    | `/type/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>uniform</dfn> :

    | `/uniform/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>var</dfn> :

    | `/var/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>workgroup</dfn> :

    | `/workgroup/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>write</dfn> :

    | `/write/`
</div>

Issue: Should read, write, and read_write be not completely reserved?  They are only used in specific contexts.

### Image Format Keywords ### {#image-format-keywords}

<div class='syntax' noexport='true'>
  <dfn for=syntax>r8unorm</dfn> :

    | `/r8unorm/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>r8snorm</dfn> :

    | `/r8snorm/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>r8uint</dfn> :

    | `/r8uint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>r8sint</dfn> :

    | `/r8sint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>r16uint</dfn> :

    | `/r16uint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>r16sint</dfn> :

    | `/r16sint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>r16float</dfn> :

    | `/r16float/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg8unorm</dfn> :

    | `/rg8unorm/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg8snorm</dfn> :

    | `/rg8snorm/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg8uint</dfn> :

    | `/rg8uint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg8sint</dfn> :

    | `/rg8sint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>r32uint</dfn> :

    | `/r32uint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>r32sint</dfn> :

    | `/r32sint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>r32float</dfn> :

    | `/r32float/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg16uint</dfn> :

    | `/rg16uint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg16sint</dfn> :

    | `/rg16sint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg16float</dfn> :

    | `/rg16float/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba8unorm</dfn> :

    | `/rgba8unorm/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba8unorm_srgb</dfn> :

    | `/rgba8unorm_srgb/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba8snorm</dfn> :

    | `/rgba8snorm/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba8uint</dfn> :

    | `/rgba8uint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba8sint</dfn> :

    | `/rgba8sint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bgra8unorm</dfn> :

    | `/bgra8unorm/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bgra8unorm_srgb</dfn> :

    | `/bgra8unorm_srgb/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgb10a2unorm</dfn> :

    | `/rgb10a2unorm/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg11b10float</dfn> :

    | `/rg11b10float/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg32uint</dfn> :

    | `/rg32uint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg32sint</dfn> :

    | `/rg32sint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rg32float</dfn> :

    | `/rg32float/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba16uint</dfn> :

    | `/rgba16uint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba16sint</dfn> :

    | `/rgba16sint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba16float</dfn> :

    | `/rgba16float/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba32uint</dfn> :

    | `/rgba32uint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba32sint</dfn> :

    | `/rgba32sint/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>rgba32float</dfn> :

    | `/rgba32float/`
</div>

TODO(dneto): Eliminate the image formats that are not used in storage images.
For example SRGB formats (bgra8unorm_srgb), mixed channel widths (rg11b10float), out-of-order channels (bgra8unorm)

## Reserved Words ## {#reserved-words}

A <dfn>reserved word</dfn> is a [=token=] which is reserved for future use.
A [SHORTNAME] program must not contain a reserved word.

The following are reserved words:

<div class='syntax' noexport='true'>
  <dfn for=syntax>_reserved</dfn> :

    | `/asm/`

    | `/bf16/`

    | `/const/`

    | `/do/`

    | `/enum/`

    | `/f16/`

    | `/f64/`

    | `/handle/`

    | `/i8/`

    | `/i16/`

    | `/i64/`

    | `/mat/`

    | `/premerge/`

    | `/regardless/`

    | `/typedef/`

    | `/u8/`

    | `/u16/`

    | `/u64/`

    | `/unless/`

    | `/using/`

    | `/vec/`

    | `/void/`

    | `/while/`
</div>

## Syntactic Tokens ## {#syntactic-tokens}

A <dfn>syntactic token</dfn> is a sequence of special characters, used:
* to spell an expression operator, or
* as punctuation: to group, sequence, or separate other grammar elements.

<div class='syntax' noexport='true'>
  <dfn for=syntax>and</dfn> :

    | `'&'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>and_and</dfn> :

    | `'&&'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>arrow</dfn> :

    | `'->'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>attr_left</dfn> :

    | `'[['`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>attr_right</dfn> :

    | `']]'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>forward_slash</dfn> :

    | `'/'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bang</dfn> :

    | `'!'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bracket_left</dfn> :

    | `'['`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bracket_right</dfn> :

    | `']'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>brace_left</dfn> :

    | `'{'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>brace_right</dfn> :

    | `'}'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>colon</dfn> :

    | `':'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>comma</dfn> :

    | `','`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>equal</dfn> :

    | `'='`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>equal_equal</dfn> :

    | `'=='`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>not_equal</dfn> :

    | `'!='`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>greater_than</dfn> :

    | `'>'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>greater_than_equal</dfn> :

    | `'>='`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>shift_right</dfn> :

    | `'>>'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>less_than</dfn> :

    | `'<'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>less_than_equal</dfn> :

    | `'<='`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>shift_left</dfn> :

    | `'<<'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>modulo</dfn> :

    | `'%'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>minus</dfn> :

    | `'-'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>minus_minus</dfn> :

    | `'--'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>period</dfn> :

    | `'.'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>plus</dfn> :

    | `'+'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>plus_plus</dfn> :

    | `'++'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>or</dfn> :

    | `'|'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>or_or</dfn> :

    | `'||'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_left</dfn> :

    | `'('`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_right</dfn> :

    | `')'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>semicolon</dfn> :

    | `';'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>star</dfn> :

    | `'*'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>tilde</dfn> :

    | `'~'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>underscore</dfn> :

    | `'_'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>xor</dfn> :

    | `'^'`
</div>

Note: The `MINUS_MINUS` and `PLUS_PLUS` tokens are reserved, i.e. they are not used in any grammar productions.
For example `x--` and `++i` are not syntactically valid expressions in [SHORTNAME].

# Built-in variables # {#builtin-variables}

See [[#builtin-inputs-outputs]] for how to declare a built-in variable.

<table class='data'>
  <thead>
    <tr><th>Built-in<th>Stage<th>Input or Output<th>Store type<th>Description
  </thead>

  <tr><td>`vertex_index`
      <td>vertex
      <td>in
      <td>u32
      <td style="width:50%">Index of the current vertex within the current API-level draw command,
         independent of draw instancing.

         For a non-indexed draw, the first vertex has an index equal to the `firstVertex` argument
         of the draw, whether provided directly or indirectly.
         The index is incremented by one for each additional vertex in the draw instance.

         For an indexed draw, the index is equal to the index buffer entry for
         vertex, plus the `baseVertex` argument of the draw, whether provided directly or indirectly.

  <tr><td>`instance_index`
      <td>vertex
      <td>in
      <td>u32
      <td style="width:50%">Instance index of the current vertex within the current API-level draw command.

         The first instance has an index equal to the `firstInstance` argument of the draw,
         whether provided directly or indirectly.
         The index is incremented by one for each additional instance in the draw.

  <tr><td>`position`
      <td>vertex
      <td>out
      <td>vec4&lt;f32&gt;
      <td style="width:50%">Output position of the current vertex, using homogeneous coordinates.
      After homogeneous normalization (where each of the *x*, *y*, and *z* components
      are divided by the *w* component), the position is in the WebGPU normalized device
      coordinate space.
      See [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]].

  <tr><td>`position`
      <td>fragment
      <td>in
      <td>vec4&lt;f32&gt;
      <td style="width:50%">Framebuffer position of the current fragment, using normalized homogeneous
      coordinates.
      (The *x*, *y*, and *z* components have already been scaled such that *w* is now 1.)
      See [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]].

  <tr><td>`front_facing`
      <td>fragment
      <td>in
      <td>bool
      <td style="width:50%">True when the current fragment is on a front-facing primitive.
         False otherwise.
         See [[WebGPU#front-facing|WebGPU &sect; Front-facing]].

  <tr><td>`frag_depth`
      <td>fragment
      <td>out
      <td>f32
      <td style="width:50%">Updated depth of the fragment, in the viewport depth range.
      See [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]].

  <tr><td>`local_invocation_id`
      <td>compute
      <td>in
      <td>vec3&lt;u32&gt;
      <td style="width:50%">The current invocation's [=local invocation ID=],
            i.e. its position in the [=workgroup grid=].

  <tr><td>`local_invocation_index`
      <td>compute
      <td>in
      <td>u32
      <td style="width:50%">The current invocation's [=local invocation index=], a linearized index of
          the invocation's position within the [=workgroup grid=].

  <tr><td>`global_invocation_id`
      <td>compute
      <td>in
      <td>vec3&lt;u32&gt;
      <td style="width:50%">The current invocation's [=global invocation ID=],
          i.e. its position in the [=compute shader grid=].

  <tr><td>`workgroup_id`
      <td>compute
      <td>in
      <td>vec3&lt;u32&gt;
      <td style="width:50%">The current invocation's [=workgroup ID=],
          i.e. the position of the workgroup in the [=workgroup grid=].

  <tr><td>`num_workgroups`
      <td>compute
      <td>in
      <td>vec3&lt;u32&gt;
      <td style="width:50%">The [=dispatch size=], `vec<u32>(group_count_x,
      group_count_y, group_count_z)`, of the compute shader
      [[WebGPU#dom-gpucomputepassencoder-dispatch|dispatched]] by the API.

  <tr><td>`sample_index`
      <td>fragment
      <td>in
      <td>u32
      <td style="width:50%">Sample index for the current fragment.
         The value is least 0 and at most `sampleCount`-1, where
         [[WebGPU#dom-gpurenderpipelinedescriptor-samplecount|sampleCount]]
         is the number of MSAA samples specified for the GPU render pipeline.
         <br>See [[WebGPU#render-pipeline|WebGPU &sect; GPURenderPipeline]].

  <tr><td>`sample_mask`
      <td>fragment
      <td>in
      <td>u32
      <td style="width:50%">Sample coverage mask for the current fragment.
         It contains a bitmask indicating which samples in this fragment are covered
         by the primitive being rendered.
         <br>See [[WebGPU#sample-masking|WebGPU &sect; Sample Masking]].

  <tr><td>`sample_mask`
      <td>fragment
      <td>out
      <td>u32
      <td style="width:50%">Sample coverage mask control for the current fragment.
         The last value written to this variable becomes the
         [[WebGPU#shader-output-mask|shader-output mask]].
         Zero bits in the written value will cause corresponding samples in
         the color attachments to be discarded.
         <br>See [[WebGPU#sample-masking|WebGPU &sect; Sample Masking]].
</table>

<div class='example wgsl global-scope' heading="Declaring built-in variables">
  <xmp>
    struct VertexOutput {
      [[builtin(position)]] my_pos: vec4<f32>;
      //   OpDecorate %my_pos BuiltIn Position
      //   %float = OpTypeFloat 32
      //   %v4float = OpTypeVector %float 4
      //   %ptr = OpTypePointer Output %v4float
      //   %my_pos = OpVariable %ptr Output
    };

    [[stage(vertex)]]
    fn vs_main(
      [[builtin(vertex_index)]] my_index: u32,
      //   OpDecorate %my_index BuiltIn VertexIndex
      //   %uint = OpTypeInt 32 0
      //   %ptr = OpTypePointer Input %uint
      //   %my_index = OpVariable %ptr Input
      [[builtin(instance_index)]] my_inst_index: u32,
      //    OpDecorate %my_inst_index BuiltIn InstanceIndex
    ) -> VertexOutput {}

    struct FragmentOutput {
      [[builtin(frag_depth)]] depth: f32;
      //     OpDecorate %depth BuiltIn FragDepth
      [[builtin(sample_mask)]] mask_out: u32;
      //      OpDecorate %mask_out BuiltIn SampleMask ; an output variable
    };

    [[stage(fragment)]]
    fn fs_main(
      [[builtin(front_facing)]] is_front: bool,
      //     OpDecorate %is_front BuiltIn FrontFacing
      [[builtin(position)]] coord: vec4<f32>,
      //     OpDecorate %coord BuiltIn FragCoord
      [[builtin(sample_index)]] my_sample_index: u32,
      //      OpDecorate %my_sample_index BuiltIn SampleId
      [[builtin(sample_mask_in)]] mask_in: u32,
      //      OpDecorate %mask_in BuiltIn SampleMask ; an input variable
      //      OpDecorate %mask_in Flat
    ) -> FragmentOutput {}

    [[stage(compute)]]
    fn cs_main(
      [[builtin(local_invocation_id)]] local_id: vec3<u32>,
      //     OpDecorate %local_id BuiltIn LocalInvocationId
      [[builtin(local_invocation_index)]] local_index: u32,
      //     OpDecorate %local_index BuiltIn LocalInvocationIndex
      [[builtin(global_invocation_id)]] global_id: vec3<u32>,
      //      OpDecorate %global_id BuiltIn GlobalInvocationId
   ) {}
  </xmp>
</div>

# Built-in functions # {#builtin-functions}

Certain functions are [=predeclared=], provided by the implementation, and
therefore always available for use in a [SHORTNAME] program.
These are called <dfn noexport>built-in functions</dfn>.

A built-in function is a family of functions, all with the same name,
but distinguished by the number, order, and types of their [=formal parameters=].
Each of these distinct function variations is called an <dfn>overload</dfn>.

Note: In this sense, each [=user-defined function=] only has one overload.

Each [=overload=] is defined below via:
* Type parameterizations, if any.
* The built-in function name, a parenthesized list of [=formal parameters=], and optionally a [=return type=].
* The behaviour of this overload of the function.

Since a built-in function is always in scope, it is an error to attempt to redefine
one or to use the name of a built-in function as an [=identifier=] for any other
kind of declaration.

When calling a built-in function, all arguments to the function are evaluated
before function evaluation begins.
See [[#function-calls]].

## Logical built-in functions ## {#logical-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>Parameterization<td style="width:40%;">Overload<td>Description
  </thead>
  <tr algorithm="vector all">
    <td>
    <td>`all`(|e|: vec|N|&lt;bool&gt;) -> bool
    <td>Returns true if each component of |e| is true.<br>
        (OpAll)

  <tr algorithm="scalar all">
    <td>|e|: bool
    <td>`all(`|e|`)`: bool
    <td>Returns |e|.

  <tr algorithm="vector any">
    <td>
    <td>`any`(|e|: vec|N|&lt;bool&gt;) -> bool
    <td>Returns true if any component of |e| is true.<br>
        (OpAny)

  <tr algorithm="scalar any">
    <td>|e|: bool
    <td>`any(`|e|`)`: bool
    <td>Returns |e|.

  <tr algorithm="scalar select">
    <td>|T| is [=scalar=] or [=vector=]
    <td>`select`(|f|: |T|, |t|: |T|, |cond|: bool) -> |T|
    <td>Returns |t| when |cond| is true, and |f| otherwise.<br>
        (OpSelect)

  <tr algorithm="vector select">
    <td>|T| is [=scalar=]
    <td>`select`(|f|: vec|N|&lt;|T|&gt;, |t|: vec|N|&lt;|T|&gt;, |cond|: vec|N|&lt;bool&gt;) -> vec|N|&lt;|T|&gt;
    <td>[=Component-wise=] selection. Result component |i| is evaluated
        as `select(`|f|`[`|i|`], `|t|`[`|i|`], `|cond|`[`|i|`])`.<br>
        (OpSelect)
</table>

## Value-testing built-in functions ## {#value-testing-builtin-functions}
<table class='data'>
  <caption>Unary operators</caption>
  <thead>
    <tr><th>Parameterization<th>Overload<th>Description
  </thead>
  <tr algorithm="isNan">
  <td rowspan=4>
    |I| is [FLOATING]<br>
    |T| is bool if |I| is a scalar, or<br>
    vec|N|&lt;bool&gt; if |I| is a vector
    <td class="nowrap">`isNan(`|e|`:` |I| `) -> ` |T|
    <td>Test for NaN according to [[!IEEE-754|IEEE-754]].<br>
    [=Component-wise=] when |I| is a vector. (OpIsNan)
  <tr algorithm="isInf">
    <td class="nowrap">`isInf(`|e|`:` |I| `) -> ` |T|
    <td>Test for infinity according to [[!IEEE-754|IEEE-754]].<br>
    [=Component-wise=] when |I| is a vector. (OpIsInf)
  <tr algorithm="isFinite">
    <td class="nowrap">`isFinite(`|e|`:` |I| `) -> ` |T|
    <td>Test a finite value according to [[!IEEE-754|IEEE-754]].<br>
    [=Component-wise=] when |I| is a vector.
  <tr algorithm="isNormal">
    <td class="nowrap">`isNormal(`|e|`:` |I| `) -> ` |T|
    <td>Test a normal value according to [[!IEEE-754|IEEE-754]].<br>
    [=Component-wise=] when |I| is a vector.

  <tr algorithm="runtime-sized array length">
    <td>
    <td>`arrayLength`(|e|: ptr&lt;storage,array&lt;|T|&gt;&gt; ) -> u32
        <td>Returns the number of elements in the [=runtime-sized=] array.<br>
        (OpArrayLength, but the implementation has to trace back to get the pointer to the enclosing struct.)
</table>

## Float built-in functions ## {#float-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>Parameterization<th>Overload<th>Description
  </thead>
  <tr algorithm="float abs">
    <td>|T| is [FLOATING]
    <td class="nowrap">`abs(`|e|`:` |T| `) -> ` |T|
    <td>Returns the absolute value of |e| (e.g. |e| with a positive sign bit).
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Fabs)

  <tr algorithm="acos">
    <td>|T| is [FLOATING]
    <td class="nowrap">`acos(`|e|`:` |T| `) -> ` |T|
    <td>Returns the arc cosine of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Acos)

  <tr algorithm="asin">
    <td>|T| is [FLOATING]
    <td class="nowrap">`asin(`|e|`:` |T| `) -> ` |T|
    <td>Returns the arc sine of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Asin)

  <tr algorithm="atan">
    <td>|T| is [FLOATING]
    <td class="nowrap">`atan(`|e|`:` |T| `) -> ` |T|
    <td>Returns the arc tangent of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Atan)

  <tr algorithm="atan2">
    <td>|T| is [FLOATING]
    <td class="nowrap">`atan2(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>Returns the arc tangent of |e1| over |e2|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Atan2)

  <tr algorithm="ceil">
    <td>|T| is [FLOATING]
    <td class="nowrap">`ceil(`|e|`:` |T| `) -> ` |T|
    <td>Returns the [=ceiling expression|ceiling=] of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Ceil)

  <tr algorithm="clamp">
    <td>|T| is [FLOATING]
    <td class="nowrap">`clamp(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T|`) -> ` |T|
    <td>Returns `min(max(`|e1|`,`|e2|`),`|e3|`)`.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450NClamp)

  <tr algorithm="cos">
    <td>|T| is [FLOATING]
    <td class="nowrap">`cos(`|e|`:` |T| `) -> ` |T|
    <td>Returns the cosine of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Cos)

  <tr algorithm="cosh">
    <td>|T| is [FLOATING]
    <td class="nowrap">`cosh(`|e|`:` |T| `) -> ` |T|
    <td>Returns the hyperbolic cosine of |e|.
    [=Component-wise=] when |T| is a vector
    (GLSLstd450Cosh)

  <tr algorithm="vector case, cross">
    <td>|T| is f32
    <td class="nowrap">`cross(`|e1|`:` vec3<|T|> `, `|e2|`:` vec3<|T|>`) -> ` vec3<|T|>
    <td>Returns the cross product of |e1| and |e2|. (GLSLstd450Cross)

  <tr algorithm="distance">
    <td>|T| is [FLOATING]
    <td class="nowrap">`distance(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` f32
    <td>Returns the distance between |e1| and |e2| (e.g. `length(`|e1|` - `|e2|`)`).
    (GLSLstd450Distance)

  <tr algorithm="exp">
    <td>|T| is [FLOATING]
    <td class="nowrap">`exp(`|e1|`:` |T| `) -> ` |T|
    <td>Returns the natural exponentiation of |e1| (e.g. `e`<sup>|e1|</sup>).
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Exp)

  <tr algorithm="exp2">
    <td>|T| is [FLOATING]
    <td class="nowrap">`exp2(`|e|`:` |T| `) -> ` |T|
    <td>Returns 2 raised to the power |e| (e.g. `2`<sup>|e|</sup>).
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Exp2)

  <tr algorithm="faceForward">
    <td>|T| is vec|N|&lt;f32&gt;
    <td class="nowrap">`faceForward(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T| `) -> ` |T|
    <td>Returns |e1| if `dot(`|e2|`,`|e3|`)` is negative, and `-`|e1| otherwise.
    (GLSLstd450FaceForward)

  <tr algorithm="floor">
    <td>|T| is [FLOATING]
    <td class="nowrap">`floor(`|e|`:` |T| `) -> ` |T|
    <td>Returns the [=floor expression|floor=] of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Floor)

  <tr algorithm="fma">
    <td>|T| is [FLOATING]
    <td class="nowrap">`fma(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T| `) -> ` |T|
    <td>Returns |e1| `*` |e2| `+` |e3|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Fma)

  <tr algorithm="fract">
    <td>|T| is [FLOATING]
    <td class="nowrap">`fract(`|e|`:` |T| `) -> ` |T|
    <td>Returns the fractional bits of |e| (e.g. |e| `- floor(`|e|`)`).
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Fract)

  <tr algorithm="scalar case, frexp">
    <td>|T| is f32
    <td class="nowrap">`frexp(`|e|`: `|T|`) -> _frexp_result`<br>
    <td>Splits |e| into a significand and exponent of the form `significand * 2`<sup>`exponent`</sup>.
    Returns the `_frexp_result` built-in structure, defined as:
    ```rust
struct _frexp_result {
  sig : f32; // significand part
  exp : i32; // exponent part
};
    ```
    The magnitude of the significand is in the range of [0.5, 1.0) or 0.

    Note: A value cannot be explicitly declared with the type `_frexp_result`, but a value may infer the type.

    (GLSLstd450FrexpStruct)

  <tr algorithm="vector case, frexp">
    <td>|T| is vec|N|&lt;f32&gt;
    <td class="nowrap">`frexp(`|e|`: `|T|`) -> _frexp_result_vec`|N|<br>
    <td>Splits the components of |e| into a significand and exponent of the form `significand * 2`<sup>`exponent`</sup>.
    Returns the `_frexp_result_vec`|N| built-in structure, defined as:
    ```rust
struct _frexp_result_vecN {
  sig : vecN<f32>; // significand part
  exp : vecN<i32>; // exponent part
};
    ```
    The magnitude of each component of the significand is in the range of [0.5, 1.0) or 0.

    Note: A value cannot be explicitly declared with the type `_frexp_result_vec`|N|, but a value may infer the type.

    (GLSLstd450FrexpStruct)

  <tr algorithm="inverseSqrt">
    <td>|T| is [FLOATING]
    <td class="nowrap">`inverseSqrt(`|e|`:` |T| `) -> ` |T|
    <td>Returns the reciprocal of `sqrt(`|e|`)`.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450InverseSqrt)

  <tr algorithm="ldexp">
    <td>|T| is [FLOATING]<br>
        |I| is [SIGNEDINTEGRAL], where<br>
        |I| is a scalar if |T| is a scalar, or<br>
        a vector when |T| is a vector
    <td class="nowrap">`ldexp(`|e1|`:` |T| `, `|e2|`:` |I| `) -> ` |T|
    <td>Returns |e1| `* 2`<sup>|e2|</sup>.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Ldexp)

  <tr algorithm="length">
    <td>|T| is [FLOATING]
    <td class="nowrap">`length(`|e|`:` |T| `) -> ` f32
    <td>Returns the length of |e| (e.g. `abs(`|e|`)` if |T| is a scalar, or `sqrt(`|e|`[0]`<sup>`2`</sup> `+` |e|`[1]`<sup>`2`</sup> `+ ...)` if |T| is a vector).
    (GLSLstd450Length)

  <tr algorithm="log">
    <td>|T| is [FLOATING]
    <td class="nowrap">`log(`|e|`:` |T| `) -> ` |T|
    <td>Returns the natural logaritm of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Log)

  <tr algorithm="log2">
    <td>|T| is [FLOATING]
    <td class="nowrap">`log2(`|e|`:` |T| `) -> ` |T|
    <td>Returns the base-2 logarithm of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Log2)

  <tr algorithm="max">
    <td>|T| is [FLOATING]
    <td class="nowrap">`max(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>Returns |e2| if |e1| is less than |e2|, and |e1| otherwise.
    If one operand is a NaN, the other is returned.
    If both operands are NaNs, a NaN is returned.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450NMax)

  <tr algorithm="min">
    <td>|T| is [FLOATING]
    <td class="nowrap">`min(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>Returns |e2| if |e2| is less than |e1|, and |e1| otherwise.
    If one operand is a NaN, the other is returned.
    If both operands are NaNs, a NaN is returned.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450NMin)

  <tr algorithm="mix all same type operands">
    <td>|T| is [FLOATING]
    <td class="nowrap">`mix(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T|`) -> ` |T|
    <td>Returns the linear blend of |e1| and |e2| (e.g. |e1|`*(1-`|e3|`)+`|e2|`*`|e3|).
    [=Component-wise=] when |T| is a vector.
    <br>
    (GLSLstd450FMix)

  <tr algorithm="vector mix with scalar blending factor">
    <td>|T| is vec|N|&lt;f32&gt;
    <td class="nowrap">`mix(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` f32 `) -> ` |T|
    <td>Returns the component-wise linear blend of |e1| and |e2|,
        using scalar blending factor |e3| for each component.<br>
        Same as `mix(`|e1|`, `|e2|`, `|T|`(`|e3|`))`.

  <tr algorithm="scalar case, modf">
    <td>|T| is f32
    <td class="nowrap">`modf(`|e|`: `|T|`) -> _modf_result`<br>
    <td>Splits |e| into fractional and whole number parts.
    Returns the `_modf_result` built-in structure, defined as:
    ```rust
struct _modf_result {
  fract : f32; // fractional part
  whole : f32; // whole part
};
    ```

    Note: A value cannot be explicitly declared with the type `_modf_result`, but a value may infer the type.

    (GLSLstd450ModfStruct)

  <tr algorithm="vector case, modf">
    <td>|T| is vec|N|&lt;f32&gt;
    <td class="nowrap">`modf(`|e|`: `|T|`) -> _modf_result_vec`|N|<br>
    <td>Splits the components of |e| into fractional and whole number parts.
    Returns the `_modf_result_vec`|N| built-in structure, defined as:
    ```rust
struct _modf_result_vecN {
  fract : vecN<f32>; // fractional part
  whole : vecN<f32>; // whole part
};
    ```

    Note: A value cannot be explicitly declared with the type `_modf_result_vec`|N|, but a value may infer the type.

    (GLSLstd450ModfStruct)

  <tr algorithm="vector case, normalize">
    <td>|T| is f32
    <td class="nowrap">`normalize(`|e|`:` vec|N|<|T|> `) -> ` vec|N|<|T|>
    <td>Returns a unit vector in the same direction as |e|.
    (GLSLstd450Normalize)

  <tr algorithm="pow">
    <td>|T| is [FLOATING]
    <td class="nowrap">`pow(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>Returns |e1| raised to the power |e2|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Pow)

  <tr algorithm="quantize to f16">
    <td>|T| is [FLOATING]
    <td class="nowrap">`quantizeToF16(`|e|`:` |T| `) -> ` |T|
    <td>Quantizes a 32-bit floating point value |e| as if |e| were converted to a [[!IEEE-754|IEEE 754]] binary16 value,
        and then converted back to a IEEE 754 binary32 value.<br>
        See [[#floating-point-conversion]].<br>
        [=Component-wise=] when |T| is a vector.<br>

        Note: The vec2&lt;f32&gt; case is the same as `unpack2x16float(pack2x16float(`|e|`))`.

        (OpQuantizeToF16)

  <tr algorithm="reflect">
    <td>|T| is vec|N|&lt;f32&gt;
    <td class="nowrap">`reflect(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>For the incident vector |e1| and surface orientation |e2|, returns the reflection direction
    |e1|`-2*dot(`|e2|`,`|e1|`)*`|e2|.
    (GLSLstd450Reflect)

  <tr algorithm="refract">
    <td>|T| is vec|N|&lt;f32&gt;<br>I is f32
    <td class="nowrap">`refract(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |I| `) -> ` |T|
    <td>For the incident vector |e1| and surface normal |e2|, and the ratio of indices of refraction |e3|,
    let `k = 1.0 - `|e3|` * `|e3|` * (1.0 - dot(`|e2|`, `|e1|`) * dot(`|e2|`, `|e1|`))`. If `k < 0.0`, returns the
    refraction vector 0.0, otherwise return the refraction vector
    |e3|` * `|e1|` - (`|e3|` * dot(`|e2|`, `|e1|`) + sqrt(k)) * `|e2|.
    (GLSLstd450Refract)

  <tr algorithm="round">
    <td>|T| is [FLOATING]
    <td class="nowrap">`round(`|e|`:` |T| `) -> ` |T|
    <td>Result is the integer |k| nearest to |e|, as a floating point value.<br>
        When |e| lies halfway between integers |k| and |k|+1,
        the result is |k| when |k| is even, and |k|+1 when |k| is odd.<br>
        [=Component-wise=] when |T| is a vector.
        (GLSLstd450RoundEven)

  <tr algorithm="float sign">
    <td>|T| is [FLOATING]
    <td class="nowrap">`sign(`|e|`:` |T| `) -> ` |T|
    <td>Returns the sign of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450FSign)

  <tr algorithm="sin">
    <td>|T| is [FLOATING]
    <td class="nowrap">`sin(`|e|`:` |T| `) -> ` |T|
    <td>Returns the sine of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Sin)

  <tr algorithm="sinh">
    <td>|T| is [FLOATING]
    <td class="nowrap">`sinh(`|e|`:` |T| `) -> ` |T|
    <td>Returns the hyperbolic sine of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Sinh)

  <tr algorithm="smoothStep">
    <td>|T| is [FLOATING]
    <td class="nowrap">`smoothStep(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T| `) -> ` |T|
    <td>Returns the smooth Hermite interpolation between 0 and 1.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450SmoothStep)

  <tr algorithm="sqrt">
    <td>|T| is [FLOATING]
    <td class="nowrap">`sqrt(`|e|`:` |T| `) -> ` |T|
    <td>Returns the square root of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Sqrt)

  <tr algorithm="step">
    <td>|T| is [FLOATING]
    <td class="nowrap">`step(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>Returns 0.0 if |e1| is less than |e2|, and 1.0 otherwise.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Step)

  <tr algorithm="tan">
    <td>|T| is [FLOATING]
    <td class="nowrap">`tan(`|e|`:` |T| `) -> ` |T|
    <td>Returns the tangent of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Tan)

  <tr algorithm="tanh">
    <td>|T| is [FLOATING]
    <td class="nowrap">`tanh(`|e|`:` |T| `) -> ` |T|
    <td>Returns the hyperbolic tangent of |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Tanh)

  <tr algorithm="trunc">
    <td>|T| is [FLOATING]
    <td class="nowrap">`trunc(`|e|`:` |T| `) -> ` |T|
    <td>Returns the nearest whole number whose absolute value is less than or equal to |e|.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450Trunc)
</table>

## Integer built-in functions ## {#integer-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>Parameterization<th>Overload<th>Description
  </thead>
  <tr algorithm="signed abs">
    <td>|T| is [SIGNEDINTEGRAL]
    <td class="nowrap">`abs`(|e|: |T| ) -> |T|
    <td>The absolute value of |e|.
        [=Component-wise=] when |T| is a vector.
        If |e| evaluates to the largest negative value, then the result is |e|.
        (GLSLstd450SAbs)

  <tr algorithm="scalar case, unsigned abs">
    <td>|T| is [UNSIGNEDINTEGRAL]
    <td class="nowrap">`abs`(|e|: |T| ) -> |T|
    <td>Result is |e|.  This is provided for symmetry with `abs` for signed integers.
    [=Component-wise=] when |T| is a vector.

  <tr algorithm="unsigned clamp">
    <td>|T| is [UNSIGNEDINTEGRAL]
    <td class="nowrap">`clamp(`|e1|`:` |T| `, `|e2|`:` |T|`, `|e3|`:` |T|`) ->` |T|
    <td>Returns `min(max(`|e1|`,`|e2|`),`|e3|`)`.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450UClamp)

  <tr algorithm="signed clamp">
    <td>|T| is [SIGNEDINTEGRAL]
    <td class="nowrap">`clamp(`|e1|`:` |T| `, `|e2|`:` |T|`, `|e3|`:` |T|`) ->` |T|
    <td>Returns `min(max(`|e1|`,`|e2|`),`|e3|`)`.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450SClamp)

  <tr algorithm="count 1 bits">
    <td>|T| is [INTEGRAL]
    <td class="nowrap">`countOneBits(`|e|`:` |T| `) ->` |T|
    <td>The number of 1 bits in the representation of |e|.<br>
        Also known as "population count".<br>
        [=Component-wise=] when |T| is a vector.
        (SPIR-V OpBitCount)

  <tr algorithm="unsigned max">
    <td>|T| is [UNSIGNEDINTEGRAL]
    <td class="nowrap">`max(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>Returns |e2| if |e1| is less than |e2|, and |e1| otherwise.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450UMax)

  <tr algorithm="signed max">
    <td>|T| is [SIGNEDINTEGRAL]
    <td class="nowrap">`max(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>Returns |e2| if |e1| is less than |e2|, and |e1| otherwise.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450SMax)

  <tr algorithm="unsigned min">
    <td>|T| is [UNSIGNEDINTEGRAL]
    <td class="nowrap">`min(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>Returns |e1| if |e1| is less than |e2|, and |e2| otherwise.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd450UMin)

  <tr algorithm="signed min">
    <td>|T| is [SIGNEDINTEGRAL]
    <td class="nowrap">`min(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>Returns |e1| if |e1| is less than |e2|, and |e2| otherwise.
    [=Component-wise=] when |T| is a vector.
    (GLSLstd45SUMin)

  <tr algorithm="bit reversal">
    <td>|T| is [INTEGRAL]
    <td class="nowrap">`reverseBits(`|e|`:` |T| `) ->`  |T|
    <td>Reverses the bits in |e|:  The bit at position |k| of the result equals the
        bit at position 31-|k| of |e|.<br>
        [=Component-wise=] when |T| is a vector.
        (SPIR-V OpBitReverse)
</table>

## Matrix built-in functions ## {#matrix-builtin-functions}
<table class='data'>
  <thead>
    <tr><th>Parameterization<th>Overload<th>Description
  </thead>
  <tr algorithm="determinant">
    <td>|T| is f32
    <td class="nowrap">`determinant(`|e|`:` mat|N|x|N|<|T|> `) -> ` |T|
    <td>Returns the determinant of |e|.
    (GLSLstd450Determinant)
  <tr algorithm="transpose">
    <td>|T| is f32
    <td class="nowrap">`transpose(`|e|`:` mat|M|x|N|<|T|> `) -> ` mat|N|x|M|<|T|>
    <td>Returns the transpose of |e|.
    (OpTranspose)
</table>

## Vector built-in functions ## {#vector-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>Parameterization<td>Overload<td>Description
  </thead>
  <tr algorithm="dot"><td>|T| is f32
  <td>`dot(`|e1|`: vecN<`|T|`>, `|e2|`: vecN<`|T|`>) ->` |T|
  <td>Returns the dot product of |e1| and |e2|.
  (OpDot)
</table>

## Derivative built-in functions ## {#derivative-builtin-functions}

See [[#derivatives]].

These functions:
* Must only be used in a [=fragment=] shader stage.
* Must only be invoked in uniform control flow.

<table class='data'>
  <thead>
    <tr><th>Parameterization<th>Overload<th>Description
  </thead>
  <tr algorithm="dpdx">
  <td rowspan=9>|T| is f32 or vecN&lt;f32&gt;
    <td>`dpdx(`|e|`: `|T|`) ->` |T|
    <td>Partial derivative of |e| with respect to window x coordinates.
    The result is the same as either `dpdxFine(`|e|`)` or `dpdxCoarse(`|e|`)`.
    (OpDPdx)
  <tr algorithm="dpdxCoarse">
    <td>`dpdxCoarse(`|e|`: `|T|`) -> `|T|
    <td>Returns the partial derivative of |e| with respect to window x coordinates using local differences.
    This may result in fewer unique positions that `dpdxFine(`|e|`)`.
    (OpDPdxCoarse)
  <tr algorithm="dpdxFine">
    <td>`dpdxFine(`|e|`: `|T|`) -> `|T|
    <td>Returns the partial derivative of |e| with respect to window x coordinates.
    (OpDPdxFine)
  <tr algorithm="dpdy">
    <td>`dpdy(`|e|`: `|T|`) -> `|T|
    <td>Partial derivative of |e| with respect to window y coordinates.
    The result is the same as either `dpdyFine(`|e|`)` or `dpdyCoarse(`|e|`)`.
    (OpDPdy)
  <tr algorithm="dpdyCoarse">
    <td>`dpdyCoarse(`|e|`: `|T|`) -> `|T|
    <td>Returns the partial derivative of |e| with respect to window y coordinates using local differences.
    This may result in fewer unique positions that `dpdyFine(`|e|`)`.
    (OpDPdyCoarse)
  <tr algorithm="dpdyFine">
    <td>`dpdyFine(`|e|`: `|T|`) -> `|T|
    <td>Returns the partial derivative of |e| with respect to window y coordinates.
    (OpDPdyFine)
  <tr algorithm="fwidth">
    <td>`fwidth(`|e|`: `|T|`) -> `|T|
    <td>Returns `abs(dpdx(`|e|`)) + abs(dpdy(`|e|`))`.
    (OpFwidth)
  <tr algorithm="fwidthCoarse">
    <td>`fwidthCoarse(`|e|`: `|T|`) -> `|T|
    <td>Returns `abs(dpdxCoarse(`|e|`)) + abs(dpdyCoarse(`|e|`))`.
    (OpFwidthCoarse)
  <tr algorithm="fwidthFine">
    <td>`fwidthFine(`|e|`: `|T|`) -> `|T|
    <td>Returns `abs(dpdxFine(`|e|`)) + abs(dpdyFine(`|e|`))`.
    (OpFwidthFine)
</table>

## Texture built-in functions ## {#texture-builtin-functions}

In this section, texture types are shown with the following parameters:
* |T|, a sampled type.
* <var ignore>F</var>, a [=texel format=].
* <var ignore>A</var>, an [=access mode=].

Parameter values must be valid for the respective texture types.

### `textureDimensions` ### {#texturedimensions}

Returns the dimensions of a texture, or texture's mip level in texels.

```rust
textureDimensions(t: texture_1d<T>) -> i32
textureDimensions(t: texture_1d<T>, level: i32) -> i32
textureDimensions(t: texture_2d<T>) -> vec2<i32>
textureDimensions(t: texture_2d<T>, level: i32) -> vec2<i32>
textureDimensions(t: texture_2d_array<T>) -> vec2<i32>
textureDimensions(t: texture_2d_array<T>, level: i32) -> vec2<i32>
textureDimensions(t: texture_3d<T>) -> vec3<i32>
textureDimensions(t: texture_3d<T>, level: i32) -> vec3<i32>
textureDimensions(t: texture_cube<T>) -> vec2<i32>
textureDimensions(t: texture_cube<T>, level: i32) -> vec2<i32>
textureDimensions(t: texture_cube_array<T>) -> vec2<i32>
textureDimensions(t: texture_cube_array<T>, level: i32) -> vec2<i32>
textureDimensions(t: texture_multisampled_2d<T>)-> vec2<i32>
textureDimensions(t: texture_depth_2d) -> vec2<i32>
textureDimensions(t: texture_depth_2d, level: i32) -> vec2<i32>
textureDimensions(t: texture_depth_2d_array) -> vec2<i32>
textureDimensions(t: texture_depth_2d_array, level: i32) -> vec2<i32>
textureDimensions(t: texture_depth_cube) -> vec2<i32>
textureDimensions(t: texture_depth_cube, level: i32) -> vec2<i32>
textureDimensions(t: texture_depth_cube_array) -> vec2<i32>
textureDimensions(t: texture_depth_cube_array, level: i32) -> vec2<i32>
textureDimensions(t: texture_depth_multisampled_2d)-> vec2<i32>
textureDimensions(t: texture_storage_1d<F,A>) -> i32
textureDimensions(t: texture_storage_2d<F,A>) -> vec2<i32>
textureDimensions(t: texture_storage_2d_array<F,A>) -> vec2<i32>
textureDimensions(t: texture_storage_3d<F,A>) -> vec3<i32>
textureDimensions(t: texture_external) -> vec2<i32>
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type),
  [multisampled](#multisampled-texture-type), [depth](#texture-depth),
  [storage](#texture-storage), or [external](#external-texture-type) texture.
  <tr><td>`level`<td>
  The mip level, with level 0 containing a full size version of the texture.<br>
  If omitted, the dimensions of level 0 are returned.
</table>

**Returns:**

The dimensions of the texture in texels.

For textures based on cubes, the results are the dimensions of each face of the cube.
Cube faces are square, so the x and y components of the result are equal.

If `level` is outside the range `[0, textureNumLevels(t))` then any valid value
for the return type may be returned.

### `textureLoad` ### {#textureload}

Reads a single texel from a texture without sampling or filtering.

```rust
textureLoad(t: texture_1d<T>, coords: i32, level: i32) -> vec4<T>
textureLoad(t: texture_2d<T>, coords: vec2<i32>, level: i32) -> vec4<T>
textureLoad(t: texture_2d_array<T>, coords: vec2<i32>, array_index: i32, level: i32) -> vec4<T>
textureLoad(t: texture_3d<T>, coords: vec3<i32>, level: i32) -> vec4<T>
textureLoad(t: texture_multisampled_2d<T>, coords: vec2<i32>, sample_index: i32)-> vec4<T>
textureLoad(t: texture_depth_2d, coords: vec2<i32>, level: i32) -> f32
textureLoad(t: texture_depth_2d_array, coords: vec2<i32>, array_index: i32, level: i32) -> f32
textureLoad(t: texture_depth_multisampled_2d, coords: vec2<i32>, sample_index: i32)-> f32
textureLoad(t: texture_external, coords: vec2<i32>) -> vec4<f32>
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type),
  [multisampled](#multisampled-texture-type), [depth](#texture-depth),
  or [external](#external-texture-type) texture.
  <tr><td>`coords`<td>
  The 0-based texel coordinate.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`level`<td>
  The mip level, with level 0 containing a full size version of the texture.
  <tr><td>`sample_index`<td>
  The 0-based sample index of the multisampled texture.
</table>

**Returns:**

The unfiltered texel data.

An out of bounds access occurs if:
* any element of `coords` is outside the range `[0, textureDimensions(t, level))`
    for the corresponding element, or
* `array_index` is outside the range `[0, textureNumLayers(t))`, or
* `level` is outside the range `[0, textureNumLevels(t))`

If an out of bounds access occurs, the built-in function returns one of:
* The data for some texel within bounds of the texture
* A vector (0,0,0,0) or (0,0,0,1) of the appropriate type for non-depth textures
* 0.0 for depth textures

### `textureNumLayers` ### {#texturenumlayers}

Returns the number of layers (elements) of an array texture.

```rust
textureNumLayers(t: texture_2d_array<T>) -> i32
textureNumLayers(t: texture_cube_array<T>) -> i32
textureNumLayers(t: texture_depth_2d_array) -> i32
textureNumLayers(t: texture_depth_cube_array) -> i32
textureNumLayers(t: texture_storage_2d_array<F,A>) -> i32
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type),
  [multisampled](#multisampled-texture-type), [depth](#texture-depth) or
  [storage](#texture-storage) array texture.
</table>

**Returns:**

If the number of layers (elements) of the array texture.


### `textureNumLevels` ### {#texturenumlevels}

Returns the number of mip levels of a texture.

```rust
textureNumLevels(t: texture_1d<T>) -> i32
textureNumLevels(t: texture_2d<T>) -> i32
textureNumLevels(t: texture_2d_array<T>) -> i32
textureNumLevels(t: texture_3d<T>) -> i32
textureNumLevels(t: texture_cube<T>) -> i32
textureNumLevels(t: texture_cube_array<T>) -> i32
textureNumLevels(t: texture_depth_2d) -> i32
textureNumLevels(t: texture_depth_2d_array) -> i32
textureNumLevels(t: texture_depth_cube) -> i32
textureNumLevels(t: texture_depth_cube_array) -> i32
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type) or [depth](#texture-depth) texture.
</table>

**Returns:**

If the number of mip levels for the texture.


### `textureNumSamples` ### {#texturenumsamples}

Returns the number samples per texel in a multisampled texture.

```rust
textureNumSamples(t: texture_multisampled_2d<T>) -> i32
textureNumSamples(t: texture_depth_multisampled_2d) -> i32
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [multisampled](#multisampled-texture-type) texture.
</table>

**Returns:**

If the number of samples per texel in the multisampled texture.


### `textureSample` ### {#texturesample}

Samples a texture.

Must only be used in a [=fragment=] shader stage.
Must only be invoked in uniform control flow.

```rust
textureSample(t: texture_1d<f32>, s: sampler, coords: f32) -> vec4<f32>
textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>) -> vec4<f32>
textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32) -> vec4<f32>
textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> vec4<f32>
textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>
textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, offset: vec3<i32>) -> vec4<f32>
textureSample(t: texture_cube<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>
textureSample(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32) -> vec4<f32>
textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>) -> f32
textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> f32
textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32) -> f32
textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> f32
textureSample(t: texture_depth_cube, s: sampler, coords: vec3<f32>) -> f32
textureSample(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: i32) -> f32
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type), [depth](#texture-depth),
  or [external](#external-texture-type)
  texture to sample.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression must be either:
    * a `const_expression` expression (e.g. `vec2<i32>(1, 2)`).<br>
    * a name of a [[#module-constants|module-scope constant]] that is not [=pipeline-overridable=]
  Each `offset` component must be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.

### `textureSampleBias` ### {#texturesamplebias}

Samples a texture with a bias to the mip level.

Must only be used in a [=fragment=] shader stage.
Must only be invoked in uniform control flow.

```rust
textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32) -> vec4<f32>
textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32, offset: vec2<i32>) -> vec4<f32>
textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, bias: f32) -> vec4<f32>
textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, bias: f32, offset: vec2<i32>) -> vec4<f32>
textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32, offset: vec3<i32>) -> vec4<f32>
textureSampleBias(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
textureSampleBias(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32, bias: f32) -> vec4<f32>
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [texture](#sampled-texture-type) to sample.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`bias`<td>
  The bias to apply to the mip level before sampling.
  `bias` must be between `-16.0` and `15.99`.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression must be a `const_expression` expression (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component must be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.


### `textureSampleCompare` ### {#texturesamplecompare}

Samples a depth texture and compares the sampled depth values against a reference value.

Must only be used in a [=fragment=] shader stage.
Must only be invoked in uniform control flow.

```rust
textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32, offset: vec2<i32>) -> f32
textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32) -> f32
textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32, offset: vec2<i32>) -> f32
textureSampleCompare(t: texture_depth_cube, s: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
textureSampleCompare(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3<f32>, array_index: i32, depth_ref: f32) -> f32
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [depth](#texture-depth) texture to sample.
  <tr><td>`s`<td>
  The [sampler comparision](#sampler-type) type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression must be a `const_expression` expression (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component must be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A value in the range `[0.0..1.0]`.

Each sampled texel is compared against the reference value using the comparision
operator defined by the `sampler_comparison`, resulting in either a `0` or `1`
value for each texel.

If the sampler uses bilinear filtering then the returned value is
the filtered average of these values, otherwise the comparision result of a
single texel is returned.


### `textureSampleCompareLevel` ### {#texturesamplecomparelevel}

Samples a depth texture and compares the sampled depth values against a reference value.

```rust
textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32, offset: vec2<i32>) -> f32
textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32) -> f32
textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32, offset: vec2<i32>) -> f32
textureSampleCompareLevel(t: texture_depth_cube, s: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
textureSampleCompareLevel(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3<f32>, array_index: i32, depth_ref: f32) -> f32
```

The `textureSampleCompareLevel` function is the same as `textureSampleCompare`, except that:

* `textureSampleCompareLevel` always samples texels from mip level 0.
    * The function does not compute derivatives.
    * There is no requirement for `textureSampleCompareLevel` to be invoked in uniform control flow.
* `textureSampleCompareLevel` may be invoked in any shader stage.

### `textureSampleGrad` ### {#texturesamplegrad}

Samples a texture using explicit gradients.

```rust
textureSampleGrad(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
textureSampleGrad(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
textureSampleGrad(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
textureSampleGrad(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, ddx: vec2<f32>, ddy: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
textureSampleGrad(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
textureSampleGrad(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>, offset: vec3<i32>) -> vec4<f32>
textureSampleGrad(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
textureSampleGrad(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [texture](#sampled-texture-type) to sample.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`ddx`<td>
  The x direction derivative vector used to compute the sampling locations.
  <tr><td>`ddy`<td>
  The y direction derivative vector used to compute the sampling locations.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression must be a `const_expression` expression (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component must be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.


### `textureSampleLevel` ### {#texturesamplelevel}

Samples a texture using an explicit mip level, or at mip level 0.

```rust
textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32, offset: vec2<i32>) -> vec4<f32>
textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, level: f32, offset: vec2<i32>) -> vec4<f32>
textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32, offset: vec3<i32>) -> vec4<f32>
textureSampleLevel(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: i32) -> f32
textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: i32, offset: vec2<i32>) -> f32
textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, level: i32) -> f32
textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, level: i32, offset: vec2<i32>) -> f32
textureSampleLevel(t: texture_depth_cube, s: sampler, coords: vec3<f32>, level: i32) -> f32
textureSampleLevel(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: i32, level: i32) -> f32
textureSampleLevel(t: texture_external, s: sampler, coords: vec2<f32>) -> vec4<f32>
```

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type) or [depth](#texture-depth) texture to
  sample.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`level`<td>
  The mip level, with level 0 containing a full size version of the texture.
  For the functions where `level` is a `f32`, fractional values may interpolate
  between two levels if the format is filterable according to the
  [Texture Format Capabilities](https://gpuweb.github.io/gpuweb/#texture-format-caps).<br>
  When not specified, mip level 0 is sampled.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression must be a `const_expression` expression (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component must be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.


### `textureStore` ### {#texturestore}

Writes a single texel to a texture.

```rust
textureStore(t: texture_storage_1d<F,write>, coords: i32, value: vec4<T>)
textureStore(t: texture_storage_2d<F,write>, coords: vec2<i32>, value: vec4<T>)
textureStore(t: texture_storage_2d_array<F,write>, coords: vec2<i32>, array_index: i32, value: vec4<T>)
textureStore(t: texture_storage_3d<F,write>, coords: vec3<i32>, value: vec4<T>)
```

The channel format `T` depends on the storage texel format `F`.
[See the texel format table](#storage-texel-formats) for the mapping of texel
format to channel format.

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [write-only storage texture](#texture-storage).
  <tr><td>`coords`<td>
  The 0-based texel coordinate.<br>
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`value`<td>
  The new texel value.<br>
</table>

**Note:**

An out-of-bounds access occurs if:
* any element of `coords` is outside the range `[0, textureDimensions(t))`
    for the corresponding element, or
* `array_index` is outside the range of `[0, textureNumLayers(t))`

If an out-of-bounds access occurs, the built-in function may do any of the following:
* not be executed
* store `value` to some in bounds texel

**TODO:**

<pre class='def'>
TODO(dsinclair): Need gather operations
</pre>

## Atomic built-in functions ## {#atomic-builtin-functions}

Atomic built-in functions can be used to read/write/read-modify-write atomic
objects. They are the only operations allowed on [[#atomic-types]].

All atomic built-in functions use a `relaxed` memory ordering (**0**-value
integral constant in SPIR-V for all `Memory Semantics` operands).
This means synchronization and ordering guarantees only apply among atomic
operations acting on the same [=memory locations=].
No synchronization or ordering guarantees apply between atomic and
non-atomic memory accesses, or between atomic accesses acting on different
memory locations.

Atomic built-in functions `must` not be used in a [=vertex=] shader stage.

The storage class `SC` of the `atomic_ptr` parameter in all atomic built-in
functions `must` be either [=storage classes/storage=] or [=storage
classes/workgroup=]. [=storage classes/workgroup=] atomics have a **Workgroup**
memory scope in SPIR-V, while [=storage classes/storage=] atomics have a
**Device** memory scope in SPIR-V.

The access mode `A` in all atomic built-in functions must be [=access/read_write=].

TODO: Add links to the eventual memory model descriptions.

### Atomic Load ### {#atomic-load}

```rust
atomicLoad(atomic_ptr: ptr<SC, atomic<T>, A>) -> T

// Maps to the SPIR-V instruction OpAtomicLoad.
```

Returns the atomically loaded the value pointed to by `atomic_ptr`.
It does not [=atomic modification|modify=] the object.

### Atomic Store ### {#atomic-store}

```rust
atomicStore(atomic_ptr: ptr<SC, atomic<T>, A>, v: T)

// Maps to the SPIR-V instruction OpAtomicStore.
```

Atomically stores the value `v` in the atomic object pointed to by `atomic_ptr`.

### Atomic Read-Modify-Write ### {#atomic-rmw}

```rust
atomicAdd(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicSub(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicMax(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicMin(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicAnd(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicOr(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicXor(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T

// Mappings to SPIR-V instructions:
// atomicAdd -> OpAtomicIAdd
// atomicSub -> OpAtomicISub
// atomicMax -> OpAtomicSMax or OpAtomicUMax (depending on the signedness of T)
// atomicMin -> OpAtomicSMin or OpAtomicUMin (depending on the signedness of T)
// atomicAnd -> OpAtomicAnd
// atomicOr  -> OpAtomicOr
// atomicXor -> OpAtomicXor
```
Each function performs the following steps atomically:

1. Load the original value pointed to by `atomic_ptr`.
2. Obtains a new value by performing the operation (e.g. max) from the function
    name with the value |v|.
3. Store the new value using `atomic_ptr`.

Each function returns the original value stored in the atomic object.

```rust
atomicExchange(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T

// Maps to the SPIR-V instruction OpAtomicExchange.
```

Atomically stores the value `v` in the atomic object pointed to
`atomic_ptr` and returns the original value stored in the atomic object.

```rust
atomicCompareExchangeWeak(atomic_ptr: ptr<SC, atomic<T>, A>, cmp: T, v: T) -> _atomic_compare_exchange_result<T>

struct _atomic_compare_exchange_result<T> {
  old_value : T; // old value stored in the atomic
  exchanged : bool; // true if the exchange was done
};

// Maps to the SPIR-V instruction OpAtomicCompareExchange.
```

Note: A value cannot be explicitly declared with the type `_atomic_compare_exchange_result`, but a value may infer the type.

Performs the following steps atomically:

1. Load the original value pointed to by `atomic_ptr`.
2. Compare the original value to the value `v` using an equality operation.
3. Store the value `v` `only if` the result of the equality comparison was **true**.

Returns a two-element vector, where the first element is the original value of
the atomic object and the second element is whether or not the comparison
succeeded (**1** if successful, **0** otherwise).

Note: the equality comparison may spuriously fail on some implementations. That
is, the second element of the result vector may be **0** even if the first
element of the result vector equals `cmp`.

## Data packing built-in functions ## {#pack-builtin-functions}

Data packing builtin functions can be used to encode values using data formats that
do not correspond directly to types in [SHORTNAME].
This enables a program to write many densely packed values to memory, which can
reduce a shader's memory bandwidth demand.

<table class='data'>
  <thead>
    <tr><td>Overload<td>Description
  </thead>
  <tr algorithm="packing 4x8snorm">
    <td class="nowrap">`pack4x8snorm`(|e|: vec4&lt;f32&gt;) -> u32
    <td>Converts four normalized floating point values to 8-bit signed integers, and then combines them
        into one `u32` value.<br>
        Component |e|[|i|] of the input is converted to an 8-bit twos complement integer value
        &lfloor; 0.5 + 127 &times; min(1, max(-1, |e|[|i|])) &rfloor; which is then placed in bits
        8 &times; |i| through
        8 &times; |i| + 7 of the result.

  <tr algorithm="packing 4x8unorm">
    <td class="nowrap">`pack4x8unorm`(|e|: vec4&lt;f32&gt;) -> u32
    <td>Converts four normalized floating point values to 8-bit unsigned integers, and then combines them
        into one `u32` value.<br>
        Component |e|[|i|] of the input is converted to an 8-bit unsigned integer value
        &lfloor; 0.5 + 255 &times; min(1, max(0, |e|[|i|])) &rfloor; which is then placed in bits
        8 &times; |i| through
        8 &times; |i| + 7 of the result.

  <tr algorithm="packing 2x16snorm">
    <td class="nowrap">`pack2x16snorm`(|e|: vec2&lt;f32&gt;) -> u32
    <td>Converts two normalized floating point values to 16-bit signed integers, and then combines them
        into one `u32` value.<br>
        Component |e|[|i|] of the input is converted to a 16-bit twos complement integer value
        &lfloor; 0.5 + 32767 &times; min(1, max(-1, |e|[|i|])) &rfloor; which is then placed in bits
        16 &times; |i| through
        16 &times; |i| + 15 of the result.

  <tr algorithm="packing 2x16unorm">
    <td class="nowrap">`pack2x16unorm`(|e|: vec2&lt;f32&gt;) -> u32
    <td>Converts two normalized floating point values to 16-bit unsigned integers, and then combines them
        into one `u32` value.<br>
        Component |e|[|i|] of the input is converted to a 16-bit unsigned integer value
        &lfloor; 0.5 + 65535 &times; min(1, max(0, |e|[|i|])) &rfloor; which is then placed in bits
        16 &times; |i| through
        16 &times; |i| + 15 of the result.

  <tr algorithm="packing 2x16float">
    <td class="nowrap">`pack2x16float`(|e|: vec2&lt;f32&gt;) -> u32
    <td>Converts two floating point values to half-precision floating point numbers, and then combines
        them into one one `u32` value.<br>
        Component |e|[|i|] of the input is converted to a [[!IEEE-754|IEEE-754]] binary16 value, which is then
        placed in bits
        16 &times; |i| through
        16 &times; |i| + 15 of the result.
        See [[#floating-point-conversion]].
</table>

## Data unpacking built-in functions ## {#unpack-builtin-functions}

Data unpacking builtin functions can be used to decode values in
data formats that do not correspond directly to types in [SHORTNAME].
This enables a program to read many densely packed values from memory, which can
reduce a shader's memory bandwidth demand.

<table class='data'>
  <thead>
    <tr><td>Overload<td>Description
  </thead>
  <tr algorithm="unpacking 4x8snorm">
    <td class="nowrap">`unpack4x8snorm`(|e|: u32) -> vec4&lt;f32&gt;
    <td>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br>
        Component |i| of the result is max(|v| &div; 127, -1), where |v| is the interpretation of
        bits 8&times;|i| through 8&times;|i|+7 of |e| as a twos-complement signed integer.

  <tr algorithm="unpacking 4x8unorm">
    <td class="nowrap">`unpack4x8unorm`(|e|: u32) -> vec4&lt;f32&gt;
    <td>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br>
        Component |i| of the result is |v| &div; 255, where |v| is the interpretation of
        bits 8&times;|i| through 8&times;|i|+7 of |e| as an unsigned integer.

  <tr algorithm="unpacking 2x16snorm">
    <td class="nowrap">`unpack2x16snorm`(|e|: u32) -> vec2&lt;f32&gt;
    <td>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br>
        Component |i| of the result is max(|v| &div; 32767, -1), where |v| is the interpretation of
        bits 16&times;|i| through 16&times;|i|+15 of |e| as a twos-complement signed integer.

  <tr algorithm="unpacking 2x16unorm">
    <td class="nowrap">`unpack2x16unorm`(|e|: u32) -> vec2&lt;f32&gt;
    <td>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br>
        Component |i| of the result is |v| &div; 65535, where |v| is the interpretation of
        bits 16&times;|i| through 16&times;|i|+15 of |e| as an unsigned integer.

  <tr algorithm="unpacking 2x16float">
    <td class="nowrap">`unpack2x16float`(|e|: u32) -> vec2&lt;f32&gt;
    <td>Decomposes a 32-bit value into two 16-bit chunks, and reinterpets each chunk
        as a floating point value.<br>
        Component |i| of the result is the f32 representation of |v|,
        where |v| is the interpretation of bits 16&times;|i| through 16&times;|i|+15 of |e|
        as an [[!IEEE-754|IEEE-754]] binary16 value.
        See [[#floating-point-conversion]].
</table>

## Synchronization built-in functions ## {#sync-builtin-functions}

[SHORTNAME] provides the following synchronization functions:

```rust
storageBarrier()
workgroupBarrier()
```

All synchronization functions execute a control barrier with Acquire/Release
memory ordering. That is, all synchronization functions, and affected memory
and atomic operations are ordered in [[#program-order]] relative to the
synchronization function.  Additionally, the affected memory and atomic
operations program-ordered before the synchronization function must be visible
to all other threads in the workgroup before any affected memory or atomic
operation program-ordered after the synchronization function is executed by a
member of the workgroup.
All synchronization functions must only be used in the [=compute=] shader stage.

storageBarrier affects memory and atomic operations in the [=storage
classes/storage=] storage class.

workgroupBarrier affects memory and atomic operations in the [=storage
classes/workgroup=] storage class.

TODO: Add links to the eventual memory model.

<div class='example spirv barrier mapping' heading="Mapping workgroupBarrier to SPIR-V">
  <xmp>
    storageBarrier();
    // Maps to:
    // Execution Scope is Workgroup = %uint_2
    // Memory Scope is Device = %uint_1
    // Memory Semantics are AcquireRelease | UniformMemory (0x8 | 0x40) = %uint_72
    // OpControlBarrier %uint_2 %uint_1 %uint_72

    workgroupBarrier();
    // Maps to:
    // Execution and Memory Scope are Workgroup = %uint_2
    // Memory semantics are AcquireRelease | WorkgroupMemory (0x8 | 0x100) = %uint_264
    // OpControlBarrier %uint_2 %uint_2 %uint_264

    workgroupBarrier();
    storageBarrier();
    // Or, equivalently:
    storageBarrier();
    workgroupBarrier();
    // Could be mapped to a single OpControlBarrier:
    // Execution scope is Workgroup = %uint_2
    // Memory Scope is Device = %uint_1
    // Memory semantics are AcquireRelease | UniformMemory | WorkgroupMemory
    //   (0x8 | 0x40 | 0x100) = %uint_328
    // OpControlBarrier %uint_2 %uint_1 %uint_328
  </xmp>
</div>


# MATERIAL TO BE MOVED TO A NEW HOME OR DELETED # {#junkyard}


[SHORTNAME] has operations for:

* creating a new composite value from an old one by replacing one of its components
