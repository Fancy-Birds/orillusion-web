<pre class='metadata'>
Title: WebGPU Shading Language
Shortname: WGSL
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/wgsl/
TR: https://www.w3.org/TR/WGSL/
Repository: gpuweb/gpuweb
Text Macro: INT i32 or u32
Text Macro: UNSIGNEDINTEGRAL u32 or vec|N|&lt;u32&gt;
Text Macro: SIGNEDINTEGRAL i32 or vec|N|&lt;i32&gt;
Text Macro: INTEGRAL i32, u32, vec|N|&lt;i32&gt;, or vec|N|&lt;u32&gt;
Text Macro: FLOATING f32 or vec|N|&lt;f32&gt;
Ignored Vars: i, e, e1, e2, e3, eN, N, M, v, Stride, Offset, Align, Extent, S, T, T1

!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new?labels=wgsl">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues?q=is%3Aissue+is%3Aopen+label%3Awgsl">open issues</a>)
!Translator: 赵凌云，lingyun.zhao@orillusion.com
!Translator: 薛沛，pei.xue@orillusion.com
Editor: David Neto, Google https://www.google.com, dneto@google.com, w3cid 99785
Editor: Myles C. Maxfield, Apple Inc., mmaxfield@apple.com, w3cid 77180
Former Editor: dan sinclair, Google https://www.google.com, dsinclair@google.com
Abstract: Shading language for WebGPU. WGSL 翻译文档。本翻译非官方翻译。
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Markup Shorthands: idl no
Assume Explicit For: yes
</pre>

<style>
tr:nth-child(2n) {
  background-color: #b0b0b050;
}
thead {
  background-color: #b0b0b050;
  font-weight: bold;
}
.nowrap {
  white-space:nowrap;
}
.small {
  font-size: smaller;
}
div.syntax {
  display: block;
  page-break-before: avoid;
  padding: .5em 1em;
  background: var(--def-bg);
  border-left: 0.5em solid var(--def-border);
  color: black;
  color: var(--def-text);
  margin-block-start: 1em;
  margin-block-end: 1em;
}
div.syntax > p {
  margin-block-start: 0em;
  margin-block-end: 0em;
  margin-inline-start: 1em;
  margin-inline-end: 0em;
}
div.syntax > p::first-letter {
  letter-spacing: 0.5em;
}
div.syntax > p > a {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
}
div.syntax > p > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
}
</style>

<pre class=biblio>
{
  "WebGPU": {
    "authors": [
      "Dzmitry Malyshau",
      "Justin Fan",
      "Kai Ninomiya"
    ],
    "href": "https://gpuweb.github.io/gpuweb/",
    "title": "WebGPU",
    "status": "Editor's Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "IEEE-754":{
    "href":"http://ieeexplore.ieee.org/servlet/opac?punumber=4610933",
    "title":"IEEE Standard for Floating-Point Arithmetic",
    "publisher":"Institute of Electrical and Electronics Engineers",
    "isbn":"978-0-7381-5752-8",
    "versions":["IEEE-754-2008","IEEE-754-1985"],
    "id":"IEEE-754",
    "date":"29 August 2008"
  },
  "SPIR-V": {
    "authors": [
      "John Kessenich",
      "Boaz Ouriel",
      "Raun Krisch"
    ],
    "href": "https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html",
    "title": "SPIR-V Specification",
    "publisher": "Khronos Group"
  },
  "VulkanMemoryModel": {
    "authors": [
      "Jeff Bolz",
      "Alan Baker",
      "Tobias Hector",
      "David Neto",
      "Robert Simpson",
      "Brian Sumner"
    ],
    "href": "https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model",
    "title": "Vulkan Memory Model",
    "publisher": "Khronos Group"
  }
}
</pre>

<pre class='anchors'>
spec: SPIR-V; urlPrefix: https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#
    type: dfn
        text: image formats; url: _a_id_image_format_a_image_format
</pre>

# 介绍 # {#intro}

WebGPU Shading Language ([SHORTNAME])是为 [[!WebGPU]] 设计的着色器语言。也就是说，使用 WebGPU API 的应用程序使用 [SHORTNAME] 来表达在 GPU 上运行的程序（称为着色器）。

<div class='example wgsl global-scope'>
  <xmp highlight='rust'>
    [[stage(fragment)]]
    fn main() -> [[location(0)]] vec4<f32> {
        return vec4<f32>(0.4, 0.4, 0.8, 1.0);
    }
  </xmp>
</div>


## 目标 ## {#goals}

 * 可轻松转换为 [[!SPIR-V]]
 * 构造被定义为其对应 [[!SPIR-V]] 的规范参考
 * WGSL 中的所有功能都可以直接转换为 [[!SPIR-V]]。（没有多态，没有通用指针，没有重载等）
 * 特性和语法完全同[[!SPIR-V]]
 * 本规范中的每一项都必须为构造提供到 [[!SPIR-V]] 的映射。

## 技术概览 ## {#technical-overview}

WebGPU 以[[WebGPU#gpu-command|GPU command]]的形式向 GPU 发出一个工作单元。[SHORTNAME] 关注两种 GPU 命令：
* <dfn noexport>draw command</dfn>在[=pipeline input|inputs=]、[=pipeline output|outputs=]和附加[=resources=]的上下文中执行[=GPUComputePipeline|compute pipeline=]。
* <dfn noexport>dispatch command</dfn>在[=GPUComputePipeline|compute pipeline=]和附加[=resources=]的上下文中执行[=GPUComputePipeline|compute pipeline=]。

这两种管线都使用以[SHORTNAME]编写的着色器。

<dfn noexport>shader</dfn>是WGSL程序的一部分，用于在管线中执行[=shader stage=]。着色器包括：
* 一个[=entry point=] [=function/function=]。
* 所有被调用函数的传递闭包，从入口点开始。该集合包括[=user-defined function|user-defined=]和[=built-in function|built-in=]函数。（有关更严格的定义，请参阅“[=functions in a shader stage=]”。）
* 所有这些函数静态访问（[=statically accessed=]）的一组变量和常量。
* 用于定义或分析所有这些函数、变量和常量的类型集。

执行着色器阶段时，实现：
* 将资源（[=resources=]）绑定到着色器资源接口([=resource interface of a shader|resource interface=])中的变量，使这些资源的内容在执行期间可供着色器使用。
* 为其他模块范围([=module scope|module-scope=])的变量分配内存，并使用指定的初始值填充该内存。
* 使用阶段的管线输入填充入口点的形式参数（如果存在）。
* 将入口点返回值([=return value=])（如果存在）连接到阶段的管线输出。
* 然后它调用入口点。

一个 [SHORTNAME] 程序被组织成：
* 函数，指定执行行为。
* 语句，是可执行行为的声明或单元。
* 文字，是纯数学值的文本表示。
* 常量，每个常量都为在特定时间计算的值提供一个名称。
* 变量，每个变量都为用于保存值的内存存储提供名称。
* 表达式，每个表达式组合一组值以生成结果值。
* 类型，每个类型描述：
    * 一组值。
    * 对受支持表达式的限制。
    * 这些表达式的语义。

[SHORTNAME]是一种命令式语言：行为被指定为要执行的语句序列。声明：
* 声明常量或变量
* 修改变量内容
* 使用结构化编程结构修改执行顺序：
    * 选择：if/else/elseif, switch
    * 重复：loop, for
    * 跳出：break, continue
    * 重构：函数调用和返回
    * 丢弃（仅限片元着色器）：终止调用并丢弃输出

* 评估表达式以计算值作为上述行为的一部分。

[SHORTNAME]是静态类型的：由特定表达式计算的每个值都属于特定类型，仅通过检查程序源来确定。

[SHORTNAME具有以数组和结构的形式描述布尔值、数字、向量、矩阵和它们的聚合的类型。其他类型描述内存。

[SHORTNAME]没有数字或布尔类型之间的隐式转换或提升。 将值从一种数字或布尔类型转换为另一种需要显式转换([[#conversion-expr|conversion]])、构造([[#type-constructor-expr|construction]])或重新解释位([[#bitcast-expr|reinterpretation of bits]])。这也适用于向量类型。

[SHORTNAME]有纹理和采样器类型。连同相关的内置函数，这些支持通常用于图形渲染的功能，并且通常由GPU提供。

着色器阶段的工作被划分为一个或多个调用（<dfn noexport>invocations</dfn>），每个调用都执行入口点，但条件略有不同。着色器阶段中的调用共享对某些变量的访问：
* 阶段中的所有调用共享着色器接口中的资源。
* 在计算着色器（[=compute shader stage|compute shader=]）中，同一工作组（[=compute shader stage/workgroup=]）中的调用共享工作组（[=storage classes/workgroup=]）存储类（[=storage class=]）中的变量。不同工作组中的调用不共享这些变量。

但是，调用作用于不同的管线输入集，包括提供识别值以将调用与其对等调用区分开的内置输入。此外，每个调用在私有（[=storage classes/private=]）和函数（[=storage classes/function=]）存储类中以变量的形式拥有自己独立的内存存储空间。

着色器阶段中的调用并发执行，并且通常可能并行执行。着色器作者负责确保着色器阶段调用的动态行为：

* 满足某些图元操作的一致性要求，包括纹理采样和控制屏障。
* 协调对共享变量的潜在冲突访问，以避免竞争条件。

[SHORTNAME]有时允许给定特征的几种可能行为。这是一种可移植性危害，因为不同的实现可能会表现出不同的行为。WGSL的设计旨在最大限度地减少此类情况，但受到可行性和在各种设备上实现高性能的目标的限制。

## 符号 ## {#notation}

<dfn noexport>floor expression</dfn>在实数|x|上定义：

* &lfloor;|x|&rfloor; = |k|, 其中|k|是一个唯一整数，使得|k| &le; |x| &lt; |k|+1

<dfn noexport>ceiling expression</dfn>在实数|x|上定义：

* &lceil;|x|&rceil; = |k|, 其中|k|是一个唯一整数，使得|k|-1 &lt; |x| &le; |k|

<dfn noexport>roundUp</dfn>函数在正整数|k|和|n|上定义：

* roundUp(|k|, |n|) = &lceil;|n| &div; |k|&rceil; &times; |k|

|n|列|m|行矩阵|A|的转置（<dfn noexport>transpose</dfn>）是将|A|的行复制为|A|<sup>T</sup>的列形成的|m|列|n|行矩阵|A|<sup>T</sup>：

* transpose(|A|) = |A|<sup>T</sup>
* transpose(|A|)<sub>|i|,|j|</sub> = |A|<sub>|j|,|i|</sub>

列向量的转置是通过将列向量解释为1行矩阵来定义的。类似地，行向量的转置是通过将行向量解释为1列矩阵来定义的。

# 着色器生命周期 # {#program-lifecycle}

[SHORTNAME]程序及其可能包含的着色器生命周期中有四个关键事件。前两个对应于用于准备[SHORTNAME]程序以供执行的WebGPU API方法。最后两个是着色器执行的开始和结束。

事件为：

1. <dfn noexport>Shader module creation</dfn>
    * 当[[WebGPU#dom-gpudevice-createshadermodule|WebGPU createShaderModule]]方法被调用后发生。此时[SHORTNAME]程序的源文件被提供。
2. <dfn noexport>Pipeline creation</dfn>
    * 当[[WebGPU#dom-gpudevice-createcomputepipeline|WebGPU createComputePipeline]]或[[WebGPU#dom-gpudevice-createrenderpipeline|WebGPU createRenderPipeline]]方法被调用时发生。这些方法使用一个或更多先前被创建的着色器模块，以及其他配置信息。
3. <dfn noexport>Shader execution start</dfn>
    * 当向GPU发出[=draw command|draw=]或[=dispatch command=]命令、开始执行管线并调用[=shader stage=] [=entry point=]函数时发生。
4. <dfn noexport>Shader execution end</dfn>
    * 当所有着色器中的工作被完成时发生：
        * 所有调用（[=invocations=]）完结。
        * 所有对资源（[=resources=]）的访问完结。
        * 输出（如果有）已经传递给下游管线阶段。

事件按照以下方式排序：
*  数据依赖：着色器执行需要一个管线，一个管线同样需要一个着色器模块。
*  因果关系：着色器必须开始执行才能完成执行。

## 处理错误 ## {#processing-errors}

一个WebGPU实现可能由于两个原因对着色器处理失败：

* 程序错误（<dfn export>program error</dfn>）当着色器不满足[SHORTNAME]或WebGPU规范要求时发生。
* 未分类错误（<dfn noexport>uncategorized error</dfn>）当所有[SHORTNAME]和WebGPU需求都被满足时可能发生，可能的原因包括：
    * 着色器太复杂，超出了实现的能力，但在某种程度上不容易被规定的限制（[[#limits|limits]]）捕获。 简化着色器可能会解决此问题。
    * WebGPU实现中的缺陷。

处理错误可能会发生在着色器生命周期的三个阶段：

* <dfn export>shader-creation error</dfn>是在着色器模块创建时可行检测到的错误。检测必须仅依赖于[SHORTNAME]程序源文本和其他可用于 `createShaderModule` API 方法的信息。

* <dfn export>pipeline-creation error</dfn>是在管线创建时可检测到的错误。检测必须仅依赖于特定管线创建API方法可用的[SHORTNAME]程序源文本和其他信息。

* <dfn export>dynamic error</dfn>是在着色器执行期间发生的错误。这些错误可能会也可能不会被检测到。

注意：比如，一个竞争条件可能不会被检测到。

每个要求将被尽早检查。也就是：
* 当未能满足着色器创建时可检测到的要求，会导致shader-creation错误。
* 当未能满足管线创建时可检测到的要求，但更早无法检测到，会导致pipeline-creation错误。

当上下文不清楚时，本规范会指出未能满足特定要求是否会导致着色器创建、管线创建或动态错误。

WebGPU规范描述了每种错误的后果。

TODO：更新WebGPU规范，参考这里定义的三种错误。

## 限制 ## {#limits}

一个程序必须满足以下限制：

<table class='data'>
  <caption>Quantifiable shader complexity limits</caption>
  <thead>
    <tr><th>Limit<th>Maximum value
  </thead>
    <tr><td>[=structure=]类型中的成员数量<td>16383
    <tr><td>[=composite=]类型中的[=Nesting depth=]<td>255
    <tr><td>一个函数[=formal parameter|parameters=]的数量<td>255
    <tr><td>[=statement/switch=]语句中条件选择值的数量<td>16383
</table>

# 纹理结构 # {#textual-structure}

[SHORTNAME]程序为文本。本规范并未规定该文本的特定编码。但是，UTF-8始终是[SHORTNAME]程序的有效编码。

注意：像这样推广 UTF-8 的目的是为了简化[SHORTNAME]程序的交换并鼓励工具之间的互操作性。

[SHORTNAME]程序文本由一系列字符组成，分组为连续的非空集形成：

* [=comments=]
* [=tokens=]
* [=blankspace=]

<dfn>Blankspace</dfn>是以下一个或多个字符的任意组合：
* space
* horizontal tab
* linefeed
* vertical tab
* formfeed
* carriage return

<div class='syntax' noexport='true'>
  <dfn for=syntax>_space</dfn> :

    | `/\s/`
</div>

问题：还有什么应该是blankspace？Unicode分隔符类别中的一些内容？

要解析一个[SHORTNAME]程序：
1. 去掉注释：
    * 用一个space字符替换第一个注释。
    * 重复直到没有注释。
2. 从头到尾扫描，以贪心的方式将剩余的字符分组为标记和空格：
    * 下一组由剩余未分组字符的最长非空前缀组成，即：
        * 一个有效的token, 或者
        * blankspace
    * 重复直到没有未分组的字符剩余。
3. 去掉blankspace，只留下tokens。
3. 解析token序列，尝试匹配 `translation_unit` 语法规则。

<div class='syntax' noexport='true'>
  <dfn for=syntax>translation_unit</dfn> :

    | [=syntax/global_decl_or_directive=] *
</div>

在以下情况下会导致[=shader-creation error=]：
* 整个源文本无法转换为有限的有效tokens序列，或
* `translation_unit` 语法规则与整个token序列不匹配。

## 注释 ## {#comments}

注释（<dfn>comment</dfn>）是一块不影响[SHORTNAME]程序有效性和含义的文本，只是注释可以分隔[=tokens=]。着色器作者可以使用注释去给程序添加文档信息。

行尾注释（<dfn noexport>line-ending comment</dfn>）是一种由两个字符 // 和后面的字符组成的注释，直到但不包括：
* 除[=blankspace=]或水平制表符之外的下一个空格字符，或
* 程序结尾

TODO(dneto)：合并块注释，per https://github.com/gpuweb/gpuweb/pull/1470

## 标记 ## {#tokens}

一个标记（<dfn>token</dfn>）是一系列连续字符构成以下内容：
* 一个[=literal=].
* 一个[=keyword=].
* 一个[=reserved word=].
* 一个[=syntactic token=].
* 一个[=identifier=].

## 文字 ## {#literals}

文字（<dfn>literal</dfn>）为一下之一：
* 用作表达数字的<dfn>numeric literal</dfn>
* 为 `true` 或 `false` 的<dfn noexport>boolean literal</dfn>

[=numeric literal=]的形式是通过模式匹配定义的：

<div class='syntax' noexport='true'>
  <dfn for=syntax>decimal_float_literal</dfn> :

    | `/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+)/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>hex_float_literal</dfn> :

    | `/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+))/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>int_literal</dfn> :

    | `/-?0x[0-9a-fA-F]+|0|-?[1-9][0-9]*/`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>uint_literal</dfn> :

    | `/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/`
</div>

注意：文字被贪心解析。这意味着对于像 `a -5` 这样的语句，这*不会*解析为 `a` `减` `5`，而是解析为 `a` `-5`，这可能是意外的。如果需要第一个表达式，则必须在 `-` 之后插入一个空格。

TODO(dneto)：描述数字文字标记如何映射到理想化值，然后映射到类型化值。

<div class='syntax' noexport='true'>
  <dfn for=syntax>const_literal</dfn> :

    | [=syntax/int_literal=]

    | [=syntax/uint_literal=]

    | [=syntax/float_literal=]

    | [=syntax/true=]

    | [=syntax/false=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>float_literal</dfn> :

    | [=syntax/decimal_float_literal=]

    | [=syntax/hex_float_literal=]
</div>


## 关键字 ## {#keywords}

一个关键字(<dfn>keyword</dfn>)是一个[=token=]，总是指代被预定义的语言概念。有关[SHORTNAME]关键字列表，请参阅[[#keyword-summary]]。

## 标识符 ## {#identifiers}

标识符（<dfn>identifier</dfn>）是一种用作名称的[=token=]，请参阅[[#declaration-and-scope]]和[[#directives]]。

标识符的形式是通过模式匹配定义的，但标识符：
 * 不得与 [=keyword=] 或 [=reserved word=] 拼写相同。
 * 不能是`_`（单个下划线）
 * 不能以两个下划线开头。

<div class='syntax' noexport='true'>
  <dfn for=syntax>ident</dfn> :

     | `/([a-zA-Z_][0-9a-zA-Z][0-9a-zA-Z_]*)|([a-zA-Z][0-9a-zA-Z_]*)/`
</div>

注意：某些 [=built-in functions=] 的 [=return type=] 是其名称不能用于 [SHORTNAME] 源的结构类型。
这些结构类型被描述为 [=predeclared=]，名称以两个下划线开头。
结果值可以使用类型推断保存到新声明的 `let` 或 `var` 中，或者立即通过名称立即提取其成员之一。 参见 `frexp` 和 `modf` 描述中的示例用法。

## 属性 ## {#attributes}

属性（<dfn noexport>attribute</dfn>）修改对象或类型。[SHORTNAME]为应用属性提供了统一的语法。属性用于多种目的，例如指定带有API的接口。一般来说，从语言的角度来看，出于类型和语义检查的目的，可以忽略属性。

对每个对象或类型，属性不能被多次指定。

<div class='syntax' noexport='true'>
  <dfn for=syntax>attribute_list</dfn> :

    | [=syntax/attr_left=] ( [=syntax/attribute=] [=syntax/comma=] ) * [=syntax/attribute=] [=syntax/attr_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>attribute</dfn> :

    | [=syntax/ident=] [=syntax/paren_left=] ( [=syntax/literal_or_ident=] [=syntax/comma=] ) * [=syntax/literal_or_ident=] [=syntax/paren_right=]

    | [=syntax/ident=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>literal_or_ident</dfn> :

    | [=syntax/float_literal=]

    | [=syntax/int_literal=]

    | [=syntax/uint_literal=]

    | [=syntax/ident=]
</div>

<table class='data'>
  <caption>Attributes defined in [SHORTNAME]</caption>
  <thead>
    <tr><th>Attribute<th>Valid Values<th>Description
  </thead>

  <tr><td><dfn noexport dfn-for="attribute">`align`</dfn>
    <td>正i32文字
    <td>必须仅应用于结构（[=structure=]）类型的成员。

    必须是2的幂。

    见内存布局[alignment and size](#alignment-and-size)。

  <tr><td><dfn noexport dfn-for="attribute">`binding`
    <td>非负i32文字
    <td>必须仅应用于资源（[=resource=]）变量。

    指定绑定组（[=attribute/group=]）中资源的绑定号。见[[#resource-interface]]。

  <tr><td><dfn noexport dfn-for="attribute">`block`</dfn>
    <td>*None*
    <td>必须仅应用于结构（[=structure=]）类型。

    表示这个结构类型代表了在着色器的资源接口（[=resource interface of a
    shader|shader's resource interface=]）中占用单个绑定槽的缓冲区资源的内容。

    `block` 属性必须应用于用作统一缓冲区（[=uniform buffer=]）或存储缓冲区（[=storage buffer=]）变量的存储类型（[=store type=]）的结构类型。

    具有 `block` 属性的结构类型不得为：
    * 数组（[=array=]）类型的元素类型
    * 另一个结构中的成员类型

  <tr><td><dfn noexport dfn-for="attribute">`builtin`
    <td>一个内置变量标识符
    <td>只能应用于入口点函数参数、入口点返回类型或结构（[=structure=]）成员。

    声明一个内置变量。见[[#builtin-variables]]。

  <tr><td><dfn noexport dfn-for="attribute">`group`
    <td>非负i32文字
    <td>必须仅应用于资源（[=resource=]）变量。

    指定资源的绑定组。见[[#resource-interface]]。

  <tr><td><dfn noexport dfn-for="attribute">`interpolate`
    <td>一个或两个参数。

    第一个参数必须是插值类型（[=interpolation type=]）。 第二个参数（如果存在）必须指定插值采样（[=interpolation sampling=]）。

    <td>

    只能应用于入口点函数参数、入口点返回类型或结构（[=structure=]）类型的成员。只能应用于浮点类型的标量或向量的声明。不得与计算（[=compute=]）着色器阶段一起使用。

    指定用户定义的IO如何必须插入。该属性仅对用户定义的顶点（[=vertex=]）输出和片元（[=fragment=]）输入有意义。见[[#interpolation]]。

  <tr><td><dfn noexport dfn-for="attribute"> `invariant`
    <td>*None*
    <td>

    仅应用于 `position` 内置变量。

    当应用于顶点着色器的位置内置输出变量（`position` [=built-in output variable=]）时，结果的计算在不同程序和同一入口点的不同调用之间是不变的。 也就是说，如果数据和控制流在不同入口点的两个位置输出匹配，则结果值保证相同。对位置内置输入变量（`position` [=built-in input variable=]）没有影响。

    注意：此属性映射到 SPIR-V 中的 `Invariant` 修饰、HLSL 中的 `precise` 限定符和GLSL中的 `invariant` 限定符。

  <tr><td><dfn noexport dfn-for="attribute">`location`
    <td>非负i32文字
    <td>仅应用于入口点函数参数、入口点返回类型或结构（[=structure=]）类型的成员。只能应用于数值标量（[=numeric scalar=]）或数值向量（[=numeric
    vector=]）类型的声明。不得与计算（[=compute=]）着色器阶段一起使用。

    指定入口点的用户定义IO的一部分。见[[#input-output-locations]]。

  <tr><td><dfn noexport dfn-for="attribute">`override`
    <td>一个可选的，非负i32文字
    <td>仅应用于标量（[=scalar=]）类型的模块范围常量声明。

    指定管线可覆盖（[=pipeline-overridable=]）的常量。在WebGPU API中，管线可覆盖常量由应用该属性的常量的标识符指定。 如果指定了可选参数，则管道可覆盖常量由指定的数字id引用。

  <tr><td><dfn noexport dfn-for="attribute">`size`</dfn>
    <td>正i32文字
    <td>
    仅应用于结构（[=structure=]）类型的成员。

    在结构中为此成员保留的字节数。

  <tr><td><dfn noexport dfn-for="attribute">`stage`</dfn>
    <td>`compute`, `vertex`, or `fragment`
    <td>

    仅应用于函数声明。
    通过指定其管线阶段声明入口点。

  <tr><td><dfn noexport dfn-for="attribute">`stride`</dfn>
    <td>正i32文字
    <td>

    仅应用于数组（[=array=]）类型。

    从数组的一个元素的开头到下一个元素的开头的字节数。

  <tr><td><dfn noexport dfn-for="attribute">`workgroup_size`</dfn>
    <td>

    一个，两个，或三个参数。

    每个参数是文字常量或模块范围常量（[[#module-constants|module-scope constant]]）。所有参数的类型必须相同，i32或u32。

    <td>

    必须应用于计算着色器（[=compute shader stage|compute shader=]）入口点函数。不得应用于任何其他对象。

    指定计算着色器的工作组网格（[=workgroup grid=]）的x、y和z维度。

    第一个参数指定x维度。第二个参数（如果提供）指定y维度，否则假设为1。第三个参数（如果提供）指定z维度，否则假设为1。每个维度必须至少为 1，最多为一个上限由WebGPU API指定的边界。

</table>


## 指令 ## {#directives}

指令（<dfn noexport>directive</dfn>）是一个[=token=]序列，它修改了WebGPU实现对[SHORTNAME]程序的处理方式。见[[#enable-directive-section]]。

## 声明和范围 ## {#declaration-and-scope}

声明（<dfn noexport>declaration</dfn>）将标识符（[=identifier=]）与以下类型的对象之一相关联：
* a type
* a value
* a variable
* a function
* a formal parameter

换句话说，声明引入了对象的名称（<dfn noexport>name</dfn>）。名称不能在在声明之前使用。

声明的范围（<dfn noexport>scope</dfn>）是一组程序位置，其中使用声明的标识符可能表示其关联对象。我们说标识符在那些源位置的（声明的）范围内（<dfn noexport>in scope</dfn>）。

每种声明都有自己的规则来确定其范围。通常，范围是在声明结束后立即开始的一段文本。

某些对象由WebGPU实现提供，并被视为已在[SHORTNAME]程序开始时声明。我们说这样的对象是预先声明的（<dfn noexport>predeclared</dfn>）。他们的范围是整个[SHORTNAME]程序。预先声明的对象的示例为：
* [=built-in functions=], and
* built-in types.

当该标识符已经在与该名称的另一个实例具有相同结束范围的范围内时，声明不得引入名称。 当标识符用于该名称的一个或多个声明的范围内时，标识符将表示最接近该用途的声明对象。我们说标识符使用解析（<dfn noexport>resolves</dfn>）为该声明。

注意：声明总是在其标识符的作用域之前。因此，最近的标识符作用域声明总是在标识符的使用之前。

<div class='example' heading='Valid and invalid declarations'>
  <xmp>
    // Invalid, cannot reuse built-in function names.
    var<private> modf: f32 = 0.0;

    // Valid, foo_1 is in scope until the end of the program.
    var<private> foo: f32 = 0.0; // foo_1

    // Valid, bar_1 is in scope until the end of the program.
    var<private> bar: u32 = 0u; // bar_1

    // Valid, my_func_1 is in scope until the end of the program.
    // Valid, foo_2 is in scope until the end of the function.
    fn my_func(foo: f32) { // my_func_1, foo_2
      // Any reference to 'foo' resolves to the function parameter.

      // Invalid, the scope of foo_2 ends at the of the function.
      var foo: f32; // foo_3

      // Valid, bar_2 is in scope until the end of the function.
      var bar: u32; // bar_2
      // References to 'bar' resolve to bar_2
      {
        // Valid, bar_3 is in scope until the end of the compound statement.
        var bar: u32; // bar_3
        // References to 'bar' resolve to bar_3

        // Invalid, bar_4 has the same end scope as bar_3.
        var bar: i32; // bar_4

        // Valid, i_1 is in scope until the end of the for loop
        for (var i: i32 = 0; i < 10; i = i + 1) { // i_1
          // Invalid, i_2 has the same end scope as i_1.
          var i: i32 = 1; // i_2.
        }
      }

      // Invalid, bar_5 has the same end scope as bar_2.
      var bar: u32; // bar_5
    }

    // Invalid, bar_6 has the same end scope as bar_1.
    var<private> bar: u32 = 1u; // bar_6

    // Invalid, my_func_2 has the same end scope as my_func_1.
    fn my_func() { } // my_func_2

    // Valid, my_foo_1 is in scope until the end of the program.
    fn my_foo(
      // Valid, my_foo_2 is in scope until the end of the function.
      my_foo: i32 // my_foo_2
    ) { }
  </xmp>
</div>

根据声明的方式和位置，有多个级别的范围。

使用标识符时，它必须在某些声明的范围内，或作为指令的一部分。

如果声明出现在任何其他声明的文本之外，则声明在模块范围（<dfn noexport>module scope</dfn>）内。

Note: 只有[=function declaration=]可以包含其他声明。

# 类型 # {#types}

程序计算值。

在[SHORTNAME]中，类型（<dfn noexport>type</dfn>）是一组值，每个值都属于一种类型。值的类型决定了可以对该值执行的操作的语法和语义。

例如，数学数字1对应于[SHORTNAME]中的三个不同值：
* 32-位有符号整数 `1`，
* 32-位无符号整数 `1u`，和
* 32-位浮点型数值 `1.0`。

[SHORTNAME]将它们视为不同的值，因为它们的机器表示和操作不同。

类型要么是预声明（[=predeclared=]）的，要么是通过声明（[=declaration=]）在WGSL源代码中创建的。

我们区分类型的*概念*和[SHORTNAME]中表示该类型的*语法*。在许多情况下，本规范中类型的拼写与其[SHORTNAME]语法相同。例如：
* 32-位无符号整数值的集合在本规范中拼写为 `u32`，在[SHORTNAME]程序中也一样。
* 结构类型或包含结构的类型的拼写不同。

一些[SHORTNAME]类型仅用于分析源程序和确定程序的运行时行为。本规范将描述此类类型，但它们不会出现在[SHORTNAME]源文本中。

注意：[SHORTNAME] [=reference types=]未写在[SHORTNAME]程序中。见[[#memory-view-types]]。

## 类型检查 ## {#type-checking-section}

[SHORTNAME]值是通过计算表达式来计算的。表达式（<dfn noexport>expression</dfn>）是解析为[SHORTNAME]语法规则之一的源文本片段，其名称以“`_expression`”结尾。表达式*E*可以包含子表达式（<dfn noexport>subexpressions</dfn>），这些子表达式是正确包含在外部表达式*E*中的表达式。

表达式求值产生的特定值取决于：
* <dfn noexport>static context</dfn>:
    表达式周围的源文本，以及
* <dfn noexport>dynamic context</dfn>:
    计算表达式的调用状态，以及调用在运行时的执行上下文。

计算特定表达式可能产生的值将始终属于特定的[SHORTNAME]类型，称为表达式的静态类型（<dfn noexport>static type</dfn>）。[SHORTNAME]的规则被设计为表达式的静态类型仅取决于表达式的静态上下文。

语句通常使用表达式，并且可能对这些表达式的静态类型提出要求。例如：
* `if` 语句的条件表达式必须为布尔（[=bool=]）类型。
* 在 `let` 声明中，初始值必须评估为常量的声明类型。

类型检查（<dfn noexport>Type checking</dfn>）成功解析[SHORTNAME]程序是将每个表达式映射至其静态类型，并确定每个语句的类型要求是否满足的过程。

类型断言（<dfn noexport>type assertion</dfn>）是从一些[SHORTNAME]源表达式到[SHORTNAME]类型的映射。符号

> *e* : *T*

是一个意思为*T*为[SHORTNAME]表达式*e*的静态类型的断言。

注意：类型断言是关于程序文本的事实陈述。它不是运行时的检查。

可以通过递归应用类型规则来查找表达式的静态类型。类型规则（<dfn noexport>type rule</dfn>）有两部分：
* 声明为对一个表达式的类型断言的结论。类型断言中的表达式是示意性指定的，使用*斜体*名称表示子表达式或其他语法确定的参数。
* 先决条件，包括：
    * 子表达式的类型断言，当有子表达式时。
    * 其他语义参数的条件，如果有的话。
    * 语句中表达是如何使用。
    * 可选择地，其他静态上下文。

一个类型规则适用于一个表达式（<dfn noexport>type rule applies to an expression</dfn>）当：
* 规则的结论与一个有效解析的表达式匹配，和
* 规则的先决条件被满足。

TODO：写一个例子，例如 `1+2` 或 `3 - a`，其中 `a` 在 `i32` 类型的let声明的范围内。

类型规则被设计成如果解析成功，最多一个类型规则将应用于每个表达式。如果类型规则适用于表达式，则结论被断言，从而确定表达式的静态类型。

一个[SHORTNAME]源程序为<dfn noexport>well-typed</dfn>当：
* 可以通过应用类型规则为程序中的每个表达式确定静态类型，并且
* 满足每个语句的类型要求

否则会出现类型错误（<dfn noexport>type error</dfn>）并且源程序不是有效的[SHORTNAME]程序。

[SHORTNAME]是一种静态类型语言（<dfn noexport>statically typed language</dfn>），因为 WGSL 程序的类型检查要么成功要么发现类型错误，而只需要检查程序源文本。

TODO(dneto): Lazy-decay是一个tie-breaking规则。上面的描述可以通过在潜在匹配类型规则上使用优先级来适应它。

### 类型规则表 ### {#typing-tables-section}

[SHORTNAME]类型规则（[=type rules=]）被组织成类型规则表（<dfn noexport>type rule tables</dfn>），每个类型规则占一行。

表达式的语义（<dfn noexport>semantics of an expression</dfn>）是对表达式求值的结果，主要是结果值的产生。 适用于表达式的类型规则的*描述*列将指定表达式的语义。语义通常取决于类型规则参数的值，包括任何子表达式的假定值。 有时，表达式的语义包括产生结果值以外的效果，例如其子表达式的非结果值效果。

TODO：示例：非结果值效应是函数调用子表达式的任何副作用。

## 普通类型 ## {#plain-types-section}

普通类型（[=Plain types=]）是用于表示布尔值、数字、向量、矩阵或这些值的聚合的类型。

普通类型（<dfn>plain type</dfn>）是一个标量（[=scalar=]）类型，一个原子（[=atomic type|atomic=]）类型，或一个复合（[=composite=]）类型。

注意：[SHORTNAME]中的普通类型类似于C++中的Plain-Old-Data类型，但也包括原子类型。

### 布尔类型 ### {#bool-type}

布尔（<dfn dfn noexport>bool</dfn>）类型包括值 `true` 和 `false`。

### 整数类型 ### {#integer-types}

<dfn dfn noexport>u32</dfn>类型为一组32-位无符号整数的集合。

<dfn noexport>i32</dfn>类型为一组32-位有符号整数的集合。它使用二进制补码表示，符号位位于最高有效位的位置。

### 浮点类型 ### {#floating-point-types}

<dfn noexport>f32</dfn>类型是一组[[!IEEE-754|IEEE-754]] binary32 （单精度）格式的32-位浮点型数值。详见[[#floating-point-evaluation]]。

### 标量类型 ### {#scalar-types}

标量（<dfn dfn noexport>scalar</dfn>）类型有[=bool=], [=i32=], [=u32=], 和[=f32=]。

数字标量（<dfn dfn noexport>numeric scalar</dfn>）类型有[=i32=], [=u32=], 和[=f32=]。

整数标量（<dfn dfn noexport>integer scalar</dfn>）有[=i32=]和[=u32=]。

### 向量类型 ### {#vector-types}

向量（<dfn noexport>vector</dfn>）是一组由2，3，或4个标量（[=scalar=]）组件构成的序列。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr><td>vec*N*<*T*><td>
  *N*个类型*T*元素构成的向量。*N*必须为{2, 3, 4}中的值，*T*必须为一种标量（[=scalar=]）类型。我们称*T*为向量的组件类型（<dfn noexport>component type</dfn>）。
</table>

当一个向量组件类型为数字标量（[=numeric scalar=]）时，我们称之为数字向量（<dfn dfn>numeric vector</dfn>）。

向量的关健用例包括：

* 同时表示方向和大小。
* 表示空间中的位置。
* 在某个颜色空间中表达一种颜色。例如，分量可以是红色、绿色和蓝色的强度，而第四个分量可以是alpha（不透明度）值。

向量上的许多操作都是按组件（<dfn noexport>component-wise</dfn>）进行的，即结果向量是通过对每个组件独立操作而形成的。

<div class='example wgsl type-scope' heading='Vector'>
  <xmp highlight='rust'>
    vec2<f32>  // 两个f32组成的向量。
  </xmp>
</div>

<div class='example component-wise addition' heading='Component-wise addition'>
  <xmp highlight='rust'>
    let x : vec3<f32> = a + b; // a 和 b 为 vec3<f32>
    // x[0] = a[0] + b[0]
    // x[1] = a[1] + b[1]
    // x[2] = a[2] + b[2]
  </xmp>
</div>

### 矩阵类型 ### {#matrix-types}

矩阵（<dfn noexport>matrix</dfn>）是一组由2，3，或4个浮点型向量组成的序列，

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="matrix type">
    <td>mat|N|x|M|&lt;f32&gt;
    <td>
        |N|列|M|行矩阵，|N|和|M|都为{2, 3, 4}中的值。等价地，它同样可以被看作|N|列vec|M|&lt;f32&gt;类型的向量。
</table>

矩阵的关键用例是体现线性变换。在这种解释中，矩阵的向量被视为列向量。

乘积操作符(`*`)可用于：

* 按标量大小缩放变换。
* 对一个向量应用变换。
* 与另一个矩阵组合变换。

见[[#arithmetic-expr]]。

<div class='example wgsl type-scope' heading='Matrix'>
  <xmp highlight='rust'>
    mat2x3<f32>  // 此为 2 列 3 行的 32-位浮点数矩阵。
                 // 等价地，此为 2 列类型 vec3<f32> 构成的向量。
  </xmp>
</div>

### 原子类型 ### {#atomic-types}

原子类型（<dfn noexport>atomic type</dfn>）封装了一个标量类型，使得：
* 原子对象为并发观察者提供了一定的保证，并且
* 对原子对象唯一有效的操作是原子内置函数（[[#atomic-builtin-functions|atomic builtin functions]]）。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="atomic type"><td>atomic&lt;|T|&gt;
    <td>类型|T|的原子。|T|必须为[=u32=]或[=i32=]。
</table>

表达式不得计算为原子类型。

原子类型只能由[=storage classes/workgroup=]存储类中的变量或具有[=access/read_write=]访问模式的存储缓冲区（[=storage buffer=]）变量实例化。

原子修改（<dfn noexport>atomic modification</dfn>）是对原子对象的任何设置对象内容的操作。即使新值与对象的现有值相同，该操作也算作修改。

在[SHORTNAME]中，对于每个对象，原子修改是相互排序的。也就是说，在着色器阶段的执行期间，对于每个原子对象*A*，所有代理都观察应用于*A* 的相同修改操作顺序。不同原子对象的顺序可能没有任何关系；没有任何因果关系。注意，工作组（[=storage classes/workgroup=]）存储中的变量在一个工作组（[=compute shader stage/workgroup=]）内共享，但在不同工作组之间不共享。

TODO: 添加链接最终的内存模型描述。

<div class='example storage atomic' heading='Mapping atomics in a storage variable to SPIR-V'>
  <xmp>
    [[block]] struct S {
      a: atomic<i32>;
      b: atomic<u32>;
    };

    [[group(0), binding(0)]]
    var<storage,read_write> x: S;

    // Maps to the following SPIR-V:
    // - When atomic types are members of a struct, the Volatile decoration
    //   is annotated on the member.
    // OpDecorate %S Block
    // OpMemberDecorate %S 0 Volatile
    // OpMemberDecorate %S 1 Volatile
    // ...
    // %i32 = OpTypeInt 32 1
    // %u32 = OpTypeInt 32 0
    // %S = OpTypeStruct %i32 %u32
    // %ptr_storage_S = OpTypePointer StorageBuffer %S
    // %x = OpVariable %ptr_storage_S StorageBuffer
  </xmp>
</div>

<div class='example workgroup atomic' heading='Mapping atomics in a workgroup variable to SPIR-V'>
  <xmp>
    var<workgroup> x: atomic<u32>;

    // Maps to the following SPIR-V:
    // - When atomic types are directly instantiated by a variable,  the Volatile
    //   decoration is annotated on the OpVariable.
    // OpDecorate %x Volatile
    // ...
    // %u32 = OpTypeInt 32 0
    // %ptr_workgroup_u32 = OpTypePointer Workgroup %S
    // %x = OpVariable %ptr_workgroup_u32 Workgroup
  </xmp>
</div>


### 数组类型 ### {#array-types}

数组（<dfn noexport>array</dfn>）是一组可索引的元素值。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr><td algorithm="fixed-size array type">array&lt;|E|,|N|&gt;
      <td>
          |N|个类型为|E|的元素组成的固定大小数组（<dfn>fixed-size array</dfn>。
          <br>
          |N|被称为数组的元素计数（<dfn noexport>element count</dfn>）。
  <tr><td algorithm="runtime-sized array type">array&lt;|E|&gt;
      <td>
          由类型|E|元素构成的<dfn noexport>runtime-sized</dfn>数组。它们仅出现在特定上下文中。
          <br>
</table>

当被指定，元素计数表达式|N|必须：
* 是一个文字，或者为不[=pipeline-overridable=]的[[#module-constants|module-scope constant]]的名称，以及
* 计算为一个大于零的整数标量（[=integer scalar=]）。

注意：元素计数在[=shader module creation=]时已被完全确定。

当且仅当以下所有条件都为真时，两种数组类型是相同的：
* 它们拥有相同的元素类型。
* 它们的元素计数规范匹配，即以下任一情况为真：
    * 它们都是runtime-sized。
    * 它们都是fixed-sized，具有等值的元素计数，即使一个是有符号的，另外是无符号的。（在这种情况下，有符号和无符号值是可比较的，因为元素计数必须大于零。）

问题：如果数组类型具有不同的元素步幅，则它们应该不同。见https://github.com/gpuweb/gpuweb/issues/1534

<div class='example fixed-size array types' heading='Example fixed-size array types'>
  <xmp>
    // array<f32,8> and array<i32,8> are different types:
    // different element types
    var<private> a: array<f32,8>;
    var<private> b: array<i32,8>;
    var<private> c: array<i32,8u>;  // array<i32,8> and array<i32,8u> are the same type

    let width = 8;
    let height = 8;

    // array<i32,8>, array<i32,8u>, and array<i32,width> are the same type.
    // Their element counts evaluate to 8.
    var<private> d: array<i32,width>;

    // array<i32,height> and array<i32,width> are the same type.
    var<private> e: array<i32,width>;
    var<private> f: array<i32,height>;
  </xmp>
</div>

数组中的第一个元素位于索引 0 处，每个后续元素位于下一个整数索引处。见[[#array-access-expr]]。

一个数组元素类型必须为以下之一：
* 标量（[=scalar=]）类型
* 向量类型
* 矩阵类型
* 原子（[=atomic type|atomic=]）类型
* 数组类型
* 结构（[=structure=]）类型

注意：也就是说，元素类型必须为普通类型（[=plain type=]）。

[SHORTNAME]定义了以下可应用于数组类型的属性：
* [=attribute/stride=]

runtime-sized数组局限：
* 定义[=storage classes/storage=]存储类中变量的存储类型（[=store type=]）的结构类型的最后一个成员可能是runtime-sized数组。
* 在任何其他情况下，不得将runtime-sized数组用作存储类型或包含在存储类型中。
* 一个表达式不能计算为一个runtime-sized数组类型。

<div class='syntax' noexport='true'>
  <dfn for=syntax>array_type_decl</dfn> :

    | [=syntax/attribute_list=] * [=syntax/array=] [=syntax/less_than=] [=syntax/type_decl=] ( [=syntax/comma=] [=syntax/element_count_expression=] ) ? [=syntax/greater_than=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>element_count_expression</dfn> :

    | [=syntax/int_literal=]

    | [=syntax/uint_literal=]

    | [=syntax/ident=]
</div>

### 结构类型 ### {#struct-types}

<dfn noexport>structure</dfn>是一组已命名的成员值。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="structure type">
      <td>struct&lt;|T|<sub>1</sub>,...,|T|<sub>N</sub>&gt;
      <td>
          类型为|T|<sub>1</sub>到|T|<sub>N</sub>的*N*个成员的有序元组，其中*N*是大于0的整数。结构类型声明为每个成员指定标识符（[=identifier=]）名称。相同结构类型的两个成员不得具有相同的名称。
</table>

一个结构成员类型必须为以下之一：
* 标量（[=scalar=]）类型
* 向量类型
* 矩阵类型
* 原子（[=atomic type|atomic=]）类型
* 数组类型
* 结构（[=structure=]）类型

注意：也就是说，任何成员类型必须为普通类型（[=plain type=]）。

注意：结构成员类型限制和数组元素类型限制是相辅相成的。 结合起来，它们意味着指针可能不会出现在数组或结构内的任何嵌套级别中。 同样，相同的限制也适用于纹理和采样器。

<div class='example wgsl global-scope' heading="Structure">
  <xmp highlight='rust'>
    // 拥有两个成员的结构
    struct Data {
      a: i32;
      b: vec2<f32>;
    };
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_decl</dfn> :

    | [=syntax/attribute_list=] * [=syntax/struct=] [=syntax/ident=] [=syntax/struct_body_decl=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_body_decl</dfn> :

    | [=syntax/brace_left=] [=syntax/struct_member=] * [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_member</dfn> :

    | [=syntax/attribute_list=] * [=syntax/variable_ident_decl=] [=syntax/semicolon=]
</div>

[SHORTNAME]定义了以下可应用于结构类型的属性：
 * [=attribute/block=]

[SHORTNAME]定义了以下可应用于结构成员的属性：
 * [=attribute/builtin=]
 * [=attribute/location=]
 * [=attribute/stride=]
 * [=attribute/align=]
 * [=attribute/size=]

注意：如果结构类型用于定义统一缓冲区（[=uniform buffer=]）或存储缓冲区（[=storage buffer=]），则可能需要布局属性。见[[#memory-layouts]]。

<div class='example wgsl global-scope' heading='Structure WGSL'>
  <xmp>
    struct my_struct {
      a: f32;
      b: vec4<f32>;
    };
  </xmp>
</div>

<div class='example spirv' heading='Structure SPIR-V'>
  <xmp>
                  OpName %my_struct "my_struct"
                  OpMemberName %my_struct 0 "a"
                  OpMemberDecorate %my_struct 0 Offset 0
                  OpMemberName %my_struct 1 "b"
                  OpMemberDecorate %my_struct 1 Offset 4
     %my_struct = OpTypeStruct %float %v4float
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Structure WGSL'>
  <xmp>
    // Runtime Array
    type RTArr = [[stride(16)]] array<vec4<f32>>;
    [[block]] struct S {
      a: f32;
      b: f32;
      data: RTArr;
    };
  </xmp>
</div>

<div class='example spirv' heading='Structure SPIR-V'>
  <xmp>
                  OpName %my_struct "my_struct"
                  OpMemberName %my_struct 0 "a"
                  OpMemberDecorate %my_struct 0 Offset 0
                  OpMemberName %my_struct 1 "b"
                  OpMemberDecorate %my_struct 1 Offset 4
                  OpMemberName %my_struct 2 "data"
                  OpMemberDecorate %my_struct 2 Offset 16
                  OpDecorate %rt_arr ArrayStride 16
        %rt_arr = OpTypeRuntimeArray %v4float
     %my_struct = OpTypeStruct %float %v4float %rt_arr
  </xmp>
</div>

### 复合类型 ### {#composite-types}

如果一个类型内部结构表达为其他类型的复合，则其为复合的（<dfn noexport>composite</dfn>）。内部部分不重叠，并称为组件（<dfn noexport>components</dfn>）。

复合类型为：

* [=vector=]类型
* [=matrix=]类型
* [=array=]类型
* [=structure=]类型

对于一个复合类型|T|，|T|的<dfn>nesting depth</dfn>，写作*NestDepth*(|T|)为：
* 对向量类型，为1
* 对矩阵类型，为2
* 对类型为|E|的数组类型，1 + *NestDepth*(|E|)
* 成员类型为*M*<sub>1</sub>,...,*M*<sub>1</sub>的结构类型|T|，1 + max(*NestDepth*(*M*<sub>1</sub>),..., *NestDepth*(*M*<sub>N</sub>))


### 可构造类型 ### {#constructible-types}

多种类型的数值可以被创建，加载，存储，传递至函数，以及作为函数返回值。
我们称之为可构造的（[=constructible=]）。

一个类型为可构造的（<dfn>constructible</dfn>）如果其为以下之一：
* [=scalar=]类型
* [=vector=]类型
* [=matrix=]类型
* [=fixed-size array=]类型，如果其元素类型为可构造的。
* [=structure=]类型, 如果它的全部成员都为可构造的。

注意：所有可构造类型为普通类型（[=plain types|plain=]）。

注意：原子类型和runtime-sized数组类型是不可构造的。包含原子和runtime-sized数组的复合类型是不可构造的。

## 内存 ## {#memory}

[SHORTNAME]中，可存储类型的值可以存储在内存中，以供以后检索。本节介绍内存的结构，以及如何使用[SHORTNAME]类型来描述内存的内容。

一般来说，[SHORTNAME]遵循[[!VulkanMemoryModel|Vulkan Memory Model]]。

### 内存位置 ### {#memory-locations-section}

内存由一组不同的内存位置（<dfn noexport>memory locations</dfn>）组成。每个内存位置的大小为8位。影响内存的操作与一组由一个或多个组成的内存位置交互。

如果两组存储器位置的交集非空，则两组存储器位置重叠（<dfn noexport>overlap</dfn>）。每个变量声明都有一组内存位置，不会与任何其他变量声明的内存位置集重叠。对结构和数组的内存操作可以访问元素之间的填充，但不得访问结构或数组末尾的填充。

### 内存访问模式 ### {#memory-access-mode}

内存访问（<dfn noexport>memory access</dfn>）是一种作用于内存位置的操作。

* 读操作（<dfn noexport>read access</dfn>）观察内存位置的内容。
* 写操作（<dfn noexport>write access</dfn>）设置内存位置的内容。

单个操作可以为读，写，或读与写。

特定的内存位置可能只支持某些类型的访问，表示为内存的访问模式（<dfn noexport>access mode</dfn>）：

: <dfn noexport dfn-for="access">read</dfn>
:: 支持读访问，但不是写。
: <dfn noexport dfn-for="access">write</dfn>
:: 支持写访问，但不是读。
: <dfn noexport dfn-for="access">read_write</dfn>
:: 读写访问都支持。

<div class='syntax' noexport='true'>
  <dfn for=syntax>access_mode</dfn> :

    | [=syntax/read=]

    | [=syntax/write=]

    | [=syntax/read_write=]
</div>

### 可存储类型 ### {#storable-types}

变量（[=variable=]）中包含的值必须是可存储（[=storable=]）类型。可存储类型可能具有WGSL定义的显式表示，如[[#internal-value-layout]]中所述，或者它可能是不透明的，例如纹理和采样器。

如果一个类型为以下之一，其为可存储的（<dfn dfn noexport>storable</dfn>）

* 标量（[=scalar=]）类型
* 向量（[=vector=]）类型
* 矩阵（[=matrix=]）类型
* 原子（[=atomic type|atomic=]）类型
* 数组（[=array=]）类型
* 结构（[=structure=]）类型
* 纹理（[=texture=]）类型
* 采样器（[=sampler=]）类型

注意：也就是说，可存储类型是普通类型（[=plain types=]）、纹理类型和采样器类型。

### IO可共享类型 ### {#io-shareable-types}

管线输入和输出值必须为IO可共享类型。

一个类型是IO可共享的（<dfn dfn noexport>IO-shareable</dfn>）当其为以下之一：

* 标量（[=scalar=]）类型
* 数值向量（[=numeric vector=]）类型
* 结构（[=structure=]）类型，如果其成员全部为标量（[=scalars=]）或数值向量（[=numeric vectors=]）。

以下类型的值必须是IO可共享类型：

* 从内置变量读取或写入的值。
* 接受作为来自上游管线阶段的输入的值。
* 作为管线中下游处理的输出或输出附件写入的值。

注意：只有内置管线输入可能具有布尔类型。用户输入或输出数据属性不得为[=bool=]类型或包含[=bool=]类型。见[[#pipeline-inputs-outputs]]。

### 主机可共享类型 ### {#host-shareable-types}

主机可共享类型用于描述在主机和GPU之间共享的缓冲区内容，或者在主机和GPU之间复制而无需格式转换的内容。 用于此目的时，该类型必须额外使用布局属性进行修饰，如[[#memory-layouts]]中所述。 我们将在[[#module-scope-variables]]中看到统一缓冲区（[=uniform buffer=]）和存储缓冲区（[=storage buffer=]）变量的存储类型（[=store type=]）必须是主机可共享的。

类型为主机可共享的（<dfn dfn noexport>host-shareable</dfn>）当其为以下之一：

* 数值标量（[=numeric scalar=]）类型
* 数值向量（[=numeric vector=]）类型
* 矩阵（[=matrix=]）类型
* 原子（[=atomic type|atomic=]）类型
* [=fixed-size array=]类型，如果其元素类型为主机可共享的
* [=runtime-sized=]数组类型，如果其元素类型为主机可共享的
* 结构（[=structure=]）类型，如果其所有元素为主机可共享的。

[SHORTNAME]定义了以下影响内存布局的属性：
 * [=attribute/stride=]
 * [=attribute/align=]
 * [=attribute/size=]

注意：当[=IO-shareable=]类型*T*不是[=bool=]并且不包含[=bool=]时，其为主机可共享的。许多类型为主机可共享的，但不是IO可共享的，包括原子类型（[=atomic types=]），[=runtime-sized=]数组，以及任何包含它们的复合类型。


注意：IO可共享类型和主机可共享类型都具有具体大小，但是各自计数。IO可共享类型的大小由位置计数指标决定，见[[#input-output-locations]]。主机可共享类型的大小由字节计数指标决定，见[[#memory-layouts]]。

### 存储类 ### {#storage-class}

内存位置被划分为存储类（<dfn noexport>storage classes</dfn>）。每个存储类都具有确定可变性、可见性、它可能包含的值以及如何使用变量的单独属性。

<table class='data' id="storage-class-table">
  <caption>Storage Classes</caption>
  <thead>
    <tr><th>Storage class
        <th>Sharing among invocations
        <th>Supported access modes
        <th>Variable scope
        <th>Restrictions on stored values
        <th>Notes
  </thead>
  <tr><td><dfn noexport dfn-for="storage classes">function</dfn>
      <td>仅相同调用
      <td>[=access/read_write=]
      <td>[=Function scope=]
      <td>[=Constructible=]类型
      <td>
  <tr><td><dfn noexport dfn-for="storage classes">private</dfn>
      <td>仅相同调用
      <td>[=access/read_write=]
      <td>[=Module scope=]
      <td>[=Constructible=]类型
      <td>
      <td>
  <tr><td><dfn noexport dfn-for="storage classes">workgroup</dfn>
      <td>相同[=compute shader stage|compute shader=] [=compute shader stage/workgroup=]中的调用
      <td>[=access/read_write=]
      <td>[=Module scope=]
      <td>[=Plain type=]，不包括[=runtime-sized=]数组，或包含runtime-sized数组的[=composite=]类型。
      <td>
  <tr><td><dfn noexport dfn-for="storage classes">uniform</dfn>
      <td>相同[=shader stage=]中的调用
      <td>[=access/read=]
      <td>[=Module scope=]
      <td>[=Constructible=] [=host-shareable=]类型
      <td>对[=uniform buffer=]变量
  <tr><td><dfn noexport dfn-for="storage classes">storage</dfn>
      <td>相同[=shader stage=]中的调用
      <td> [=access/read_write=], [=access/read=] (default)
      <td>[=Module scope=]
      <td>[=Host-shareable=]
      <td>对[=storage buffer=]变量
  <tr><td><dfn noexport dfn-for="storage classes">handle</dfn>
      <td>相同着色器阶段中的调用
      <td>[=access/read=]
      <td>[=Module scope=]
      <td>[=Sampler=]类型或[=texture=]类型
      <td>对[=sampler=]和纹理变量<br>
</table>

注意：标记 `handle` 被保留：它在[SHORTNAME]程序中从不被使用。

注意：纹理变量包含一个不透明的句柄，用于访问底层的纹素网格。句柄本身始终是只读的。在大多数情况下，底层纹素是只读的。对于只写存储纹理，底层纹素是只写的。

<div class='syntax' noexport='true'>
  <dfn for=syntax>storage_class</dfn> :

    | [=syntax/function=]

    | [=syntax/private=]

    | [=syntax/workgroup=]

    | [=syntax/uniform=]

    | [=syntax/storage=]
</div>

<table class='data'>
  <thead>
    <tr><th>WGSL storage class<th>SPIR-V storage class
  </thead>
  <tr><td>uniform<td>Uniform
  <tr><td>workgroup<td>Workgroup
  <tr><td>handle<td>UniformConstant
  <tr><td>storage<td>StorageBuffer
  <tr><td>private<td>Private
  <tr><td>function<td>Function
</table>


### 内存布局 ### {#memory-layouts}

统一缓冲区（[=Uniform buffer=]）和存储缓冲区（[=storage buffer=]）变量用于共享在内存中组织为字节序列的批量数据。缓冲区在 CPU 和 GPU 之间共享，或在管线中的不同着色器阶段之间，或在不同管线之间共享。

由于缓冲区数据无需重新格式化或转换即可共享，缓冲区生产者和消费者必须就<dfn noexport>memory layout</dfn>达成一致，
这是如何将缓冲区中的字节组织成类型化的[SHORTNAME]值的描述。

缓冲区变量的存储类型（[=store type=]）必须是主机可共享的（[=host-shareable=]），具有完全详细的内存布局，如下所述。

每个缓冲区变量必须在[=storage classes/uniform=]或[=storage classes/storage=]存储类中声明。

类型的内存布局仅在评估具有以下内容的表达式时才有意义：
* [=storage classes/uniform=]或[=storage classes/storage=]存储类中的变量，或
* 指向[=storage classes/uniform=]或[=storage classes/storage=]存储类的指针。

一个8位字节是[=host-shareable=]内存的最基本单位。本节中定义的术语表示 8 位字节的计数。

我们将使用以下符号：
* <dfn noexport>AlignOf</dfn>(|T|)是主机共享类型|T|的对齐方式。
* <dfn noexport>AlignOfMember</dfn>(|S|，|M|) 是主机共享结构|S|的成员|M|的对齐方式。
* <dfn noexport>SizeOf</dfn>(|T|) 是主机共享类型|T|的大小。
* <dfn noexport>SizeOfMember</dfn>(|S|，|M|) 是主机共享结构|S|的成员|M|的大小。
* <dfn noexport>StrideOf</dfn>(|A|) 是主机可共享数组类型|A|的[=element stride=]。
* <dfn noexport>OffsetOfMember</dfn>(|S|，|M|) 是成员|M|从主机共享结构|S|开始的偏移量。

#### 对齐和大小 ####  {#alignment-and-size}

每个[=host-shareable=]数据类型|T|有一个对齐和大小值，分别用[=AlignOf=](|T|)和[=SizeOf=](|T|)表示。

对齐保证值在内存中的地址将是指定值的倍数。 这可以启用更高效的硬件指令来访问值或满足对某些存储类的更严格的硬件要求。（见[存储类布局约束](#storage-class-layout-constraints)）。

注意：根据构造，每个对齐值始终是2的幂。

类型或结构成员的大小是主机可共享内存中为存储类型或结构成员的值而保留的连续字节数。大小可能包括类型末尾的不可寻址填充。 因此，值的加载和存储访问的内存位置可能少于值的大小。

主机可共享类型的对齐方式和大小在下表中递归定义：

<table class='data'>
  <caption>
    Alignment and size for host-shareable types<br>
  </caption>
  <thead>
    <tr><th>Host-shareable type |T|
        <th>[=AlignOf=](|T|)
        <th>[=SizeOf=](|T|)
  </thead>
  <tr><td>[=i32=], [=u32=], or [=f32=]
      <td>4
      <td>4
  <tr><td>atomic&lt;|T|&gt;
      <td>4
      <td>4
  <tr><td>vec2&lt;|T|&gt;
      <td>8
      <td>8
  <tr><td>vec3&lt;|T|&gt;
      <td>16
      <td>12
  <tr><td>vec4&lt;|T|&gt;
      <td>16
      <td>16
  <tr><td>mat|N|x|M| (col-major)<br>
      <p class="small">(General form)</p>
      <td>[=AlignOf=](vec|M|)
      <td>[=SizeOf=](array&lt;vec|M|, |N|&gt;)
  <tr><td>mat2x2&lt;f32&gt;
      <td>8
      <td>16
  <tr><td>mat3x2&lt;f32&gt;
      <td>8
      <td>24
  <tr><td>mat4x2&lt;f32&gt;
      <td>8
      <td>32
  <tr><td>mat2x3&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat3x3&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat4x3&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat2x4&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat3x4&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat4x4&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>struct |S|
      <td>max([=AlignOfMember=](S, M<sub>1</sub>), ... , [=AlignOfMember=](S, M<sub>N</sub>))<br>
      <td>[=roundUp=]([=AlignOf=](|S|), [=OffsetOfMember=](|S|, |L|) + [=SizeOfMember=](|S|, |L|))<br><br>
          其中|L|是结构中的最后一个成员
  <tr><td>array<|E|, |N|><br>
      <p class="small">(Implicit stride)</p>
      <td>[=AlignOf=](|E|)
      <td>|N| * [=roundUp=]([=AlignOf=](|E|), [=SizeOf=](|E|))
  <tr><td>array<|E|><br>
      <p class="small">(Implicit stride)</p>
      <td>[=AlignOf=](|E|)
      <td>N<sub>runtime</sub> * [=roundUp=]([=AlignOf=](|E|), [=SizeOf=](|E|))<br><br>
          其中N<sub>runtime</sub>是运行时确定的|T|元素数。
  <tr><td>[[[=attribute/stride=](|Q|)]]<br> array<|E|, |N|>
      <td>[=AlignOf=](|E|)
      <td>|N| * |Q|
  <tr><td>[[[=attribute/stride=](|Q|)]]<br> array<|E|>
      <td>[=AlignOf=](|E|)
      <td>N<sub>runtime</sub> * |Q|
</table>


#### 结构布局规则 ####  {#structure-layout-rules}

每个结构|S|成员M<sub>N</sub>都有一个大小和对齐值，分别由[=SizeOfMember=](|S|, M<sub>N</sub>)和[=AlignOfMember=](|S|, M<sub>N</sub>)表示。成员大小和对齐方式用于计算每个成员从结构开始的字节偏移量。

结构成员大小和对齐值默认为成员类型 `T` 的[=SizeOf=](T)和[=AlignOf=](T)值。

如果结构成员使用[=attribute/size=]装饰进行装饰，则结构成员将使用装饰的值作为其大小而不是其类型的大小。

如果结构成员使用[=attribute/align=]装饰进行装饰，则结构成员将使用装饰的值进行对齐而不是类型的对齐。

第一个结构成员从结构开头的偏移量始终为零字节。

后续成员从结构的开头具有以下字节偏移量：
<p algorithm="structure member offset">
  [=OffsetOfMember=](|S|, M<sub>N</sub>) = [=roundUp=]([=AlignOfMember=](|S|, M<sub>N</sub>), [=OffsetOfMember=](|S|, M<sub>N-1</sub>) + [=SizeOfMember=](|S|, M<sub>N-1</sub>)<br>
  其中M<sub>N</sub>为当前成员，M<sub>N-1</sub>为前一个成员。
</p>

结构成员不能重叠。如果一个结构成员被[=attribute/size=]属性装饰，值必须至少和成员类型的大小一样大。

<p algorithm="member size constraint">
  [=SizeOfMember=](|S|, M<sub>N</sub>) &ge; [=SizeOf=](T)<br>
  其中|T|为成员M<sub>N</sub>的类型。
</p>

结构的对齐等于其所有成员的最大对齐：
<p algorithm="structure alignment">
  [=AlignOf=](|S|) = max([=AlignOfMember=](|S|, M<sub>1</sub>), ... , [=AlignOfMember=](|S|, M<sub>N</sub>))
</p>

结构的大小等于偏移量加上其最后一个成员的大小，四舍五入为结构对齐的下一个倍数：
<p algorithm="structure size">
  [=SizeOf=](|S|) = [=roundUp=]([=AlignOf=](|S|), [=OffsetOfMember=](|S|, |L|) + [=SizeOfMember=](|S|, |L|))<br>
  其中|L|是结构的最后一个成员
</p>

<div class='example wgsl' heading='Layout of structures using implicit member sizes, alignments and strides'>
  <xmp highlight='rust'>
    struct A {                                     //             align(8)  size(24)
        u: f32;                                    // offset(0)   align(4)  size(4)
        v: f32;                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>;                              // offset(8)   align(8)  size(8)
        x: f32;                                    // offset(16)  align(4)  size(4)
        // -- implicit struct size padding --      // offset(20)            size(4)
    };

    [[block]] struct B {                           //             align(16) size(160)
        a: vec2<f32>;                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>;                              // offset(16)  align(16) size(12)
        c: f32;                                    // offset(28)  align(4)  size(4)
        d: f32;                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(12)
        e: A;                                      // offset(40)  align(8)  size(24)
        f: vec3<f32>;                              // offset(64)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(76)            size(4)
        g: array<A, 3>;                            // offset(80)  align(8)  size(72) stride(24)
        h: i32;                                    // offset(152) align(4)  size(4)
        // -- implicit struct size padding --      // offset(156)           size(4)
    };

    [[group(0), binding(0)]]
    var<storage,read_write> storage_buffer: B;
  </xmp>
</div>

<div class='example wgsl' heading='Layout of structures with explicit member sizes, alignments and strides'>
  <xmp highlight='rust'>
    struct A {                                     //             align(8)  size(32)
        u: f32;                                    // offset(0)   align(4)  size(4)
        v: f32;                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>;                              // offset(8)   align(8)  size(8)
        [[size(16)]] x: f32;                       // offset(16)  align(4)  size(16)
    };

    [[block]] struct B {                           //             align(16) size(208)
        a: vec2<f32>;                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>;                              // offset(16)  align(16) size(12)
        c: f32;                                    // offset(28)  align(4)  size(4)
        d: f32;                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(12)
        [[align(16)]] e: A;                        // offset(48)  align(16) size(32)
        f: vec3<f32>;                              // offset(80)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(92)            size(4)
        g: [[stride(32)]] array<A, 3>;             // offset(96)  align(8)  size(96)
        h: i32;                                    // offset(192) align(4)  size(4)
        // -- implicit struct size padding --      // offset(196)           size(12)
    };

    [[group(0), binding(0)]]
    var<uniform> uniform_buffer: B;
  </xmp>
</div>

#### 数组布局规则 ####  {#array-layout-rules}

第一个数组元素从数组开头的偏移量始终为零字节。

数组的元素步幅（<dfn noexport>element stride</dfn>）是从一个数组元素的开头到下一个元素的开头的字节数。 确定如下：
* 如果指定，它是类型上显式步幅（[=attribute/stride=]）属性的值。
* 否则，它是隐式步幅，等于数组元素类型的大小，四舍五入到元素类型的对齐方式：

<p algorithm="array implicit element stride">
  [=StrideOf=](array<|T|[, |N|]>) = [=roundUp=]([=AlignOf=](T), [=SizeOf=](T))
</p>

在所有情况下，数组元素步幅必须是元素对齐的倍数。

<div class='example wgsl' heading='Implicit / explicit array element strides'>
  <xmp highlight='rust'>
    // 具有 16 字节隐式元素步幅的数组
    var implicit_stride: array<vec3<f32>, 8>;

    // 具有 32 字节显式元素步幅的数组
    var explicit_stride: [[stride(32)]] array<vec3<f32>, 8>;
  </xmp>
</div>

用[=attribute/stride=]属性修饰的数组的步幅必须至少是元素类型的大小，并且是元素类型对齐值的倍数。

数组大小（以字节为单位）等于数组的元素步幅乘以元素数：
<p algorithm="array element stride">
  [=SizeOf=](array<|T|, |N|>) = [=StrideOf=](array<|T|, |N|>) &times; |N|<br>
  [=SizeOf=](array<|T|>) = [=StrideOf=](array<|T|>) &times; N<sub>runtime</sub>
</p>

数组对齐等于元素对齐：
<p algorithm="array alignment">
  [=AlignOf=](array<|T|[, N]>) = [=AlignOf=](|T|)
</p>

例如，`[[stride(S)]] array<T, 3>` 类型的布局等效于以下结构：

<div class='example wgsl global-scope' heading='Structure equivalent of a three element array'>
  <xmp highlight='rust'>
    struct Array {
      [[size(S)]] element_0: T;
      [[size(S)]] element_1: T;
      [[size(S)]] element_2: T;
    };
  </xmp>
</div>

#### 值的内部布局 ####  {#internal-value-layout}

本节描述了如何将值的内部结构放置在缓冲区的字节位置中，给定一个假设的整个值的位置。这些布局取决于值的类型、数组类型的步幅（[=attribute/stride=]）属性以及结构类型成员的对齐（[=attribute/align=]）和大小（[=attribute/size=]）属性。

无论存储类别如何，数据都将显示相同。

当[=u32=]或[=i32=]类型的值|V|放置在主机共享缓冲区的字节偏移量|k|处时，则：
   * 字节|k|包含|V|的0-7位
   * 字节|k|+1包含|V|的8-15位
   * 字节|k|+2包含|V|的16-23位
   * 字节|k|+3包含|V|的24-31位

注意：回想一下，[=i32=]使用二进制补码表示，因此符号位位于第31位。

[=f32=]类型的值|V|以[[!IEEE-754|IEEE-754]] binary32格式表示。它有1个符号位、8个指数位和23个分数位。当|V|被放置在主机共享缓冲区的字节偏移 k处时，则：
   * 字节|k|包含分数位的0-7位。
   * 字节|k|+1包含分数位的8-15位。
   * 字节|k|+2的0-6位包含分数位的16-23位。
   * 字节|k|+2的第7位包含指数位的第0位。
   * 字节|k|+3的第0-6位包含指数位的1-7位。
   * 字节|k|+3的第7位包含符号位。

注意：上述规则隐含表明主机共享缓冲区中的数值以little-endian格式存储。

当原子类型（[=atomic type=]） `atomic`&lt;|T|&gt; 的值|V|放置在主机共享缓冲区中时，它具有与基础类型|T|的值相同的内部布局。

当向量类型 vec|N|&lt;|T|&gt; 的值 |V| 放置在主机共享缓冲区的字节偏移量 |k| 处时，则：

   * |V|.x 被放置在字节偏移量 |k| 处
   * |V|.y 被放置在字节偏移量 |k|+4 处
   * 如果 |N| &ge; 3，则|V|.z被放置在字节偏移量 |k|+8 处
   * 如果 |N| &ge; 4，则|V|.w被放置在字节偏移量 |k|+12 处

当矩阵值 |M| 放置在主机共享内存缓冲区的字节偏移量 k 处时，则：
   * 如果|M|有两行，则：
      * |M| 的列向量 |i| 被放置在字节偏移量 |k| + 8 &times; |i| 处
   * 如果|M|有3或4行，则：
      * |M| 的列向量 |i| 被放置在字节偏移量 k| + 16 &times; |i| 处

当数组类型 |A| 的值放置在主机共享内存缓冲区的字节偏移量 |k| 处时，则：
   * 数组的元素 |i| 被放置在字节偏移量 k| + |i| &times; [=StrideOf=](|A|) 处

当结构类型 |S| 的值被放置在主机共享内存缓冲区的字节偏移量 |k| 处时，则：
   * 结构值的第 |i| 个成员被放置在字节偏移量 |k| + [=OffsetOfMember=](|S|,|i|) 处


#### 存储类布局约束 ####  {#storage-class-layout-constraints}

存储类（[=storage classes/storage=]）和统一存储类（[=storage classes/uniform=]）具有不同的缓冲区布局约束，本节将对此进行介绍。

变量直接或间接引用的所有结构和数组类型必须遵守变量存储类的约束。违反存储类约束会导致编译时错误。

在本节中，我们将<dfn noexport>RequiredAlignOf</dfn>(|S|, |C|)定义为当存储类 |C| 使用主机可共享类型 |S| 的值时所需的字节偏移对齐。

<table class='data'>
  <caption>
    对[=storage classes/storage=]和[=storage classes/uniform=]存储类的主机可共享类型的对齐要求。
  </caption>
  <thead>
    <tr><th>Host-shareable type |S|
        <th>[=RequiredAlignOf=](|S|, [=storage classes/storage=])
        <th>[=RequiredAlignOf=](|S|, [=storage classes/uniform=])
  </thead>
  <tr><td>[=i32=], [=u32=], or [=f32=]
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>atomic&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>vecN&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of a matrix with N columns and M rows">
      <td>matNxM&lt;f32&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of an array">
      <td>array&lt;T, N&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of an runtime-sized array">
      <td>array&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of a structure">
      <td>struct |S|
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))<br>
</table>

类型 |T| 的结构成员必须从结构的开头有一个字节偏移量，该偏移量是对存储类 |C| 的 [=RequiredAlignOf=](|T|, |C|) 的倍数：

<p algorithm="structure member minimum alignment">
    [=OffsetOfMember=](|S|, |M|) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    其中 |k| 为一个正整数，且 |M| 为具有类型 |T| 的结构 |S| 的成员。
</p>

元素类型 |T| 的数组的元素步幅（[=element stride=]）必须是对存储类 |C| 的 [=RequiredAlignOf=](|T|, |C|) 的倍数：

<p algorithm="array element minimum alignment">
    [=StrideOf=](array<|T|[, |N|]>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    其中 |k| 是一个正整数
</p>

注意：[=RequiredAlignOf=](|T|, |C|) 不会对对齐（[=attribute/align=]）修饰允许的值施加任何额外限制，也不会影响 [=AlignOf=](|T|) 的规则。数据按照前面部分中定义的规则进行布局，然后根据 [=RequiredAlignOf=](|T|, |C|) 规则验证生成的布局。

统一（[=storage classes/uniform=]）存储类还要求：
* 数组元素对齐到 16 字节边界。也就是说，对于某个正整数 k'，[=StrideOf=](array&lt;|T|,|N|&gt;) = 16 &times; |k|'。
* 如果结构成员本身具有结构类型 `S`，则该成员的开头和任何后续成员的开头之间的字节数必须至少为 [=roundUp=](16, [=SizeOf=](S))。

<div class='example wgsl global-scope' heading='invalid structure layout for uniform storage class'>
  <xmp highlight='rust'>
    struct S {
      x: f32;
    };
    struct Invalid {
      a: S;
      b: f32; // 无效：a 和 b 之间的偏移量为 4 字节，但必须至少为 16
    };
    struct Valid {
      a: S;
      [[align(16)]] b: f32; // 有效：a 和 b 之间的偏移量为 16 字节
    };
    [[group(0), binding(0)]] var<uniform> invalid: Invalid;
    [[group(0), binding(1)]] var<uniform> valid: Valid;
  </xmp>
</div>

## 内存视图类型 ## {#memory-view-types}

除了使用普通（[=plain types|plain=]）值进行计算之外，[SHORTNAME]程序还经常通过内存访问（[=memory access=]）操作从内存中读取值或将值写入内存。 每个内存访问都是通过内存视图（[=memory view=]）执行的。

内存视图（<dfn noexport>memory view</dfn>）由以下内容组成：
* 特定存储类（[=storage class=]）中的一组内存位置（[=memory locations=]），
* 将这些位置的内容解释为 [SHORTNAME] 类型（[=type=]），以及
* 一个访问模式（[=access mode=]）。

内存视图的访问方式必须被存储类支持。见[[#storage-class]]。

[SHORTNAME] 有两种表示内存视图的类型：引用类型（[=reference types=]）和指针类型（[=pointer types=]）。

<table class='data'>
  <thead>
    <tr><th>Constraint<th>Type<th>Description
  </thead>
  <tr algorithm="memory reference type">
    <td style="width:25%">|SC| 是一个存储类（[=storage class=]）,<br>|T|是一个可存储（[=storable=]）类型,<br>|A| 是访问模式（[=access mode=]）
    <td>ref&lt;|SC|,|T|,|A|&gt;
    <td>
        引用类型（<dfn noexport>reference type</dfn>）由一组对 |SC| 中的内存位置持有类型 |T| 的值的内存视图（[=memory views=]）标识，支持模式 |A| 中描述的内存访问。<br>在这种情况下，|T| 被称为存储类型（<dfn noexport>store type</dfn>）。<br>参考类型没有写在 [SHORTNAME] 源程序中；相反它们用于分析 [SHORTNAME] 程序。
  <tr algorithm="pointer type">
    <td>|SC|是一个存储类（[=storage class=]）,<br>|T|是一个可存储（[=storable=]）类型,<br>|A| 是一个访问模式（[=access mode=]）
    <td>ptr&lt;|SC|,|T|,|A|&gt;
    <td>
        指针类型（<dfn noexport>pointer type</dfn>）由一组对 |SC| 中内存位置持有类型 |T| 的值的内存视图（[=memory views=]）标识，支持模式 |A| 中描述的内存访问。<br>在这种情况下，|T| 被称为指针类型（<dfn noexport>pointee type</dfn>）。<br>指针类型可能出现在 [SHORTNAME] 程序源中。
</table>

在*分析* WGSL 程序时，引用和指针类型完全由存储类、可存储类型和访问模式参数化。在本规范的代码示例中，注释显示了这种完全参数化的形式。

但是，在 [SHORTNAME] *源*文本中：
* 引用类型必须不能出现。
* 指针类型可能出现。一个参数化的指针类型通过以下内容拼写：
    * 存储类，
    * 存储类型，以及
    * 有时通过访问模式，如[[#access-mode-defaults]]中所述。

<div class='example wgsl' heading='Pointer type'>
  <xmp highlight='rust'>
    fn my_function(
      // 'ptr<function,i32,read_write>' 是一个指针类型，引用存储保持 'i32' 值，使用函数存储类中的内存位置
      // 这里 'i32' 是指针类型。
      // 隐含的访问模式为 'read_write' ，访问模式的默认值见下文。
      ptr_int: ptr<function,i32>,

      // 'ptr<private,array<f32,50>,read_write>' 是指针值的类型，
      // 它指的是使用 'private' 存储类中的内存位置保存 50 个类型为 'f32' 元素的数组的存储。
      // 这里的指针类型是'array<f32,50>'。 隐含的访问模式是“read_write”。见下面的访问模式默认值。
      ptr_array: ptr<private, array<f32, 50>>
    ) { }
  </xmp>
</div>

引用类型和指针类型都是内存视图的集合：特定的内存视图与唯一的引用值和唯一的指针值相关联：

<blockquote algorithm="pointer reference correspondence">
每个类型ptr&lt;|SC|,|T|,|A|&gt;的指针值 |p| 对应于一个类型ref&lt;|SC|,|T|,|A|&gt;的单独参考值|r|，反之亦然，其中 |p| 和 |r| 描述相同的内存视图。
</blockquote>

### 访问模式默认值 ### {#access-mode-defaults}

内存视图的访问模式通常由上下文决定：

* [=storage classes/storage=] 存储类支持 [=access/read=] 和 [=access/read_write=] 两种访问模式。
* 每个其他存储类仅支持一种访问模式，如<a href="#storage-class-table">存储类</a>表中所述。

当在 [SHORTNAME] 源码中写入变量声明（[=variable declaration=]）或指针类型（[=pointer type=]）时：
* 对 [=storage classes/storage=] 存储类，访问模式是可选的，默认为 [=access/read=]。
* 对其他存储类，访问模式必须不填写。

### 原始变量 ### {#originating-variable-section}

在 [SHORTNAME] 中，参考值始终对应于某些变量的部分或全部内存位置的内存视图。这定义了参考值的原始变量（<dfn noexport>originating variable</dfn>）。

一个指针值总是对应一个引用值，因此指针的原始变量与相应引用的原始变量相同。

注意：原始变量是一个动态概念。函数形式参数的原始变量取决于函数的调用位置（[=call site|call sites=]）。 不同的调用位置可以提供指向不同起始变量的指针。

如果一个引用或指针访问出界，则产生一个无效内存引用（<dfn noexport>invalid
memory reference</dfn>）。

从无效引用中加载（[=Load Rule|Loads=]）返回以下内容之一：
    * 来自绑定到原始变量（[=originating variable=]）的 WebGPU 缓冲区（[[WebGPU#buffers|WebGPU buffer]]）的任何内存位置（[=memory locations|memory location(s)=]）的值
    * 引用的存储类型的零值（[=zero value=]）。
    * 如果加载的值是向量，则值 (0, 0, 0, x)，其中 x 是：
        * 0、1 或最大正值对整数分量
        * 0.0 或 1.0 对浮点分量
对无效引用的存储（[=statement/assignment|Stores=]）可能：
    * 将值存储到绑定到原始变量的 WebGPU 缓冲区（[[WebGPU#buffers|WebGPU buffer]]）的任何内存位置（[=memory locations|memory location(s)=]）
    * 没有被执行

对无效内存引用进行操作的读-修改-写原子（[[#atomic-rmw|Read-modify-write atomics]]）必须从相同的内存位置（[=memory locations|memory
locations=]）加载和存储，如果它们访问内存。

### 引用和指针用例 ### {#ref-ptr-use-cases}

引用和指针通过使用方法来区分：

* 一个变量（[=variable=]）的类型为一个引用类型。
* 寻址（[=address-of=]）操作（unary `&`）将一个引用值转换为其对应的指针值。
* 间接寻址（[=indirection=]）操作（unary *）将指针值转换为其对应的引用值。
* let声明（[=let declaration=]）可以为指针类型，但是不能为引用类型。
* 形式参数（[=formal parameter=]）可以是指针类型，但是不能为引用类型。
* 赋值语句（[=statement/assignment=]）执行写访问（[=write access=]）以通过引用更新内存内容，其中：
    * 赋值语句的左侧必须是引用类型，访问模式为 [=access/write=] 或 [=access/read_write=]。
    * 赋值语句的右侧必须计算为左侧的存储类型。
* 加载规则（<dfn noexport>Load Rule</dfn>）：在函数内部，引用会自动解除引用（读取）以满足类型规则：
    * 在函数中，当在语句或表达式中使用存储类型为 |T| 的引用表达式 |r| 时，其中
    * |r| 具有访问模式 [=access/read=] 或 [=access/read_write=]，且
    * 唯一可能匹配的类型规则要求 |r| 具有类型 |T| 的值，然后
    * 此类型规则的要求视作被满足，且
    * 在该上下文中，表达式 |r| 的计算结果为存储在计算时被 |r| 引用的内存位置的值（类型为|T|）。也就是说，执行读取访问（[=read access=]）以产生结果值。

以这种方式定义引用可以简单地惯用变量：

<div class='example wgsl' heading='Reference types enable simple use of variables'>
  <xmp highlight='rust'>
    [[stage(compute)]]
    fn main() {
      // 'i' 具有引用类型 ref<function,i32,read_write>。
      // 'i' 的内存位置存储 i32 值 0。
      var i: i32 = 0;

      // 'i + 1'只能匹配'i'子表达式为 i32 类型的类型规则。
      // 因此，表达式'i + 1'的类型为 i32，并且在计算时，'i'子表达式的计算结果为计算时存储在'i'的内存位置中的 i32 值。
      let one: i32 = i + 1;

      // 更新 'i' 引用的位置中的值，使它们保持值 2。
      i = one + 1;

      // 更新 'i' 引用的位置中的值，使它们保持值 5。
      // 右侧的计算发生在分配生效之前。
      i = i + 3;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Returning a reference returns the value loaded via the reference'>
  <xmp highlight='rust'>
    var<private> age: i32;
    fn get_age() -> i32 {
      // return 语句中的表达式类型必须是“i32”，因为它必须与函数声明的返回类型匹配。
      // 'age' 表达式的类型为 ref<private,i32,read_write>。
      // 应用加载规则，因为引用的存储类型与所需的表达式类型匹配，并且不应用其他类型规则。
      // 在此上下文中对'age'的计算是在执行 return 语句时从'age'引用的内存位置加载的 i32 值。
      return age;
    }

    fn caller() {
      age = 21;
      // copy_age 常量将获得 i32 值 21。
      let copy_age: i32 = get_age();
    }
  </xmp>
</div>

以这种方式定义指针可以实现两个关键用例：

* 使用带指针类型的 let 声明，为变量的部分内容形成一个短名称。
* 使用函数的形式参数来引用调用函数（[=calling function=]）可访问变量的存储。
    * 对此类函数的调用必须为该操作数提供一个指针值。这通常需要使用寻址（[=address-of=]）操作（unary `&`）来获取指向变量内容的指针。

注意：以下示例使用了本规范稍后解释的 [SHORTNAME] 功能。

<div class='example wgsl' heading='Using a pointer as a short name for part of a variable'>
  <xmp highlight='rust'>
    struct Particle {
      position: vec3<f32>;
      velocity: vec3<f32>;
    };
    [[block]] struct System {
      active_index: i32;
      timestep: f32;
      particles: array<Particle,100>;
    };
    [[group(0), binding(0)]] var<storage,read_write> system: System;

    [[stage(compute)]]
    fn main() {
      // 在存储内存中形成一个指向特定粒子的指针。
      let active_particle: ptr<storage,Particle> =
          &system.particles[system.active_index];

      let delta_position: vec3<f32> = (*active_particle).velocity * system.timestep;
      let current_position: vec3<f32>  = (*active_particle).position;
      (*active_particle).position = delta_position + current_position;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Using a pointer as a formal parameter'>
  <xmp highlight='rust'>
    fn add_one(x: ptr<function,i32>) {
      // 更新 'x' 的位置以包含下一个更高的整数值，（或环绕到最大的负 i32 值）。
      // 在左侧，一元“*”将指针转换为随后可以分配给的引用。
      // 默认情况下，它具有 read_write 访问模式。
      // 在右侧：
      // - 一元'*'将指针转换为引用，具有 read_write 访问模式。
      // - 唯一匹配的类型规则是加法 (+) 并且要求 '*x' 具有类型 i32，这是 '*x' 的存储类型。
      //   所以负载规则应用并且 '*x' 计算为在计算时为 '*x' 存储在内存中的值，即 0 的 i32 值。
      // - 将 1 添加到 0，以生成右侧的最终值 1 - 手边。 将 1 存储到 '*x' 的内存中。
      *x = *x + 1;
    }

    [[stage(compute)]]
    fn main() {
      var i: i32 = 0;

      // 修改'i' 的内容，使其包含1。使用一元'&' 获取'i' 的指针值。
      // 这是一个明确的信号，表明被调用的函数可以访问 'i' 的存储，并且可以修改它。
      add_one(&i);
      let one: i32 = i;  // 'one' has value 1.
    }
  </xmp>
</div>

### 形成引用和指针值 ### {#forming-references-and-pointers}

引用值通过以下方式之一形成：

* 解析为范围内（[=in scope|in-scope=]）变量 *v* 的标识符（[=identifier=]）表示 *v* 存储的引用值。
    * 解析成的变量是对引用的原始变量（[=originating variable=]）。
* 对一个指针使用间接寻址（[=indirection=] (unary `*`)）操作。
    * 结果的原始变量被定义为指针的原始变量。
* 使用一个复合参考元件表达式（<dfn noexport>composite reference component expression</dfn>）。
    在每种情况下，结果的原始变量都被定义为原始引用的原始变量。
    * 给定具有向量存储类型的引用，附加单字母向量访问短语会产生对向量的命名组件的引用。见[[#component-reference-from-vector-reference]]。
    * 给定具有向量存储类型的引用，附加数组索引访问短语会产生对向量的索引组件的引用。见[[#component-reference-from-vector-reference]]。
    * 给定具有矩阵存储类型的引用，附加数组索引访问短语会产生对矩阵的索引列向量的引用。见[[#matrix-access-expr]]。
    * 给定具有数组存储类型的引用，附加数组索引访问短语会产生对数组索引元素的引用。见[[#array-access-expr]]。
    * 给定具有结构存储类型的引用，附加成员访问短语会产生对结构的命名成员的引用。见[[#struct-access-expr]]。

在所有情况下，结果的访问模式与原始引用的访问模式相同。
<div class='example wgsl' heading='Component reference from a composite reference'>
  <xmp highlight='rust'>
    struct S {
        age: i32;
        weight: f32;
    };
    var<private> person: S;
    // 'person' 的使用表示对变量底层存储的引用，并且类型为 ref<private,S,read_write>。

    fn f() {
        var uv: vec2<f32>;
        // 'uv' 的使用表示对变量底层存储的引用，并且类型为 ref<function,vec2<f32>,read_write>。
        // 计算赋值的左侧： 计算 'uv.x' 以产生引用：
        // 1. 首先计算 'uv'，产生对 'uv' 变量存储的引用。结果的类型为 ref<function,vec2<f32>,read_write>。
        // 2. 然后应用'.x'向量访问短语，产生对由上一步中的引用值指向的向量的第一个分量的存储的引用。
        //    结果的类型为 ref<function,f32,read_write>。
        //    计算赋值的右侧会产生 f32 值 1.0。 将 f32 值 1.0 存储到 uv.x 引用的存储内存位置。
        uv.x = 1.0;

        // 计算赋值的左侧： 计算 'uv[1]' 以产生引用：
        // 1. 首先计算 'uv'，产生对 'uv' 变量存储的引用。 结果的类型为 ref<function,vec2<f32>,read_write>。
        // 2. 然后应用'[1]'数组索引短语，产生对上一步引用的向量的第二个组件的存储的引用。
        //    结果的类型为 ref<function,f32,read_write>。
        //    计算赋值的右侧会产生 f32 值 2.0。
        //    将 f32 值 2.0 存储到 uv[1] 引用的存储内存位置。
        uv[1] = 2.0;

        var m: mat3x2<f32>;
        // 计算'm[2]'时：
        // 1. 首先计算'm'，产生对“m”变量存储的引用。结果的类型为 ref<function,mat3x2<f32>,read_write>。
        // 2. 然后应用 '[2]' 数组索引短语，产生对存储由上一步中的参考值指向的第三列向量。
        //    因此，'m[2]' 表达式的类型为 ref<function,vec2<f32>,read_write>。
        //    'let' 声明是针对 vec2<f32> 类型的，因此声明语句要求初始化程序的类型为 vec2<f32>。
        //    加载规则适用（因为没有其他类型规则可以适用），以及初始化器的计算产生 vec2<f32> 值，
        //    该值是在执行声明时从 'm[2]' 引用的内存位置加载的。
        let p_m_col2: vec2<f32> = m[2];

        var A: array<i32,5>;
        // 计算'A[4]'时
        // 1. 首先计算“A”，产生对“A”变量存储的引用。
        //    结果的类型为 ref<function,array<i32,5>,read_write>。
        // 2. 然后应用'[4]'数组索引短语，产生对由上一步中的引用值引用的数组的第五个元素的存储的引用。
        //    结果值的类型为 ref<function,i32,read_write>。 他让声明要求右手边是 i32 类型。
        //    加载规则适用（因为没有其他类型规则可以应用），并且初始化器的计算产生从执行声明时由 'A[5]' 引用的内存位置加载的 i32 值。
        let A_4_value: i32 = A[4];

        // 计算'person.weight'时：
        // 1. 首先计算'person'，产生对在模块范围内声明的“person”变量的存储的引用。
        //    结果的类型为 ref<private,S,read_write>。
        // 2. 然后应用'.weight'成员访问短语，产生对存储器的第二个成员的存储器的引用，该存储器由上一步中的引用值引用。
        //    结果的类型为 ref<private,f32,read_write>。
        //    let 声明要求右侧的类型为 f32。
        //    加载规则适用（因为没有其他类型规则可以应用），并且初始化器的计算产生从执行声明时'person.weight'引用的内存位置加载的 f32 值。

        let person_weight: f32 = person.weight;
    }
  </xmp>
</div>

指针值以下列方式之一形成：

* 对引用使用寻址（[=address-of=] (unary '&')）操作。
    * 结果的原始变量被定义为引用的原始变量。
* 如果函数形式参数（[=formal parameter=]）具有指针类型，则在运行时调用该函数时，形参的使用表示在调用函数（[=calling function=]）的调用位置（[=call site=]）处提供给相应操作数的指针值。
    * 形式参数（在运行时）的原始变量被定义为在调用位置处指针操作数的原始变量。

在所有情况下，结果的访问模式与原始指针的访问模式相同。

<div class='example wgsl' heading='Pointer from a variable'>
  <xmp highlight='rust'>
    // 在私有存储类中声明一个变量，用于存储 f32 值。
    var<private> x: f32;

    fn f() {
        // 在函数存储类中声明一个变量，用于存储 i32 值。
        var y: i32;

        // 名称'x'解析为模块范围变量'x'，并且具有引用类型 ref<private,f32,read_write>。
        // 应用一元“&”运算符将引用转换为指针。
        // 访问方式与原变量的访问方式相同，所以完全指定的类型为ptr<private,f32,read_write>。
        // 但是read_write是函数存储类的默认访问方式，所以这种情况下不需要拼写read_write
        let x_ptr: ptr<private,f32> = &x;

        // 名称'y'解析为函数范围变量'y'，并且具有引用类型 ref<private,i32,read_write>。
        // 应用一元“&”运算符将引用转换为指针。 访问模式默认为“read_write”。
        let y_ptr: ptr<function,i32> = &y;

        // 一个新变量，不同于在模块范围内声明的变量。
        var x: u32;

        // 此处，名称'x'解析为前一条语句中声明的函数作用域变量'x'，其类型为 ref<function,u32,read_write>。
        // 应用一元'&'运算符将引用转换为指针。 访问模式默认为'read_write'。
        let inner_x_ptr: ptr<function,u32> = &x;
    }
  </xmp>
</div>

### 与其他语言中引用和指针的比较 ### {#pointers-other-languages}

本节是信息性的，是不规范的。

[SHORTNAME]中的引用和指针相较于其他语言受更多的限制。具体为：

* 在 [SHORTNAME] 中，不能将引用直接声明为另一个引用或变量的别名，无论是变量还是形式参数。
* 在 [SHORTNAME] 中，指针和引用不可存储（[=storable=]）。也就是说，[SHORTNAME] 变量的内容可能不包含指针或引用。
* 在 [SHORTNAME] 中，函数必须不返回指针或引用。
* 在 [SHORTNAME] 中，无法在整数值和指针值之间进行转换。
* 在 [SHORTNAME] 中，无法将指针值的类型强制更改为另一种指针类型。
    * 复合组件引用表达式是不同的：它获取对复合值的引用，并产生对复合值内的组件或元素之一的引用。这些在 [SHORTNAME] 中被认为是不同的引用，即使它们在实现抽象级别的较低级别可能具有相同的机器地址。
* 在 [SHORTNAME] 中，无法将引用值的类型强制更改为另一种引用类型
* 在 [SHORTNAME] 中，无法更改指针或引用的访问模式。
    * 相比之下，C++ 会自动将非常量指针转换为 const 指针，并有一个 const_cast 将一个 const 值转换为一个非常量值。
* 在 [SHORTNAME] 中，无法从“堆”分配新的存储空间。
* 在 [SHORTNAME] 中，无法显式销毁变量。 只有当变量超出范围时，[SHORTNAME] 变量的存储才会变得不可访问。

注意：根据上述规则，不可能形成“悬空”指针，即不引用有效的（或“活动的”）原始变量的存储的指针。

## 纹理和采样器类型 ## {#texture-types}

纹素（<dfn noexport>texel</dfn>）是用作纹理的最小可独立访问元素的标量或向量。*texel*这个词是*纹理元素*的缩写。

纹理（<dfn noexport>texture</dfn>）是支持对渲染有用的特殊操作的纹素集合。 在 [SHORTNAME] 中，这些操作是通过纹理内置函数调用的。 有关完整列表，见[[#texture-builtin-functions]]。

[SHORTNAME] 纹理对应于 [[WebGPU#gputexture|WebGPU GPUTexture]]。

纹理可以是数组形式的，也可以是非数组的：

* 非数组纹理（<dfn noexport>non-arrayed texture</dfn>）是一个纹素网格，每个纹素有单独的网格坐标。
* 数组纹理（<dfn noexport>arrayed texture</dfn>）是纹素网格的齐次数组。在数组纹理中，每个纹素通过其唯一的数组索引和网格坐标组合来标识。

纹理具有以下特性：
: 纹素格式
:: 每个纹素中的数据，见[[#texel-formats]]。
: 维度
:: 网格坐标中的维数，以及坐标的解释方式。维度数为 1、2 或 3。大多数纹理使用笛卡尔坐标。立方体纹理有六个方形面，并使用三维坐标进行采样，该坐标解释为从原点到以原点为中心的立方体的方向向量。
: 大小
:: 沿每个维度的网格坐标的范围
: mip 级别计数
:: 采样纹理的 mip 级别计数至少为 1，存储纹理的 mip 级别计数至少为 1。Mip 级别 0 包含纹理的全尺寸版本。每个连续的 mip 级别都包含前一个 mip 级别的过滤版本，大小为前一个 mip 级别的一半（在舍入范围内）。在对纹理进行采样时，使用显式或隐式计算的细节级别来选择从中读取纹素数据的 mip 级别。 然后通过过滤将它们组合起来以产生采样值。
: 数组化
:: 纹理是否为数组化
: 数组大小（<dfn noexport>array size</dfn>）
:: 齐次网格的数量，如果纹理为数组化的

纹理的表示通常针对渲染操作进行优化。为了实现这一点，许多细节对程序员是隐藏的，包括无法直接用着色器语言表达的数据布局、数据类型和内部操作。

因此，着色器无法直接访问纹理变量中的纹素存储。相反，访问是通过一个不透明的句柄来调解的：

* 在着色器内：
    * 声明一个模块范围变量，其中存储类型（[=store type=]）是后面部分中描述的纹理类型之一。 该变量存储底层纹理内存的不透明句柄，并自动放置在句柄（[=storage classes/handle=]）存储类中。
    * 在函数内部，调用其中一个纹理内置函数，并提供纹理变量作为第一个参数。
* 在构建 WebGPU 管道时，纹理变量的存储类型和绑定必须与相应的绑定组布局条目兼容。

TODO：更新此处以描述处理纹理或采样器函数参数。

这样，纹理类型支持的操作集由接受该纹理类型作为第一个参数的纹理内置函数的可用性决定。

注意：着色器无法更改纹理变量存储的句柄。也就是说，该变量是只读的，即使它提供访问的底层纹理可能是可变的（例如，只写存储纹理）。

TODO：在相同的广框架中描述采样器的使用。

### 纹素格式 ### {#texel-formats}

在 [SHORTNAME] 中，某些纹理类型由纹素格式参数化。

纹素格式（<dfn noexport>texel format</dfn>）被归类为：

: 频道（<dfn noexport>channels</dfn>）
:: 每个频道包含一个标量。纹素格式最多有四个通道：r、g、b 和 a，通常对应于红色、绿色、蓝色和 alpha 通道的概念。
: 频道格式（<dfn noexport>channel format</dfn>）
:: 通道中的位数，以及如何解释这些位。

[SHORTNAME] 中的每个纹素格式都对应一个同名的 [[WebGPU#enumdef-gputextureformat|WebGPU GPUTextureFormat]]。

[SHORTNAME] 源代码中仅使用某些纹素格式。用于定义这些纹素格式的频道格式在频道格式（<dfn dfn>Channel Formats</dfn>）表中列出。 最后一列指定从存储的频道位到着色器中使用的值的转换。这也称为频道传递函数（<dfn noexport>channel transfer function</dfn>）或 CTF。

<table class='data'>
  <caption>Channel Formats</caption>
  <thead>
    <tr><th>Channel format
        <th>Number of stored bits
        <th>Interpetation of stored bits
        <th>Shader type<td style="width:25%">Shader value
(Channel Transfer Function)
  </thead>
  <tr><td>8unorm<td>8<td>无符号整数 |v| &isinv; {0,...,255}<td>f32<td> |v| &div; 255
  <tr><td>8snorm<td>8<td>有符号整数 |v| &isinv; {-128,...,127}<td>f32<td> max(-1, |v| &div; 127)
  <tr><td>8uint<td>8<td>无符号整数 |v| &isinv; {0,...,255}<td>u32<td> |v|
  <tr><td>8sint<td>8<td>有符号整数 |v| &isinv; {-128,...,127}<td>i32<td> |v|
  <tr><td>16uint<td>16<td>无符号整数 |v| &isinv; {0,...,65535}<td>u32<td> |v|
  <tr><td>16sint<td>16<td>有符号整数 |v| &isinv; {-32768,...,32767}<td>i32<td> |v|
  <tr><td>16float<td>16<td>[[!IEEE-754|IEEE-754]] binary16 16-位浮点值 |v|, 1 符号位，5指数位，10尾数位<td>f32<td>|v|
  <tr><td>32uint<td>32<td>32-位无符号整数值 |v|<td>u32<td>|v|
  <tr><td>32sint<td>32<td>32-位有符号整数值 |v|<td>i32<td>|v|
  <tr><td>32float<td>32<td>[[!IEEE-754|IEEE-754]] binary32 32-位浮点值 |v|<td>f32<td>|v|
</table>

存储纹理的纹素格式（<dfn dfn lt="storage-texel-formats">Texel Formats for Storage Textures</dfn>）表中列出的纹素格式对应于支持 [[WebGPU#dom-gputextureusage-storage|WebGPU STORAGE]] 使用的 WebGPU 纯色格式（[[WebGPU#plain-color-formats|WebGPU plain color formats]]）。这些纹素格式用于参数化在[[#texture-storage]]中定义的存储纹理类型。

当纹素格式没有所有四个频道时，则：

* 当读取纹素时：
    * 如果纹素格式没有绿色频道，则着色器值的第二个分量为 0。
    * 如果纹素格式没有蓝色频道，则着色器值的第三个分量为 0。
    * 如果纹素格式没有 Alpha 频道，则着色器值的第四个分量为 1。
* 写入纹素时，缺失频道的着色器值组件将被忽略。

下表中的最后一列使用了频道格式（[=channel formats=]）表中特定于格式的频道传输函数（[=channel transfer function=]）。

<table class='data'>
  <caption>存储纹理的纹素格式</caption>
  <thead>
    <tr><th>Texel format
        <th>Channel format
        <th>Channels in memory order
        <th style="width:50%">Corresponding shader value
  </thead>
  <tr><td>rgba8unorm<td>8unorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8snorm<td>8snorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8uint<td>8uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8sint<td>8sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16uint<td>16uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16sint<td>16sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16float<td>16float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>r32uint<td>32uint<td>r<td>vec4&lt;u32&gt;(CTF(r), 0u, 0u, 1u)
  <tr><td>r32sint<td>32sint<td>r<td>vec4&lt;i32&gt;(CTF(r), 0, 0, 1)
  <tr><td>r32float<td>32float<td>r<td>vec4&lt;f32&gt;(CTF(r), 0.0, 0.0, 1.0)
  <tr><td>rg32uint<td>32uint<td>r, g<td>vec4&lt;u32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rg32sint<td>32sint<td>r, g<td>vec4&lt;i32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rg32float<td>32float<td>r, g<td>vec4&lt;f32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rgba32uint<td>32uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba32sint<td>32sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba32float<td>32float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
</table>

下表列出了 WGSL 纹素格式和 SPIR-V 图像格式（[=image formats=]）之间的对应关系。

<table class='data'>
  <caption>映射纹素格式至SPIR-V</caption>
  <thead>
    <tr><th>Texel format
        <th>SPIR-V Image Format
        <th>SPIR-V Enabling Capability
  </thead>
  <tr><td>rgba8unorm<td>Rgba8<td>Shader
  <tr><td>rgba8snorm<td>Rgba8Snorm<td>Shader
  <tr><td>rgba8uint<td>Rgba8ui<td>Shader
  <tr><td>rgba8sint<td>Rgba8i<td>Shader
  <tr><td>rgba16uint<td>Rgba16ui<td>Shader
  <tr><td>rgba16sint<td>Rgba16i<td>Shader
  <tr><td>rgba16float<td>Rgba16f<td>Shader
  <tr><td>r32uint<td>R32ui<td>Shader
  <tr><td>r32sint<td>R32i<td>Shader
  <tr><td>r32float<td>R32f<td>Shader
  <tr><td>rg32uint<td>Rg32ui<td>StorageImageExtendedFormats
  <tr><td>rg32sint<td>Rg32i<td>StorageImageExtendedFormats
  <tr><td>rg32float<td>Rg32f<td>StorageImageExtendedFormats
  <tr><td>rgba32uint<td>Rgba32ui<td>Shader
  <tr><td>rgba32sint<td>Rgba32i<td>Shader
  <tr><td>rgba32float<td>Rgba32f<td>Shader
</table>

### 采样纹理类型 ### {#sampled-texture-type}

<pre class='def'>
`texture_1d<type>`
  %1 = OpTypeImage %type 1D 0 0 0 1 Unknown

`texture_2d<type>`
  %1 = OpTypeImage %type 2D 0 0 0 1 Unknown

`texture_2d_array<type>`
  %1 = OpTypeImage %type 2D 0 1 0 1 Unknown

`texture_3d<type>`
  %1 = OpTypeImage %type 3D 0 0 0 1 Unknown

`texture_cube<type>`
  %1 = OpTypeImage %type Cube 0 0 0 1 Unknown

`texture_cube_array<type>`
  %1 = OpTypeImage %type Cube 0 1 0 1 Unknown
</pre>
* 类型必须为 `f32`, `i32` 或 `u32`
* 图像的参数化类型是采样转换后的类型。例如：你可以使用带有 8 位 unorm 组件的纹素图像，但是当您对它们进行采样时，您会得到 32 位浮点结果（或 vec-of-f32）。

### 多重采样纹理类型 ### {#multisampled-texture-type}

<pre class='def'>
`texture_multisampled_2d<type>`
  %1 = OpTypeImage %type 2D 0 0 1 1 Unknown
</pre>
* 类型必须为 `f32`, `i32` 或 `u32`

### 外部采样纹理类型 ### {#external-texture-type}

<pre class='def'>
`texture_external`
</pre>

`texture_external` 是一种类似于 `texture_2d<f32>` 的不透明 2d 浮点采样纹理类型，但可能具有不同的表示。可以使用 `textureLoad` 或 `textureSampleLevel` 读取它，它们不透明地处理这些不同的表示。

详见[`GPUExternalTexture`](https://gpuweb.github.io/gpuweb/#gpu-external-texture)。

### 存储纹理类型 ### {#texture-storage}

存储纹理（<dfn noexport>storage texture</dfn）支持在不使用采样器的情况下访问单个纹素。

* 只写存储纹理（A <dfn noexport>write-only storage texture</dfn>）支持写入单个纹素，并自动将着色器值转换为存储的纹素值。

存储纹理类型必须由一种存储纹理的纹素格式（[=storage-texel-format|texel formats for storage textures=]）进行参数化。纹素格式决定了 [[#texel-formats]] 中指定的转换函数。

对于只写存储纹理，转换函数的*逆*函数用于将着色器值转换为存储的纹素。

见[[#texture-builtin-functions]]。

TODO(dentro)：将转换的描述移动到实际进行读取的内置函数中。

<pre class='def'>
`texture_storage_1d<texel_format,access>`
  // %1 = OpTypeImage sampled_type 1D 0 0 0 2 image_format

`texture_storage_2d<texel_format,access>`
  // %1 = OpTypeImage sampled_type 2D 0 0 0 2 image_format

`texture_storage_2d_array<texel_format,access>`
  // %1 = OpTypeImage sampled_type 2D 0 1 0 2 image_format

`texture_storage_3d<texel_format,access>`
  // %1 = OpTypeImage sampled_type 3D 0 0 0 2 image_format
</pre>

* `texel format` 必须为存储纹素格式（[=storage-texel-formats=]）中指定的纹素类型之一
* `access` 必须为 [=access/write=]

在 SPIR-V 映射中：
* 图像类型声明的*图像格式*参数按照[[#texel-formats]]中SPIR-V 纹素格式对应表的规定。
* 图像类型声明的*采样类型*参数为纹素格式的频道格式对应的SPIR-V标量类型。

映射到 SPIR-V 时，只写存储纹理变量必须具有 `NonReadable` 修饰。

例如：

<div class='example wgsl global-scope' heading='Mapping a writable texture_storage_1d variable to SPIR-V'>
  <xmp>
      var tbuf: texture_storage_1d<rgba8unorm,write>;

      // Maps to the following SPIR-V:
      //  OpDecorate %tbuf NonReadable
      //  ...
      //  %float = OpTypeFloat 32
      //  %image_type = OpTypeImage %float 1D 0 0 0 2 Rgba8
      //  %image_ptr_type = OpTypePointer UniformConstant %image_type
      //  %tbuf = OpVariable %image_ptr_type UniformConstant
  </xmp>
</div>

### 深度纹理类型 ### {#texture-depth}
<pre class='def'>
`texture_depth_2d`
  %1 = OpTypeImage %f32 2D 1 0 0 1 Unknown

`texture_depth_2d_array`
  %1 = OpTypeImage %f32 2D 1 1 0 1 Unknown

`texture_depth_cube`
  %1 = OpTypeImage %f32 Cube 1 0 0 1 Unknown

`texture_depth_cube_array`
  %1 = OpTypeImage %f32 Cube 1 1 0 1 Unknown

`texture_depth_multisampled_2d`
  %1 = OpTypeImage %f32 2D 1 0 1 1 Unknown
</pre>

### 采样器类型 ### {#sampler-type}

采样器（<dfn>sampler</dfn>）通过执行以下组合来调节对采样纹理或深度纹理的访问：
* 坐标转换。
* 可选地修改 mip-level 选择。
* 对于采样纹理，可选择过滤检索到的纹素值。
* 对于深度纹理，确定应用于检索到的纹素的比较函数。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="sampler type">
    <td>sampler
    <td>采样器。调节对采样纹理的访问。</td>
  <tr algorithm="comparison sampler type">
    <td>sampler_comparison
    <td>比较采样器。调节对深度纹理的访问。</td>
</table>

采样器在被 WebGPU API 创建时参数化。它们在 [SHORTNAME] 程序中不能被修改。

采样器仅能通过[[#texture-builtin-functions|texture builtin functions]]被使用。

<pre class='def'>
sampler
  OpTypeSampler

sampler_comparison
  OpTypeSampler
</pre>

### 纹理类型语法 ### {#texture-types-grammar}
TODO: 添加纹理使用校验规则。

<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_sampler_types</dfn> :

    | [=syntax/sampler_type=]

    | [=syntax/depth_texture_type=]

    | [=syntax/sampled_texture_type=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/multisampled_texture_type=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/storage_texture_type=] [=syntax/less_than=] [=syntax/texel_format=] [=syntax/comma=] [=syntax/access_mode=] [=syntax/greater_than=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler_type</dfn> :

    | [=syntax/sampler=]

    | [=syntax/sampler_comparison=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampled_texture_type</dfn> :

    | [=syntax/texture_1d=]

    | [=syntax/texture_2d=]

    | [=syntax/texture_2d_array=]

    | [=syntax/texture_3d=]

    | [=syntax/texture_cube=]

    | [=syntax/texture_cube_array=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>multisampled_texture_type</dfn> :

    | [=syntax/texture_multisampled_2d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>storage_texture_type</dfn> :

    | [=syntax/texture_storage_1d=]

    | [=syntax/texture_storage_2d=]

    | [=syntax/texture_storage_2d_array=]

    | [=syntax/texture_storage_3d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>depth_texture_type</dfn> :

    | [=syntax/texture_depth_2d=]

    | [=syntax/texture_depth_2d_array=]

    | [=syntax/texture_depth_cube=]

    | [=syntax/texture_depth_cube_array=]

    | [=syntax/texture_depth_multisampled_2d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texel_format</dfn> :

    | [=syntax/r8unorm=]

    | [=syntax/r8snorm=]

    | [=syntax/r8uint=]

    | [=syntax/r8sint=]

    | [=syntax/r16uint=]

    | [=syntax/r16sint=]

    | [=syntax/r16float=]

    | [=syntax/rg8unorm=]

    | [=syntax/rg8snorm=]

    | [=syntax/rg8uint=]

    | [=syntax/rg8sint=]

    | [=syntax/r32uint=]

    | [=syntax/r32sint=]

    | [=syntax/r32float=]

    | [=syntax/rg16uint=]

    | [=syntax/rg16sint=]

    | [=syntax/rg16float=]

    | [=syntax/rgba8unorm=]

    | [=syntax/rgba8unorm_srgb=]

    | [=syntax/rgba8snorm=]

    | [=syntax/rgba8uint=]

    | [=syntax/rgba8sint=]

    | [=syntax/bgra8unorm=]

    | [=syntax/bgra8unorm_srgb=]

    | [=syntax/rgb10a2unorm=]

    | [=syntax/rg11b10float=]

    | [=syntax/rg32uint=]

    | [=syntax/rg32sint=]

    | [=syntax/rg32float=]

    | [=syntax/rgba16uint=]

    | [=syntax/rgba16sint=]

    | [=syntax/rgba16float=]

    | [=syntax/rgba32uint=]

    | [=syntax/rgba32sint=]

    | [=syntax/rgba32float=]
</div>

## 类型别名 TODO ## {#type-aliases}

<div class='syntax' noexport='true'>
  <dfn for=syntax>type_alias</dfn> :

    | [=syntax/type=] [=syntax/ident=] [=syntax/equal=] [=syntax/type_decl=]
</div>

<div class='example wgsl global-scope' heading='Type Alias'>
  <xmp>
    type Arr = array<i32, 5>;

    type RTArr = [[stride(16)]] array<vec4<f32>>;
  </xmp>
</div>

## 类型声明语法 ## {#type-declarations}

<div class='syntax' noexport='true'>
  <dfn for=syntax>type_decl</dfn> :

    | [=syntax/ident=]

    | [=syntax/bool=]

    | [=syntax/float32=]

    | [=syntax/int32=]

    | [=syntax/uint32=]

    | [=syntax/vec2=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/vec3=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/vec4=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/pointer=] [=syntax/less_than=] [=syntax/storage_class=] [=syntax/comma=] [=syntax/type_decl=] ( [=syntax/comma=] [=syntax/access_mode=] ) ? [=syntax/greater_than=]

    | [=syntax/array_type_decl=]

    | [=syntax/mat2x2=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat2x3=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat2x4=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat3x2=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat3x3=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat3x4=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat4x2=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat4x3=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat4x4=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/atomic=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/texture_sampler_types=]
</div>

当类型声明是标识符（[=identifier=]）时，表达式必须在标识符声明（[=declaration=]）的范围内，作为类型别名或结构类型。

<div class='example' heading="Type Declarations">
  <xmp>
    identifier
      Allows to specify types created by the type command

    bool
       %1 = OpTypeBool

    f32
       %2 = OpTypeFloat 32

    i32
       %3 = OpTypeInt 32 1

    u32
       %4 = OpTypeInt 32 0

    vec2<f32>
        %7 = OpTypeVector %float 2

    array<f32, 4>
       %uint_4 = OpConstant %uint 4
            %9 = OpTypeArray %float %uint_4

    [[stride(32)]] array<f32, 4>
                 OpDecorate %9 ArrayStride 32
       %uint_4 = OpConstant %uint 4
            %9 = OpTypeArray %float %uint_4

    array<f32>
       %rtarr = OpTypeRuntimeArray %float

    mat2x3<f32>
       %vec = OpTypeVector %float 3
         %6 = OpTypeMatrix %vec 2
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Access modes for buffers'>
  <xmp>
    // Storage buffers
    [[group(0), binding(0)]]
    var<storage,read> buf1: Buffer;       // Can read, cannot write.
    [[group(0), binding(0)]]
    var<storage> buf2: Buffer;            // Can read, cannot write.
    [[group(0), binding(1)]]
    var<storage,read_write> buf3: Buffer; // Can both read and write.

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    struct ParamsTable {};
    [[group(0), binding(2)]]
    var<uniform> params: ParamsTable;     // Can read, cannot write.
  </xmp>
</div>

# `var` 和 `let` # {#var-and-let}

let 声明（<dfn noexport>let declaration</dfn>）指定值的名称。一旦计算出 let 声明的值，它就是不可变的。当标识符（[=identifier=]） 使用[=resolves=]至一个let-声明，该标识符表示该值。

当在没有明确指定类型的情况下声明 `let` 标识符时，例如 `let foo = 4`，类型是从等号 (`=`) 右边的表达式自动推断出来的。 当指定类型时，例如 `let foo: i32 = 4`，初始化表达式必须计算为该类型。

关于 `let`-声明的一些规则取决于声明出现的位置。见[[#module-constants]]与[[#function-scope-variables]]。

<div class='example let declaration at module-scope' heading='let-declared constants at module scope'>
  <xmp highlight='rust'>
    // 'blockSize' 表示 i32 值 1024。
    let blockSize: i32 = 1024;

    // 'row_size' 表示 u32 值 16u。类型被指定。
    let row_size = 16u;
  </xmp>
</div>

变量（<dfn dfn noexport>variable</dfn>）是对内存的命名引用，可以包含特定可存储（[=storable=]）类型的值。

有两种类型与变量相关联：它的存储类型（[=store type=]）（可以放置在被引用内存中的值的类型）和它的引用类型（[=reference type=]）（变量本身的类型）。 如果变量具有存储类型 *T*、存储类（[=storage class=]） *S* 和访问模式 *A*，则其引用类型为 ref&lt;*S*,*T*,*A*&gt;。

变量声明（<dfn dfn noexport>variable declaration</dfn>）：

* 指定变量名称。
* 指定[=storage class=], [=store type=], 和 [=access mode=]。这些一同构成变量的引用类型（[=reference type=]）。
* 确保执行环境在指定的存储类中为存储类型的值分配内存，对变量的生命周期（[=lifetime=]）支持给定的访问模式。
* 如果变量在私有（[=storage classes/private=]）或函数（[=storage classes/function=]）存储类中，可选择地有一个*初始化*表达式。 如果存在，初始化表达式必须计算为变量的存储类型。

当标识符（[=identifier=]）对变量声明使用[=resolves=]时，标识符是表示变量内存的引用内存视图（[=memory view=]）的表达式，其类型是变量的引用类型。见[[#var-identifier-expr]]。

有关可以在何处声明特定存储类中的变量以及何时需要、可选或禁止存储类修饰的规则，见[[#module-scope-variables]]和[[#function-scope-variables]]。

访问方式总是有默认的，除了[=storage classes/storage=]存储类中的变量，不得写入[SHORTNAME]源文本。见[[#access-mode-defaults]]。

<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_statement</dfn> :

    | [=syntax/variable_decl=]

    | [=syntax/variable_decl=] [=syntax/equal=] [=syntax/short_circuit_or_expression=]

    | [=syntax/let=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/equal=] [=syntax/short_circuit_or_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_decl</dfn> :

    | [=syntax/var=] [=syntax/variable_qualifier=] ? ( [=syntax/ident=] | [=syntax/variable_ident_decl=] )
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_ident_decl</dfn> :

    | [=syntax/ident=] [=syntax/colon=] [=syntax/attribute_list=] * [=syntax/type_decl=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_qualifier</dfn> :

    | [=syntax/less_than=] [=syntax/storage_class=] ( [=syntax/comma=] [=syntax/access_mode=] ) ? [=syntax/greater_than=]
</div>

一个变量的生命周期（<dfn noexport>lifetime</dfn>）为该变量存在时进行着色器处理的期间。模块范围（[=module scope=]）变量的生命周期为着色器阶段的全部执行时间。

对于函数作用域（[=function scope=]）变量，每个调用都有其自己的独立变量版本。变量的生存周期取决于其作用域：
* 当控制写入变量声明时，它就开始了。
* 它包括从变量作用域内调用的任何函数的整个执行过程。
* 它在控制离开变量的作用域时结束，而不是从变量的作用域内调用函数。

两个生命周期重叠的变量不会有重叠的内存（[=overlap|overlapping memory=]）。当一个变量的生命周期结束时，它的内存可能会被另一个变量使用。

当一个变量被创建时，它的内存包含一个初始值，如下所示：

* 对于在私有（[=storage classes/private=]）或函数（[=storage classes/function=]）存储类中的变量：
    * 如果变量声明没有初始化表达式，存储类型为零值（[=zero value=]）。
    * 否则它是对初始化表达式在程序执行处计算求值后的结果。
* 对于其他存储类中的变量，执行环境提供初始值。

考虑如下WGSL片段：
<div class='example wsgl function-scope' heading='Variable initial values'>
  <xmp highlight='rust'>
    var i: i32;         // 初始值为 0。不是推荐的方式。
    loop {
      var twice: i32 = 2 * i;   // 重新计算每次迭代。
      i = i + 1;
      if (i == 5) { break; }
    }
  </xmp>
</div>
循环体会执行 5 次，变量 `i` 会具有值0, 1, 2, 3, 4, 5, 且变量 `twice` 会具有值0, 2, 4, 6, 8。

考虑如下WGSL片段：
<div class='example wsgl function-scope' heading='Reading a variable multiple times'>
  <xmp highlight='rust'>
    var x: f32 = 1.0;
    let y = x * x + x + 1;
  </xmp>
</div>
由于 `x` 为一个变量，所有对齐的访问都变成了加载和存储操作。如果这段代码被编译为 SPIR-V ，它将表示为：
<div class='example spirv' heading='Sample translation for reading a variable multiple times'>
  <xmp highlight='asm'>
    %temp_1 = OpLoad %float %x
    %temp_2 = OpLoad %float %x
    %temp_3 = OpFMul %float %temp_1 %temp_2
    %temp_4 = OpLoad %float %x
    %temp_5 = OpFAdd %float %temp_3 %temp_4
    %y      = OpFAdd %float %temp_5 %one
  </xmp>
</div>

然而，期望浏览器或驱动程序优化此中间表示，从而消除冗余负载。

## 模块作用域变量 ## {#module-scope-variables}

在所有函数之外声明的变量在模块作用域（[=module scope=]）内。变量名在其声明语句之后立即可用，直到程序结束。

模块作用域（[=module scope=]）内的变量被限制如下：

* 变量不能在函数（[=storage classes/function=]）存储类中。
* 变量在[=storage classes/private=], [=storage classes/workgroup=], [=storage classes/uniform=], 或 [=storage classes/storage=] 存储类中：
    * 必须使用显式存储类修饰声明。
    * 必须使用[[#storage-class]]中所描述的存储类型（[=store type=]）。
* 如果存储类型（[=store type=]）是纹理类型或采样器类型，则变量声明不得具有存储类修饰。存储类将始终是句柄（[=storage classes/handle=]）。

统一（[=storage classes/uniform=]）存储类中的变量是统一缓冲区（<dfn noexport>uniform buffer</dfn>）变量。 其存储类型（[=store type=]）必须是具有块（[=attribute/block=]）属性的主机可共享（[=host-shareable=]）结构类型，满足存储类布局约束（[storage class layout constraints](#storage-class-layout-constraints)）。

[=storage classes/storage=]存储类中的变量是存储缓冲区（<dfn noexport>storage buffer</dfn>）变量。其存储类型（[=store type=]）必须是具有块（[=attribute/block=]）属性的主机可共享（[=host-shareable=]）结构类型，满足存储类布局约束（[storage class layout constraints](#storage-class-layout-constraints)）。它可以声明为 [=access/read=] 或 [=access/read_write=] 访问模式； 默认为 [=access/read=] 。

如[[#resource-interface]]中所述，统一缓冲区、存储缓冲区、纹理和采样器构成了着色器的资源接口（[=resource interface of a shader=]）。 此类变量使用组（[=attribute/group=]）和绑定（[=attribute/binding=]）修饰声明。

<div class='example wgsl global-scope' heading="Module scope variable declarations">
  <xmp>
    var<private> decibels: f32;
    var<workgroup> worklist: array<i32,10>;

    [[block]] struct Params {
      specular: f32;
      count: i32;
    };
    [[group(0), binding(2)]]
    var<uniform> param: Params;    // A uniform buffer

    [[block]] struct PositionsBuffer {
      pos: array<vec2<f32>>;
    };
    // A storage buffer, for reading and writing
    [[group(0), binding(0)]]
    var<storage,read_write> pbuf: PositionsBuffer;

    // Textures and samplers are always in "handle" storage.
    [[group(0), binding(1)]]
    var filter_params: sampler;
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_variable_decl</dfn> :

    | [=syntax/attribute_list=] * [=syntax/variable_decl=] ( [=syntax/equal=] [=syntax/const_expression=] ) ?
</div>

<div class='example' heading="Variable Decorations">
  <xmp>
    [[group(4), binding(3)]]
       OpDecorate %variable DescriptorSet 4
       OpDecorate %variable Binding 3
  </xmp>
</div>

[SHORTNAME] 定义了以下可应用于全局变量的属性：
 * [=attribute/binding=]
 * [=attribute/group=]

## 模块常量 ## {#module-constants}

一个在所有函数外声明的 `let`-声明声明了一个模块作用域（[=module scope|module-scope=]）常量。该名称可在声明结束后使用，直到 [SHORTNAME] 程序结束。

模块作用域 let-声明的常量必须是可构造（[=constructible=]）的类型。

当声明没有属性时，必须存在初始化表达式，名称表示该表达式的值。

<div class='example wgsl global-scope' heading='Module constants'>
  <xmp>
    // The golden ratio.
    let golden: f32 = 1.61803398875;

    // The second unit vector for three dimensions, with inferred type.
    let e2 = vec3<i32>(0,1,0);
  </xmp>
</div>

当声明使用 [=attribute/override=] 属性时，常量是管线可覆盖的（<dfn noexport>pipeline-overridable</dfn>）。在这种情况下：

  * 类型必须为 [=scalar=] 类型中的一种。
  * 初始化表达式是可选的。
  * 属性的文字操作数（如果存在）称为管线常量 ID（<dfn noexport>pipeline constant ID</dfn>），并且必须是 0 到 65535 之间的整数值。
  * [SHORTNAME] 程序中的管线常量 ID 必须是唯一的：两个模块常量不得使用相同的管线常量 ID。
  * 应用程序可以在管线创建时为常量指定其自己的值。管线创建 API 接受从可覆盖常量到常量类型值的映射。 常量由管线可覆盖常量标识符字符串（<dfn export>pipeline-overridable constant identifier string</dfn>）标识，如果指定，它是管线常量 ID （[=pipeline constant ID=]）的基数为 10 的表示，否则为常量的声明名称（[=name=]）。
  * 如果管线可覆盖常量的声明具有初始化表达式，则其具有默认值（<dfn export>pipeline-overridable constant has a default value</dfn>）。 如果没有，则必须在管线创建时提供一个值。

<div class='example wgsl global-scope' heading='Module constants, pipeline-overrideable'>
  <xmp>
    [[override(0)]]    let has_point_light: bool = true;  // Algorithmic control
    [[override(1200)]] let specular_param: f32 = 2.3;     // Numeric control
    [[override(1300)]] let gain: f32;                     // Must be overridden
    [[override]]       let width: f32 = 0.0;              // Specifed at the API level using
                                                          // the name "width".
    [[override]]       let depth: f32;                    // Specifed at the API level using
                                                          // the name "depth".
                                                          // Must be overridden.
  </xmp>
</div>

当在依赖于常量值的控制流中使用变量或特性时，则认为该变量或特性被程序使用。 无论常量的值如何，无论该值是来自常量声明的值还是来自管线覆盖的值，都是如此。

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_constant_decl</dfn> :

    | [=syntax/attribute_list=] * [=syntax/let=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/global_const_initializer=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>global_const_initializer</dfn> :

    | [=syntax/equal=] [=syntax/const_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>const_expression</dfn> :

    | [=syntax/type_decl=] [=syntax/paren_left=] ( ( [=syntax/const_expression=] [=syntax/comma=] ) * [=syntax/const_expression=] [=syntax/comma=] ? ) ? [=syntax/paren_right=]

    | [=syntax/const_literal=]
</div>

<div class='example' heading='Constants'>
  <xmp>
    -1
       %a = OpConstant %int -1

    2
       %b = OpConstant %uint 2

    3.2
       %c = OpConstant %float 3.2

    true
        %d = OpConstantTrue

    false
        %e = OpConstant False

    vec4<f32>(1.2, 2.3, 3.4, 2.3)
        %f0 = OpConstant %float 1.2
        %f1 = OpConstant %float 2.3
        %f2 = OpConstant %float 3.4
         %f = OpConstantComposite %v4float %f0 %f1 %f2 %f1
  </xmp>
</div>

Issue(dneto): WebGPU 管线创建 API 必须指定 API 提供的值如何映射到着色器标量值。对于布尔值，我建议使用 32 位整数，其中只有 0 映射到 `false`。 如果 [SHORTNAME] 获得非 32 位数字标量，我建议可覆盖的常量继续是 32 位数字类型。

## 函数作用域变量和常量 ## {#function-scope-variables}

在函数体中的声明语句中声明的变量或常量在函数作用域（<dfn noexport>function scope</dfn>）内。该名称可在其声明语句之后立即使用，直到紧随声明的括号分隔语句列表的末尾。

函数范围的 let 声明常量必须是可构造（[=constructible=]）类型或指针类型（[=pointer type=]）。

对于在函数作用域中声明的变量：
* 变量总是在函数（[=storage classes/function=]）存储类中。
* 存储修饰是可选的。
* 存储类型（[=store type=]）必须为可构造（[=constructible=]）类型。
* 当指定了初始化表达式时，可以从声明中省略存储类型。在这种情况下，存储类型是初始化表达式的计算结果的类型。

<div class='example wgsl global-scope' heading="Function scope variables and constants">
  <xmp highlight='rust'>
    fn f() {
       var<function> count: u32;  // 函数存储类中的变量。
       var delta: i32;            // 函数存储类中的另一个变量。
       var sum: f32 = 0.0;        // 拥有初始化值的函数存储类变量。
       var pi = 3.14159;          // 从初始化值推断出 f32 存储类型。
       let unit: i32 = 1;         // 未使用存储类的let-声明常量。
    }
  </xmp>
</div>

在 `for` 语句的第一个子句中声明的变量或常量可用于第二个和第三个子句以及 `for` 语句的主体中。

函数作用域变量的实例是动态上下文（[=dynamic context=]）。每个一些调用范围内的变量都有一个重叠的生命周期（[=lifetime=]），因此，具有不重叠的内存。生命周期不重叠的变量可能会重用之前变量的内存；但是，不能保证同一变量的新实例使用相同的内存。

# 表达式 # {#expressions}

表达式指定值如何被计算。

## 文字表达式 ## {#literal-expressions}

<table class='data'>
  <caption>标量文字类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td><td>`true`: bool<td>`true` 布尔值。 (OpConstantTrue)
  <tr><td><td>`false`: bool<td>`false` 布尔值。 (OpConstantFalse)
  <tr><td><td>*INT_LITERAL*: i32<td>有符号整数值。 (OpConstant)
  <tr><td><td>*UINT_LITERAL*: u32<td>无符号整数值。 (OpConstant)
  <tr><td><td>*FLOAT_LITERAL*: f32<td>浮点值。 (OpConstant)
</table>

## 括号表达式 ## {#parenthesized-expressions}

<table class='data'>
  <caption>括号表达式类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="parenthesized expression">
      <td>|e| : |T|
      <td>`(` |e| `)` : |T|
      <td>计算为 |e| 。<br>
          使用括号与表达式周围文本分隔。
</table>

## 类型构造函数表达式 ## {#type-constructor-expr}

类型构造函数表达式显式地创建给定类型的值。

标量形式是多余的，但提供标量转换表达式（[[#conversion-expr|conversion expressions]]）的对称性，并可用于增强可读性。

向量形式从具有匹配组件类型的组件和子向量的各种组合中构造向量值。

另见[[#zero-value-expr]] 和 [[#conversion-expr]]。

<table class='data'>
  <caption>标量构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td>*e*: bool<td>`bool(e)`: bool<td>本体。<br>在SPIR-V翻译中，表达式 ID 重用了操作数的 ID。
  <tr><td>*e*: i32<td>`i32(e)`: i32<td>本体。<br>在SPIR-V翻译中，表达式 ID 重用了操作数的 ID。
  <tr><td>*e*: u32<td>`u32(e)`: u32<td>本体。<br>在SPIR-V翻译中，表达式 ID 重用了操作数的 ID。
  <tr><td>*e*: f32<td>`f32(e)`: f32<td>本体。<br>在SPIR-V翻译中，表达式 ID 重用了操作数的 ID。
</table>

<table class='data'>
  <caption>向量构造函数类型规则，其中 *T* 为标量类型。</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="construct a vector from copies of a single scalar">
    <td>|e|: |T|
    <td>`vec`|N|`<`|T|`>(`|e|`)`: vec|N|&lt;|T|&gt;
    <td>计算 |e| 一次。结果为一个有 |N| 个元素的向量，每个向量分量值为 |e|。
  <tr>
    <td>*e1*: *T*<br>
        *e2*: *T*
    <td>`vec2<T>(e1,e2)`: vec2<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e*: vec2&lt;T&gt;
    <td>`vec2<T>(e)`: vec2<*T*>
    <td>本体。结果为 |e|。
  <tr>
    <td>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: *T*
    <td>`vec3<T>(e1,e2,e3)`: vec3<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e1*: *T*<br>
        *e2*: vec2<*T*>
    <td>`vec3<T>(e1,e2)`: vec3<*T*><br>
        `vec3<T>(e2,e1)`: vec3<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e*: vec3&lt;T&gt;
    <td>`vec3<T>(e)`: vec3<*T*>
    <td>本体。结果为 |e|。
  <tr>
    <td>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: *T*<br>
        *e4*: *T*
    <td>`vec4<T>(e1,e2,e3,e4)`: vec4<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: vec2<*T*>
    <td>`vec4<T>(e1,e2,e3)`: vec4<*T*><br>
        `vec4<T>(e1,e3,e2)`: vec4<*T*><br>
        `vec4<T>(e3,e1,e2)`: vec4<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e1*: vec2<*T*><br>
        *e2*: vec2<*T*>
    <td>`vec4<T>(e1,e2)`: vec4<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e1*: *T*<br>
        *e2*: vec3<*T*>
    <td>`vec4<T>(e1,e2)`: vec4<*T*><br>
        `vec4<T>(e2,e1)`: vec4<*T*>
    <td>OpCompositeConstruct
  <tr>
    <td>*e*: vec4&lt;T&gt;
    <td>`vec4<T>(e)`: vec4<*T*>
    <td>本体。结果为 |e|。
</table>

<table class='data'>
  <caption>矩阵构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>|e1|: |f32|<br>
        ...<br>
        |eN|: |f32|
    <td>`mat2x2<f32>(e1,e2,e3,e4)`: mat2x2&lt;f32&gt;<br>
        `mat3x2<f32>(e1,...,e6)`: mat3x2&lt;f32&gt;<br>
        `mat2x3<f32>(e1,...,e6)`: mat2x3&lt;f32&gt;<br>
        `mat4x2<f32>(e1,...,e8)`: mat4x2&lt;f32&gt;<br>
        `mat2x4<f32>(e1,...,e8)`: mat2x4&lt;f32&gt;<br>
        `mat3x3<f32>(e1,...,e9)`: mat3x3&lt;f32&gt;<br>
        `mat4x3<f32>(e1,...,e12)`: mat4x3&lt;f32&gt;<br>
        `mat3x4<f32>(e1,...,e12)`: mat3x4&lt;f32&gt;<br>
        `mat4x4<f32>(e1,...,e16)`: mat4x4&lt;f32&gt;
    <td>通过元素列主序构造。<br>
        OpCompositeConstruct
  <tr>
    <td>*e1*: vec2&lt;f32&gt;<br>
        *e2*: vec2&lt;f32&gt;<br>
        *e3*: vec2&lt;f32&gt;<br>
        *e4*: vec2&lt;f32&gt;
    <td>`mat2x2<f32>(e1,e2)`: mat2x2&lt;f32&gt;<br>
        `mat3x2<f32>(e1,e2,e3)`: mat3x2&lt;f32&gt;<br>
        `mat4x2<f32>(e1,e2,e3,e4)`: mat4x2&lt;f32&gt;
    <td>一列一列构造。<br>
        OpCompositeConstruct
  <tr>
    <td>*e1*: vec3&lt;f32&gt;<br>
        *e2*: vec3&lt;f32&gt;<br>
        *e3*: vec3&lt;f32&gt;<br>
        *e4*: vec3&lt;f32&gt;
    <td>`mat2x3<f32>(e1,e2)`: mat2x3&lt;f32&gt;<br>
        `mat3x3<f32>(e1,e2,e3)`: mat3x3&lt;f32&gt;<br>
        `mat4x3<f32>(e1,e2,e3,e4)`: mat4x3&lt;f32&gt;
    <td>一列一列构造。<br>
        OpCompositeConstruct
  <tr>
    <td>*e1*: vec4&lt;f32&gt;<br>
        *e2*: vec4&lt;f32&gt;<br>
        *e3*: vec4&lt;f32&gt;<br>
        *e4*: vec4&lt;f32&gt;
    <td>`mat2x4<f32>(e1,e2)`: mat2x4&lt;f32&gt;<br>
        `mat3x4<f32>(e1,e2,e3)`: mat3x4&lt;f32&gt;<br>
        `mat4x4<f32>(e1,e2,e3,e4)`: mat4x4&lt;f32&gt;
    <td>一列一列构造。<br>
        OpCompositeConstruct
</table>

<table class='data'>
  <caption>数组构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="array value construction">
    <td>|e1|: |T|<br>
        ...<br>
        |eN|: |T|,<br>
        |T| is a [=constructible=] type.
    <td>`array<`|T|,|N|`>(`|e1|,...,|eN|`)` : array&lt;|T|,|N|&gt;
    <td>从元素进行的数组构造。
</table>

<table class='data'>
  <caption>结构构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="structure value construction">
    <td>|e1|: |T1|<br>
        ...<br>
        |eN|: |TN|,<br>
        |S| is a [=constructible=] structure type with members having types |T1| ... |TN|.<br>
        The expression is in the scope of declaration of |S|.
    <td>|S|`(`|e1|,...,|eN|`)`: |S|
    <td>从成员进行的结构构造。
</table>

## 零值表达式 ## {#zero-value-expr}

每个可构造的（[=constructible=]） *T* 都有一个唯一的零值（<dfn noexport>zero value</dfn>），在 WGSL 中编写为，类型后面跟一对空括号：*T* `()`。

零值如下：

* `bool()` 为 `false`
* `i32()` 为 0
* `u32()` 为 0
* `f32()` 为 0.0
* 具有 *N* 个类型 *T* 元素的向量的零值为一个 *N*-元素向量，每个分量值为 *T* 的零值。
* *N*-列 *M*行类型为 `f32` 的矩阵的零值为该维度向量被0.0项填充。
* 具有可构造（[=constructible=]）元素类型 *E* 的 *N*-元素向量的零值为一个有 *N* 个元素的数组，数组的每个分量为 *E* 的零值。
* 可构造（[=constructible=]）类型 *S* 的零值为构造值 *S* 的零值成员。

注意：WGSL中原子类型（[=atomic types=]），[=runtime-sized=]数组，以及其他非可构造（[=constructible=]）类型没有零值表达式。

<table class='data'>
  <caption>标量零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td><td>`bool()`: bool<td>false<br>零值 (OpConstantNull for bool)
  <tr><td><td>`i32()`: i32<td>0<br>零值 (OpConstantNull for i32)
  <tr><td><td>`u32()`: u32<td>0u<br>零值 (OpConstantNull for u32)
  <tr><td><td>`f32()`: f32<td>0.0<br>零值 (OpConstantNull for f32)
</table>

<table class='data'>
  <caption>向量零值类型规则，其中 *T* 为标量类型</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>
    <td>`vec2<T>()`: vec2<*T*>
    <td>零值 (OpConstantNull)
  <tr>
    <td>
    <td>`vec3<T>()`: vec3<*T*>
    <td>零值 (OpConstantNull)
  <tr>
    <td>
    <td>`vec4<T>()`: vec4<*T*>
    <td>零值 (OpConstantNull)
</table>


<div class='example' heading="Zero-valued vectors">
  <xmp highlight='rust'>
    vec2<f32>()                 // 两个 f32 元素的零值向量。
    vec2<f32>(0.0, 0.0)         // 相同的值，明确写入。

    vec3<i32>()                 // 三个 i32 元素的零值向量。
    vec3<i32>(0, 0, 0)          // 相同的值，明确写入。
  </xmp>
</div>

<table class='data'>
  <caption>向量零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>
    <td>`mat2x2<f32>()`: mat2x2&lt;f32&gt;<br>
        `mat3x2<f32>()`: mat3x2&lt;f32&gt;<br>
        `mat4x2<f32>()`: mat4x2&lt;f32&gt;
    <td>零值 (OpConstantNull)
  <tr>
    <td>
    <td>`mat2x3<f32>()`: mat2x3&lt;f32&gt;<br>
        `mat3x3<f32>()`: mat3x3&lt;f32&gt;<br>
        `mat4x3<f32>()`: mat4x3&lt;f32&gt;
    <td>零值 (OpConstantNull)
  <tr>
    <td>
    <td>`mat2x4<f32>()`: mat2x4&lt;f32&gt;<br>
        `mat3x4<f32>()`: mat3x4&lt;f32&gt;<br>
        `mat4x4<f32>()`: mat4x4&lt;f32&gt;
    <td>零值 (OpConstantNull)
</table>

<table class='data'>
  <caption>数组零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="array zero value">
    <td>|T| is a [=constructible=]
    <td>`array<`|T|,|N|`>()`: array&lt;|T|,|N|&gt;
    <td>零值数组 (OpConstantNull)
</table>

<div class='example' heading="Zero-valued arrays">
  <xmp highlight='rust'>
    array<bool, 2>()               // 两个布尔值的零值数组。
    array<bool, 2>(false, false)   // 相同的值，明确写入。
  </xmp>
</div>

<table class='data'>
  <caption>结构零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="structure zero value">
    <td>|S| is a [=constructible=] structure type.<br>
         The expression is in the scope of declaration of |S|.
    <td>|S|`()`: |S|
    <td>零值结构：类型为 |S| 的结构，每个成员为其成员类型的零值。
<br>
 (OpConstantNull)
</table>

<div class='example wgsl global-scope' heading="Zero-valued structures">
  <xmp highlight='rust'>
    struct Student {
      grade: i32;
      GPA: f32;
      attendance: array<bool,4>;
    };

    fn func() {
      var s: Student;

      // Student 的零值。
      s = Student();

      // 相同的值，明确写入。
      s = Student(0, 0.0, array<bool,4>(false, false, false, false));

      // 相同的值，用零值成员写入。
      s = Student(i32(), f32(), array<bool,4>());
    }
  </xmp>
</div>


## 转换表达式 ## {#conversion-expr}

[SHORTNAME] 不隐式转换或提升一个数值或布尔值为另外的类型。而是使用以下表格中描述的转换表达式。

另见[[#type-constructor-expr]]。

<table class='data'>
  <caption>标量转换类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="coercion to boolean from unsigned">
      <td>|e|: u32<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 为 0 则结果值为假，否则为真。<br>
          （使用 OpINotEqual 去对比 |e| 和 0。）
  <tr algorithm="coercion to boolean from signed">
      <td>|e|: i32<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 为 0 则结果值为假，否则为真。<br>
          （使用 OpINotEqual 去对比 |e| 和 0。）
  <tr algorithm="coercion to boolean from floating point">
      <td>|e|: f32<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 为 0.0 或 -0.0 则结果值为假，否则为真。特殊地，NaN 和 infinity 值映射为真。<br>
          （使用 OpFUnordNotEqual 去对比 |e| 和 `0.0`。）
  <tr algorithm="conversion from boolean to signed">
      <td>|e|: bool<td>`i32(`|e|`)`: i32
      <td>转换一个布尔值至一个有符号整数<br>
          当 |e| 为真时结果为 1，否则结果为 0。<br>
          （使 |e| 为条件使用 OpSelect，选择 1 至 0。）
  <tr algorithm="scalar reinterpretation from unsigned to signed">
      <td>|e|: u32<td>`i32(`|e|`)`: i32
      <td>位的重新解释。<br>
          结果是类型为 [=i32=] 的唯一值，等于 (|e| mod 2<sup>32</sup>)。<br>
          (OpBitcast)
  <tr algorithm="scalar conversion from floating point to signed integer">
      <td>|e|: f32<td>`i32(`|e|`)`: i32<td>
      数值转换，包括无效数值。（OpConvertFToS）
  <tr algorithm="conversion from boolean to unsigned">
      <td>|e|: bool<td>`u32(`|e|`)`: u32
      <td>
      转换布尔值为无符号整数<br>
      |e| 为真时结果为 1u，否则为 0u。<br>
      （使 |e| 为条件使用 OpSelect，选择 1 至 0。）
  <tr algorithm="scalar conversion from signed integer to unsigned integer">
      <td>|e|: i32<td>`u32(`|e|`)`: u32
      <td>位的重新解释。<br>
          结果是类型为 [=u32=] 的唯一值，等于 (|e| mod 2<sup>32</sup>)。<br>
          (OpBitcast)
  <tr algorithm="scalar conversion from floating point to unsigned integer">
      <td>|e|: f32<td>`u32(`|e|`)`: u32
      <td>值的转换，包括无效例。(OpConvertFToU)
  <tr algorithm="conversion from boolean to floating point">
      <td>|e|: bool<td>`f32(`|e|`)`: f32
      <td>
      转换布尔值至浮点值。<br>
      |e| 为真时结果为 1.0，否则为 0.0。<br>
      （使 |e| 为条件对其使用 OpSelect，选择 1.0 至 0.0。）
  <tr algorithm="scalar conversion from signed integer to floating point">
      <td>|e|: i32<td>`f32(`|e|`)`: f32<td>值的转换，包括无效例。(OpConvertSToF)
  <tr algorithm="scalar conversion from unsigned integer to floating point">
      <td>|e|: u32<td>`f32(`|e|`)`: f32<td>值的转换，包括无效例。(OpConvertUToF)
</table>

[[#floating-point-conversion]]中解释了与浮点之间的转换细节。

<table class='data'>
  <caption>向量转换类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="vector coercion of unsigned integer to boolean">
     <td>|e|: vec|N|&lt;u32&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>无符号整数向量至布尔向量的[=Component-wise=]强制转换。<br>
     （使用 OpINotEqual 去比较 |e| 和零向量）

  <tr algorithm="vector coercion of signed integer to boolean">
     <td>|e|: vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>有符号整数向量至布尔向量的[=Component-wise=]强制转换。<br>
     （使用 OpINotEqual 去比较 |e| 和零向量）

  <tr algorithm="vector coercion of floating point to boolean">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>浮点型向量至布尔向量的[=Component-wise=]强制转换。<br>
     （使用 OpFUnordNotEqual 去比较 |e| 和零向量）

  <tr algorithm="vector conversion from bool to signed">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt
     <td>布尔向量至有符号向量的[=Component-wise=]强制转换。<br>
     结果的分量 |i| 为 `i32(`|e|`[`|i|`])`<br>
     （使 |e| 为条件，与其一起使用 OpSelect，选择 `vec`|N|(1) 至 `vec`|N|(0) 区间。）

  <tr algorithm="vector reinterpretation from unsigned to signed">
     <td>|e|: vec|N|&lt;u32&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt
     <td>位的[=Component-wise=]重新解释。
     结果的分量 |i| 为 `i32(`|e|`[`|i|`])`<br>
     (OpBitcast)

  <tr algorithm="vector conversion from floating point to signed integer">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt;
     <td>值的[=Component-wise=]转换至有符号整数，包括无效例。<br>
     (OpConvertFToS)

  <tr algorithm="vector conversion from bool to unsigned">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt
     <td>布尔向量至无符号向量的[=Component-wise=]转换。<br>
     结果的分量 |i| 为 `u32(`|e|`[`|i|`])`<br>
     （使 |e| 为条件，与其一起使用 OpSelect，选择 `vec`|N|(1u) 至 `vec`|N|(0u) 区间。）

  <tr algorithm="vector reinterpretation from signed to unsigned">
     <td>|e|: vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>位的[=Component-wise=]重新解释。<br>
        (OpBitcast)

  <tr algorithm="vector conversion from floating point to unsigned integer">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>值的[=Component-wise=]转换至无符号整数，包括无效例。<br>
        (OpConvertFToU)

  <tr algorithm="vector conversion from bool to floating point">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt
     <td>布尔向量至浮点型的[=Component-wise=]转换。<br>
     结果的分量 |i| 为 `f32(`|e|`[`|i|`])`<br>
     使 |e| 为条件，使用 OpSelect，选择 `vec`|N|(1.0) 至 `vec`|N|(0.0) 区间。

  <tr algorithm="vector conversion from signed integer to floating point">
     <td>|e|: vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>值的[=Component-wise=]转换至浮点型，包括无效例。<br>
     (OpConvertSToF)

  <tr algorithm="vector conversion from unsigned integer to floating point">
     <td>|e|: vec|N|&lt;u32&gt;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>值的[=Component-wise=]转换至浮点型，包括无效例。<br>
     (ConvertUToF)
</table>

## 表示表达式的重新解释 ## {#bitcast-expr}

`bitcast`表达式用于将一种类型中的值的位表示重新解释为另一种类型中的值。

<table class='data'>
  <caption>Bitcast类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="identity reinterpretation">
    <td>|e|: |T|<br>
    |T| 为一个数值标量（[=numeric scalar=]）或数值向量（[=numeric vector=]）类型
    <td class="nowrap">bitcast&lt;|T|&gt;(|e|): |T|
    <td>本体变换。当 |T| 为向量时[=Component-wise=]。<br>
    结果为 |e|。<br>
    在 SPIR-V 翻译中，此表达式的 ID 重用了操作数的 ID。

  <tr algorithm="general reinterpretation">
    <td>|e|: |T1|<br>
    |T1| 为一个数值标量（[=numeric scalar=]）或数值向量（[=numeric vector=]）类型<br>
    |T2| 不为 |T1|，并且当 |T1| 为标量时，|T2|为一个数值标量类型。当 |T1| 为向量时，为数值向量类型。
    <td class="nowrap">bitcast&lt;|T2|&gt;(|e|): |T2|
    <td>将位重新解释为 |T2|。当 |T1| 为向量是，|T2| 为 [=Component-wise=]。<br>
    结果为将 |e| 中的位重新解释为 |T2| 值。<br>
    (OpBitcast)
</table>

## 复合值分解表达式 ## {#composite-value-decomposition-expr}

### 向量访问表达式 ### {#vector-access-expr}

访问向量的成员可以使用数组下标（例如 `a[2]`）或使用一系列便名，每个成员都映射到源向量的一个元素。

<ul>
  <li>颜色的便名集合为 `r`, `g`, `b`, `a` ，分别对应向量元素 0, 1, 2, 和 3。
  <li>维度的便名集合为 `x`, `y`, `z`, `w` ，分别对应向量元素 0, 1, 2, 和 3。
</ul>

便名访问通过 `.` 符号。（比如，`color.bgra`）

注意：便名字母不能倍混合使用。（即，你不能使用 `rybw`）

使用便名字母，或数组下标，访问超过向量末尾的元素会出现错误。

便名字母可以按任何顺序应用，包括根据需要复制字母。从向量中提取分量时，你可以提供 1 到 4 个字母。提供超过 4 个字母是错误的。

结果类型取决于提供的字母。假设为一个 `vec4<f32>`
<table>
  <thead>
    <tr><th>Accessor<th>Result type
  </thead>
  <tr><td>r<td>`f32`
  <tr><td>rg<td>`vec2<f32>`
  <tr><td>rgb<td>`vec3<f32>`
  <tr><td>rgba<td>`vec4<f32>`
</table>

<div class='example wgsl function-scope'>
  <xmp highlight='rust'>
    var a: vec3<f32> = vec3<f32>(1., 2., 3.);
    var b: f32 = a.y;          // b = 2.0
    var c: vec2<f32> = a.bb;   // c = (3.0, 3.0)
    var d: vec3<f32> = a.zyx;  // d = (3.0, 2.0, 1.0)
    var e: f32 = a[1];         // e = 2.0
  </xmp>
</div>

#### 向量单分量选择 #### {#vector-single-component}

<table class='data'>
  <caption>向量分解：单分量选择</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.x`: |T|<br>
           |e|`.r`: |T|
       <td>选择 |e| 的第一个分量<br>
           (选择索引为 0 的 OpCompositeExtract)
  <tr algorithm="second vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.y`: |T|<br>
           |e|`.g`: |T|
       <td>选择 |e| 的第二个分量<br>
           (选择索引为 1 的 OpCompositeExtract)
  <tr algorithm="third vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
          |N| is 3 or 4
       <td class="nowrap">
           |e|`.z`: |T|<br>
           |e|`.b`: |T|
       <td>选择 |e| 的第三个分量<br>
           (选择索引为 2 的 OpCompositeExtract)
  <tr algorithm="fourth vector component selection"><td>|e|: vec4&lt;|T|&gt;
       <td class="nowrap">
           |e|`.w`: |T|<br>
           |e|`.a`: |T|
       <td>选择 |e| 的第四个分量<br>
           (选择索引为 3 的 OpCompositeExtract)
  <tr algorithm="vector indexed component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |e|[|i|]: |T|
       <td>选择 |e| 的第 |i| 个分量<br>
           第一个分量在 |i|=0 处。
           如果 |i| 在区间 [0,|N|-1] 外，那么 |T| 的任何值都可能被返回。
           （OpVectorExtractDynamic）
</table>

#### 向量多分量选择 #### {#vector-multi-component}

<table class='data'>
  <caption>向量分解：多分量选择
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="two component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |J| 为字母 `x`, `y`, `z`, 或 `w`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J| 来计算2-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `z` 有效。<br>
       仅当 |N| 为 4 时，字母 `w` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="two component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |J| 为字母 `r`, `g`, `b`, 或 `a`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J| 来计算2-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `b` 有效。<br>
       仅当 |N| 为 4 时，字母 `a` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="three component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |J| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |K| 为字母 `x`, `y`, `z`, 或 `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，以及第三个分量 |e|.|K| 来计算3-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `z` 有效。<br>
       仅当 |N| 为 4 时，字母 `w` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="three component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |J| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |K| 为字母 `r`, `g`, `b`, 或 `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，以及第三个分量 |e|.|K| 来计算3-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `b` 有效。<br>
       仅当 |N| 为 4 时，字母 `a` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="four component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |J| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |K| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |L| 为字母 `x`, `y`, `z`, 或 `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，第三个分量 |e|.|K|，以及第四个分量 |e|.|L| 来计算4-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `z` 有效。<br>
       仅当 |N| 为 4 时，字母 `w` 有效。<br>
       （OpVectorShuffle）
  <tr algorithm="four component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |J| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |K| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |L| 为字母 `r`, `g`, `b`, 或 `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，第三个分量 |e|.|K|，以及第四个分量 |e|.|L| 来计算4-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `b` 有效。<br>
       仅当 |N| 为 4 时，字母 `a` 有效。<br>
       （OpVectorShuffle）
</table>

#### 来自向量引用的分量引用 #### {#component-reference-from-vector-reference}

对向量的分量的写访问（[=write access=]）**可能** 访问与该向量相关联的所有内存位置（[=memory
location|memory locations=]）。

注意：这意味着如果至少一个访问是写访问，则通过不同调用对向量的不同组件的访问必须被同步。见[[#sync-builtin-functions]]。

<table class='data'>
  <caption>从对向量的引用获取对分量的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component reference selection">
       <td>|r|: ref&lt;|SC|,vec|N|&lt;|T|&gt;&gt;<br>
       <td class="nowrap">
           |r|`.x`: ref&lt;|SC|,|T|&gt;<br>
           |r|`.r`: ref&lt;|SC|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第一个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （索引值为 0 的 OpAccessChain）
  <tr algorithm="second vector component reference selection">
       <td>|r|: ref&lt;|SC|,vec|N|&lt;|T|&gt;&gt;<br>
       <td class="nowrap">
           |r|`.y`: ref&lt;|SC|,|T|&gt;<br>
           |r|`.g`: ref&lt;|SC|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第二个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （索引值为 1 的 OpAccessChain）
  <tr algorithm="third vector component reference selection">
       <td>|r|: ref&lt;|SC|,vec|N|&lt;|T|&gt;&gt;<br>
           |N| is 3 or 4
       <td class="nowrap">
           |r|`.z`: ref&lt;|SC|,|T|&gt;<br>
           |r|`.b`: ref&lt;|SC|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第三个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （索引值为 2 的 OpAccessChain）
  <tr algorithm="fourth vector component reference selection">
       <td>|r|: ref&lt;|SC|,vec4&lt;|T|&gt;&gt;<br>
       <td class="nowrap">
           |r|`.w`: ref&lt;|SC|,|T|&gt;<br>
           |r|`.a`: ref&lt;|SC|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第四个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （索引值为 3 的 OpAccessChain）
  <tr algorithm="vector indexed component reference selection">
       <td>|r|: ref&lt;|SC|,vec|N|&lt;|T|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|SC|,|T|&gt;
       <td>计算引用 |r| 所引用的向量的第 |i| 个分量的引用。
       如果 |i| 在区间 [0,|N|-1] 外，则表达式计算为 [=invalid memory reference=]。
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （OpAccessChain）
</table>

### 矩阵访问表达式 ### {#matrix-access-expr}

<table class='data'>
  <caption>列向量提取</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector selection">
       <td class="nowrap">
          |e|: mat|N|x|M|&lt;|T|&gt;<br>
          |i|: [INT]<br>
          |i| 为一个 `const_expression` 表达式
       <td class="nowrap">
           |e|[|i|]: vec|M|&lt;|T|&gt;
       <td>结果为向量 |e| 的第 |i| 列。如果 |i| 在区间 [0,|N|-1]，则可能返回 vec|M|&lt;|T|&gt; 的无效值。
       （OpCompositeExtract）
</table>

<table class='data'>
  <caption>从对矩阵的引用获取对列向量的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector reference selection">
       <td class="nowrap">
          |r|: ref&lt;|SC|,mat|N|x|M|&lt;|T|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;vec|M|&lt;|SC|,|T|&gt;&gt;
       <td>通过引用 |r| 计算矩阵第 |i| 个列向量的引用。
       如果 |i| 在区间 [0,|N|-1] 外，则表达式计算为无效内存引用（[=invalid memory reference=]）。
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
       （OpAccessChain）
</table>

注意：反映 WGSL 旨在翻译成的语言的限制，只能使用动态计算的索引来标注对矩阵的引用。不在引用后面的矩阵只能由 `const_expression` 进行标注索引。要解决此限制，请考虑将矩阵存储在临时变量中，然后为变量添加下标：[[#var-identifier-expr|variable identifier expression]根据需要生成对变量值的引用。

### 数组访问表达式 ### {#array-access-expr}

<table class='data'>
  <caption>数组元素提取</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed element selection">
       <td class="nowrap">
          |e|: array&lt;|T|,|N|&gt;<br>
          |i|: [INT]<br>
          |i| 为 `const_expression` 表达式
       <td class="nowrap">
           |e|[|i|] : |T|
       <td>结果为数组值 |e| 的第 |i| 个元素的值。
       如果 |i| 在区间 [0,|N|-1] 外，则任何 |T| 的有效值可能被返回。
       （OpCompositeExtract）
</table>

<table class='data'>
  <caption>从对数组的引用获取对数组元素的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed reference selection">
       <td class="nowrap">
          |r|: ref&lt;|SC|,array&lt;|T|,|N|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|SC|,|T|&gt;
       <td>计算对由引用 |r| 引用的数组的第 |i| 个元素的引用。

       如果 |i| 在区间 [0,|N|-1] 外，则表达式计算为一个无效内存引用（[=invalid memory reference=]）。

       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。
       （OpAccessChain）
  <tr algorithm="array indexed reference selection">
       <td>|r|: ref&lt;|SC|,array&lt;|T|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|SC|,|T|&gt;
       <td>计算对由引用 |r| 引用的runtime-sized数组的第 |i| 个元素的引用。

       如果在运行时数组有 |N| 个元素，且 |i| 在区间 [0,|N|-1] 外，则表达式计算为一个无效内存引用（[=invalid memory reference=]）。

       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。
       （OpAccessChain）
</table>

注意：反映 WGSL 旨在翻译成的语言的限制，只能使用动态计算的索引来下标对数组的引用。不在引用后面的数组只能由 `const_expression` 索引。

### 结构访问表达式 ### {#struct-access-expr}

<table class='data'>
  <caption>结构成员提取</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member extraction">
       <td class="nowrap">
          |S| 为一个结构类型<br>
          |M| 为类型为 |T| 的 |S| 中成员的标识符名称。<br>
          |e|: |S|<br>
       <td class="nowrap">
           |e|.|M|: |T|
       <td>结果是结构值 |e| 中名称为 |M| 的成员的值。

       （OpCompositeExtract，使用成员索引）
</table>

<table class='data'>
  <caption>从对结构的引用获取对结构成员的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member reference selection">
       <td class="nowrap">
          |S| 为一个结构类型<br>
          |M| 为类型为 |T| 的 |S| 中的成员名称。<br>
          |r|: ref&lt;|SC|,|S|&gt;<br>
       <td class="nowrap">
           |r|.|M|: ref&lt;|SC|,|T|&gt;
       <td>给定对结构的引用，结果是对标识符名称为 |M| 的结构成员的引用。结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。

       （OpAccessChain，使用结构成员的索引）
</table>

## 逻辑表达式 ## {#logical-expr}
<table class='data'>
  <caption>一元逻辑运算</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="boolean negation"><td>|e|: bool<br>|T| 为布尔值或 vec|N|&lt;bool&gt;
  <td>`!`|e|: |T|
  <td>逻辑否定。

  当 |e| 为 `false` 时结果为 `true`，当 |e| 为 `true` 是结果为 `false`。

  当 |T| 为向量时，[=Component-wise=]。

  （OpLogicalNot）
</table>

<table class='data'>
  <caption>二元逻辑表达式</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="short-circuiting or"><td>|e1|: bool<br>|e2|: bool<td>|e1| `||` |e2|`: bool`
  <td>短路“或”。如果 |e1| 或 |e2| 为真，则为真； 仅当 |e1| 为假时才计算 |e2|。

  <tr algorithm="short-circuiting and"><td>|e1|: bool<br>|e2|: bool
  <td>|e1| `&&` |e2|`: bool`
  <td>短路“与”。 如果 |e1| 和 |e2| 都为真，则为真； 仅当 |e1| 为真时才计算 |e2|。

  <tr algorithm="logical or"><td>|e1|: |T|<br>|e2|: |T|<br>|T| 为布尔值或 vec|N|&lt;bool&gt;
  <td>|e1| `|` |e2|`:` |T|
  <td>逻辑“或”。

  当 |T| 是向量时，[=Component-wise=]。

  计算 |e1| 和 |e2|。
  Logical "or". [=Component-wise=] when |T| is a vector. Evaluates both |e1| and |e2|.

  <tr algorithm="logical and"><td>|e1|: |T|<br>|e2|: |T|<br>|T| 为布尔值或 vec|N|&lt;bool&gt;
  <td>|e1| `&` |e2|`:` |T|
  <td>逻辑“与”。

  当 |T| 是向量时，[=Component-wise=]。

  计算 |e1| 和 |e2|。
</table>


## 算术表达式 ## {#arithmetic-expr}

<table class='data'>
  <caption>一元算术表达式</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="integer negation"><td>|e|: |T|<br>
  |T| 为 [SIGNEDINTEGRAL]
  <td>`-`|e|`:` |T|
  <td>有符号整数否定。

  当 |T| 是向量时，[=Component-wise=]。

  如果 |e| 计算为最大的负值，则结果为 |e|。

  （OpSNegate）

  <tr algorithm="floating point negation"><td>|e|: |T|<br>|T| 为 [FLOATING]
  <td>`-`|e|`:` |T|
  <td>浮点否定。

  当 |T| 是向量时，[=Component-wise=]。

  （OpFNegate）
</table>

<table class='data'>
  <caption>Binary arithmetic expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="integer addition">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [INTEGRAL]
    <td>|e1| `+` |e2| : |T|
    <td>整数加法，模2<sup>32</sup>。

    当 |T| 是向量时，[=Component-wise=]。

    （OpIAdd）
  <tr algorithm="floating point addition">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [FLOATING]
    <td>|e1| `+` |e2| : |T|
    <td>浮点加法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpFAdd）

  <tr algorithm="integer subtraction">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [INTEGRAL]
    <td>|e1| `-` |e2| : |T|
    <td>整数减法，模2<sup>32</sup>。

    当 |T| 是向量时，[=Component-wise=]。

    （OpISub）
  <tr algorithm="floating point subtraction">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [FLOATING]
    <td>|e1| `-` |e2| : |T|
    <td>浮点减法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpFSub）

  <tr algorithm="integer multiplication">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [INTEGRAL]
    <td>|e1| `*` |e2| : |T|
    <td>整数乘法，模2<sup>32</sup>。

    当 |T| 是向量时，[=Component-wise=]。

    （OpIMul）
  <tr algorithm="floating point multiplication">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| is [FLOATING]
    <td>|e1| `*` |e2| : |T|
    <td>浮点乘法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpFMul）

  <tr algorithm="signed integer division">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [SIGNEDINTEGRAL]
    <td>|e1| `/` |e2| : |T|
    <td>有符号整数除法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpSDiv）
  <tr algorithm="unsigned integer division">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [UNSIGNEDINTEGRAL]
    <td>|e1| `/` |e2| : |T|
    <td>无符号整数除法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpUDiv）
  <tr algorithm="floating point division">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [FLOATING]
    <td>|e1| `/` |e2| : |T|
    <td>浮点除法。

    当 |T| 是向量时，[=Component-wise=]。

    （OpFDiv）

  <tr algorithm="signed integer remainder">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [SIGNEDINTEGRAL]
    <td>|e1| `%` |e2| : |T|
    <td>有符号整数取余。

    当 |T| 是向量时，[=Component-wise=]。

    （OpSMod）
  <tr algorithm="unsigned integer modulus">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [UNSIGNEDINTEGRAL]
    <td>|e1| `%` |e2| : |T|
    <td>无符号整数取余。

    当 |T| 是向量时，[=Component-wise=]。

    （OpUMod）
  <tr algorithm="floating point remainder">
    <td>|e1| : |T|<br>|e2| : |T|<br>|T| 为 [FLOATING]
    <td>|e1| `%` |e2| : |T|
    <td>浮点取余。非零结果的符号与 |e1| 的符号相匹配。

    当 |T| 是向量时，[=Component-wise=]。

    结果等于：|e1| - |e2| * trunc(|e1| / |e2|)<br>

    （OpFRem）

</table>

<table class='data'>
  <caption>具有混合标量和向量操作数的二元算术表达式</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
  <tr algorithm="vector-scalar arithmetic, any scalar type">
    <td rowspan="8">|S| 为 f32, i32, u32 之一<br>
        |V| 为 vec|N|&lt;|S|&gt<br>
        |es|: |S|<br>
        |ev|: |V|
    <td>|ev| `+` |es|: |V|
    <td>|ev| `+` |V|(|es|)
  <tr>
    <td>|es| `+` |ev|: |V|
    <td>|V|(|es|) `+` |ev|
  <tr>
    <td>|ev| `-` |es|: |V|
    <td>|ev| `-` |V|(|es|)
  <tr>
    <td>|es| `-` |ev|: |V|
    <td>|V|(|es|) `-` |ev|
  <tr>
    <td>|ev| `*` |es|: |V|
    <td>|ev| `*` |V|(|es|)
  <tr>
    <td>|es| `*` |ev|: |V|
    <td>|V|(|es|) `*` |ev|
  <tr>
    <td>|ev| `/` |es|: |V|
    <td>|ev| `/` |V|(|es|)
  <tr>
    <td>|es| `/` |ev|: |V|
    <td>|V|(|es|) `/` |ev|
  <tr algorithm="vector-scalar integer arithmetic">
    <td rowspan="2">|S| 为 i32, u32 之一<br>
        |V| 为 vec|N|&lt;|S|&gt<br>
        |es|: |S|<br>
        |ev|: |V|
    <td>|ev| `%` |es|: |V|
    <td>|ev| `%` |V|(|es|)
  <tr>
    <td>|es| `%` |ev|: |V|
    <td>|V|(|es|) `%` |ev|
</table>

<table class='data'>
  <caption>矩阵运算</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
  <tr algorithm="matrix addition">
    <td rowspan=2>|e1|, |e2|: mat|M|x|N|&lt;f32&gt
    <td>|e1| `+` |e2|: mat|M|x|N|&lt;f32&gt<br>
    <td>矩阵加法，结果的第 |i| 列为 |e1|[i] + |e2|[i]。
  <tr algorithm="matrix subtraction">
    <td>|e1| `-` |e2|: mat|M|x|N|&lt;f32&gt
    <td>矩阵减法，结果的第 |i| 列为 |e1|[|i|] - |e2|[|i|]。
  <tr algorithm="matrix-scalar multiply">
    <td rowspan=2>|m|: mat|M|x|N|&lt;f32&gt<br>
        |s|: f32
    <td>|m| `*` |s|:  mat|M|x|N|&lt;f32&gt<br>
    <td>Component-wise 缩放: (|m| `*` |s|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="scalar-matrix multiply">
    <td>|s| `*` |m|:  mat|M|x|N|&lt;f32&gt<br>
    <td>Component-wise 缩放: (|s| `*` |m|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="matrix-column-vector multiply">
    <td>|m|: mat|M|x|N|&lt;f32&gt<br>
        |v|: vec|M|&lt;f32&gt
    <td>|m| `*` |v|:  vec|N|&lt;f32&gt<br>
    <td>线性代数矩阵-列-向量乘积：

    结果的 |i| 分量为 `dot`(|m|[|i|],|v|)。

    <br>OpMatrixTimesVector
  <tr algorithm="matrix-row-vector multiply">
    <td>
        |m|: mat|M|x|N|&lt;f32&gt<br>
        |v|: vec|N|&lt;f32&gt
    <td>|v| `*` |m|:  vec|M|&lt;f32&gt<br>
    <td>线性代数行-向量-矩阵乘积：<br>
        [=transpose=](transpose(|m|) `*` transpose(|v|))
       <br>OpVectorTimesMatrix
  <tr algorithm="matrix-matrix multiply">
    <td>|e1|: mat|K|x|N|&lt;f32&gt<br>
        |e2|: mat|M|x|K|&lt;f32&gt
    <td>|e1| `*` |e2|:  mat|M|x|N|&lt;f32&gt<br>
    <td>线性代数矩阵乘积。<br>OpMatrixTimesMatrix

</table>

## 比较表达式 ## {#comparison-expr}

<table class='data'>
  <caption>比较</caption>
  <thead>
    <tr><th>Precondtion<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="bool equality">
    <td>|e1|: |T|<br>|e2|: |T|<br>|T| is bool or vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `==` |e2|`:` |T|
    <td>等价。

    当 |T| 是向量时，[=Component-wise=]。

    （OpLogicalEqual）
  <tr algorithm="bool inequality">
    <td>|e1|: |T|<br>|e2|: |T|<br>|T| is bool or vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `!=` |e2|`:` |T|
    <td>不等价。

    当 |T| 是向量时，[=Component-wise=]。

    （OpLogicalNotEqual）

  <tr algorithm="integer equality">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>
    |TI| 为 [INTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `==` |e2|`:` |TB|
    <td>等价。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpIEqual）
  <tr algorithm="integer inequality">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>
    |TI| 为 [INTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `!=` |e2|`:` |TB|
    <td>不等价。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpINotEqual）

  <tr algorithm="signed integer less than">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [SIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `<` |e2|`:` |TB|
    <td>小于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpSLessThan）
  <tr algorithm="signed integer less than equal">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [SIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `<=` |e2|`:` |TB|
    <td>小于等于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpSLessThanEqual）
  <tr algorithm="signed integer greater than">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [SIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `>` |e2|`:` |TB|
    <td>大于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpSGreaterThan）
  <tr algorithm="signed integer greater than equal">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [SIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `>=` |e2|`:` |TB|
    <td>大于等于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpSGreaterThanEqual）

  <tr algorithm="unsigned integer less than">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [UNSIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `<` |e2|`:` |TB|
    <td>小于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpULessThan）
  <tr algorithm="unsigned integer less than equal">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [UNSIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `<=` |e2|`:` |TB|
    <td>小于等于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpULessThanEqual）
  <tr algorithm="unsigned integer greater than">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [UNSIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `>` |e2|`:` |TB|
    <td>大于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpUGreaterThan）
  <tr algorithm="unsigned integer greater than equal">
    <td>|e1|: |TI|<br>|e2|: |TI|<br>|TI| 为 [UNSIGNEDINTEGRAL]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| `>=` |e2|`:` |TB|
    <td>大于等于。

    当 |TI| 是向量时，[=Component-wise=]。

    （OpUGreaterThanEqual）

  <tr algorithm="floating point equality">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| == |e2|: |TB|
    <td>等价。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdEqual）

  <tr algorithm="floating point inequality">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| != |e2|: |TB|
    <td>不等价。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdEqual）
  <tr algorithm="floating point less than">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| < |e2|: |TB|
    <td>小于。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdLessThan）
  <tr algorithm="floating point less than equal">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| <= |e2|: |TB|
    <td>小于等于。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdLessThanEqual）
  <tr algorithm="floating point greater than">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| > |e2|: |TB|
    <td>大于。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdGreaterThan）
    Greater than. [=Component-wise=] when |TF| is a vector. (OpFOrdGreaterThan)
  <tr algorithm="floating point greater than equal">
    <td>|e1|: |TF|<br>|e2|: |TF|<br>|TF| 为 [FLOATING]<br>
    当 |TI| 为标量时，|TB| 为布尔值，或<br>
    当 |TI| 为向量时，|TB| 为 vec|N|&lt;bool&gt;
    <td class="nowrap">|e1| >= |e2|: |TB|
    <td>大于等于。

    当 |TF| 是向量时，[=Component-wise=]。

    （OpFOrdGreaterThanEqual）

</table>

## 位表达式 ## {#bit-expr}

<table class='data'>
  <caption>一元按位运算</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="complement">
    <td>|e|: |T|<br>
    |T| 为 [INTEGRAL]
    <td class="nowrap">`~`|e| : |T|
    <td>|e| 上的按位补码。

    结果中的每一位都与 |e| 中的相应位相反。

    当 T 是向量时，[=Component-wise=]。

    （OpNot）
</table>

<table class='data'>
  <caption>二元按位运算</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="bitwise or">
    <td>*e1*: *T*<br>
       *e2*: *T*<br>
       *T* 为 [INTEGRAL]
    <td class="nowrap">`e1 | e2`: *T*
    <td>按位-或。当 |T| 是向量时，[=Component-wise=]。
  <tr algorithm="bitwise and">
    <td>*e1*: *T*<br>
       *e2*: *T*<br>
       *T* 为 [INTEGRAL]
    <td class="nowrap">`e1 & e2`: *T*
    <td>按位-与。当 |T| 是向量时，[=Component-wise=]。
  <tr algorithm="bitwise exclusive or">
    <td>*e1*: *T*<br>
       *e2*: *T*<br>
       *T* 为 [INTEGRAL]
    <td class="nowrap">`e1 ^ e2`: *T*
    <td>按位-异或。当 |T| 是向量时，[=Component-wise=]。
</table>


<table class='data'>
  <caption>位移表达式</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="shift left">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |T| 为 [INTEGRAL]<br>
    如果 |e1| 为标量，则 |TS| 为 u32<br>
    vec|N|&lt;u32&gt;.
    <td class="nowrap">|e1| `<<` |e2|: |T|
    <td>左移：<br>
    将 |e1| 左移，在最低有效位置插入零，并丢弃最高有效位。要移位的位数是 |e2| 的值 modulo |e1| 的位宽。

    当 T 是向量时，[=Component-wise=]。

    （OpShiftLeftLogical）

  <tr algorithm="logical shift right">
    <td>|e1|: |T|<br>
    |e2|: |T|<br>
    |T| is [UNSIGNEDINTEGRAL]
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>逻辑右移：<br>

    将 |e1| 右移，在最高有效位置插入零，并丢弃最低有效位。要移位的位数是 |e2| 的值 modulo |e1| 的位宽。

    当 T 是向量时，[=Component-wise=]。

    （OpShiftRightLogical）

  <tr algorithm="arithmetic shift right">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |T| is [SIGNEDINTEGRAL]<br>
    |TS| is u32 if |e1| is a scalar, or<br>
    vec|N|&lt;u32&gt;.
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>算术右移：<br>

    将 |e1| 右移，在最高有效位置插入符号位的副本，并丢弃最低有效位。要移位的位数是 |e2| 的值 modulo |e1| 的位宽。

    当 T 是向量时，[=Component-wise=]。

    （OpShiftRightArithmetic）
</table>

## 函数调用表达式 ## {#function-call-expr}

函数调用表达式执行函数调用（[=function call=]），其中被调用函数具有返回类型（[=return type=]）。 如果被调用的函数没有返回值，则应使用函数调用语句代替。见[[#function-call-statement]]。

## 变量标识符表达式 ## {#var-identifier-expr}

<table class='data'>
  <caption>从变量名获取引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="variable reference">
       <td>
       |v| 是解析（[=resolves|resolving=]）为 [=storage class=] |SC| 中声明的 [=in scope|in-scope=] 变量的标识符（[=identifier=]），存储类型（[=store type=]）为 |T|
       <td class="nowrap">
          |v|: ref&lt;|SC|,|T|&gt;
       <td>结果是对命名变量 |v| 的存储的引用。
</table>

## 形式参数表达式  ## {#formal-parameter-expr}

<table class='data'>
  <caption>获取声明为函数形式参数的标识符的值</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="formal parameter value">
       <td>
          |a| 是解析（[=resolves|resolving=]）为类型 |T| 的 [=in scope|in-scope=] 形式参数声明的标识符（[=identifier=]）
       <td class="nowrap">
          |a|: |T|
       <td>结果是在调用此函数实例的调用位置（[=call site=]）为相应函数调用操作数提供的值。
</table>

## 寻址表达式  ## {#address-of-expr}

寻址（<dfn noexport>address-of</dfn>）操作符将一个引用转换为其对应的指针。

<table class='data'>
  <caption>从引用获取指针</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="address-of expression">
       <td>
          |r|: ref&lt;|SC|,|T|,|A|&gt;
       <td class="nowrap">
          `&`|r|: ptr&lt;|SC|,|T|,|A|&gt;
       <td>结果是与引用值 |r| 相同的内存视图（[=memory view=]）对应的指针值。

       如果 |r| 是一个无效内存引用（[=invalid memory reference=]），作为结果的指针同样是无效内存引用。

       如果 |SC| 为 [=storage classes/handle=] 存储类，则为一个着色器创建错误（[=shader-creation error=]）。

</table>

## 间接寻址表达式  ## {#indirection-expr}

间接寻址运算符（<dfn noexport>indirection</dfn>）将指针转换为其相应的引用。

<table class='data'>
  <caption>从指针获取引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="indirection expression">
       <td>
          |p|: ptr&lt;|SC|,|T|,|A|&gt;
       <td class="nowrap">
          `*`|p|: ref&lt;|SC|,|T|,|A|&gt;
       <td>结果是与指针值 |p| 相同的内存视图（[=memory view=]）对应的引用值。

       如果 |p| 是一个无效内存引用（[=invalid memory reference=]），作为结果的指针同样是无效内存引用。

</table>

## 常量标识符表达式  ## {#constant-identifier-expr}

<table class='data'>
  <caption>获取 `let`-声明标识符的值</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="pipeline-overridable constant value">
       <td>
          |c| 是解析（[=resolves|resolving=]）为类型 |T| 的[=in scope|in-scope=]管线可覆盖（[=pipeline-overridable=]）的 `let` 声明的标识符（[=identifier=]）。
       <td class="nowrap">
          |c|: |T|
       <td>如果管线创建为常量 ID （[=pipeline constant ID|constant ID=]）指定了一个值，那么结果就是该值。对于不同的管线实例，此值可能不同。<br>

      否则，结果是为初始化表达式计算的值。管线可覆盖常量出现在模块范围内，因此在着色器开始执行之前进行计算。<br>

      注意：如果在 API 调用中没有指定初始值并且 `let`-声明没有初始化表达式，则管线创建将失败。
  <tr algorithm="constant value">
       <td>
          |c| 是解析（[=resolves|resolving=]）为类型 |T| 的[=in scope|in-scope=] `let` 声明的标识符（[=identifier=]），并且不为管线可覆盖（[=pipeline-overridable=]）的。
       <td class="nowrap">
          |c|: |T|
       <td>结果是为初始化表达式计算出的值。<br>

       对于模块范围内的 `let` 声明，计算发生在着色器开始执行之前。

       对于函数内部的 `let` 声明，每次控制到达声明时都会进行计算。<br>
</table>


## 表达式语法总结 ## {#expression-grammar}

<div class='syntax' noexport='true'>
  <dfn for=syntax>primary_expression</dfn> :

    | [=syntax/ident=] [=syntax/argument_expression_list=] ?

    | [=syntax/type_decl=] [=syntax/argument_expression_list=]

    | [=syntax/const_literal=]

    | [=syntax/paren_expression=]

    | [=syntax/bitcast=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=] [=syntax/paren_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_expression</dfn> :

    | [=syntax/paren_left=] [=syntax/short_circuit_or_expression=] [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>argument_expression_list</dfn> :

    | [=syntax/paren_left=] ( ( [=syntax/short_circuit_or_expression=] [=syntax/comma=] ) * [=syntax/short_circuit_or_expression=] [=syntax/comma=] ? ) ? [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>postfix_expression</dfn> :

    | [=syntax/bracket_left=] [=syntax/short_circuit_or_expression=] [=syntax/bracket_right=] [=syntax/postfix_expression=] ?

    | [=syntax/period=] [=syntax/ident=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>unary_expression</dfn> :

    | [=syntax/singular_expression=]

    | [=syntax/minus=] [=syntax/unary_expression=]

    | [=syntax/bang=] [=syntax/unary_expression=]

    | [=syntax/tilde=] [=syntax/unary_expression=]

    | [=syntax/star=] [=syntax/unary_expression=]

    | [=syntax/and=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>singular_expression</dfn> :

    | [=syntax/primary_expression=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>multiplicative_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/star=] [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/forward_slash=] [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/modulo=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>additive_expression</dfn> :

    | [=syntax/multiplicative_expression=]

    | [=syntax/additive_expression=] [=syntax/plus=] [=syntax/multiplicative_expression=]

    | [=syntax/additive_expression=] [=syntax/minus=] [=syntax/multiplicative_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>shift_expression</dfn> :

    | [=syntax/additive_expression=]

    | [=syntax/shift_expression=] [=syntax/shift_left=] [=syntax/additive_expression=]

    | [=syntax/shift_expression=] [=syntax/shift_right=] [=syntax/additive_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>relational_expression</dfn> :

    | [=syntax/shift_expression=]

    | [=syntax/relational_expression=] [=syntax/less_than=] [=syntax/shift_expression=]

    | [=syntax/relational_expression=] [=syntax/greater_than=] [=syntax/shift_expression=]

    | [=syntax/relational_expression=] [=syntax/less_than_equal=] [=syntax/shift_expression=]

    | [=syntax/relational_expression=] [=syntax/greater_than_equal=] [=syntax/shift_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>equality_expression</dfn> :

    | [=syntax/relational_expression=]

    | [=syntax/relational_expression=] [=syntax/equal_equal=] [=syntax/relational_expression=]

    | [=syntax/relational_expression=] [=syntax/not_equal=] [=syntax/relational_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>and_expression</dfn> :

    | [=syntax/equality_expression=]

    | [=syntax/and_expression=] [=syntax/and=] [=syntax/equality_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>exclusive_or_expression</dfn> :

    | [=syntax/and_expression=]

    | [=syntax/exclusive_or_expression=] [=syntax/xor=] [=syntax/and_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>inclusive_or_expression</dfn> :

    | [=syntax/exclusive_or_expression=]

    | [=syntax/inclusive_or_expression=] [=syntax/or=] [=syntax/exclusive_or_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>short_circuit_and_expression</dfn> :

    | [=syntax/inclusive_or_expression=]

    | [=syntax/short_circuit_and_expression=] [=syntax/and_and=] [=syntax/inclusive_or_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>short_circuit_or_expression</dfn> :

    | [=syntax/short_circuit_and_expression=]

    | [=syntax/short_circuit_or_expression=] [=syntax/or_or=] [=syntax/short_circuit_and_expression=]
</div>

# Statements TODO # {#statements}

## 复合语句 ## {#compound-statement-section}

<dfn>compound statement</dfn> 是用大括号括起来的零个或多个语句序列。
当 [=declaration=] 是这些语句之一时，它的 [=identifier=] 从下一条语句的开始到复合语句的结束都是 [=in scope=]。

<pre class='def'>
compound_statement
  : BRACE_LEFT statements? BRACE_RIGHT
</pre>

## 赋值语句 ## {#assignment}

<dfn noexport dfn-for="statement">assignment</dfn> 计算表达式，并可选择将其存储在内存中（从而更新变量的内容）。

<pre class='def'>
assignment_statement
  : (unary_expression | UNDERSCORE) EQUAL short_circuit_or_expression
</pre>


等号左侧的文本是<dfn noexport>left-hand side</dfn>，
等号右边的表达式是<dfn noexport>right-hand side</dfn>。

### 更新赋值 ### {#updating-assignment-section}

当赋值的 [=left-hand side=] 是一个表达式时，该赋值是一个 <dfn noexport>updating assignment</dfn>：
右侧的值写入左侧引用的内存中。

<table class='data'>
  <thead>
    <tr><th style="width:40%">Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="updating assignment">
    <td>|r|: ref<|SC|,|T|,|A|>,<br>
        |A| is [=access/write=] or [=access/read_write=]<br>
        |e|: |T|,<br>
        |T| is a [=constructible=] type,<br>
        |SC| is a writable [=storage class=]
    <td class="nowrap">|r| = |e|
    <td>Evaluates |e|, evaluates |r|, then writes the value computed for |e| into
        the [=memory locations=] referenced by |r|.

        Note: if the reference is an [=invalid memory reference=], the write
        may not execute, or may write to a different memory location than
        expected.

        (OpStore)
</table>

在最简单的情况下，左侧是变量的名称。
其他情况见[[#forming-references-and-pointers]]。

    <div class='example wgsl' heading='Assignments'>
      <xmp highlight='rust'>
        struct S {
            age: i32;
            weight: f32;
        };
        var<private> person: S;

        fn f() {
            var a: i32 = 20;
            a = 30;           // Replace the contents of 'a' with 30.

            person.age = 31;  // Write 31 into the age field of the person variable.

            var uv: vec2<f32>;
            uv.y = 1.25;      // Place 1.25 into the second component of uv.

            let uv_x_ptr: ptr<function,f32> = &uv.x;
            *uv_x_ptr = 2.5;   // Place 2.5 into the first component of uv.

            var friend: S;
            // Copy the contents of the 'person' variable into the 'friend' variable.
            friend = person;
        }
      </xmp>
    </div>

### 虚假赋值 ### {#phony-assignment-section}

当赋值的 [=left-hand side=] 是下划线标记时，
分配是一个<dfn noexport>虚假赋值</dfn>：
评估右侧，然后忽略。

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="phony-assignment">
    <td>|e|: |T|,<br>
        |T| is [=constructible=], a [=pointer type=], a [=texture=] type, or a [=sampler=] type
    <td class="nowrap">_ = |e|
    <td>Evaluates |e|.

        注意：结果值不会被存储。
        `_` 标记不是标识符，因此不能在表达式中使用。
</table>

虚假赋值对于以下场景有用:
* 调用返回值的函数，但明确表示不需要结果值。
* [=statically accessed|Statically accessing=]一个变量，从而将其建立为[=resource interface of a shader|shader's resource interface=]的一部分。

       注意：缓冲区变量的存储类型可能无法构造，例如 它包含原子类型或运行时大小的数组。
       在这些情况下，请改用指向变量内容的指针。

<div class='example wgsl global-scope' heading='Using phony-assignment to throw away an un-needed function result'>
  <xmp highlight=rust>
    var<private> counter: i32;

    fn increment_and_yield_previous() -> i32 {
      let previous = counter;
      counter = counter + 1;
      return previous;
    }

    fn user() {
      // Increment the counter, but don't use the result.
      _ = increment_and_yield_previous();
    }
  </xmp>
</div>


<div class='example wgsl global-scope' heading='Using phony-assignment to occupy bindings without using them'>
  <xmp highlight=rust>
    [[block]] struct BufferContents {
        counter: atomic<u32>;
        data: array<vec4<f32>>;
    };
    [[group(0),binding(0)]] var<storage> buf: BufferContents;
    [[group(0),binding(1)]] var t: texture_2d<f32>;
    [[group(0),binding(2)]] var s: sampler;

    [[stage(fragment)]]
    fn shade_it() -> [[location(0)]] vec4<f32> {
      // Declare that buf, t, and s are part of the shader interface, without
      // using them for anything.
      _ = &buf;
      _ = t;
      _ = s;
      return vec4<f32>();
    }
  </xmp>
</div>

## 控制流 TODO ## {#control-flow}

### 序列 TODO ### {#sequence-statement}

### If 语句 ### {#if-statement}

<pre class='def'>
if_statement
  : IF paren_expression compound_statement elseif_statement? else_statement?

elseif_statement
  : ELSE_IF paren_expression compound_statement elseif_statement?

else_statement
  : ELSE compound_statement
</pre>

一个 <dfn noexport dfn-for="statement">if</dfn> 语句根据条件表达式的评估，有条件地执行至多一个 [=compound statement=]。

[SHORTNAME] 中的 `if` 语句使用 if/elseif/else 结构，其中包含一个必需的 `if` 子句、零个或多个 `elseif` 子句和一个可选的 `else` 子句。
`if` 和 `elseif` 子句条件的每个表达式都必须是标量布尔表达式。

`if` 语句执行如下：
* 评估与 `if` 子句关联的条件。
    如果结果为 `true`，则控制转移到第一个复合语句（紧接在括号中的条件表达式之后）。
* 否则，按文本顺序（如果存在）评估下一个 `elseif` 子句的条件，如果结果为 `true`，则控制转移到关联的复合语句。
    * 对所有 `elseif` 子句重复此行为，直到其中一个条件评估为 `true`。
* 如果没有条件评估为 `true`，则控制转移到与 `else` 子句（如果存在）相关联的复合语句。

### Switch 语句 ### {#switch-statement}

<pre class='def'>
switch_statement
  : SWITCH paren_expression BRACE_LEFT switch_body+ BRACE_RIGHT

switch_body
  : CASE case_selectors COLON BRACE_LEFT case_body BRACE_RIGHT
  | DEFAULT COLON BRACE_LEFT case_body BRACE_RIGHT

case_selectors
  : const_literal (COMMA const_literal)* COMMA?

case_body
  :
  | statement case_body
  | FALLTHROUGH SEMICOLON
</pre>

<dfn noexport dfn-for="statement">switch</dfn> 语句将控制转移到一组 case 子句中的一个子句或 `default` 子句，具体取决于选择器表达式的评估。

选择器表达式必须是标量整数类型。
如果选择器值等于案例选择器列表中的值，则控制转移到
该 case 子句的主体。
如果选择器值不等于任何 case 选择器值，则控制是
转移到 `default` 子句。

每个 switch 语句必须恰好有一个 default 子句。

case 选择器值必须与计算选择器表达式的结果具有相同的类型。

一个表达值在 switch 语句的 case 选择器中不能出现多次。

注意：表达式的值才是重要的，而不是拼写。
例如“0”、“00”和“0x0000”都表示零值。

当控制到达 case 主体的末尾时，控制通常转移到 switch 语句之后的第一个语句。
或者，执行 <dfn noexport dfn-for="statement">fallthrough</dfn> 语句
将控制转移到下一个 case 子句或 default 子句的主体，以开关主体中的下一个出现为准。
`fallthrough` 语句不能作为 switch 的最后一个子句中的最后一个语句出现。
当一个 [=declaration=] 出现在 case body 中时，它的 [=identifier=] 是 [=in scope=] 从下一条语句的开始到 case body 的结束。

注意：在 case body 中声明的标识符不是 case body 的 [=in scope=]， 可以通过 `fallthrough` 语句访问。


### Loop 语句 ### {#loop-statement}

<pre class='def'>
loop_statement
  : LOOP BRACE_LEFT statements? continuing_statement? BRACE_RIGHT
</pre>

<dfn noexport dfn-for="statement">loop</dfn> 语句重复执行<dfn noexport>loop body</dfn>； 循环体被指定为 [=compound statement=]。
循环体的每次执行称为一次<dfn noexport>iteration</dfn>。

从下一条语句开始到循环体结束，循环中 [=declaration=] 的 [=identifier=] 是 [=in scope=]。
每次到达时都会执行声明，因此每次新迭代都会创建变量或常量的新实例，并重新初始化它。

这种重复可以被 [=statement/break=]、[=statement/return=] 或
[=statement/discard=] 声明。

可选地，循环体中的最后一条语句可以是
[=statement/continuing=]声明。

注意：loop 语句是与其他着色器语言的最大区别之一。

这种设计直接表达了编译代码中常见的循环习语。
特别是，将循环更新语句放在循环体的末尾允许它们自然地使用循环体中定义的值。

<div class='example glsl' heading='GLSL Loop'>
  <xmp>
    int a = 2;
    for (int i = 0; i < 4; i++) {
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="[SHORTNAME] Loop">
  <xmp>
    let a: i32 = 2;
    var i: i32 = 0;      // <1>
    loop {
      if (i >= 4) { break; }

      a = a * 2;

      i = i + 1;
    }
  </xmp>
</div>
* <1> The initialization is listed before the loop.

<div class='example glsl' heading='GLSL Loop with continue'>
  <xmp>
    int a = 2;
    let int step = 1;
    for (int i = 0; i < 4; i += step) {
      if (i % 2 == 0) continue;
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="[SHORTNAME] Loop with continue">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if (i >= 4) { break; }

      let step: i32 = 1;

      i = i + step;
      if (i % 2 == 0) { continue; }

      a = a * 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="[SHORTNAME] Loop with continue and continuing">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if (i >= 4) { break; }

      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {   // <2>
        i = i + step;
      }
    }
  </xmp>
</div>
* <2> continue 构造被放置在 `loop` 的末尾

### For 语句 ### {#for-statement}

<pre class='def'>
for_statement
  : FOR PAREN_LEFT for_header PAREN_RIGHT compound_statement

for_header
  : (variable_statement | assignment_statement | func_call_statement)? SEMICOLON
     short_circuit_or_expression? SEMICOLON
     (assignment_statement | func_call_statement)?
</pre>

<dfn dfn-for="statement">for</dfn> 语句采用 `for(initializer; condition; continue_part) { body }` 的形式，
是同一个 `body` 在 [=statement/loop=] 语句之上的语法糖(在计算机科学中，语法糖是一种编程语言中的语法，旨在使事物更易于阅读或表达。 它使语言更适合人类使用：
可以更清晰、更简洁地表达事物，或者以某些人可能更喜欢的另一种风格表达)。
另外:
* 如果 `initializer` 非空，则在第一个 [=iteration=] 之前的附加作用域内执行。
* 如果 `condition` 不为空，则在循环体的开始处进行检查，如果不满足则执行[[#break-statement]]。
* 如果 `continuing_part` 不为空，它会在循环体的末尾变成一个 [=statement/continuing=] 语句。

for 循环的 `initializer` 在执行循环之前执行一次。
当一个 [=declaration=] 出现在初始化器中时，它的 [=identifier=] 是 [=in scope=] 直到 `body` 的结尾。
与 `body` 中的声明不同，该声明不会在每次迭代时重新初始化。

`condition`、`body` 和 `continuing_part` 依次执行以形成一个循环 [=iteration=]。
`body` 是一种特殊形式的 [=compound statement=]。
`body` 中声明的标识符是 [=in scope=] 从下一条语句的开始到 `body` 的结尾。

每次到达时都会执行声明，因此每次新迭代都会创建变量或常量的新实例，并重新初始化它。

<div class='example glsl' heading="For to Loop transformation">
  <xmp>
    for(var i: i32 = 0; i < 4; i = i + 1) {
      if (a == 0) {
        continue;
      }
      a = a + 2;
    }
  </xmp>
</div>

转换为:

<div class='example wgsl function-scope' heading="For to Loop transformation">
  <xmp>
    { // Introduce new scope for loop variable i
      var i: i32 = 0;
      var a: i32 = 0;
      loop {
        if (!(i < 4)) {
          break;
        }

        if (a == 0) {
          continue;
        }
        a = a + 2;

        continuing {
          i = i + 1;
        }
      }
    }
  </xmp>
</div>


### Break 语句 ### {#break-statement}

<pre class='def'>
break_statement
  : BREAK
</pre>

<dfn noexport dfn-for="statement">break</dfn> 语句将控制转移到最近封闭的 [=statement/loop=] 或 [=statement/switch=] 语句的主体之后的第一个语句。
`break` 语句只能在 [=statement/loop=]、[=statement/for=] 和 [=statement/switch=] 语句中使用。

当放置 `break` 语句使其从循环的 [=statement/continuing=] 语句退出时，
然后：

* `break` 语句必须显示为以下其中之一:
    * `if` 语句的 `if` 子句中唯一的语句具有:
        * 没有 `else` 子句或空的 `else` 子句
        * 没有 `elseif` 子句
    * `if` 语句的 `else` 子句中唯一具有空的 `if` 子句且没有 `elseif` 子句的语句。
* `if` 语句必须出现在 `continuing` 子句的最后。

<div class='example wgsl function-scope' heading="[SHORTNAME] Valid loop if-break from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        if (i >= 4) { break; }
      }
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="[SHORTNAME] Valid loop if-else-break from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        if (i < 4) {} else { break; }
      }
    }
  </xmp>
</div>

<div class='example wgsl function-scope expect-error' heading="[SHORTNAME] Invalid breaks from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;

    loop {
      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        break;                                     // Invalid: too early
        if (i < 4) { i = i + 1; } else { break; }  // Invalid: if is too complex, and too early
        if (i >= 4) { break; } else { i = i + 1; } // Invalid: if is too complex
      }
    }
  </xmp>
</div>

### Continue 语句 ### {#continue-statement}

<pre class='def'>
continue_statement
  : CONTINUE
</pre>

<dfn noexport dfn-for="statement">continue</dfn> 语句在最近的封闭 [=statement/loop=] 中转移控制：

* 转发到循环体末尾的 [=statement/continuing=] 语句（如果存在）。
* 否则返回到循环体中的第一条语句，开始下一个 [=iteration=]。

`continue` 语句只能用在 [=statement/loop=] 或 [=statement/for=] 语句中。
`continue` 语句的放置不得将控制转移到封闭的 [=statement/continuing=] 语句。
（当分支到 `continuing` 语句时，它是一个 *forward* 分支。）

不得放置 `continue` 语句，以便将控制权转移到目标 [=statement/continuing=] 语句中使用的声明之后。

<div class='example wgsl function-scope expect-error' heading="Invalid continue bypasses declaration">
  <xmp>
    var i: i32 = 0;
    loop {
      if (i >= 4) { break; }
      if (i % 2 == 0) { continue; } // <3>

      let step: i32 = 2;

      continuing {
        i = i + step;
      }
    }
  </xmp>
</div>
* <3> `continue` 无效，因为它绕过了 `continuing` 构造中使用的 `step` 声明

### Continuing 语句 ### {#continuing-statement}

<pre class='def'>
continuing_statement
  : CONTINUING compound_statement
</pre>

<dfn dfn-for="statement">continuing</dfn> 语句指定要在循环 [=iteration=] 结束时执行的 [=compound statement=]。
该构造是可选的。

在任何复合语句嵌套级别，复合语句不得包含 [=statement/return=] 或 [=statement/discard=] 语句。

### Return 语句 ### {#return-statement}

<pre class='def'>
return_statement
  : RETURN short_circuit_or_expression?
</pre>

<dfn noexport dfn-for="statement">return</dfn> 语句结束当前函数的执行。
如果函数是 [=entry point=]，则终止当前着色器调用。
否则，在对当前函数调用的 [=call site=] 进行评估之后，继续评估下一个表达式或语句。

如果函数没有 [=return type=]，则 [=statement/return=] 语句是可选的。 如果为这样的函数提供了 return 语句，则它不得
提供一个值。
否则表达式必须存在，称为<dfn>return value</dfn>。
在这种情况下，此函数调用的调用点计算为返回值。
返回值的类型必须与函数的返回类型匹配。

### Discard 语句 ### {#discard-statement}

<dfn dfn-for="statement">discard</dfn> 语句立即结束片段着色器调用的执行并丢弃片段。
`discard` 语句只能用于 [=fragment=] 着色器阶段。

更准确地说，执行 `discard` 语句将：

* 立即终止当前调用，并且
* 防止为 [=entry point=] 评估和生成 [=return value=]，以及
* 防止当前片段在 [=GPURenderPipeline=] 中被下游处理。

只有在 `discard` 语句之前执行的语句才会有可观察到的效果。

注意：`discard`语句可以被任何着色器阶段中的函数|片段阶段中的函数[=functions in a shader stage|function in a fragment stage=]执行，
效果是一样的：立即终止调用。

在执行 `discard` 语句后，控制流在入口点的持续时间内是不一致的。

问题：[[#uniform-control-flow]] 需要说明是否所有被丢弃的调用都保持统一的控制流。

<div class='example' heading='Using the discard statement to throw away a fragment'>
  <xmp>
  var<private> will_emit_color: bool = false;

  fn discard_if_shallow(pos: vec4<f32>) {
    if (pos.z < 0.001) {
      // If this is executed, then the will_emit_color flag will
      // never be set to true.
      discard;
    }
    will_emit_color = true;
  }

  [[stage(fragment)]]
  fn main([[builtin(position)]] coord_in: vec4<f32>)
    -> [[location(0)]] vec4<f32>
  {
    discard_if_shallow(coord_in);

    // Set the flag and emit red, but only if the helper function
    // did not execute the discard statement.
    will_emit_color = true;
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
  }
  </xmp>
</div>

## Function Call 语句 ## {#function-call-statement}

<pre class='def'>
func_call_statement
  : IDENT argument_expression_list
</pre>

函数调用语句执行 [=function call=]。

注意：如果函数 [=return value|returns a value=]，则忽略该值。

## 语句语法总结 ## {#statements-summary}

<pre class='def'>
statements
  : statement+

statement
  : SEMICOLON
  | return_statement SEMICOLON
  | if_statement
  | switch_statement
  | loop_statement
  | for_statement
  | func_call_statement SEMICOLON
  | variable_statement SEMICOLON
  | break_statement SEMICOLON
  | continue_statement SEMICOLON
  | DISCARD SEMICOLON
  | assignment_statement SEMICOLON
  | compound_statement
</pre>


# Functions # {#functions}

<dfn dfn-for="function" noexport>function</dfn> 在调用时执行计算工作。

以下列方式之一调用函数：
* 通过评估函数调用表达式。 见[[#function-call-expr]]。
* 通过执行函数调用语句。 见[[#function-call-statement]]。
* [=entry point=] 函数由 WebGPU 实现调用，以在 [=pipeline=] 中执行 [=shader stage=] 的工作。 见 [[#entry-points]]

有两种功能：
* [=built-in function=] 由 [SHORTNAME] 实现提供，
     并且始终可用于 [SHORTNAME] 程序。
     参见 [[#builtin-functions]]。
* <dfn noexport>user-defined function</dfn>在[SHORTNAME]程序中声明。

## 声明一个用户定义的函数 ## {#function-declaration-sec}

<dfn noexport> function declaration</dfn> 通过指定以下内容来创建用户定义的函数：
* 一组可选的属性。
* 函数的名称。
* 形参列表：一个有序的零序列或更多 [=formal parameter=] 声明，用逗号分隔，和被括号包围。
* 一个可选的，可能是装饰的，<dfn noexport>返回类型</dfn>。
* <dfn noexport>function body</dfn>.

函数声明只能出现在 [=module scope=]。
函数名是 [=in scope=] 从形参列表的开头
直到程序结束。

<dfn noexport>形式参数</dfn> [=declaration=] 指定一个 [=identifier=] 名称和一个值的类型，该值在调用函数时必须提供。
形式参数可能具有属性。
见[[#function-calls]]。
标识符是 [=in scope=] 直到函数结束。
给定函数的两个形参不能同名。

如果指定了返回类型，则：
* 返回类型必须是 [=constructible=]。
* 函数体中的最后一条语句必须是 [=statement/return=] 语句。

<pre class='def'>
function_decl
  : attribute_list* function_header compound_statement

function_header
  : FN IDENT PAREN_LEFT param_list PAREN_RIGHT function_return_type_decl_optional

function_return_type_decl_optional
  :
  | ARROW attribute_list* type_decl

param_list
  :
  | (param COMMA)* param COMMA?

param
  : attribute_list* variable_ident_decl
</pre>

[SHORTNAME] 定义了以下可应用于函数声明的属性:
 * [=attribute/stage=]
 * [=attribute/workgroup_size=]

[SHORTNAME] 定义了以下可应用于函数参数和返回类型的属性:
 * [=attribute/builtin=]
 * [=attribute/location=]

<div class='example' heading='Simple functions'>
  <xmp>
    // 声明 add_two 函数。
    // 它有两个形参，i 和 b。
    // 它的返回类型为 i32。
    // 它有一个带有 return 语句的主体。
    fn add_two(i: i32, b: f32) -> i32 {
      return i + 2;  // A formal parameter is available for use in the body.
    }

     // 一个计算着色器入口点函数，'main'。
     // 它没有指定的返回类型。
     // 它调用了ordinary_two 函数，并捕获
     // 命名值 'two' 中的结果值。
    [[stage(compute)]] fn main() {
       let six: i32 = add_two(4, 5.0);
    }
  </xmp>
</div>

## Function calls ## {#function-calls}

<dfn noexport>function call</dfn> 是调用函数的语句或表达式。

函数调用必须提供相同数量的参数值
[=formal parameter|formal parameters=]在被调用的函数中。
每个参数值必须按位置计算为与相应形式参数相同的类型。

当执行函数调用时，会发生以下步骤:
* 评估函数调用参数值。
    未指定评估的相对顺序。
* 当前函数的执行被暂停。
    所有 [=function scope=] 变量和常量都保持其当前值。
* 为被调用函数中的每个函数作用域变量分配存储空间。
    * 初始化按照 [[#var-and-let]] 中的描述进行。
* 被调用函数的形参值是通过按位置匹配函数调用参数值来确定的。
    例如，在被调用函数的主体中，第一个形式参数将表示 [=call site=] 处第一个参数的值。
* 控制被转移到被调用函数中的第一条语句。
* 被调用的函数被执行。
* 当被调用函数返回时，通过执行 [=statement/return=] 语句或到达被调用函数的末尾（如果函数没有 [=return value|return a value=]），
    则控制权被转移回调用函数，并且被调用函数的执行未暂停。
    如果被调用的函数 [=return value|returns a value=]，则为函数调用表达式的值提供该值。

函数调用的位置称为<dfn noexport>call site</dfn>。
调用站点是一个 [=dynamic context=]。
因此，相同的文本位置可能代表多个呼叫站点。

注意：[SHORTNAME] 中没有默认参数值。
以这种方式描述的内置函数实际上是重载函数。

注意：如果被调用的函数或
任何被调用的后代函数都会执行一个 [=statement/discard=] 语句。

## 函数限制 ## {#function-restriction}

* 不允许递归。
    也就是说，调用图中不能有环。
* [=vertex=] 着色器必须返回 `position` [=built-in output variable|built-in variable=]。 参见 [[#builtin-variables]]。
* 入口点绝不能是 [=function call=] 的目标。
* 如果函数具有返回类型，则它必须是 [=constructible=] 类型。
* [=formal parameter|function parameter=] 必须是以下类型之一：
    * constructible 类型
    * pointer 类型
    * texture 类型
    * sampler 类型
* 每个函数调用参数必须评估为相应函数参数的类型。
    * 特别是，作为指针的参数必须与存储类、指针对象类型和访问模式上的形参一致。
* 对于[=user-defined functions=]，指针类型的参数必须在以下存储类之一中:
    * [=storage classes/function=]
    * [=storage classes/private=]
    * [=storage classes/workgroup=]
* 对于 [=built-in functions=]，指针类型的参数必须在以下存储类之一中:
    * [=storage classes/function=]
    * [=storage classes/private=]
    * [=storage classes/workgroup=]
    * [=storage classes/storage=]
* 指向 [=user-defined function=] 的指针类型的每个参数必须是以下参数之一:
    * [[#var-identifier-expr|variable identifier expression]] 的  [[#address-of-expr|address-of expression]]
    * 一个函数参数
* [SHORTNAME] 假定函数参数和变量的任何组合之间不存在别名。
    因此，指针类型的函数参数不得用于读取或写入其 [=原始变量 =] 的任何 [=内存位置 =]，这些参数也通过以下方式写入：
    * 同一个函数中的另一个函数参数
    * 直接使用原始变量的函数中的语句或表达式

注意：别名限制适用于函数中函数调用写入的内存位置。

问题：为了清晰起见，重新审视混叠规则。

# 入口点 TODO # {#entry-points}

## 着色器阶段 ## {#shader-stages-sec}

WebGPU 以 [=draw command|draw=] 或 [=dispatch commands=] 的形式向 GPU 发出工作。
这些命令在一组 [=pipeline input|inputs=]、[=pipeline output|outputs=] 和附加的 [=resources=] 的上下文中执行管道。

<dfn noexport>pipeline</dfn> 将要在 GPU 上执行的行为描述为一系列阶段，其中一些阶段是可编程的。
在 WebGPU 中，在调度绘制或调度命令以执行之前创建管道。
有两种管道：GPUComputePipeline 和 GPURenderPipeline。

[=dispatch command=] 使用 <dfn noexport>GPUComputePipeline</dfn> 在具有可控并行度的逻辑点网格上运行
<dfn noexport>计算着色器阶段</dfn>，同时读取并且可能更新缓冲区和图像资源。

[=draw command=] 使用 <dfn noexport>GPURenderPipeline</dfn> 运行多阶段进程，其中包含两个可编程阶段以及其他固定功能阶段：

* <dfn noexport>vertex shader stage</dfn> 将单个顶点的输入属性映射到该顶点的输出属性。
* 固定功能阶段将顶点映射到图形基元（例如三角形）中，然后将其光栅化以生成片段。
* <dfn noexport>fragment shader stage</dfn> 处理每个片段，可能会产生片段输出。
* 固定功能阶段消耗片段输出，可能会更新外部状态，例如颜色附件以及深度和模板缓冲区。

WebGPU 规范更详细地描述了管道。

[SHORTNAME] 定义了三个 <dfn noexport>shader stage</dfn>，对应流水线的可编程部分：

* <dfn noexport>compute</dfn>
* <dfn noexport>vertex</dfn>
* <dfn noexport>fragment</dfn>

每个着色器阶段都有自己的一组特性和约束，在别处描述。

## 入口点声明 ## {#entry-point-decl}

<dfn noexport>entry point</dfn> 是一个 [=user-defined function=]，它被调用来为特定的 [=shader stage=] 执行工作。

在 [=function declaration=] 上指定 `stage` 属性以将该函数声明为入口点。

在管道中配置阶段时，通过提供 [SHORTNAME] 模块和入口点的函数名称来指定入口点。

入口点的参数必须在 [=Entry point IO type=] 内。
如果指定，入口点的返回类型必须是 [=Entry point IO type=]。

注意：计算入口点从来没有返回类型。

<div class='example wgsl global-scope' heading='Entry Point'>
  <xmp>
    [[stage(vertex)]]
    fn vert_main() -> [[builtin(position)]] vec4<f32> {
      return vec4<f32>(0.0, 0.0, 0.0, 1.0);
    }
       // OpEntryPoint Vertex %vert_main "vert_main" %return_value
       // OpDecorate %return_value BuiltIn Position
       // %float = OpTypeFloat 32
       // %v4float = OpTypeVector %float 4
       // %ptr = OpTypePointer Output %v4float
       // %return_value = OpVariable %ptr Output

    [[stage(fragment)]]
    fn frag_main([[builtin(position)]] coord_in: vec4<f32>) -> [[location(0)]] vec4<f32> {
      return vec4<f32>(coord_in.x, coord_in.y, 0.0, 1.0);
    }
       // OpEntryPoint Fragment %frag_main "frag_main" %return_value %coord_in
       // OpDecorate %return_value Location 0
       // %float = OpTypeFloat 32
       // %v4float = OpTypeVector %float 4
       // %ptr = OpTypePointer Output %v4float
       // %return_value = OpVariable %ptr Output

    [[stage(compute)]]
    fn comp_main() { }
       // OpEntryPoint GLCompute %comp_main "comp_main"
  </xmp>
</div>

着色器阶段中的 <dfn noexport> 函数集</dfn> 是以下各项的并集：

* 阶段的入口点函数。
* 着色器阶段函数体内的函数调用目标，无论该调用是否被执行。

联合被反复应用，直到它稳定。
它将在有限数量的步骤中稳定下来。

### 入口点的函数属性 ### {#entry-point-attributes}

[SHORTNAME] 定义了以下可应用于入口点声明的属性:
 * [=attribute/stage=]
 * [=attribute/workgroup_size=]

问题：我们可以查询工作组大小维度的上限吗？ 是独立于shader，还是创建shader模块后要查询的属性？

<div class='example wgsl global-scope' heading='workgroup_size Attribute'>
  <xmp>
    [[ stage(compute), workgroup_size(8,4,1) ]]
    fn sorter() { }
       // OpEntryPoint GLCompute %sorter "sorter"
       // OpExecutionMode %sorter LocalSize 8 4 1

    [[ stage(compute), workgroup_size(8u) ]]
    fn reverser() { }
       // OpEntryPoint GLCompute %reverser "reverser"
       // OpExecutionMode %reverser LocalSize 8 1 1

    // Using an pipeline-overridable constant.
    [[override(42)]] let block_width = 12u;
    [[ stage(compute), workgroup_size(block_width) ]]
    fn shuffler() { }
        // SPIR-V 转换使用 WorkgroupSize 修饰的常量，
        // 其中第一个组件是一个装饰有的 OpSpecConstant
        // SpecID 42，默认值为12，第二个和第三个组件
        // 使用默认值 1。

    // 错误：必须在计算着色器上指定 workgroup_size
    [[ stage(compute) ]]
    fn bad_shader() { }
  </xmp>
</div>

## 着色器接口 ## {#shader-interface}

着色器接口是一组对象，着色器通过这些对象访问 [=shader stage=] 外部的数据，用于读取或写入。
接口包括:

* 管道输入和输出
* 缓存资源
* 纹理资源
* 采样器资源

这些对象由某些 [=storage classes=] 中的模块范围变量表示。

当在 [=function declaration=] [=resolves=] 中使用 [=identifier=] 到 [=module scope|module-scope=] 变量时，我们说该变量是 <dfn>静态访问的</dfn> 按功能。
`let` 声明的常量的静态访问定义类似。
请注意，静态访问与着色器的执行是否实际评估引用变量的表达式无关，甚至执行可能包含表达式的语句。

更准确地说，着色器阶段的接口<dfn noexport>interface of a shader stage</dfn>包括：
  - 入口点的所有参数
  - 入口点的结果值
  - 所有模块范围[=module scope=]变量静态访问[=statically accessed=]由着色器阶段中的函数|着色器阶段中的函数[=functions in a shader stage|functions in the shader stage=]，
        并且在存储类中[=storage classes/uniform=]，[=storage classes/storage=]，或[=storage classes/handle=]。

### 管道输入输出接口 ### {#pipeline-inputs-outputs}

<dfn dfn>Entry point IO type</dfn>s 包括以下内容：
  - 内置变量。 参考 [[#builtin-inputs-outputs]]。
  - 用户定义的 IO。 参考 [[#user-defined-inputs-outputs]]
  - 仅包含内置变量和用户定义 IO 的结构。
    该结构不得包含嵌套结构。

<dfn noexport>pipeline input</dfn>是从管道上游提供给着色器阶段的数据。
管道输入由入口点的参数表示。

<dfn noexport>pipeline output</dfn> 是着色器为管道下游的进一步处理提供的数据。
管道输出由入口点的返回类型表示。

每个管道输入或输出是以下之一：

* 一个内置变量。 参考 [[#builtin-inputs-outputs]]。
* 一个用户定义的值。 参考 [[#user-defined-inputs-outputs]]。

#### 内置输入和输出 #### {#builtin-inputs-outputs}

<dfn noexport>built-in input variable</dfn> 提供对系统生成的控制信息的访问。
[[#builtin-variables]] 中列出了一组内置输入。

声明一个变量，用于从入口点访问特定的输入内置 *X*：

* 声明入口点函数的参数，其中[=store type=] 是*X* 的列出存储类型。
* 将 `builtin(`*X*`)` 属性应用于参数。

内置输出变量<dfn noexport>built-in output varialbe</dfn>被着色器用来将控制信息传送到管道中的后续处理步骤。
[[#builtin-variables]] 中列出了一组内置输出。

要声明一个变量以从入口点访问内置的特定输出 *Y*：

* 向入口点的结果添加一个变量，其中 [=store type=] 是 *Y* 的列出存储类型：
  * 如果入口点没有结果类型，请将其更改为变量类型。
  * 否则，将结果类型设为结构体，其中一个字段是新变量。
* n将 `builtin(`*Y*`)` 属性应用于结果变量。

输入和输出内置变量也可以声明为结构的成员，这些结构是入口点函数参数（对于输入）或入口点的返回类型（对于输出）。
结构成员的类型必须与为内置变量指定的类型相匹配。

`builtin` 属性不得应用于 [=module scope=] 中的变量，或函数作用域中的局部变量。

一个变量不能有多个 `builtin` 属性。

每个内置变量都有一个关联的着色器阶段，如 [[#builtin-variables]] 中所述。
如果内置变量具有阶段 *S* 并被函数 *F* 用作参数或结果类型，则 *F* 必须是 [=着色器阶段中的函数|着色器中的函数= ] 用于阶段 *S*。

问题：在 Vulkan 中，内置变量占用 I/O 位置插槽，并计入限制。

#### 用户定义的输入和输出 #### {#user-defined-inputs-outputs}

用户定义的数据可以作为输入传递到管道的起点、在管道的各个阶段之间传递或从管道末端输出。
不得将用户定义的 IO 传递给 [=compute=] 着色器入口点。
用户定义的 IO 必须是 [=numeric scalar=] 或 [=numeric vector=] 类型，或者其成员是数字标量或向量的结构类型。
必须为所有用户定义的 IO 分配位置（请参阅 [[#input-output-locations]]）。

#### 插值 #### {#interpolation}

作者可以通过使用 [=attribute/interpolate=] 属性来控制如何插入用户定义的 IO 数据。
[SHORTNAME] 提供了两个方面的插值来控制：插值的类型和插值的采样。

插值类型 <dfn noexport>interpolation type</dfn> 必须是以下之一:
* `perspective` - 值以透视正确的方式插入。
* `linear` - 值以线性、非透视的正确方式进行插值。
* `flat` - 值不是内插的。
    插值采样不与 `flat` 插值一起使用。

插值采样 <dfn noexport>interpolation sampling</dfn> 必须为以下之一:
* `center` - 在像素的中心执行插值。
* `centroid` - 插值在位于当前基元内的片段所覆盖的所有样本内的点处执行。该值对于基元中的所有样本都是相同的。
* `sample` - 对每个样本执行内插。当应用此属性时，每个样本调用一次 [=fragment=] 着色器。

用于标量或向量浮点类型的用户自定义IO:
* 如果未指定插值属性，则假定为 `[[interpolate(perspective, center)]]`。
* 如果使用插值类型指定插值属性：
    * 如果插值类型为 `flat`，则不得指定插值采样。
    * 如果插值类型是 `perspective` 或 `linear`，则:
         * 任何插值采样都是有效的。
         * 如果未指定插值采样，则假定为 `center`。

标量或向量整数类型的用户定义 IO 始终是 `[[interpolate(flat)]]`，因此，不得在 [SHORTNAME] 程序中指定。

插值属性必须在 [=vertex=] 输出和 [=fragment=] 输入之间匹配，在相同的 [=pipeline=] 中具有相同的 [=attribute/location=] 分配。

#### 输入输出位置 #### {#input-output-locations}

每个位置最多可以存储 16 个字节的值。
类型的字节大小使用 [[#alignment-and-size]] 中的 *SizeOf* 列定义。
例如，浮点值的四元素向量占据一个位置。

位置通过 [=attribute/location=] 属性指定。

每个用户定义的输入和输出都必须有一组完全指定的位置。
入口点 IO 中的每个结构成员必须是内置变量之一
（参见 [[#builtin-inputs-outputs]]），或分配一个位置。

位置不得在以下每个集合内重叠：
* 结构类型中的成员。
     这适用于任何结构，而不仅仅是管道输入或输出中使用的结构。
* 入口点的管道输入，
     即其形式参数的位置，或其结构类型的形式参数的成员。

注意：位置编号在输入和输出之间是不同的：
入口点管道输入的位置编号与入口点管道输出的位置编号不冲突。

注意：不需要额外的规则来防止入口点输出中的位置重叠。
当输出是一个结构时，上面的第一条规则可以防止重叠。
否则，输出是标量或向量，并且只能分配一个位置。

注意：入口点的可用位置数由 WebGPU API 定义。

<div class='example applying location attribute' heading='Applying location attributes'>
  <xmp>
    struct A {
      [[location(0)]] x: f32;
      // 尽管位置是 16 字节，但 x 和 y 不能共享位置
      [[location(1)]] y: f32;
    };

    // in1 occupies locations 0 and 1.
    // in2 occupies location 2.
    // The return value occupies location 0.
    [[stage(fragment)]]
    fn fragShader(in1: A, [[location(2)]] in2: f32) -> [[location(0)]] vec4<f32> {
     // ...
    }
  </xmp>
</div>

用户定义的 IO 可以与同一结构中的内置变量混合使用。 例如，

<div class='example mixing builtins and user-defined IO' heading='Mixing builtins and user-defined IO'>
  <xmp>
    // Mixed builtins and user-defined inputs.
    struct MyInputs {
      [[location(0)]] x: vec4<f32>;
      [[builtin(front_facing)]] y: bool;
      [[location(1)]] z: u32;
    };

    struct MyOutputs {
      [[builtin(frag_depth)]] x: f32;
      [[location(0)]] y: vec4<f32>;
    };

    [[stage(fragment)]]
    fn fragShader(in1: MyInputs) -> MyOutputs {
      // ...
    }
  </xmp>
</div>

<div class='example invalid locations' heading='Invalid location assignments'>
  <xmp>
    struct A {
      [[location(0)]] x: u32;
      // Invalid, x and y cannot share a location.
      [[location(0)]] y: u32;
    };

    struct B {
      [location(0)]] x: f32;
    };

    struct C {
      // Invalid, structures with user-defined IO cannot be nested.
      b: B;
    };

    struct D {
      x: vec4<f32>;
    };

    [[stage(fragment)]]
    // Invalid, location cannot be applied to a structure type.
    fn fragShader1([[location(0)]] in1: D) {
      // ...
    }

    [[stage(fragment)]]
    // Invalid, in1 and in2 cannot share a location.
    fn fragShader2([location(0)]] in1: f32, [[location(0)]] in2: f32) {
      // ...
    }

    [[stage(fragment)]]
    // Invalid, location cannot be applied to a structure.
    fn fragShader3([[location(0)]] in1: vec4<f32>) -> [[location(0)]] D {
      // ...
    }
  </xmp>
</div>

### 资源接口 ### {#resource-interface}

<dfn noexport>resource</dfn> 是一个对象，除了 [[#pipeline-inputs-outputs|pipeline input or output]]，它提供对 [=shader stage=] 外部数据的访问。
资源由着色器的所有调用共享。

有四种资源类型:

* [=uniform buffers=]
* [=storage buffers=]
* 纹路
* 采样器

着色器的资源接口<dfn noexport>resource interface of a shader</dfn>是模块范围的集合
资源变量静态访问 [=statically accessed=] 通过着色器阶段中的函数|着色器阶段中的函数
[=functions in a shader stage|functions in the shader stage=]。

每个资源变量都必须用 [=attribute/group=] 和 [=attribute/binding=] 属性声明。
与着色器的阶段一起，这些标识了着色器管道上资源的绑定地址。
参考 [[WebGPU#pipeline-layout|WebGPU &sect; GPUPipelineLayout]]。

绑定不能在着色器阶段内别名：当被视为一对值时，给定着色器的资源接口中的两个不同变量不能具有相同的组和绑定值。

### 资源布局兼容性 ### {#resource-layout-compatibility}

WebGPU 要求着色器的资源接口与使用着色器的 [[WebGPU#pipeline-layout|layout of the pipeline]] 匹配。

资源接口中的每个 [SHORTNAME] 变量都必须绑定到具有兼容 [[WebGPU#binding-resource-type|resource type]]
和 [[WebGPU#binding-type|binding type]] 的 WebGPU 资源，其中兼容性为 由下表定义。
<table class='data'>
  <caption>WebGPU binding type compatibility</caption>
  <thead>
    <tr><th>[SHORTNAME] resource
        <th>WebGPU<br>[[WebGPU#binding-resource-type|Resource type]]
        <th colspan=2>WebGPU [[WebGPU#binding-type|Binding type]]
  </thead>
  <tr><td>[=uniform buffer=]
      <td rowspan=3>[[WebGPU#dictdef-gpubufferbinding|GPUBufferBinding]]
      <td rowspan=3>GPUBufferBindingType
      <td>[[WebGPU#dom-gpubufferbindingtype-uniform|uniform]]
  <tr><td>[=storage buffer=] with [=access/read_write=] access
      <td>[[WebGPU#dom-gpubufferbindingtype-storage|storage]]
  <tr><td>[=storage buffer=] with [=access/read=] access
      <td>[[WebGPU#dom-gpubufferbindingtype-read-only-storage|read-only-storage]]
  <tr><td rowspan=2>sampler
      <td rowspan=3>[[WebGPU#gpusampler|GPUSampler]]
      <td rowspan=3>GPUSamplerBindingType
      <td>[[WebGPU#dom-gpusamplerbindingtype-filtering|filtering]]
  <tr>
      <td>[[WebGPU#dom-gpusamplerbindingtype-non-filtering|non-filtering]]
  <tr><td>sampler_comparison
      <td>[[WebGPU#dom-gpusamplerbindingtype-comparison|comparison]]
  <tr><td rowspan=5>sampled texture
      <td rowspan=5>[[WebGPU#gputextureview|GPUTextureView]]
      <td rowspan=5>GPUTextureSampleType
      <td>[[WebGPU#dom-gputexturesampletype-float|float]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-unfilterable-float|unfilterable-float]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-sint|sint]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-uint|uint]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-depth|depth]]
  <tr><td>[=write-only storage texture=]
      <td>[[WebGPU#gputextureview|GPUTextureView]]
      <td>GPUStorageTextureAccess
      <td>[[WebGPU#dom-gpustoragetextureaccess-write-only|write-only]]
</table>

TODO: 描述过滤或非过滤采样器何时有效。

TODO: 描述浮动与不可过滤的浮动采样纹理何时有效。

如果|B| 是资源接口中的 [=uniform buffer=] 变量，并且 |WB| 是 [[WebGPU#buffer-interface|WebGPU GPUBuffer]] 绑定到 |B|，然后：
* |WB|的大小 必须至少与 |B| 的 [=store type=] 在 [=storage classes/storage=] 存储类中的大小一样大。

如果|B| 是资源接口中的 [=storage buffer=] 变量，而 |WB| 是 [[WebGPU#buffer-interface|WebGPU GPUBuffer]] 绑定到 |B|，然后：
* 如果 [=store type=] |S| 的 |B| 不包含 [=runtime-sized=] 数组，则 |WB| 的大小 必须至少与 |S| 在 [=storage classes/storage=] 存储类中的大小一样大。
* 如果 [=store type=] |S| 的 |B| 包含一个 [=runtime-sized=] 数组作为它的最后一个成员，
    那么：
    * 该成员的运行时确定的数组长度必须至少为 1。
    * |WB|的尺寸 必须至少与存储在 |B| 中的值在存储类 [=storage classes/storage=] 中的大小一样大。

注意：回想一下，[=runtime-sized=] 数组只能作为结构类型中的最后一个元素出现，该结构类型是存储缓冲区变量的存储类型。

TODO: 描述其他接口匹配要求，例如 对于图像？

## 管道兼容性 TODO ## {#pipeline-compatibility}

TODO: 匹配平面属性

TODO: 片段阶段的用户数据输入必须是顶点阶段的用户数据输出的子集

### 输入输出匹配规则 TODO ### {#input-output-matching}

# 语言扩展 # {#language-extensions}

[SHORTNAME] 语言预计会随着时间的推移而发展。

<dfn noexport>extension</dfn> 是对 [SHORTNAME] 规范的特定版本的一组连贯修改的命名分组，由以下任意组合组成：
* 通过新语法添加新概念和行为，包括：
     * 声明、语句、属性和内置函数。
* 删除当前规范或以前发布的扩展中的限制。
* 用于减少允许行为集的语法。
* 用于限制程序的一部分可用的功能的语法。
* 扩展如何与现有规范交互以及可选地与其他扩展交互的描述。

假设，扩展可用于:
* 添加数字标量类型，例如 16 位整数。
* 添加语法以限制浮点舍入模式。
* 添加语法以表示着色器不使用原子类型。
* 添加新的语句。
* 添加新的内置函数。
* 添加对着色器调用执行方式的约束。
* 添加新的着色器阶段。

## 启用指令 ## {#enable-directive-section}

<dfn noexport>enable directive</dfn> 表示由特定命名的 [=extension=] 描述的功能可以在指令本身之后的源文本中使用。
也就是说，扩展描述的语言功能可以用于任何
`enable` 指令后的源文本。

该指令不得出现在任何 [=declaration=] 的文本中。
（如果它是一个声明，它将位于 [=module scope=]。）

该指令使用 [=identifier=] 来命名扩展，但不会为标识符创建 [=scope=]。
指令对标识符的使用与将该标识符用作任何 [=declaration=] 中的名称不冲突。

<pre class='def'>
enable_directive
  : ENABLE IDENT SEMICOLON
</pre>

注意：语法规则包括终止分号标记，确保附加功能仅在该分号之后可用。
因此，任何 [SHORTNAME] 实现都可以解析整个 `enable` 指令。
当实现遇到不受支持的扩展的启用指令时，实现可以发出明确的诊断。

<div class='example using extensions' heading="Using hypothetical extensions">
  <xmp>
    // Enable a hypothetical IEEE-754 binary16 floating point extension.
    enable f16;

    // Assuming the f16 extension enables use of the f16 type:
    //    - as function return value
    //    - as the type for let declaration
    //    - as a type constructor, with an i32 argument
    //    - as operands to the division operator: /
    fn halve_it(x: f16) -> f16 {
       let two: f16 = f16(2);
       return x / two;
    };

    enable f16; // A redundant enable directive is ok.
    // Enable a hypothetical extension adding syntax for controlling
    // the rounding mode on f16 arithmetic.
    enable rounding_mode_f16;

    [[round_to_even_f16]] // Attribute enabled by the rounding_mode_f16 extension
    fn triple_it(x: f16) -> f16 {
       return x * f16(3); // Uses round-to-even.
    };
  </xmp>
</div>


# WGSL 项目 TODO # {#wgsl-module}

TODO: *Stub* A WGSL program is a sequence of [=directives=] and [=module scope=] [=declarations=].

<pre class='def'>
global_decl_or_directive
  : SEMICOLON
  | global_variable_decl SEMICOLON
  | global_constant_decl SEMICOLON
  | type_alias SEMICOLON
  | struct_decl SEMICOLON
  | function_decl
  | enable_directive
</pre>

# Execution TODO # {#execution}

## Invocation of an entry point TODO ## {#invocation-of-an-entry-point}

### Before an entry point begins TODO ### {#before-entry-point-begins}

TODO: *Stub*

* Setting values of builtin variables
* External-interface variables have initialized backing storage
* Internal module-scope variables have backing storage
  * Initializers evaluated in textual order

### Program order (within an invocation) TODO ### {#program-order}

#### Function-scope variable lifetime and initialization TODO #### {#function-scope-variable-lifetime}

#### Statement order TODO #### {#statement-order}

#### Intra-statement order (or lack) TODO #### {#intra-statement-order}

TODO: *Stub*: Expression evaluation

## Uniformity TODO ## {#uniformity}

### Uniform control flow TODO ### {#uniform-control-flow}

### Divergence and reconvergence TODO ### {#divergence-reconvergence}

### Uniformity restrictions TODO ### {#uniformity-restrictions}

## 计算着色器和工作组 ## {#compute-shader-workgroups}

<dfn noexport for="compute shader stage">workgroup</dfn> 是一组调用，
它们同时执行 [=compute shader stage=] [=entry point=]，并共享对 [=storage classes/workgroup=] 存储类。

计算着色器的 <dfn noexport>workgroup grid</dfn> 是具有整数坐标 *(i,j,k)* 的点集，其中：

*  0 &leq; i &lt; workgroup_size_x
*  0 &leq; j &lt; workgroup_size_y
*  0 &leq; k &lt; workgroup_size_z

其中 *(workgroup_size_x, workgroup_size_y, workgroup_size_z)* 是为入口点的 [=attribute/workgroup_size=] 属性指定的值。

对于工作组网格中的每个点，在工作组中恰好有一个调用。

调用的本地调用ID <dfn noexport>local invocation ID</dfn> 是调用对应的工作组网格点的坐标三元组。

当一个调用有[=local invocation ID=] (i,j,k)，那么它的<dfn noexport>local invocation index</dfn>是

  i +
  (j * workgroup_size_x) +
  (k * workgroup_size_x * workgroup_size_y)

<p algorithm="local index range">注意，如果一个工作组有|W| 调用，
然后每次调用 |I| 工作组有一个唯一的本地调用索引 |L|(|I|) 使得 0 &le; |L|(|I|) < |W|，覆盖整个范围。</p>

当 WebGPU 实现从队列中删除调度命令并开始在 GPU 上执行指定工作时，计算着色器开始执行。
dispatch 命令指定<dfn noexport>dispatch size</dfn>，
它是一个整数三元组*(group_count_x, group_count_y, group_count_z)*，指示要执行的工作组的数量，如下所述。

特定分派的 <dfn noexport>compute shader grid</dfn> 是具有整数坐标 *(CSi,CSj,CSk)* 的点集，其中：

*  0 &leq; CSi &lt; workgroup_size_x &times; group_count_x
*  0 &leq; CSj &lt; workgroup_size_y &times; group_count_y
*  0 &leq; CSk &lt; workgroup_size_z &times; group_count_z

其中*workgroup_size_x*，
*workgroup_size_y*，和
*workgroup_size_z* 与上述计算着色器入口点相同。

计算着色器分派要执行的工作是为计算着色器网格中的每个点恰好执行一次入口点调用。

调用的 <dfn noexport>global invocation ID</dfn> 是调用对应的计算着色器网格点的坐标三元组。

调用被组织成工作组，以便每个调用
*(CSi, CSj, CSk)* 用工作组网格点标识

   ( *CSi* mod workgroup_size_x ,
     *CSj* mod workgroup_size_y ,
     *CSk* mod workgroup_size_z )

在 <dfn noexport>workgroup ID</dfn> 中

   ( &lfloor; *CSi* &div; workgroup_size_x &rfloor;,
     &lfloor; *CSj* &div; workgroup_size_y &rfloor;,
     &lfloor; *CSk* &div; workgroup_size_z &rfloor;).

WebGPU 不提供任何保证:

* 来自不同工作组的调用是否并发执行。 也就是说，您不能假设一次执行多个工作组。
* 一旦来自一个工作组的调用开始执行，其他工作组是否被阻止执行。
     也就是说，您不能假设一次只有一个工作组执行。
     当工作组正在执行时，实现可以选择同时执行其他工作组，或其他排队但未阻塞的工作。
* 来自一个特定工作组的调用是否在另一个工作组的调用之前开始执行。
     也就是说，您不能假设工作组是按特定顺序启动的。

问题: [WebGPU issue 1045](https://github.com/gpuweb/gpuweb/issues/1045):
调度组计数必须为正数。
但是，我们如何处理指定组计数为零的间接调度。

## Collective operations TODO ## {#collective-operations}

### Barrier TODO ### {#barrier}

### 导数 ### {#derivatives}

偏导数<dfn noexport>partial derivative</dfn> 是值沿轴的变化率。

对相邻片元（在屏幕空间坐标中）操作的片段着色器调用协作计算近似偏导数。

*片元坐标*的偏导数是作为以下内置函数运算的一部分隐式计算的：
* [[#texturesample|textureSample]]，
* [[#texturesamplebias|textureSampleBias]]， 和
* [[#texturesamplecompare|textureSampleCompare]]。

对于这些，导数有助于确定要采样的纹素的 mip 级别，或者在“textureSampleCompare”的情况下，对参考值进行采样和比较。

*调用指定*值的偏导数由
[[#derivative-builtin-functions]] 中描述的内置函数：
* dpdx、dpdxCoarse 和 dpdxFine 计算沿 x 轴的偏导数。
* dpdy、dpdyCoarse 和 dpdyFine 计算沿 y 轴的偏导数。
* fwidth、fwidthCoarse 和 fwidthFine 计算相关联的 x 和 y 偏导数的曼哈顿度量。

因为相邻调用必须协作计算导数，所以这些函数只能在片元着色器的统一控制流中调用。

### Arrayed resource access TODO ### {#arrayed-resource-access}

## 浮点计算 ## {#floating-point-evaluation}

[SHORTNAME] 遵循 [[!IEEE-754|IEEE-754]] 浮点计算标准
以下例外:
* 不会产生浮点异常。
* 可能不会生成信令 NaN。
    任何信令 NaN 都可以转换为安静的 NaN。
* 实现可能假设 NaN、无穷大不存在
     * 注意：这意味着一些函数（例如 `isInf`、`isNan`、`min` 和 `max`）
         由于存在优化，可能不会返回预期的结果
         NaN 和无穷大。
* 实现可能会忽略零的符号。
     也就是说，带正号的零可能表现得像带负号的零，反之亦然。
* 没有指定舍入模式。
* 实现可能会刷新 [[#floating-point-accuracy]] 中列出的任何操作的输入和/或输出的非规范化值。
    * 需要其他操作来保留非规范化数字。
* 操作的准确性在 [[#floating-point-accuracy]] 中给出。

### 浮点精度 ### {#floating-point-accuracy}

<div algorithm="correctly rounded">
让|x| 当以无限精度计算时，是操作的精确实值或无限结果。
<dfn>corrctly rounded</dfn>浮点类型运算的结果|T| 是:
* |x|，但 |x| 在 |T| 的范围内，
* 否则:
    * |T| 中的最小值 大于 |x|，或
    * |T| 中的最大值 小于 |x|。

</div>

也就是说，结果可能会向上或向下舍入：
[SHORTNAME] 未指定舍入模式。

注意：浮点类型包括正无穷大和负无穷大，所以
正确舍入的结果可能是有限的或无限的。

最后一个单位（<dfn noexport>ULP</dfn>），对于浮点数 `x` 是两个不相等的浮点数 `a `和 `b` 之间的最小距离，
使得 `a` &le ; `x` &le; `b`（即 `ulp(x) = min`<sub>`a,b`</sub>`|b - a|`）。

在下表中，提供了五个操作的准确性
可能性：
* 正确的结果（对于非浮点返回值）
* [=Correctly rounded=]
* 相对误差界表示为 [=ULP=]
* 精度为 <dfn noexport>inherited from</dfn> 的函数。
    也就是说，准确度等于按照导出函数执行运算。
* 绝对误差界限

对于在一个范围内指定的任何精度值，该范围之外的结果的精度是不确定的。

如果任何操作的允许返回值的大小大于最大可表示的有限浮点值，则该操作可能另外返回具有相同符号的无穷大或具有相同符号的最大有限值。

<table class='data'>
  <caption>表达式的准确性</caption>
  <thead>
    <tr><th>表达式<th>准确性<th>
  </thead>

  <tr><td>`x + y`<td>正确四舍五入
  <tr><td>`x - y`<td>正确四舍五入
  <tr><td>`x * y`<td>正确四舍五入
  <tr><td>`x / y`<td>2.5 ULP 对于在 [2<sup>-126</sup>, 2<sup>126</sup>] 范围内的 `|y|`
  <tr><td>`x % y`<td>派生自 `x - y * trunc(x/y)`
  <tr><td>`-x`<td>正确四舍五入

  <tr><td>`x == y`<td>正确结果
  <tr><td>`x != y`<td>正确结果
  <tr><td>`x < y`<td>正确结果
  <tr><td>`x <= y`<td>正确结果
  <tr><td>`x > y`<td>正确结果
  <tr><td>`x >= y`<td>正确结果
</table>

<table class='data'>
  <caption>内置函数的准确性</caption>
  <thead>
    <tr><th>内置函数<th>准确性
  </thead>

  <tr><td>`abs(x)`<td>正确四舍五入
  <tr><td>`acos(x)`<td>派生自 `atan2(sqrt(1.0 - x * x), x)`
  <tr><td>`asin(x)`<td>派生自 `atan2(x, sqrt(1.0 - x * x))`
  <tr><td>`atan(x)`<td>4096 ULP
  <tr><td>`atan2(y, x)`<td>4096 ULP
  <tr><td>`ceil(x)`<td>正确四舍五入
  <tr><td>`clamp(x)`<td>正确四舍五入
  <tr><td>`cos(x)`<td>绝对错误 &le; 2<sup>-11</sup> 在 [-&pi;, &pi;] 范围内
  <tr><td>`cosh(x)`<td>继承自 `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`cross(x, y)`<td>继承自 `(x[i] * y[j] - x[j] * y[i])`
  <tr><td>`distance(x, y)`<td>继承自 `length(x - y)`
  <tr><td>`exp(x)`<td>3 + 2 * |x| ULP
  <tr><td>`exp2(x)`<td>3 + 2 * |x| ULP
  <tr><td class="nowrap">`faceForward(x, y, z)`<td>继承自 `select(-x, x, dot(z, y) < 0.0)`
  <tr><td>`floor(x)`<td>正确四舍五入
  <tr><td>`fma(x, y, z)`<td>继承自 `x * y + z`
  <tr><td>`fract(x)`<td>正确四舍五入
  <tr><td>`frexp(x)`<td>正确四舍五入
  <tr><td>`inverseSqrt(x)`<td>2 ULP
  <tr><td>`ldexp(x, y)`<td>正确四舍五入
  <tr><td>`length(x)`<td>继承自 `sqrt(dot(x, x))`
  <tr><td>`log(x)`<td>3 ULP 在 [0.5, 2.0] 范围外<br>绝对错误  &lt; 2<sup>-21</sup> 在 [0.5, 2.0] 范围内
  <tr><td>`log2(x)`<td>3 ULP 在 [0.5, 2.0] 范围外<br>绝对错误 &lt; 2<sup>-21</sup> 在 [0.5, 2.0] 范围内
  <tr><td>`max(x, y)`<td>正确四舍五入
  <tr><td>`min(x, y)`<td>正确四舍五入
  <tr><td>`mix(x, y, z)`<td>继承自 `x * (1.0 - z) + y * z`
  <tr><td>`modf(x)`<td>正确四舍五入
  <tr><td>`normalize(x)`<td>继承自 `x / length(x)`
  <tr><td>`pow(x, y)`<td>继承自 `exp2(y * log2(x))`
  <tr><td>`reflect(x, y)`<td>继承自 `x - 2.0 * dot(x, y) * y`
  <tr><td>`refract(x, y, z)`<td>继承自 `z * x - (z * dot(y, x) + sqrt(k)) * y`,<br>其中 `k = 1.0 - z * z * (1.0 - dot(y, x) * dot(y, x))`<br>如果 `k < 0.0` ，那么结果的精确度为 0.0
  <tr><td>`round(x)`<td>正确四舍五入
  <tr><td>`sign(x)`<td>正确四舍五入
  <tr><td>`sin(x)`<td>绝对错误&le; 2<sup>-11</sup> 在 [-&pi;, &pi;] 范围内
  <tr><td>`sinh(x)`<td>继承自 `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`smoothStep(x, y, z)`<td>继承自 `t * t * (3.0 - 2.0 * t)`,<br>where `t = clamp((z - x) / (y - x), 0.0, 1.0)`
  <tr><td>`sqrt(x)`<td>继承自 `1.0 / inverseSqrt(x)`
  <tr><td>`step(x, y)`<td>正确四舍五入
  <tr><td>`tan(x)`<td>继承自 `sin(x) / cos(x)`
  <tr><td>`tanh(x)`<td>继承自 `sinh(x) / cosh(x)`
  <tr><td>`trunc(x)`<td>正确四舍五入

</table>

<dfn noexport>Reassociation</dfn> 是对表达式中的操作进行重新排序，这样如果精确计算，答案是相同的。 例如：
* `(a + b) + c` 重新关联到 `a + (b + c)`
* `(a - b) + c` 重新关联到 `(a + c) - b`
* `(a * b) / c` 重新关联到 `(a / c) * b`

然而，当以浮点计算时，结果可能不一样。
由于近似，重新关联的结果可能不准确，或者在计算中间结果时可能会触发溢出或 NaN。

如果优化至少与原始公式一样准确，则实现可以重新关联和/或融合操作。

### 浮点数转换 ### {#floating-point-conversion}

在本节中，浮点类型可以是以下任何一种：
* WGSL 中的 [=f32=] 类型。
* 对应于 [[!IEEE-754|IEEE-754]] 浮点标准定义的二进制格式的假设类型。

    注：binary16 格式是这样引用的。

注意：回想一下 [=f32=] WGSL 类型对应于 IEEE-754 binary32 格式。

将浮点标量值转换为整数类型时：
* 如果原始值可以在目标类型中准确表示，则结果就是该值。
* 如果原始值有小数部分，则它不能在目标类型中精确表示，结果为 TODO
* 如果原始值超出目标类型的范围，则 TODO.

将值转换为浮点类型时：
* 如果原始值可以在目标类型中准确表示，则结果就是该值。
    * 如果原始值为零且为整数类型，则结果值具有零符号位。
* 否则，原始值不能完全表示。
    * 如果原始值不同于但位于目标类型中可表示的两个相邻值之间，则结果是这两个值之一。
         [SHORTNAME] 没有指定是选择较大还是较小的可表示值，并且此类转换的不同实例可能选择不同。
    * 否则，如果原始值位于目标类型的范围之外。
         * 当原始类型为 [=i32=] 或 [=u32=] 之一且目标类型为 [=f32=] 时，不会发生这种情况。
         * 当源类型是指数和尾数位较少的浮点类型时，不会发生这种情况。
         * 如果源类型是尾数位多于目标类型的浮点类型，则：
             * 可以丢弃源值的额外尾数位（将它们视为 0）。
                 * 如果结果值是目标类型的最大正常值，那么这就是结果。
             * 否则，结果是与源值具有相同符号的无穷大值。
    * 否则，如果源类型的原始值是 NaN，则结果是目标类型的 NaN。

注意：整数值可能位于两个相邻的可表示浮点值之间。
特别是，[=f32=] 类型使用 23 个显式小数位。
此外，当浮点值在正常范围内时（指数既不是极值），尾数就是小数位的集合，以及在位位置 23 的最高有效位置处的额外 1 位。
然后，例如，整数 2<sup>28</sup> 和 1+2<sup>28</sup> 都映射到相同的浮点值：
最低有效 1 位不能用浮点格式表示。
这种碰撞发生在大小至少为 2<sup>25</sup> 的相邻整数对中。

问题：(dneto) 默认舍入模式是一种实现选择。 那是我们想要的吗？

问题：检查 f32 到 f16 转换的行为是否超出了最大正常 f16 值。
我已经写了 NVIDIA GPU 的功能。 有关可执行的测试用例，请参阅 https://github.com/google/amber/pull/918。

# 内存模型 TODO # {#memory-model}

# 关键字和符号摘要 # {#grammar}

## 关键字摘要 ## {#keyword-summary}

<table class='data'>
  <caption>类型定义关键字</caption>
  <thead>
    <tr><th>符号<th>定义
  </thead>
  <tr><td>`ARRAY`<td>array
  <tr><td>`ATOMIC`<td>atomic
  <tr><td>`BOOL`<td>bool
  <tr><td>`FLOAT32`<td>f32
  <tr><td>`INT32`<td>i32
  <tr><td>`MAT2x2`<td>mat2x2  // 2 column x 2 row
  <tr><td>`MAT2x3`<td>mat2x3  // 2 column x 3 row
  <tr><td>`MAT2x4`<td>mat2x4  // 2 column x 4 row
  <tr><td>`MAT3x2`<td>mat3x2  // 3 column x 2 row
  <tr><td>`MAT3x3`<td>mat3x3  // 3 column x 3 row
  <tr><td>`MAT3x4`<td>mat3x4  // 3 column x 4 row
  <tr><td>`MAT4x2`<td>mat4x2  // 4 column x 2 row
  <tr><td>`MAT4x3`<td>mat4x3  // 4 column x 3 row
  <tr><td>`MAT4x4`<td>mat4x4  // 4 column x 4 row
  <tr><td>`POINTER`<td>ptr
  <tr><td>`SAMPLER`<td>sampler
  <tr><td>`SAMPLER_COMPARISON`<td>sampler_comparison
  <tr><td>`STRUCT`<td>struct
  <tr><td>`TEXTURE_1D`<td>texture_1d
  <tr><td>`TEXTURE_2D`<td>texture_2d
  <tr><td>`TEXTURE_2D_ARRAY`<td>texture_2d_array
  <tr><td>`TEXTURE_3D`<td>texture_3d
  <tr><td>`TEXTURE_CUBE`<td>texture_cube
  <tr><td>`TEXTURE_CUBE_ARRAY`<td>texture_cube_array
  <tr><td>`TEXTURE_MULTISAMPLED_2D`<td>texture_multisampled_2d
  <tr><td>`TEXTURE_STORAGE_1D`<td>texture_storage_1d
  <tr><td>`TEXTURE_STORAGE_2D`<td>texture_storage_2d
  <tr><td>`TEXTURE_STORAGE_2D_ARRAY`<td>texture_storage_2d_array
  <tr><td>`TEXTURE_STORAGE_3D`<td>texture_storage_3d
  <tr><td>`TEXTURE_DEPTH_2D`<td>texture_depth_2d
  <tr><td>`TEXTURE_DEPTH_2D_ARRAY`<td>texture_depth_2d_array
  <tr><td>`TEXTURE_DEPTH_CUBE`<td>texture_depth_cube
  <tr><td>`TEXTURE_DEPTH_CUBE_ARRAY`<td>texture_depth_cube_array
  <tr><td>`TEXTURE_DEPTH_MULTISAMPLED_2D`<td>texture_depth_multisampled_2d
  <tr><td>`UINT32`<td>u32
  <tr><td>`VEC2`<td>vec2
  <tr><td>`VEC3`<td>vec3
  <tr><td>`VEC4`<td>vec4
</table>
<table class='data'>
  <caption>其他关键词</caption>
  <thead>
    <tr><td>符号<td>定义
  </thead>
  <tr><td>`BITCAST`<td>bitcast
  <tr><td>`BLOCK`<td>block
  <tr><td>`BREAK`<td>break
  <tr><td>`CASE`<td>case
  <tr><td>`CONTINUE`<td>continue
  <tr><td>`CONTINUING`<td>continuing
  <tr><td>`DEFAULT`<td>default
  <tr><td>`DISCARD`<td>discard
  <tr><td>`ELSE`<td>else
  <tr><td>`ELSE_IF`<td>elseif
  <tr><td>`ENABLE`<td>enable
  <tr><td>`FALLTHROUGH`<td>fallthrough
  <tr><td>`FALSE`<td>false
  <tr><td>`FN`<td>fn
  <tr><td>`FOR`<td>for
  <tr><td>`FUNCTION`<td>function
  <tr><td>`IF`<td>if
  <tr><td>`LET`<td>let
  <tr><td>`LOOP`<td>loop
  <tr><td>`PRIVATE`<td>private
  <tr><td>`READ`<td>read
  <tr><td>`READ_WRITE`<td>read_write
  <tr><td>`RETURN`<td>return
  <tr><td>`STORAGE`<td>storage
  <tr><td>`SWITCH`<td>switch
  <tr><td>`TRUE`<td>true
  <tr><td>`TYPE`<td>type
  <tr><td>`UNIFORM`<td>uniform
  <tr><td>`VAR`<td>var
  <tr><td>`WORKGROUP`<td>workgroup
  <tr><td>`WRITE`<td>write
</table>
问题: Should read, write, and read_write be not completely reserved?  They are only used in specific contexts.
<table class='data'>
  <caption>Image format keywords</caption>
  <thead>
    <tr><td>符号<td>定义
  </thead>
  <tr><td>`R8UNORM`<td>r8unorm
  <tr><td>`R8SNORM`<td>r8snorm
  <tr><td>`R8UINT`<td>r8uint
  <tr><td>`R8SINT`<td>r8sint
  <tr><td>`R16UINT`<td>r16uint
  <tr><td>`R16SINT`<td>r16sint
  <tr><td>`R16FLOAT`<td>r16float
  <tr><td>`RG8UNORM`<td>rg8unorm
  <tr><td>`RG8SNORM`<td>rg8snorm
  <tr><td>`RG8UINT`<td>rg8uint
  <tr><td>`RG8SINT`<td>rg8sint
  <tr><td>`R32UINT`<td>r32uint
  <tr><td>`R32SINT`<td>r32sint
  <tr><td>`R32FLOAT`<td>r32float
  <tr><td>`RG16UINT`<td>rg16uint
  <tr><td>`RG16SINT`<td>rg16sint
  <tr><td>`RG16FLOAT`<td>rg16float
  <tr><td>`RGBA8UNORM`<td>rgba8unorm
  <tr><td>`RGBA8UNORM-SRGB`<td>rgba8unorm_srgb
  <tr><td>`RGBA8SNORM`<td>rgba8snorm
  <tr><td>`RGBA8UINT`<td>rgba8uint
  <tr><td>`RGBA8SINT`<td>rgba8sint
  <tr><td>`BGRA8UNORM`<td>bgra8unorm
  <tr><td>`BGRA8UNORM-SRGB`<td>bgra8unorm_srgb
  <tr><td>`RGB10A2UNORM`<td>rgb10a2unorm
  <tr><td>`RG11B10FLOAT`<td>rg11b10float
  <tr><td>`RG32UINT`<td>rg32uint
  <tr><td>`RG32SINT`<td>rg32sint
  <tr><td>`RG32FLOAT`<td>rg32float
  <tr><td>`RGBA16UINT`<td>rgba16uint
  <tr><td>`RGBA16SINT`<td>rgba16sint
  <tr><td>`RGBA16FLOAT`<td>rgba16float
  <tr><td>`RGBA32UINT`<td>rgba32uint
  <tr><td>`RGBA32SINT`<td>rgba32sint
  <tr><td>`RGBA32FLOAT`<td>rgba32float
</table>

TODO(dneto)：消除存储图像中未使用的图像格式。
例如 SRGB 格式 (bgra8unorm_srgb)、混合通道宽度 (rg11b10float)、乱序通道 (bgra8unorm)

## 保留字 ## {#reserved-words}

<dfn>reserved word</dfn> 是一个 [=token=] 保留供将来使用。
[SHORTNAME] 程序不得包含保留字。

以下是保留字:

<table class='data'>
  <tr>
    <td>asm
    <td>bf16
    <td>const
    <td>do
    <td>enum
  <tr>
    <td>f16
    <td>f64
    <td>handle
    <td>i8
    <td>i16
  <tr>
    <td>i64
    <td>mat
    <td>premerge
    <td>regardless
    <td>typedef
  <tr>
    <td>u8
    <td>u16
    <td>u64
    <td>unless
    <td>using
  <tr>
    <td>vec
    <td>void
    <td>while
</table>

## 句法符号 ## {#syntactic-tokens}

<dfn>syntactic token</dfn> 是一个特殊字符序列，用于：
* 拼写表达式运算符，或
* 作为标点符号：对其他语法元素进行分组、排序或分隔。

<table class='data'>
  <tr><td>`AND`<td>`&`
  <tr><td>`AND_AND`<td>`&&`
  <tr><td>`ARROW`<td>`->`
  <tr><td>`ATTR_LEFT`<td>`[[`
  <tr><td>`ATTR_RIGHT`<td>`]]`
  <tr><td>`FORWARD_SLASH`<td>`/`
  <tr><td>`BANG`<td>`!`
  <tr><td>`BRACKET_LEFT`<td>`[`
  <tr><td>`BRACKET_RIGHT`<td>`]`
  <tr><td>`BRACE_LEFT`<td>`{`
  <tr><td>`BRACE_RIGHT`<td>`}`
  <tr><td>`COLON`<td>`:`
  <tr><td>`COMMA`<td>`,`
  <tr><td>`EQUAL`<td>`=`
  <tr><td>`EQUAL_EQUAL`<td>`==`
  <tr><td>`NOT_EQUAL`<td>`!=`
  <tr><td>`GREATER_THAN`<td>`>`
  <tr><td>`GREATER_THAN_EQUAL`<td>`>=`
  <tr><td>`SHIFT_RIGHT`<td>`>>`
  <tr><td>`LESS_THAN`<td>`<`
  <tr><td>`LESS_THAN_EQUAL`<td>`<=`
  <tr><td>`SHIFT_LEFT`<td>`<<`
  <tr><td>`MODULO`<td>`%`
  <tr><td>`MINUS`<td>`-`
  <tr><td>`MINUS_MINUS`<td>`--`
  <tr><td>`PERIOD`<td>`.`
  <tr><td>`PLUS`<td>`+`
  <tr><td>`PLUS_PLUS`<td>`++`
  <tr><td>`OR`<td>`|`
  <tr><td>`OR_OR`<td>`||`
  <tr><td>`PAREN_LEFT`<td>`(`
  <tr><td>`PAREN_RIGHT`<td>`)`
  <tr><td>`SEMICOLON`<td>`;`
  <tr><td>`STAR`<td>`*`
  <tr><td>`TILDE`<td>`~`
  <tr><td>`UNDERSCORE`<td>`_`
  <tr><td>`XOR`<td>`^`
</table>

注意：`MINUS_MINUS` 和 `PLUS_PLUS` 标记是保留的，即它们不用于任何语法产生式。
例如 `x--` 和 `++i` 在[SHORTNAME] 中不是语法上有效的表达式。

# 内置变量 # {#builtin-variables}

查看 [[#builtin-inputs-outputs]] 如何创建内置变量

<table class='data'>
  <thead>
    <tr><th>内置<th>阶段<th>输入或输出<th>存储类型<th>描述
  </thead>

  <tr><td>`vertex_index`
      <td>vertex
      <td>in
      <td>u32
      <td style="width:50%">当前 API 级绘制命令中当前顶点的索引，与绘制实例无关。

         对于非索引绘制，第一个顶点的索引等于绘制的 `firstVertex` 参数，无论是直接提供还是间接提供。
         绘制实例中每增加一个顶点，索引就会增加 1。

         对于索引绘制，索引等于顶点的索引缓冲区条目，加上绘制的 `baseVertex` 参数，无论是直接提供还是间接提供。

  <tr><td>`instance_index`
      <td>vertex
      <td>in
      <td>u32
      <td style="width:50%">当前 API 级绘制命令中当前顶点的实例索引。

         第一个实例的索引等于绘制的 `firstInstance` 参数，无论是直接提供还是间接提供。
         抽签中每增加一个实例，索引就会增加 1。

  <tr><td>`position`
      <td>vertex
      <td>out
      <td>vec4&lt;f32&gt;
      <td style="width:50%">当前顶点的输出位置，使用齐次坐标。
      在均匀归一化（其中 *x*、*y* 和 *z* 分量中的每一个除以 *w* 分量）之后，位置在 WebGPU 归一化设备坐标空间中。
      查看 [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]]。

  <tr><td>`position`
      <td>fragment
      <td>in
      <td>vec4&lt;f32&gt;
      <td style="width:50%">当前片元的帧缓冲区位置，使用归一化齐次坐标。
      （*x*、*y* 和 *z* 分量已经被缩放，使得 *w* 现在为 1。）
      查看 [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]]。

  <tr><td>`front_facing`
      <td>fragment
      <td>in
      <td>bool
      <td style="width:50%">当当前片段位于正面图元上时为True。
         否则为False
         查看 [[WebGPU#front-facing|WebGPU &sect; Front-facing]].

  <tr><td>`frag_depth`
      <td>fragment
      <td>out
      <td>f32
      <td style="width:50%">在视口深度范围内更新了片段的深度。
      查看 [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]]。

  <tr><td>`local_invocation_id`
      <td>compute
      <td>in
      <td>vec3&lt;u32&gt;
      <td style="width:50%">当前调用的 [=local invocation ID=]，即它在 [=workgroup grid=] 中的位置。

  <tr><td>`local_invocation_index`
      <td>compute
      <td>in
      <td>u32
      <td style="width:50%">当前调用的 [=local invocation index=]，即 [=workgroup grid=] 中调用位置的线性化索引。

  <tr><td>`global_invocation_id`
      <td>compute
      <td>in
      <td>vec3&lt;u32&gt;
      <td style="width:50%">当前调用的 [=global invocation ID=]，即它在 [=compute shader grid=] 中的位置。

  <tr><td>`workgroup_id`
      <td>compute
      <td>in
      <td>vec3&lt;u32&gt;
      <td style="width:50%">当前调用的 [=workgroup ID=]，即工作组在 [=workgroup grid=] 中的位置。

  <tr><td>`num_workgroups`
      <td>compute
      <td>in
      <td>vec3&lt;u32&gt;
      <td style="width:50%">API 计算着色器 [[WebGPU#dom-gpucomputepassencoder-dispatch|dispatched]] 的 [=dispatch size=]、`vec<u32>(group_count_x, group_count_y, group_count_z)`。

  <tr><td>`sample_index`
      <td>fragment
      <td>in
      <td>u32
      <td style="width:50%">当前片段的示例索引。
         该值最小为 0，最大为 `sampleCount`-1，
         其中 [[WebGPU#dom-gpurenderpipelinedescriptor-samplecount|sampleCount]] 是为 GPU 渲染管道指定的 MSAA 样本数。
         <br>查看 [[WebGPU#render-pipeline|WebGPU &sect; GPURenderPipeline]]。

  <tr><td>`sample_mask`
      <td>fragment
      <td>in
      <td>u32
      <td style="width:50%">当前片元的样本覆盖掩码。
         它包含一个位掩码，指示正在渲染的图元覆盖此片段中的哪些样本。
         <br>查看 [[WebGPU#sample-masking|WebGPU &sect; Sample Masking]]。

  <tr><td>`sample_mask`
      <td>fragment
      <td>out
      <td>u32
      <td style="width:50%">当前片元的示例覆盖掩码控制。
         写入此变量的最后一个值成为 [[WebGPU#shader-output-mask|shader-output mask]]。
         写入值中的零位将导致颜色附件中的相应样本被丢弃。
         <br>查看 [[WebGPU#sample-masking|WebGPU &sect; Sample Masking]]。
</table>

<div class='example wgsl global-scope' heading="Declaring built-in variables">
  <xmp>
    struct VertexOutput {
      [[builtin(position)]] my_pos: vec4<f32>;
      //   OpDecorate %my_pos BuiltIn Position
      //   %float = OpTypeFloat 32
      //   %v4float = OpTypeVector %float 4
      //   %ptr = OpTypePointer Output %v4float
      //   %my_pos = OpVariable %ptr Output
    };

    [[stage(vertex)]]
    fn vs_main(
      [[builtin(vertex_index)]] my_index: u32,
      //   OpDecorate %my_index BuiltIn VertexIndex
      //   %uint = OpTypeInt 32 0
      //   %ptr = OpTypePointer Input %uint
      //   %my_index = OpVariable %ptr Input
      [[builtin(instance_index)]] my_inst_index: u32,
      //    OpDecorate %my_inst_index BuiltIn InstanceIndex
    ) -> VertexOutput {}

    struct FragmentOutput {
      [[builtin(frag_depth)]] depth: f32;
      //     OpDecorate %depth BuiltIn FragDepth
      [[builtin(sample_mask)]] mask_out: u32;
      //      OpDecorate %mask_out BuiltIn SampleMask ; an output variable
    };

    [[stage(fragment)]]
    fn fs_main(
      [[builtin(front_facing)]] is_front: bool,
      //     OpDecorate %is_front BuiltIn FrontFacing
      [[builtin(position)]] coord: vec4<f32>,
      //     OpDecorate %coord BuiltIn FragCoord
      [[builtin(sample_index)]] my_sample_index: u32,
      //      OpDecorate %my_sample_index BuiltIn SampleId
      [[builtin(sample_mask_in)]] mask_in: u32,
      //      OpDecorate %mask_in BuiltIn SampleMask ; an input variable
      //      OpDecorate %mask_in Flat
    ) -> FragmentOutput {}

    [[stage(compute)]]
    fn cs_main(
      [[builtin(local_invocation_id)]] local_id: vec3<u32>,
      //     OpDecorate %local_id BuiltIn LocalInvocationId
      [[builtin(local_invocation_index)]] local_index: u32,
      //     OpDecorate %local_index BuiltIn LocalInvocationIndex
      [[builtin(global_invocation_id)]] global_id: vec3<u32>,
      //      OpDecorate %global_id BuiltIn GlobalInvocationId
   ) {}
  </xmp>
</div>

# 内置函数 # {#builtin-functions}

某些功能在 [SHORTNAME] 程序中始终可用，并由实现提供。
这些被称为<dfn noexport>built-in functions</dfn>。

由于内置函数始终在作用域内，因此尝试重新定义一个函数或将内置函数的名称用作任何其他类型的声明的 [=identifier=] 都是错误的。

与 [SHORTNAME] 程序中定义的普通函数不同，内置函数可以使用相同的函数名和不同的参数集。
换句话说，一个内置函数可能有多个*重载*，但 [SHORTNAME] 中的普通函数定义可能没有。

调用内置函数时，函数的所有参数都会在函数求值开始之前求值。

TODO(dneto): 详细说明内置函数。 到目前为止，我只是重新组织了现有表的内容。

TODO: 解释表中函数原型的使用：提供名称、形参列表和返回类型。这不是完整的用户定义函数声明。

## 逻辑内置函数 ## {#logical-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>前提条件<td>结论<td>解释
  </thead>
  <tr algorithm="vector all">
    <td>|e|: vecN&lt;bool&gt;
    <td>`all(`|e|`)`: bool
    <td>如果 |e| 的每个分量都是真，则返回真。
    (OpAll)

  <tr algorithm="vector any">
    <td>|e|: vecN&lt;bool&gt;
    <td>`any(`|e|`)`: bool
    <td>如果 |e| 的每个分量都是真，则返回真。
    (OpAny)

  <tr algorithm="scalar select">
    <td>|T| 是标量或是向量
    <td>`select(`|f|`: `|T|`, `|t|`: `|T|`, `|cond|`: bool)`: |T|
    <td>返回 |t| 当 |cond| 为真， 除此以外返回 |f|。
    (OpSelect)

  <tr algorithm="vector select">
    <td>|T| 是标量
    <td>`select(`|f|`: vecN<`|T|`>, `|t|`: vecN<`|T|`>, `|cond|`: vecN<bool>)`
    <td>[=Component-wise=] 选择。 结果组件 |i| 被计算为 `select(`|f|`[`|i|`], `|t|`[`|i|`], `|cond|`[`|i|`])`。
    (OpSelect)
</table>

## 值测试内置函数 ## {#value-testing-builtin-functions}
<table class='data'>
  <caption>一元运算符</caption>
  <thead>
    <tr><th>前提条件<th>结论<th>解释
  </thead>
  <tr algorithm="isNan">
  <td rowspan=4>
    |I| 是 [FLOATING]<br>
    |T| 是 bool 如果 |I| 是一个标量， 或者<br>
    vec|N|&lt;bool&gt; 如果 |I| 是一个向量
    <td class="nowrap">`isNan(`|e|`:` |I| `) -> ` |T|
    <td>根据 [[!IEEE-754|IEEE-754]] 测试 NaN。<br>
    [=Component-wise=] 当 |I| 为一个向量。 (OpIsNan)
  <tr algorithm="isInf">
    <td class="nowrap">`isInf(`|e|`:` |I| `) -> ` |T|
    <td>根据 [[!IEEE-754|IEEE-754]] 测试无限值。<br>
    [=Component-wise=] 当 |I| 是一个向量。 (OpIsInf)
  <tr algorithm="isFinite">
    <td class="nowrap">`isFinite(`|e|`:` |I| `) -> ` |T|
    <td>根据 [[!IEEE-754|IEEE-754]] 测试有限值。<br>
    [=Component-wise=] 当 |I| 是一个向量。
  <tr algorithm="isNormal">
    <td class="nowrap">`isNormal(`|e|`:` |I| `) -> ` |T|
    <td>根据 [[!IEEE-754|IEEE-754]] 测试一个法向值。<br>
    [=Component-wise=] 当 |I| 是一个向量。

  <tr algorithm="runtime-sized array length">
    <td>|e|: ptr&lt;storage,array&lt;|T|&gt;&gt;
    <td>`arrayLength(`|e|`)`: u32<td>返回 [=runtime-sized=] 数组中的元素数。<br>
        (OpArrayLength，但实现必须回溯以获取指向封闭结构的指针。)
</table>

## 浮动内置函数 ## {#float-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论<th>描述
  </thead>
  <tr algorithm="float abs">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`abs(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的绝对值 （例如 |e| 带有正符号位）。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Fabs)

  <tr algorithm="acos">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`acos(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的反余弦值。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Acos)

  <tr algorithm="asin">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`asin(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的反正弦。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Asin)

  <tr algorithm="atan">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`atan(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的反正切。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Atan)

  <tr algorithm="atan2">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`atan2(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>返回 |e1|/|e2| 的反正切。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Atan2)

  <tr algorithm="ceil">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`ceil(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的向上取整 [=ceiling expression|ceiling=]。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Ceil)

  <tr algorithm="clamp">
    <td>|T| is [FLOATING]
    <td class="nowrap">`clamp(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T|`) -> ` |T|
    <td>返回 `min(max(`|e1|`,`|e2|`),`|e3|`)`。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450NClamp)

  <tr algorithm="cos">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`cos(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的余弦。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Cos)

  <tr algorithm="cosh">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`cosh(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的双曲余弦值。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Cosh)

  <tr algorithm="vector case, cross">
    <td>|T| 是 f32
    <td class="nowrap">`cross(`|e1|`:` vec3<|T|> `, `|e2|`:` vec3<|T|>`) -> ` vec3<|T|>
    <td>返回 |e1| 和 |e2| 的叉积。 (GLSLstd450Cross)

  <tr algorithm="distance">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`distance(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` f32
    <td>返回 |e1| 和 |e2| 之间的距离（即 `length(`|e1|` - `|e2|`)`）。
    (GLSLstd450Distance)

  <tr algorithm="exp">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`exp(`|e1|`:` |T| `) -> ` |T|
    <td>返回 |e1| 的自然求幂 (即 `e`<sup>|e1|</sup>)。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Exp)

  <tr algorithm="exp2">
    <td>|T| is [FLOATING]
    <td class="nowrap">`exp2(`|e|`:` |T| `) -> ` |T|
    <td>Returns 2 raised to the power |e| (e.g. `2`<sup>|e|</sup>).
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Exp2)

  <tr algorithm="faceForward">
    <td>|T| 是 vec|N|&lt;f32&gt;
    <td class="nowrap">`faceForward(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T| `) -> ` |T|
    <td>如果 `dot(`|e2|`,`|e3|`)` 是负的返回 |e1|, 否则返回 `-`|e1| 。
    (GLSLstd450FaceForward)

  <tr algorithm="floor">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`floor(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的向下取整 [=floor expression|floor=]。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Floor)

  <tr algorithm="fma">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`fma(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T| `) -> ` |T|
    <td>返回 |e1| `*` |e2| `+` |e3|.
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Fma)

  <tr algorithm="fract">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`fract(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的小数位 (即 |e| `- floor(`|e|`)`)。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Fract)

  <tr algorithm="scalar case, frexp">
    <td>|T| 是 f32
    <td class="nowrap">`frexp(`|e|`: `|T|`) -> __frexp_result`<br>
    <td>拆分 |e| 转换为 `significand * 2`<sup>`exponent`</sup>形式的有效数和指数。
    返回 `__frexp_result` 内置结构，定义为：
    ```rust
struct __frexp_result {
  sig : f32; // significand part
  exp : i32; // exponent part
};
    ```
    有效数的大小在 [0.5, 1.0) 或 0 的范围内。

    注意：一个值不能用类型 `__frexp_result` 显式声明，但一个值可以推断类型。
    <div class='example wgsl function-scope' heading='frexp usage'>
    <xmp>
     // 推断结果类型
     let sig_and_exp = frexp(1.5);
     // 设置 fraction_direct 的值为 0.75
     let fraction_direct = frexp(1.5).sig;
    </xmp>
    </div>
    (GLSLstd450FrexpStruct)

  <tr algorithm="vector case, frexp">
    <td>|T| 是 vec|N|&lt;f32&gt;
    <td class="nowrap">`frexp(`|e|`: `|T|`) -> __frexp_result_vec`|N|<br>
    <td>拆分 |e| 的组件 转换为 `significand * 2`<sup>`exponent`</sup>形式的有效数和指数。
    返回 `__frexp_result_vec`|N| 内置结构，定义为：
    ```rust
struct __frexp_result_vecN {
  sig : vecN<f32>; // significand part
  exp : vecN<i32>; // exponent part
};
    ```
    有效数的每个分量的大小在 [0.5, 1.0) 或 0 的范围内。

    注意：不能用 `__frexp_result_vec`|N| 类型显式声明值，但值可以推断类型。

    (GLSLstd450FrexpStruct)

  <tr algorithm="inverseSqrt">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`inverseSqrt(`|e|`:` |T| `) -> ` |T|
    <td>返回 `sqrt(`|e|`)` 的倒数。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450InverseSqrt)

  <tr algorithm="ldexp">
    <td>|T| 是 [FLOATING]<br>
        |I| 是 [SIGNEDINTEGRAL]， 其中<br>
        如果 |T| 是标量，那么 |I| 是标量，或者<br>
        当 |T| 是向量，那么 |I| 是向量
    <td class="nowrap">`ldexp(`|e1|`:` |T| `, `|e2|`:` |I| `) -> ` |T|
    <td>返回 |e1| `* 2`<sup>|e2|</sup>。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Ldexp)

  <tr algorithm="length">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`length(`|e|`:` |T| `) -> ` f32
    <td>返回 |e| 的长度 （例如 `abs(`|e|`)` 如果 |T| 是标量，或者 `sqrt(`|e|`[0]`<sup>`2`</sup> `+` |e|` [1]`<sup>`2`</sup> `+ ...)` 如果 |T| 是向量）。
    (GLSLstd450Length)

  <tr algorithm="log">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`log(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的自然对数。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Log)

  <tr algorithm="log2">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`log2(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的以 2 为底的对数。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Log2)

  <tr algorithm="max">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`max(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>返回 |e2| 如果 |e1| 小于 |e2|，且 |e1| 除此以外。
    如果一个操作数是 NaN，则返回另一个操作数。
    如果两个操作数都是 NaN，则返回 NaN。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450NMax)

  <tr algorithm="min">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`min(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>返回 |e2| 如果|e2| 小于 |e1|，且 |e1| 除此以外。
    如果一个操作数是 NaN，则返回另一个操作数。
    如果两个操作数都是 NaN，则返回 NaN。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450NMin)

  <tr algorithm="mix all same type operands">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`mix(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T|`) -> ` |T|
    <td>返回 |e1| 和 |e2| 的线性混合（例如 |e1|`*(1-`|e3|`)+`|e2|`*`|e3|）。
    [=Component-wise=] 当 |T| 是一个向量。
    <br>
    (GLSLstd450FMix)

  <tr algorithm="vector mix with scalar blending factor">
    <td>|T| 是 vec|N|&lt;f32&gt;
    <td class="nowrap">`mix(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` f32 `) -> ` |T|
    <td>返回 |e1| 和 |e2| 的分量线性混合，
    使用标量混合因子 |e3| 对于每个组件。<br>
    与 `mix(`|e1|`, `|e2|`, `|T|`(`|e3|`))` 相同。

  <tr algorithm="scalar case, modf">
    <td>|T| 是 f32
    <td class="nowrap">`modf(`|e|`: `|T|`) -> __modf_result`<br>
    <td>拆分 |e| 分为小数部分和整数部分。
    返回 `__modf_result` 内置结构，定义为：
    ```rust
struct __modf_result {
  fract : f32; // fractional part
  whole : f32; // whole part
};
    ```

    注意：一个值不能用 `__modf_result` 类型显式声明，但一个值可以推断类型。
    <div class='example wgsl function-scope' heading='modf usage'>
    <xmp>
     // 推断结果类型
     let fract_and_whole = modf(1.5);
     // 设置 fract_direct 的值为 0.5
     let fract_direct = modf(1.5).fract;
    </xmp>
    </div>
    (GLSLstd450ModfStruct)

  <tr algorithm="vector case, modf">
    <td>|T| 是 vec|N|&lt;f32&gt;
    <td class="nowrap">`modf(`|e|`: `|T|`) -> __modf_result_vec`|N|<br>
    <td>拆分 |e| 的组件 分为小数部分和整数部分。
    返回 `__modf_result_vec`|N| 内置结构，定义为：
    ```rust
struct __modf_result_vecN {
  fract : vecN<f32>; // fractional part
  whole : vecN<f32>; // whole part
};
    ```

    注意：不能用类型 `__modf_result_vec`|N| 显式声明值，但值可以推断类型。

    (GLSLstd450ModfStruct)

  <tr algorithm="vector case, normalize">
    <td>|T| 是 f32
    <td class="nowrap">`normalize(`|e|`:` vec|N|<|T|> `) -> ` vec|N|<|T|>
    <td>返回与 |e| 方向相同的单位向量。
    (GLSLstd450Normalize)

  <tr algorithm="pow">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`pow(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>返回 |e1| 提升到 |e2| 的幂。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Pow)

  <tr algorithm="quantize to f16">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`quantizeToF16(`|e|`:` |T| `) -> ` |T|
    <td>量化 32 位浮点值 |e| 好像 |e| 被转换为 [[!IEEE-754|IEEE 754]] binary16 值，
        然后转换回 IEEE 754 binary32 值。<br>
        查看 [[#floating-point-conversion]]。<br>
        [=Component-wise=] 当 |T| 是一个向量。<br>

        注意: vec2&lt;f32&gt; 的情况和 `unpack2x16float(pack2x16float(`|e|`))` 一样。

        (OpQuantizeToF16)

  <tr algorithm="reflect">
    <td>|T| 是 vec|N|&lt;f32&gt;
    <td class="nowrap">`reflect(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>对于事件向量 |e1| 和表面方向|e2|，返回反射方向 |e1|`-2*dot(`|e2|`,`|e1|`)*`|e2|。
    (GLSLstd450Reflect)

  <tr algorithm="refract">
    <td>|T| 是 vec|N|&lt;f32&gt;<br>I 是 f32
    <td class="nowrap">`refract(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |I| `) -> ` |T|
    <td>对于事件向量 |e1| 和表面法线|e2|，以及折射率比|e3|，
    让 `k = 1.0 - `|e3|` * `|e3|` * (1.0 - dot(`|e2|`, `|e1|`) * dot(`|e2|`, `|e1|`) )`。 如果 `k < 0.0`，则返回
    折射向量 0.0，否则返回折射向量
    |e3|` * `|e1|` - (`|e3|` * dot(`|e2|`, `|e1|`) + sqrt(k)) * `|e2|。
    (GLSLstd450Refract)

  <tr algorithm="round">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`round(`|e|`:` |T| `) -> ` |T|
    <td>返回值是最接近 |e| 的整数 |k|，作为浮点值。<br>
        当 |e| 位于 |k| 和 |k|+1 的中间的整数，
        结果是 |k| 当|k| 是偶数，当 |k| 是奇数时，返回 |k|+1 。<br>
        [=Component-wise=] 当 |T| 是一个向量。
        (GLSLstd450RoundEven)

  <tr algorithm="float sign">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`sign(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的符号。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450FSign)

  <tr algorithm="sin">
    <td>|T| is [FLOATING]
    <td class="nowrap">`sin(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的正弦值。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Sin)

  <tr algorithm="sinh">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`sinh(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的双曲正弦值。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Sinh)

  <tr algorithm="smoothStep">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`smoothStep(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T| `) -> ` |T|
    <td>返回 0 和 1 之间的平滑 Hermite 插值。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450SmoothStep)

  <tr algorithm="sqrt">
    <td>|T| is [FLOATING]
    <td class="nowrap">`sqrt(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的平方根。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Sqrt)

  <tr algorithm="step">
    <td>|T| is [FLOATING]
    <td class="nowrap">`step(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>如果 |e1| 小于 |e2| 返回 0.0 ，否则为 1.0。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Step)

  <tr algorithm="tan">
    <td>|T| is [FLOATING]
    <td class="nowrap">`tan(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的正切。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Tan)

  <tr algorithm="tanh">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`tanh(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的双曲正切值。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Tanh)

  <tr algorithm="trunc">
    <td>|T| 是 [FLOATING]
    <td class="nowrap">`trunc(`|e|`:` |T| `) -> ` |T|
    <td>返回最近的绝对值小于或等于 |e| 的整数。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450Trunc)
</table>

## 整数内置函数 ## {#integer-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="signed abs">
    <td>|T| 是 [SIGNEDINTEGRAL]
    <td class="nowrap">`abs`(|e|: |T| ) -> |T|
    <td>|e| 的绝对值。
        [=Component-wise=] 当 |T| 是一个向量。
        如果|e| 计算为最大的负值，则结果为 |e|。
        (GLSLstd450SAbs)

  <tr algorithm="scalar case, unsigned abs">
    <td>|T| 是 [UNSIGNEDINTEGRAL]
    <td class="nowrap">`abs`(|e|: |T| ) -> |T|
    <td>结果是|e|。 这是为了与带符号整数的 `abs` 对称而提供的。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="unsigned clamp">
    <td>|T| 是 [UNSIGNEDINTEGRAL]
    <td class="nowrap">`clamp(`|e1|`:` |T| `, `|e2|`:` |T|`, `|e3|`:` |T|`) ->` |T|
    <td>返回 `min(max(`|e1|`,`|e2|`),`|e3|`)`。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450UClamp)

  <tr algorithm="signed clamp">
    <td>|T| 是 [SIGNEDINTEGRAL]
    <td class="nowrap">`clamp(`|e1|`:` |T| `, `|e2|`:` |T|`, `|e3|`:` |T|`) ->` |T|
    <td>返回 `min(max(`|e1|`,`|e2|`),`|e3|`)`。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450SClamp)

  <tr algorithm="count 1 bits">
    <td>|T| 是 [INTEGRAL]
    <td class="nowrap">`countOneBits(`|e|`:` |T| `) ->` |T|
    <td>|e| 的表示中 1 的位数。<br>
        也叫作 "population count"。<br>
        [=Component-wise=] 当 |T| 是一个向量。
        (SPIR-V OpBitCount)

  <tr algorithm="unsigned max">
    <td>|T| 是 [UNSIGNEDINTEGRAL]
    <td class="nowrap">`max(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>返回 |e2| 如果 |e1| 小于 |e2|， 否则返回 |e1|。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450UMax)

  <tr algorithm="signed max">
    <td>|T| 是 [SIGNEDINTEGRAL]
    <td class="nowrap">`max(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>返回 |e2| 如果 |e1| 小于 |e2|，否则返回 |e1|。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450SMax)

  <tr algorithm="unsigned min">
    <td>|T| 是 [UNSIGNEDINTEGRAL]
    <td class="nowrap">`min(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>返回 |e1| 如果 |e1| 小于 |e2|，否则返回 |e2|。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd450UMin)

  <tr algorithm="signed min">
    <td>|T| 是 [SIGNEDINTEGRAL]
    <td class="nowrap">`min(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>返回 |e1| 如果 |e1| 小于 |e2|， 否则返回 |e2|。
    [=Component-wise=] 当 |T| 是一个向量。
    (GLSLstd45SUMin)

  <tr algorithm="bit reversal">
    <td>|T| 是 [INTEGRAL]
    <td class="nowrap">`reverseBits(`|e|`:` |T| `) ->`  |T|
    <td>反转 |e| 中的位：结果的位置 |k| 处的位 等于 |e| 的位置 31-|k| 处的位。<br>
        [=Component-wise=] 当 |T| 是一个向量。
        (SPIR-V OpBitReverse)
</table>

## 矩阵内置函数 ## {#matrix-builtin-functions}
<table class='data'>
  <thead>
    <tr><th>前提条件<th>结果<th>描述
  </thead>
  <tr algorithm="determinant">
    <td>|T| 是 f32
    <td class="nowrap">`determinant(`|e|`:` mat|N|x|N|<|T|> `) -> ` |T|
    <td>返回 |e| 的行列式。
    (GLSLstd450Determinant)
  <tr algorithm="transpose">
    <td>|T| 是 f32
    <td class="nowrap">`transpose(`|e|`:` mat|M|x|N|<|T|> `) -> ` mat|N|x|M|<|T|>
    <td>返回 |e| 的转置。
    (OpTranspose)
</table>

## 向量内置函数 ## {#vector-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>前提条件<td>结果<td>解释
  </thead>
  <tr algorithm="dot"><td>|T| 是 f32
  <td>`dot(`|e1|`: vecN<`|T|`>, `|e2|`: vecN<`|T|`>) ->` |T|
  <td>返回 |e1| 和 |e2| 的点积。
  (OpDot)
</table>

## 倒数内置函数 ## {#derivative-builtin-functions}

查看 [[#derivatives]].

这些函数:
* 只能在 [=fragment=] 着色器阶段使用。
* 只能在统一控制流中调用。

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论<th>解释
  </thead>
  <tr algorithm="dpdx">
  <td rowspan=9>|T| 是 f32 或 vecN&lt;f32&gt;
    <td>`dpdx(`|e|`: `|T|`) ->` |T|
    <td>|e| 的偏导数对应窗口 x 的坐标。
    结果与 `dpdxFine(`|e|`)` 或 `dpdxCoarse(`|e|`)` 相同。
    (OpDPdx)
  <tr algorithm="dpdxCoarse">
    <td>`dpdxCoarse(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口 x 坐标，使用局部差异。
     这可能会导致比 `dpdxFine(`|e|`)` 更少的独特位置。
    (OpDPdxCoarse)
  <tr algorithm="dpdxFine">
    <td>`dpdxFine(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口 x 坐标。
    (OpDPdxFine)
  <tr algorithm="dpdy">
    <td>`dpdy(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口 y 坐标。
    结果与 `dpdyFine(`|e|`)` 或 `dpdyCoarse(`|e|`)` 相同。
    (OpDPdy)
  <tr algorithm="dpdyCoarse">
    <td>`dpdyCoarse(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口 y 坐标，使用局部差异。
    这可能会导致比 `dpdyFine(`|e|`)` 更少的独特位置。
    (OpDPdyCoarse)
  <tr algorithm="dpdyFine">
    <td>`dpdyFine(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口y坐标。
    (OpDPdyFine)
  <tr algorithm="fwidth">
    <td>`fwidth(`|e|`: `|T|`) -> `|T|
    <td>返回 `abs(dpdx(`|e|`)) + abs(dpdy(`|e|`))`.
    (OpFwidth)
  <tr algorithm="fwidthCoarse">
    <td>`fwidthCoarse(`|e|`: `|T|`) -> `|T|
    <td>返回 `abs(dpdxCoarse(`|e|`)) + abs(dpdyCoarse(`|e|`))`.
    (OpFwidthCoarse)
  <tr algorithm="fwidthFine">
    <td>`fwidthFine(`|e|`: `|T|`) -> `|T|
    <td>返回 `abs(dpdxFine(`|e|`)) + abs(dpdyFine(`|e|`))`.
    (OpFwidthFine)
</table>

## 纹理内置函数 ## {#texture-builtin-functions}

在本节中，显示的纹理类型具有以下参数：
* |T|，采样类型。
* <var ignore>F</var>，[=texel format=]。
* <var ignore>A</var>，[=access mode=]。

参数值必须对相应的纹理类型有效。

### `textureDimensions` ### {#texturedimensions}

返回纹理的尺寸，或以 texels 为单位的纹理的 mip 级别。

```rust
textureDimensions(t: texture_1d<T>) -> i32
textureDimensions(t: texture_1d<T>, level: i32) -> i32
textureDimensions(t: texture_2d<T>) -> vec2<i32>
textureDimensions(t: texture_2d<T>, level: i32) -> vec2<i32>
textureDimensions(t: texture_2d_array<T>) -> vec2<i32>
textureDimensions(t: texture_2d_array<T>, level: i32) -> vec2<i32>
textureDimensions(t: texture_3d<T>) -> vec3<i32>
textureDimensions(t: texture_3d<T>, level: i32) -> vec3<i32>
textureDimensions(t: texture_cube<T>) -> vec2<i32>
textureDimensions(t: texture_cube<T>, level: i32) -> vec2<i32>
textureDimensions(t: texture_cube_array<T>) -> vec2<i32>
textureDimensions(t: texture_cube_array<T>, level: i32) -> vec2<i32>
textureDimensions(t: texture_multisampled_2d<T>)-> vec2<i32>
textureDimensions(t: texture_depth_2d) -> vec2<i32>
textureDimensions(t: texture_depth_2d, level: i32) -> vec2<i32>
textureDimensions(t: texture_depth_2d_array) -> vec2<i32>
textureDimensions(t: texture_depth_2d_array, level: i32) -> vec2<i32>
textureDimensions(t: texture_depth_cube) -> vec2<i32>
textureDimensions(t: texture_depth_cube, level: i32) -> vec2<i32>
textureDimensions(t: texture_depth_cube_array) -> vec2<i32>
textureDimensions(t: texture_depth_cube_array, level: i32) -> vec2<i32>
textureDimensions(t: texture_depth_multisampled_2d)-> vec2<i32>
textureDimensions(t: texture_storage_1d<F,A>) -> i32
textureDimensions(t: texture_storage_2d<F,A>) -> vec2<i32>
textureDimensions(t: texture_storage_2d_array<F,A>) -> vec2<i32>
textureDimensions(t: texture_storage_3d<F,A>) -> vec3<i32>
textureDimensions(t: texture_external) -> vec2<i32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [sampled](#sampled-texture-type),
  [multisampled](#multisampled-texture-type)， [depth](#texture-depth),
  [storage](#texture-storage)，或者 [external](#external-texture-type) 纹理。
  <tr><td>`level`<td>
  mip 级别，级别 0 包含纹理的全尺寸版本。<br>
  如果省略，则返回级别 0 的维度。
</table>

**返回:**

以纹素为单位的纹理尺寸。

对于基于立方体的纹理，结果是立方体每个面的尺寸。
立方体面是正方形，因此结果的 x 和 y 分量相等。

如果 `level` 在范围 `[0, textureNumLevels(t))` 之外，则可以返回返回类型的任何有效值。

### `textureLoad` ### {#textureload}

从纹理中读取单个纹素，无需采样或过滤。

```rust
textureLoad(t: texture_1d<T>, coords: i32, level: i32) -> vec4<T>
textureLoad(t: texture_2d<T>, coords: vec2<i32>, level: i32) -> vec4<T>
textureLoad(t: texture_2d_array<T>, coords: vec2<i32>, array_index: i32, level: i32) -> vec4<T>
textureLoad(t: texture_3d<T>, coords: vec3<i32>, level: i32) -> vec4<T>
textureLoad(t: texture_multisampled_2d<T>, coords: vec2<i32>, sample_index: i32)-> vec4<T>
textureLoad(t: texture_depth_2d, coords: vec2<i32>, level: i32) -> f32
textureLoad(t: texture_depth_2d_array, coords: vec2<i32>, array_index: i32, level: i32) -> f32
textureLoad(t: texture_depth_multisampled_2d, coords: vec2<i32>, sample_index: i32)-> f32
textureLoad(t: texture_external, coords: vec2<i32>) -> vec4<f32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [sampled](#sampled-texture-type)，
  [multisampled](#multisampled-texture-type)， [depth](#texture-depth),
  或者 [external](#external-texture-type) 纹理。
  <tr><td>`coords`<td>
  基于 0 的纹素坐标。
  <tr><td>`array_index`<td>
  从 0 开始的纹理数组索引。
  <tr><td>`level`<td>
  mip 级别，级别 0 包含纹理的全尺寸版本。
  <tr><td>`sample_index`<td>
  多重采样纹理的基于 0 的样本索引。
</table>

**返回:**

未过滤的纹素数据。

如果发生越界访问:
* `coords` 的任何元素都在相应元素的 `[0, textureDimensions(t, level))` 范围之外，或
* `array_index` 超出范围 `[0, textureNumLayers(t))`，或
* `level` 超出范围 `[0, textureNumLevels(t))`

如果发生越界访问，内置函数返回以下之一：
* 纹理边界内某些纹素的数据
* 非深度纹理的适当类型的向量 (0,0,0,0) 或 (0,0,0,1)
* 0.0 深度纹理

### `textureNumLayers` ### {#texturenumlayers}

返回数组纹理的层数（元素数）。

```rust
textureNumLayers(t: texture_2d_array<T>) -> i32
textureNumLayers(t: texture_cube_array<T>) -> i32
textureNumLayers(t: texture_depth_2d_array) -> i32
textureNumLayers(t: texture_depth_cube_array) -> i32
textureNumLayers(t: texture_storage_2d_array<F,A>) -> i32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [sampled](#sampled-texture-type)，
  [multisampled](#multisampled-texture-type)， [depth](#texture-depth) 或
  [storage](#texture-storage) 数组纹理。
</table>

**返回:**

如果数组纹理的层数（元素数）。


### `textureNumLevels` ### {#texturenumlevels}

返回纹理的 mip 级别数。

```rust
textureNumLevels(t: texture_1d<T>) -> i32
textureNumLevels(t: texture_2d<T>) -> i32
textureNumLevels(t: texture_2d_array<T>) -> i32
textureNumLevels(t: texture_3d<T>) -> i32
textureNumLevels(t: texture_cube<T>) -> i32
textureNumLevels(t: texture_cube_array<T>) -> i32
textureNumLevels(t: texture_depth_2d) -> i32
textureNumLevels(t: texture_depth_2d_array) -> i32
textureNumLevels(t: texture_depth_cube) -> i32
textureNumLevels(t: texture_depth_cube_array) -> i32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [sampled](#sampled-texture-type) 或 [depth](#texture-depth) 纹理。
</table>

**返回:**

如果纹理的 mip 级别数。


### `textureNumSamples` ### {#texturenumsamples}

返回多重采样纹理中每个纹素的样本数。

```rust
textureNumSamples(t: texture_multisampled_2d<T>) -> i32
textureNumSamples(t: texture_depth_multisampled_2d) -> i32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [multisampled](#multisampled-texture-type) 纹理。
</table>

**返回:**

如果多重采样纹理中每个纹素的样本数。


### `textureSample` ### {#texturesample}

采样纹理。

只能在 [=fragment=] 着色器阶段使用。
只能在统一控制流中调用。

```rust
textureSample(t: texture_1d<f32>, s: sampler, coords: f32) -> vec4<f32>
textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>) -> vec4<f32>
textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32) -> vec4<f32>
textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> vec4<f32>
textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>
textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, offset: vec3<i32>) -> vec4<f32>
textureSample(t: texture_cube<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>
textureSample(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32) -> vec4<f32>
textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>) -> f32
textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> f32
textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32) -> f32
textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> f32
textureSample(t: texture_depth_cube, s: sampler, coords: vec3<f32>) -> f32
textureSample(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: i32) -> f32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type), [depth](#texture-depth),
  or [external](#external-texture-type)
  texture to sample.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression must be either:
    * a `const_expression` expression (e.g. `vec2<i32>(1, 2)`).<br>
    * a name of a [[#module-constants|module-scope constant]] that is not [=pipeline-overridable=]
  Each `offset` component must be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**返回:**

采样值。

### `textureSampleBias` ### {#texturesamplebias}

对具有 mip 级别偏差的纹理进行采样。

只能在 [=fragment=] 着色器阶段使用。
只能在统一控制流中调用。

```rust
textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32) -> vec4<f32>
textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32, offset: vec2<i32>) -> vec4<f32>
textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, bias: f32) -> vec4<f32>
textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, bias: f32, offset: vec2<i32>) -> vec4<f32>
textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32, offset: vec3<i32>) -> vec4<f32>
textureSampleBias(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
textureSampleBias(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32, bias: f32) -> vec4<f32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  要采样的 [texture](#sampled-texture-type)。
  <tr><td>`s`<td>
  [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  要采样的基于 0 的纹理数组索引。
  <tr><td>`bias`<td>
  采样前应用于 mip 级别的偏差。
  `bias` 必须介于 `-16.0` 和 `15.99` 之间。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  `offset` 表达式必须是一个 `const_expression` 表达式（例如 `vec2<i32>(1, 2)`）。<br>
   每个 `offset` 组件必须最少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

采样值。


### `textureSampleCompare` ### {#texturesamplecompare}

对深度纹理进行采样并将采样的深度值与参考值进行比较。

只能在 [=fragment=] 着色器阶段使用。
只能在统一控制流中调用。

```rust
textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32, offset: vec2<i32>) -> f32
textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32) -> f32
textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32, offset: vec2<i32>) -> f32
textureSampleCompare(t: texture_depth_cube, s: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
textureSampleCompare(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3<f32>, array_index: i32, depth_ref: f32) -> f32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  要采样的 [depth](#texture-depth) 纹理。
  <tr><td>`s`<td>
  [sampler comparision](#sampler-type) 类型。
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  要采样的基于 0 的纹理数组索引。
  <tr><td>`depth_ref`<td>
  用于比较采样深度值的参考值。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  `offset` 表达式必须是一个 `const_expression` 表达式（例如 `vec2<i32>(1, 2)`）。<br>
  每个 `offset` 组件必须至少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

在 `[0.0..1.0]` 范围内的一个值。

使用 `sampler_comparison`，定义的比较运算符将每个采样的纹素与参考值进行比较，从而为每个纹素生成“0”或“1”值。

如果采样器使用双线性过滤，则返回值是这些值的过滤平均值，否则返回单个纹素的比较结果。


### `textureSampleCompareLevel` ### {#texturesamplecomparelevel}

对深度纹理进行采样并将采样的深度值与参考值进行比较。

```rust
textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32, offset: vec2<i32>) -> f32
textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32) -> f32
textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32, offset: vec2<i32>) -> f32
textureSampleCompareLevel(t: texture_depth_cube, s: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
textureSampleCompareLevel(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3<f32>, array_index: i32, depth_ref: f32) -> f32
```

`textureSampleCompareLevel` 函数与 `textureSampleCompare` 相同，除了：

* `textureSampleCompareLevel` 总是从 mip 级别 0 采样纹素。
    * 该函数不计算导数。
    * 不要求在统一控制流中调用 `textureSampleCompareLevel`。
* `textureSampleCompareLevel` 可以在任何着色器阶段调用。

### `textureSampleGrad` ### {#texturesamplegrad}

使用显式渐变对纹理进行采样。

```rust
textureSampleGrad(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
textureSampleGrad(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
textureSampleGrad(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
textureSampleGrad(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, ddx: vec2<f32>, ddy: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
textureSampleGrad(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
textureSampleGrad(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>, offset: vec3<i32>) -> vec4<f32>
textureSampleGrad(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
textureSampleGrad(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  要采样的 [texture](#sampled-texture-type)。
  <tr><td>`s`<td>
  [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  要采样的基于 0 的纹理数组索引。
  <tr><td>`ddx`<td>
  用于计算采样位置的 x 方向导数向量。
  <tr><td>`ddy`<td>
  用于计算采样位置的 y 方向导数向量。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  `offset` 表达式必须是一个 `const_expression` 表达式（例如 `vec2<i32>(1, 2)`）。<br>
  每个 `offset` 组件必须至少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

采样值。


### `textureSampleLevel` ### {#texturesamplelevel}

使用显式 mip 级别或 mip 级别 0 对纹理进行采样。

```rust
textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32, offset: vec2<i32>) -> vec4<f32>
textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, level: f32, offset: vec2<i32>) -> vec4<f32>
textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32, offset: vec3<i32>) -> vec4<f32>
textureSampleLevel(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32, level: f32) -> vec4<f32>
textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: i32) -> f32
textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: i32, offset: vec2<i32>) -> f32
textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, level: i32) -> f32
textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, level: i32, offset: vec2<i32>) -> f32
textureSampleLevel(t: texture_depth_cube, s: sampler, coords: vec3<f32>, level: i32) -> f32
textureSampleLevel(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: i32, level: i32) -> f32
textureSampleLevel(t: texture_external, s: sampler, coords: vec2<f32>) -> vec4<f32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  要采样的 [sampled](#sampled-texture-type) 或 [depth](#texture-depth) 纹理。
  <tr><td>`s`<td>
  [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  要采样的基于 0 的纹理数组索引。
  <tr><td>`level`<td>
  mip 级别，级别 0 包含纹理的全尺寸版本。
  对于 `level` 是 `f32` 的函数，如果格式是可过滤的，则可以在两个级别之间插入小数值根据
  [Texture Format Capabilities](https://gpuweb.github.io/gpuweb/#texture-format-caps)。<br>
  如果未指定，则对 mip 级别 0 进行采样。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  `offset` 表达式必须是一个 `const_expression` 表达式（例如 `vec2<i32>(1, 2)`）。<br>
  每个 `offset` 组件必须至少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

采样值。


### `textureStore` ### {#texturestore}

将单个纹素写入纹理。

```rust
textureStore(t: texture_storage_1d<F,write>, coords: i32, value: vec4<T>)
textureStore(t: texture_storage_2d<F,write>, coords: vec2<i32>, value: vec4<T>)
textureStore(t: texture_storage_2d_array<F,write>, coords: vec2<i32>, array_index: i32, value: vec4<T>)
textureStore(t: texture_storage_3d<F,write>, coords: vec3<i32>, value: vec4<T>)
```

通道格式“T”取决于存储纹素格式“F”。
【查看texel格式表】(#storage-texel-formats) 有关texel格式到通道格式的映射。

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [write-only storage texture](#texture-storage).
  <tr><td>`coords`<td>
  基于 0 的纹素坐标。<br>
  <tr><td>`array_index`<td>
  从 0 开始的纹理数组索引。
  <tr><td>`value`<td>
  新的纹素值。<br>
</table>

**注意:**

如果出现以下情况，则会发生越界访问：
* `coords` 的任何元素都在相应元素的 `[0, textureDimensions(t))` 范围之外，或者
* `array_index` 超出了 `[0, textureNumLayers(t))` 的范围

如果发生越界访问，内置函数可以执行以下任一操作：
* 不被执行
* 将 `value` 存储到一些边界 texel

**TODO:**

<pre class='def'>
TODO(dsinclair): Need gather operations
</pre>

## 原子内置函数 ## {#atomic-builtin-functions}

原子内置函数可用于 读/写/读-修改-写 原子
对象。 它们是 [[#atomic-types]] 上唯一允许的操作。

所有原子内置函数都使用“宽松”内存排序（SPIR-V 中所有“内存语义”操作数的 **0** 值整数常量）。
这意味着同步和排序保证仅适用于原子
作用于相同 [= memory locations =] 的操作。
原子和非原子内存访问之间或作用于不同内存位置的原子访问之间没有同步或排序保证。

原子内置函数“不得”用在 [=vertex=] 着色器阶段。

所有原子内置函数 `atomic_ptr` 参数的存储类 `SC` 必须是[=storage classes/storage=]或[=storage classes/workgroup=]。
[=storage classes/workgroup=] 原子在 SPIR-V 中具有 **Workgroup** 内存范围，而 [=storage classes/storage=] 原子在
SPIR-V 中具有 **Device** 内存范围。

所有原子内置函数中的访问模式 `A` 必须是[=access/read_write=]。

TODO: 添加指向最终内存模型描述的链接。

### 原子负载 ### {#atomic-load}

```rust
atomicLoad(atomic_ptr: ptr<SC, atomic<T>, A>) -> T

// Maps to the SPIR-V instruction OpAtomicLoad.
```

返回原子加载的 `atomic_ptr` 指向的值。
它不原子修改|修改 [=atomic modification|modify=] 对象。

### 原子商店 ### {#atomic-store}

```rust
atomicStore(atomic_ptr: ptr<SC, atomic<T>, A>, v: T)

// Maps to the SPIR-V instruction OpAtomicStore.
```

以原子方式将值 `v` 存储在 `atomic_ptr` 指向的原子对象中。
### 原子 读-修改-写### {#atomic-rmw}

```rust
atomicAdd(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicSub(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicMax(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicMin(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicAnd(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicOr(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
atomicXor(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T

// Mappings to SPIR-V instructions:
// atomicAdd -> OpAtomicIAdd
// atomicSub -> OpAtomicISub
// atomicMax -> OpAtomicSMax or OpAtomicUMax (depending on the signedness of T)
// atomicMin -> OpAtomicSMin or OpAtomicUMin (depending on the signedness of T)
// atomicAnd -> OpAtomicAnd
// atomicOr  -> OpAtomicOr
// atomicXor -> OpAtomicXor
```
每个函数原子地执行以下步骤：

1.加载 `atomic_ptr` 指向的原始值。
2. 通过对函数名称执行操作（例如 max）来获得一个新值，其值为 |v|。
3. 使用 `atomic_ptr` 存储新值。

每个函数返回存储在原子对象中的原始值。

```rust
atomicExchange(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T

// Maps to the SPIR-V instruction OpAtomicExchange.
```

以原子方式将值 `v` 存储在指向 `atomic_ptr` 的原子对象中，并返回存储在原子对象中的原始值。

```rust
atomicCompareExchangeWeak(atomic_ptr: ptr<SC, atomic<T>, A>, cmp: T, v: T) -> __atomic_compare_exchange_result<T>

struct __atomic_compare_exchange_result<T> {
  old_value : T; // old value stored in the atomic
  exchanged : bool; // true if the exchange was done
};

// Maps to the SPIR-V instruction OpAtomicCompareExchange.
```

注意：不能使用类型 `__compare_exchange_result` 显式声明值，但值可以推断类型。

以原子方式执行以下步骤：

1. 加载 `atomic_ptr` 指向的原始值。
2. 使用相等运算将原始值与值 `v` 进行比较。
3. 仅当相等比较的结果为 **true** 时才存储值 `v`。

返回一个双元素向量，其中第一个元素是原子对象的原始值，第二个元素是比较是否成功（**1**如果成功，否则为**0**）。

注意：在某些实现中，相等比较可能会失败。 也就是说，即使结果向量的第一个元素等于 `cmp`，结果向量的第二个元素也可能是 **0**。

## 数据打包内置函数 ## {#pack-builtin-functions}

数据打包内置函数可用于使用与 [SHORTNAME] 中的类型不直接对应的数据格式对值进行编码。
这使程序能够将许多密集打包的值写入内存，从而减少着色器的内存带宽需求。

<table class='data'>
  <thead>
    <tr><td>结论<td>解释
  </thead>
  <tr algorithm="packing 4x8snorm">
    <td class="nowrap">`pack4x8snorm`(|e|: vec4&lt;f32&gt;) -> u32
    <td>将四个标准化浮点值转换为 8 位有符号整数，然后将它们组合成一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 8 位二进制补码整数值 &lfloor; 0.5 + 127 × min(1, max(-1, |e|[|i|])) &rfloor;
        然后放置在位 8 &times; |i| 通过 8 &times; |i| + 7 结果。

  <tr algorithm="packing 4x8unorm">
    <td class="nowrap">`pack4x8unorm`(|e|: vec4&lt;f32&gt;) -> u32
    <td>将四个标准化的浮点值转换为 8 位无符号整数，然后将它们组合成一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 8 位无符号整数值 &lfloor; 0.5 + 255 × min(1, max(0, |e|[|i|])) &rfloor;
        然后放置在位 8 &times; |i| 通过 8 &times; |i| + 7 结果。

  <tr algorithm="packing 2x16snorm">
    <td class="nowrap">`pack2x16snorm`(|e|: vec2&lt;f32&gt;) -> u32
    <td>将两个标准化浮点值转换为 16 位有符号整数，然后将它们组合成一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 16 位二进制补码整数值 &lfloor; 0.5 + 32767 × min(1, max(-1, |e|[|i|])) &rfloor;
        然后放置在位 16 &times; |i| 通过 16 &times; |i| + 15 结果。

  <tr algorithm="packing 2x16unorm">
    <td class="nowrap">`pack2x16unorm`(|e|: vec2&lt;f32&gt;) -> u32
    <td>将两个标准化浮点值转换为 16 位无符号整数，然后将它们组合成一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 16 位无符号整数值 &lfloor; 0.5 + 65535 × min(1, max(0, |e|[|i|])) &rfloor;
        然后放置在位 16 &times; |i| 通过 16 &times; |i| + 15 结果。

  <tr algorithm="packing 2x16float">
    <td class="nowrap">`pack2x16float`(|e|: vec2&lt;f32&gt;) -> u32
    <td>将两个浮点值转换为半精度浮点数，然后将它们合并为一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 [[!IEEE-754|IEEE-754]] binary16 值，然后将其放置在位 16 × |i| 通过 16 &times; |i| + 15 结果。
        查看 [[#floating-point-conversion]].
</table>

## 数据解包内置函数 ## {#unpack-builtin-functions}

数据解包内置函数可用于解码与 [SHORTNAME] 中的类型不直接对应的数据格式中的值。
这使程序能够从内存中读取许多密集打包的值，从而减少着色器的内存带宽需求。

<table class='data'>
  <thead>
    <tr><td>结论<td>解释
  </thead>
  <tr algorithm="unpacking 4x8snorm">
    <td class="nowrap">`unpack4x8snorm`(|e|: u32) -> vec4&lt;f32&gt;
    <td>将 32 位值分解为四个 8 位块，然后将每个块重新解释为有符号的标准化浮点值。<br>
        组件 |i| 结果的最大值是 max(|v| &div; 127, -1)，其中 |v| 是位 8&times;|i| 的解释 通过 8&times;|i|+7 的 |e| 作为二进制补码的有符号整数。

  <tr algorithm="unpacking 4x8unorm">
    <td class="nowrap">`unpack4x8unorm`(|e|: u32) -> vec4&lt;f32&gt;
    <td>将 32 位值分解为四个 8 位块，然后将每个块重新解释为无符号标准化浮点值。<br>
        组件 |i| 结果是|v| &div; 255，其中|v| 是位 8&times;|i| 的解释 通过 8&times;|i|+7 的 |e| 作为无符号整数。

  <tr algorithm="unpacking 2x16snorm">
    <td class="nowrap">`unpack2x16snorm`(|e|: u32) -> vec2&lt;f32&gt;
    <td>将 32 位值分解为两个 16 位块，然后将每个块重新解释为有符号的标准化浮点值。<br>
        组件 |i| 结果的最大值是 max(|v| &div; 32767, -1)，
        其中 |v| 是位 16&times;|i| 的解释 通过 |e| 的 16&times;|i|+15 作为二进制补码的有符号整数。

  <tr algorithm="unpacking 2x16unorm">
    <td class="nowrap">`unpack2x16unorm`(|e|: u32) -> vec2&lt;f32&gt;
    <td>将 32 位值分解为两个 16 位块，然后将每个块重新解释为无符号标准化浮点值。<br>
        组件 |i| 结果是|v| &div; 65535，其中|v| 是位 16&times;|i| 的解释 通过 |e| 的 16&times;|i|+15 作为无符号整数。

  <tr algorithm="unpacking 2x16float">
    <td class="nowrap">`unpack2x16float`(|e|: u32) -> vec2&lt;f32&gt;
    <td>将 32 位值分解为两个 16 位块，并将每个块重新解释为浮点值。<br>
        组件 |i| 结果的 f32 表示 |v|，其中 |v| 是位 16&times;|i| 的解释
        通过 |e| 的 16&times;|i|+15 作为 [[!IEEE-754|IEEE-754]] binary16 值。
        查看 [[#floating-point-conversion]]。
</table>

## 同步内置函数 ## {#sync-builtin-functions}

[SHORTNAME] 提供以下同步函数:

```rust
fn storageBarrier()
fn workgroupBarrier()
```

所有同步函数都执行一个带有获取/释放内存排序的控制屏障。 也就是说，
所有同步函数以及受影响的内存和原子操作都在 [[#program-order]] 中相对于同步函数进行排序。
此外，在同步函数由工作组成员执行之后，在任何受影响的内存或原子操作程序排序之前，同步函数之前受影响的内存和原子操作必须对工作组中的所有其他线程可见。
所有同步函数只能在 [=compute=] 着色器阶段使用。

storageBarrier 影响 [=storage classes/storage=] 存储类中的内存和原子操作。

workgroupBarrier 影响 [=storage classes/workgroup=] 存储类中的内存和原子操作。

TODO: 添加指向最终内存模型的链接。

<div class='example spirv barrier mapping' heading="Mapping workgroupBarrier to SPIR-V">
  <xmp>
    storageBarrier();
    // Maps to:
    // Execution Scope is Workgroup = %uint_2
    // Memory Scope is Device = %uint_1
    // Memory Semantics are AcquireRelease | UniformMemory (0x8 | 0x40) = %uint_72
    // OpControlBarrier %uint_2 %uint_1 %uint_72

    workgroupBarrier();
    // Maps to:
    // Execution and Memory Scope are Workgroup = %uint_2
    // Memory semantics are AcquireRelease | WorkgroupMemory (0x8 | 0x100) = %uint_264
    // OpControlBarrier %uint_2 %uint_2 %uint_264

    workgroupBarrier();
    storageBarrier();
    // Or, equivalently:
    storageBarrier();
    workgroupBarrier();
    // Could be mapped to a single OpControlBarrier:
    // Execution scope is Workgroup = %uint_2
    // Memory Scope is Device = %uint_1
    // Memory semantics are AcquireRelease | UniformMemory | WorkgroupMemory
    //   (0x8 | 0x40 | 0x100) = %uint_328
    // OpControlBarrier %uint_2 %uint_1 %uint_328
  </xmp>
</div>


# MATERIAL TO BE MOVED TO A NEW HOME OR DELETED # {#junkyard}


[SHORTNAME] has operations for:

* creating a new composite value from an old one by replacing one of its components
