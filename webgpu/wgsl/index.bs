<pre class='metadata'>
Title: WebGPU Shading Language
Shortname: WGSL
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/wgsl/
TR: https://www.w3.org/TR/WGSL/
Repository: gpuweb/gpuweb
Text Macro: INT i32 or u32
Text Macro: UNSIGNEDINTEGRAL u32 or vecN&lt;u32&gt;
Text Macro: SIGNEDINTEGRAL i32 or vecN&lt;i32&gt;
Text Macro: ALLSIGNEDINTEGRAL AbstractInt, i32, vecN&lt;AbstractInt&gt;, or vecN&lt;i32&gt;
Text Macro: INTEGRAL i32, u32, vecN&lt;i32&gt;, or vecN&lt;u32&gt;
Text Macro: FLOATING f32, f16, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
Text Macro: NUMERIC i32, u32, f32, f16, vecN&lt;i32&gt;, vecN&lt;u32&gt;, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
Text Macro: FLOATSCALAR [=AbstractFloat=], [=f16=], or [=f32=]
Text Macro: ALLINTEGRALDECL S is AbstractInt, i32, or u32<br>T is S or vecN&lt;S&gt;
Text Macro: ALLFLOATINGDECL S is AbstractFloat, f32, or f16<br>T is S or vecN&lt;S&gt;
Text Macro: ALLNUMERICDECL S is AbstractInt, AbstractFloat, i32, u32, f32, or f16<br>T is S, or vecN&lt;S&gt;
Text Macro: ALLSIGNEDNUMERICDECL S is AbstractInt, AbstractFloat, i32, f32, or f16<br>T is S, or vecN&lt;S&gt;
Ignored Vars: i, c0, e, e1, e2, e3, edge, eN, p, s1, s2, sn, AS, AM, N, newbits, M, C, R, v, Stride, Offset, Align, Extent, T, T1

!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new?labels=wgsl">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues?q=is%3Aissue+is%3Aopen+label%3Awgsl">open issues</a>)
!Tests: <a href=https://github.com/gpuweb/cts/tree/main/src/webgpu/shader/>WebGPU CTS shader/</a>

Editor: Alan Baker, Google https://www.google.com, alanbaker@google.com, w3cid 129277
Editor: Mehmet Oguz Derin, mehmetoguzderin@mehmetoguzderin.com, w3cid 101130
Editor: David Neto, Google https://www.google.com, dneto@google.com, w3cid 99785
Former Editor: Myles C. Maxfield, Apple Inc., mmaxfield@apple.com, w3cid 77180
Former Editor: dan sinclair, Google https://www.google.com, dsinclair@google.com, w3cid 107549
Abstract: Shading language for WebGPU.
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
</pre>

<style>
tr:nth-child(2n) {
  background-color: #b0b0b050;
}
thead {
  background-color: #b0b0b050;
  font-weight: bold;
}
.nowrap {
  white-space:nowrap;
}
.small {
  font-size: smaller;
}
div.syntax {
  display: block;
  page-break-before: avoid;
  padding: .5em 1em;
  background: var(--def-bg);
  border-left: 0.5em solid var(--def-border);
  color: var(--def-text);
  margin-block-start: 1em;
  margin-block-end: 1em;
}
div.syntax > p {
  color: var(--text);
  font-weight: 100;
  margin: 0;
}
div.syntax > p > .choice {
  display: inline-block;
  width: 1em;
  text-align: center;
}
div.syntax > p > a {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  font-style: italic;
  font-weight: normal;
  color: var(--text);
}
div.syntax > p > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
div.syntax > p > a > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
[data-dfn-for="syntax"] {
  font-style: italic;
  font-weight: normal;
  color: var(--text);
}
[data-dfn-for="syntax_kw"] {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
[data-dfn-for="syntax_sym"] {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
.hidden {
  display: none
}
table.data.builtin tbody{
  border-bottom: 0;
}
table.builtin {
  border-bottom: 2px solid grey;
}
table.builtin tr:nth-child(2n) {
    background-color: #00000000;
}
table.builtin td {
    vertical-align: top;
}
/* Our SVGs aren't responsive to light/dark mode, so they're opaque with a
 * white or black background. Rounded corners make them a bit less jarring. */
object[type="image/svg+xml"] {
    border-radius: .5em;
}
</style>

<pre class=biblio>
{
  "WebGPU": {
    "authors": [
      "Kai Ninomiya",
      "Brandon Jones",
      "Myles C. Maxfield"
    ],
    "href": "https://w3.org/TR/webgpu",
    "title": "WebGPU",
    "status": "Working Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "WGSL": {
    "authors": [
      "Alan Baker",
      "Mehmet Oguz Derin",
      "David Neto"
    ],
    "href": "https://www.w3.org/TR/WGSL/",
    "title": "WebGPU Shading Language",
    "status": "Working Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "IEEE-754":{
    "href":"http://ieeexplore.ieee.org/servlet/opac?punumber=4610933",
    "title":"IEEE Standard for Floating-Point Arithmetic",
    "publisher":"Institute of Electrical and Electronics Engineers",
    "isbn":"978-0-7381-5752-8",
    "versions":["IEEE-754-2008","IEEE-754-1985"],
    "id":"IEEE-754",
    "date":"29 August 2008"
  },
  "VulkanMemoryModel": {
    "authors": [
      "Jeff Bolz",
      "Alan Baker",
      "Tobias Hector",
      "David Neto",
      "Robert Simpson",
      "Brian Sumner"
    ],
    "href": "https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model",
    "title": "Vulkan Memory Model",
    "publisher": "Khronos Group"
  },
  "UnicodeVersion14": {
    "href":"http://www.unicode.org/versions/Unicode14.0.0/",
    "author":"The Unicode Consortium",
    "title":"The Unicode Standard, Version 14.0.0",
    "isbn":"978-1-936213-29-0",
    "id":"UnicodeVersion14"
  },
  "DeRemer1969": {
    "href":"http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-065.pdf",
    "author":"F. L. DeRemer",
    "publisher":"Massachusetts Institute of Technology",
    "date":"24 October 1969",
    "title":"Practical Translators for LR(k) Languages"
  },
  "Muller2005": {
    "title":"On the definition of ulp(x)",
    "href":"https://inria.hal.science/inria-00070503",
    "source":"[Research Report] RR-5504, LIP RR-2005-09, INRIA, LIP",
    "author":"Jean-Michel Muller",
    "publisher":"INRIA",
    "date":"February 2005",
    "rawDate": "2005-02"
  },
  "Jeannerod2013": {
    "href":"https://www.ams.org/journals/mcom/2013-82-284/S0025-5718-2013-02679-8/S0025-5718-2013-02679-8.pdf",
    "title":"Further Analysis of Kahan's Algorithm for the Accurate Computation of 2x2 Determinants",
    "authors": [
      "Claude-Pierre Jeannerod",
      "Nicolas Louvet",
      "Jean-Michel Muller"
    ],
    "publisher": "American Mathematical Society",
    "rawDate":"2013-10",
    "pages": "2245-2264"
  },
  "VanWyk2007": {
    "href":"https://dl.acm.org/doi/10.1145/1289971.1289983",
    "title":"Context-Aware Scanning for Parsing Extensible Languages",
    "authors": [
      "Eric R. Van Wyk",
      "August C. Schwerdfeger"
    ],
    "publisher":"Association for Computing Machinery",
    "series":"GCPE'07",
    "date":"2007"
  }
}
</pre>

<pre class='anchors'>
spec: Vulkan ; urlPrefix: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#
    type: dfn
        text: memory model memory operation; url: memory-model-memory-operation
        text: memory model reference; url: memory-model-references
        text: memory model atomic operation; url: memory-model-atomic-operation
        text: memory model scope; url:memory-model-scope
        text: memory model memory semantics; url:memory-model-memory-semantics
        text: memory model non-private; url: memory-model-non-private
spec: UAX14; urlPrefix: https://www.unicode.org/reports/tr14
    type: dfn
        text: UAX14 Section 6.1 Non-tailorable Line Breaking Rules; url: BreakingRules
        text: UAX14 LB4; url: LB4
        text: UAX14 LB5; url: LB5
spec: UAX31; urlPrefix: https://www.unicode.org/reports/tr31/tr31-35.html
    type: dfn
        text: Unicode Standard Annex #31 for Unicode Version 14.0.0
        text: UAX31 Lexical Classes; url: Table_Lexical_Classes_for_Identifiers
        text: UAX31 Grammar; url: D1
spec: Unicode Character Database for Unicode Version 14.0.0; urlPrefix: https://www.unicode.org/Public/14.0.0/ucd/DerivedCoreProperties.txt
    type: dfn
        text: Unicode Character Database for Unicode Version 14.0.0
spec: UnicodeVersion14; urlPrefix: https://www.unicode.org/versions/Unicode14.0.0/UnicodeStandard-14.0.pdf
    type: dfn
        text: code point; url:
spec: WebGPU; urlPrefix: https://gpuweb.github.io/gpuweb/#
    type: dfn
        text: GPU command; url: gpu-command
        text: RasterizationPoint; url: rasterizationpoint
        text: effective buffer binding size; url: abstract-opdef-effective-buffer-binding-size
        text: binding member; url: binding-member
        text: binding resource type; url: binding-resource-type
        text: binding type; url: binding-type
        text: GPU error scope; url: gpu-error-scope
        text: front-facing; url: front-facing
        text: shader-output mask; url: shader-output-mask
        text: framebuffer; url: framebuffer
        text: normalized device coordinates; url: ndc
        text: clip space coordinates; url: clip-space-coordinates
        text: clip position; url: clip-position
        text: viewport; url: dom-renderstate-viewport-slot
        text: rasterizationpoint-destination; url: rasterizationpoint-destination
        text: rasterizationpoint-depth; url: rasterizationpoint-depth
        text: rasterizationpoint-perspectivedivisor; url: rasterizationpoint-perspectivedivisor
        text: fragmentdestination-position; url: fragmentdestination-position
        for: supported limits
            text: maxComputeWorkgroupStorageSize; url: dom-supported-limits-maxcomputeworkgroupstoragesize
    type: attribute
        for: GPU
            text: wgslLanguageFeatures; url: gpuwgsllanguagefeatures
    type: abstract-op
        text: validating GPUProgrammableStage; url: abstract-opdef-validating-gpuprogrammablestage
    type: enum-value
        for: GPUStorageTextureAccess
            text: read-only; url: dom-gpustoragetextureaccess-read-only
            text: read-write; url: dom-gpustoragetextureaccess-read-write
</pre>

# 介绍 # {#intro}

WebGPU着色语言（WGSL）是[[!WebGPU]]的着色语言。换句话说，使用WebGPU API的应用程序使用WGSL来表达在GPU上运行的程序，也称为着色器。

<div class='example wgsl global-scope'>
  <xmp>
    // A fragment shader which lights textured geometry with point lights.

    // Lights from a storage buffer binding.
    struct PointLight {
      position : vec3f,
      color : vec3f,
    }

    struct LightStorage {
      pointCount : u32,
      point : array<PointLight>,
    }
    @group(0) @binding(0) var<storage> lights : LightStorage;

    // Texture and sampler.
    @group(1) @binding(0) var baseColorSampler : sampler;
    @group(1) @binding(1) var baseColorTexture : texture_2d<f32>;

    // Function arguments are values from the vertex shader.
    @fragment
    fn fragmentMain(@location(0) worldPos : vec3f,
                    @location(1) normal : vec3f,
                    @location(2) uv : vec2f) -> @location(0) vec4f {
      // Sample the base color of the surface from a texture.
      let baseColor = textureSample(baseColorTexture, baseColorSampler, uv);

      let N = normalize(normal);
      var surfaceColor = vec3f(0);

      // Loop over the scene point lights.
      for (var i = 0u; i < lights.pointCount; i++) {
        let worldToLight = lights.point[i].position - worldPos;
        let dist = length(worldToLight);
        let dir = normalize(worldToLight);

        // Determine the contribution of this light to the surface color.
        let radiance = lights.point[i].color * (1 / pow(dist, 2));
        let nDotL = max(dot(N, dir), 0);

        // Accumulate light contribution to the surface color.
        surfaceColor += baseColor.rgb * radiance * nDotL;
      }

      // Return the accumulated surface color.
      return vec4(surfaceColor, baseColor.a);
    }
  </xmp>
</div>

## 总览 ## {#overview}

WebGPU通过GPU命令将工作单元发送到GPU中。WGSL关注两种类型的GPU命令：

  * 一个draw command在着色器阶段输入、着色器阶段输出和附加资源的上下文中执行render pipeline。
  * 一个dispatch command在着色器阶段输入和附加资源的上下文中执行compute pipeline。

这两种类型的管线都使用WGSL编写的着色器。


一个shader是WGSL程序中执行管线中的着色器阶段的部分。
一个着色器由以下部分组成：

  * 一个入口函数。
  * 从入口函数开始的所有被调用函数的传递闭包。 这个集合包括用户定义函数和内置函数。(更严格的定义请参见"着色器阶段中的函数"。)
  * 所有这些函数静态访问的变量和常量集合。
  * 用于定义或分析所有这些函数、变量和常量的类型集合。

注意：一个WGSL程序不需要入口函数；然而，API无法执行这样的程序，因为创建GPUProgrammableStage需要入口函数。

执行着色器阶段时，实现的操作：
* 计算在模块范围声明的常量的值。
* 将资源绑定到着色器的资源接口中的变量，使得这些资源的内容在执行期间对着色器可用。
* 为其他模块范围变量分配内存，并使用指定的初始值填充该内存。
* 如果存在，将入口点的形式参数与着色器阶段的输入连接。
* 将入口点的返回值（如果存在）连接到着色器阶段的输出。
* 然后调用入口点。

一个WGSL程序的组织结构包括：

* 指令，用于指定模块级别的行为控制。
* 函数，用于指定执行行为。
* 语句，即声明或可执行行为的单元。
* 文字字面量，用于表示纯数学值的文本表示。
* 常量，为每个特定时间计算的值提供一个名称。
* 变量，为存储值的内存提供一个名称。
* 表达式，每个表达式组合一组值以产生一个结果值。
* 类型，每个类型描述：
    * 一组值。
    * 支持的表达式的约束。
    * 这些表达式的语义。
* 属性，用于修改对象以指定额外信息，例如：
    * 指定接口与入口点。
    * 指定诊断过滤器。

注意：目前，WGSL程序由单个WGSL模块组成。

WGSL是一种命令式语言：行为被指定为要执行的一系列语句。
语句可以：

* 声明[[#value-decls|常量]]或[[#var-decls|变量]]。
* 修改变量的内容。
* 使用结构化编程结构修改执行顺序：
    * 有选择性的执行：[[#if-statement|if]]（可选的else if和else子句），[[#switch-statement|switch]]。
    * 循环执行：[[#loop-statement|loop]]，[[#while-statement|while]]，[[#for-statement|for]]。
    * 退出嵌套的执行结构：[[#continue-statement|continue]]，[[#break-statement|break]]，[[#break-if-statement|break if]]。
    * 重构：[[#function-calls|函数调用]]和[[#return-statement|return]]。
* 评估表达式以计算上述行为的值。
* 在[=shader模块创建|shader creation=]时间使用[=const-expression|常量表达式=]检查[[#const-assert-statement|假设]]。

WGSL是静态类型的：特定表达式计算的每个值都有一个特定类型，只能通过检查程序源代码来确定。

WGSL具有描述布尔值和数字（整数和浮点数）的类型。
这些类型可以组合成复合类型（向量、矩阵、数组和结构体）。
WGSL具有特殊类型（例如原子类型），提供独特的操作。
WGSL描述了可以存储在内存中的类型，称为内存视图。
WGSL以纹理和采样器的形式提供常用的渲染类型。
这些类型有相关的内置函数，用于暴露常见的用于图形渲染的GPU硬件。


WGSL不支持从具体类型自动进行隐式转换或提升，但可以从抽象类型进行隐式转换和提升。
将一个值从一个具体的数值或布尔类型转换为另一个类型需要显式的转换、值构造函数或位的重新解释。
然而，WGSL确实提供了一些有限的方法来将标量类型提升为向量类型。
这同样适用于复合类型。

着色器阶段的工作被划分为一个或多个<dfn noexport>调用</dfn>，每个调用在稍微不同的条件下执行入口点。
着色器阶段中的调用共享某些变量的访问权限：

* 阶段中的所有调用共享着色器接口中的资源。
* 在计算着色器阶段中，同一个计算着色器阶段/工作组中的调用共享地址空间/工作组（address spaces/workgroup）中的变量。不同工作组中的调用不共享这些变量。

然而，调用作用于不同的着色器阶段输入集，包括提供标识值以区分调用与其同行的内建输入。
每个调用都有自己独立的内存空间，即在地址空间/私有（address spaces/private）和地址空间/函数（address spaces/function）中的变量。


在着色器阶段内部，调用并发执行，并且通常可以并行执行。
着色器作者负责确保着色器阶段中调用的动态行为：


满足某些原始操作（包括纹理采样和控制栅栏）的[[#uniformity|一致性]]要求。
协调对共享变量的潜在冲突访问，以避免数据竞争。

在某些情况下，WGSL允许多种可能的行为。
这是一个可移植性风险，因为不同的实现可能表现出不同的行为。
WGSL的设计旨在尽量减少这种情况，但受到可行性和在广泛设备范围内实现高性能的目标的限制。


<dfn noexport>行为要求</dfn>是实现处理或执行WGSL程序时执行的操作。它们描述了实现与程序员的合同中的义务。当这些义务可能不明显时，规范会明确说明这些义务。

## 语法符号表示法 ## {#syntax-notation}

以下语法符号表示WGSL的语法规则约定：

* 在规则两侧的斜体文本表示语法规则。
* 在规则右侧以单引号（'）开始和结束的粗体等宽文本表示关键字和令牌。
* 正常文本中的冒号（:）注册一个语法规则。
* 正常文本中的竖线（|）表示多个可选项。
* 正常文本中的问号（?）表示前一个关键字、令牌、规则或组出现零次或一次（可选）。
* 正常文本中的星号（*）表示前一个关键字、令牌、规则或组出现零次或多次。
* 正常文本中的加号（+）表示前一个关键字、令牌、规则或组出现一次或多次。
* 正常文本中的配对的括号（( 和 )）表示一组元素。

## 数学术语和符号 ## {#terms-and-notation}

<dfn noexport>Angles</dfn>:
* 按照惯例，角度用弧度来表示。
* 测量角度的参考射线是从原点(0,0)指向(+∞,0)的射线。
* 设θ为比较射线和参考射线所对应的角度。那么当比较射线逆时针移动时，θ增加。
* 一个完整的圆周有2π弧度。
* 例子：
    * 角度0从原点指向右边，即指向(1,0)
    * 角度2π从原点指向右边，即指向(1,0)
    * 角度π/4从原点指向(1,1)点
    * 角度π/2从原点指向(0,1)点
    * 角度π从原点指向(-1,0)点
    * 角度(3/2)π从原点指向(0,-1)点

一个间隔是一个有下界和上界的连续数集。
根据上下文，它们可以是整数、浮点数或实数集合。

* 闭区间[a, b]是一组数字x，使得a ≤ x ≤ b。
* 半开区间[a, b)是一组数字x，使得a ≤ x < b。
* 半开区间(a, b]是一组数字x，使得a < x ≤ b。

地板函数是定义在实数 |x| 扩展为正无穷和负无穷的范围内的：

* ⌊ + ∞ ⌋ = +∞
* ⌊ − ∞ ⌋ = −∞
* 对于实数 |x|，⌊|x|⌋ = |k|，其中 |k| 是满足 |k| ≤ |x| < |k|+1 的唯一整数

天花板函数是定义在实数 |x| 扩展为正无穷和负无穷的范围内的：

* ⌈ +∞ ⌉ = +∞
* ⌈ −∞ ⌉ = −∞
* 对于实数 |x|，⌈|x|⌉ = |k|，其中 |k| 是满足 |k|-1 < |x| ≤ |k| 的唯一整数

截断函数是定义在实数 |x| 扩展为正无穷和负无穷的范围内的：

* truncate(+∞) = +∞
* truncate(−∞) = −∞
* 对于实数 |x|，计算绝对值小于或等于 |x| 的最近整数：
    * 如果 |x| ≥ 0，则 truncate(|x|) = ⌊|x|⌋，否则为 ⌈|x|⌉

向上取整函数对于正整数 |k| 和 |n| 定义如下：

* roundUp(|k|, |n|) = ⌈|n| ÷ |k|⌉ × |k|

一个 |c| 列 |r| 行矩阵 |A| 的转置是通过将 |A| 的行复制为 |A|<sup>T</sup> 的列来形成的 |r| 列 |c| 行矩阵：

* transpose(|A|) = |A|<sup>T</sup>
* transpose(|A|)<sub>|i|,|j|</sub> = |A|<sub>|j|,|i|</sub>

列向量的转置是通过将列向量解释为一个 1 行矩阵来定义的。类似地，行向量的转置是通过将行向量解释为一个 1 列矩阵来定义的。

# WGSL 模块 # {#wgsl-module}

一个WGSL程序由一个单独的WGSL模块组成。

一个模块是一个可选指令序列，后面跟着模块作用域声明和const_assert语句。
一个模块按以下方式组织：

* 指令，用于指定模块级别的行为控制。
* 函数，用于指定执行行为。
* 表达式，包括声明或可执行行为的单元。
* 文字量，是纯数学值的文本表示。
* 变量，每个变量提供一个存储值的名称。
* 常量，每个常量提供一个在特定时间计算的值的名称。
* 表达式，每个表达式将一组值组合在一起产生一个结果值。
* 类型，每个类型描述：
    * 一组值。
    * 支持表达式的限制。
    * 表达式的语义。
* 属性，用于修改对象以指定额外的信息，例如：
    * 指定接口到入口点的接口。
    * 指定诊断过滤器。

<pre class=include>
path: syntax/translation_unit.syntax.bs.include
</pre>

<pre class=include>
path: syntax/global_decl.syntax.bs.include
</pre>

## 着色器生命周期 ## {#shader-lifecycle}

一个WGSL程序和它可能包含的着色器的生命周期中有四个关键事件。
前两个对应于用于准备执行WGSL程序的WebGPU API方法。
最后两个是着色器执行的开始和结束。


这些事件包括：

1. <dfn noexport>着色器模块创建</dfn>
    * 当调用WebGPU的{{GPUDevice/createShaderModule()}}方法时发生。 此时提供了WGSL程序的源文本。
2. <dfn noexport>管线创建</dfn>
    * 当调用WebGPU的{{GPUDevice/createComputePipeline()}}方法或{{GPUDevice/createRenderPipeline()}}方法时发生。 这些方法使用一个或多个先前创建的着色器模块，以及其他配置信息。
3. <dfn noexport>着色器执行开始</dfn>
    * 当向GPU发出绘制命令或调度命令时发生， 着色器开始执行指定的管线， 并调用着色器阶段的入口点函数。
4. <dfn noexport>着色器执行结束</dfn>
    * 当着色器中的所有工作完成时发生：
        * 所有执行终止，
        * 所有对资源的访问完成，
        * 如果有输出，将传递给下游管线阶段。

事件的排序是基于以下原因：

* 数据依赖性：着色器执行需要流水线，而流水线需要着色器模块。
* 因果关系：着色器必须在完成执行前开始执行。

## 错误 ## {#errors}

WebGPU 实现可能由于两个原因无法处理着色器：

* 如果着色器不满足 WGSL 或 WebGPU 规范的要求，则会出现 <dfn export>程序错误</dfn>。
* 即使满足了所有 WGSL 和 WebGPU 的要求，也可能出现 <dfn noexport>未分类错误</dfn>。 可能的原因包括：
    * 着色器过于复杂，超出了实现的能力，但无法轻松捕捉到预定的[[#limits |limits]]。简化着色器可能可以解决此问题。
    * WebGPU 实现中的缺陷。

着色器的生命周期中可能会发生处理错误的三个阶段：

* <dfn export>着色器创建错误</dfn> 是在[=着色器模块创建=]过程中可能检测到的错误。 检测仅依赖于 WGSL 模块源文本和可用于 createShaderModule API 方法的其他信息。 如果程序违反了规范中描述的必须进行的某些操作，则通常会产生着色器创建错误。

* <dfn export>管线创建错误</dfn> 是在[=管线创建=]过程中可能检测到的错误。 检测依赖于 WGSL 模块源文本和可用于特定管线创建 API 方法的其他信息。

* <dfn export>动态错误</dfn>是在着色器执行过程中发生的错误。 这些错误可能可检测，也可能不可检测。


注意：例如，数据竞争可能无法检测到。


每个要求的[=行为要求|行为=]将在最早的机会进行检查。
也就是说：

* 如果在着色器创建时未满足可在着色器创建时检测到的要求，则会导致着色器创建错误。
* 如果在管线创建时未满足可在管线创建时检测到的要求，则会导致管线创建错误，但不会在此之前检测到。

在上下文不清楚的情况下，该规范会指出
未满足特定要求的结果是着色器创建错误、管线创建错误还是动态错误。

错误的后果如下：

* 具有[=着色器创建错误=]或[=管线创建错误=]错误的 WGSL 模块将不会合并到[=管线=]中，因此不会被执行。
* 可检测到的错误[=行为要求|将=]会触发[=诊断=]。
* 如果发生[=动态错误=]：
    * [=内存访问=]只能限制为：
        * [=着色器阶段输入=]，
        * [=着色器阶段输出=]，
        * 绑定到 WGSL 模块变量的[=资源=]的任何部分以及
        * 在 WGSL 模块中声明的其他变量。
    * 否则，程序可能不会按照本规范的其余部分描述的那样运行。 注意：这些效果可能是非局部的。

## 诊断 ## {#diagnostics}


在"着色器模块创建"或"管线创建"过程中，实现可能会产生诊断信息。
诊断信息是为了应用程序作者的利益而由实现生成的消息。


当满足特定条件时，会创建或触发诊断，这被称为"触发规则"。
在源文本中满足条件的位置，表示为源文本中的点或范围，被称为"触发位置"。


诊断具有以下属性：

* 诊断严重性。
* 触发规则。
* 触发位置。

诊断的严重性可以是以下类型，按照从高到低排序：
: <dfn dfn-for="severity" noexport>错误</a>
:: 该诊断是一个错误。
    这对应于"着色器创建错误"或"管线创建错误"。
: <dfn dfn-for="severity" noexport>警告</a>
:: 该诊断描述了值得应用程序开发人员注意的异常，但不是错误。
: <dfn dfn-for="severity" noexport>信息</a>
:: 该诊断描述了值得应用程序开发人员注意的显著条件，但不是错误或警告。
: <dfn dfn-for="severity" noexport>关闭</a>
:: 该诊断已被禁用。不会传达给应用程序。

"触发规则"的名称可以是：

* 一个"诊断名称标记"，或
* 两个"诊断名称标记"，由句点"."（U+002E）分隔。

<pre class=include>
path:syntax/diagnostic_rule_name.syntax.bs.include
</pre>

### 诊断处理 ### {#diagnostic-processing}

触发的诊断行为将按以下方式进行处理：

1. 对于每个诊断D，找到包含D的触发位置的最小受影响范围的诊断过滤器，并且该过滤器具有相同的触发规则。
    * 如果存在这样的过滤器，将其应用于D，更新D的严重程度。
    * 否则，D保持不变。
2. 丢弃严重程度为关闭的诊断。
3. 如果至少有一个剩余的诊断DI的严重程度为信息：
    * 可能会丢弃其他具有相同触发规则的信息诊断，只保留原始诊断DI。
4. 如果至少有一个剩余的诊断DW的严重程度为警告：
    * 可能会丢弃其他严重程度为信息或警告的具有相同触发规则的诊断，只保留原始诊断DW。
5. 如果至少有一个剩余的诊断的严重程度为错误：
    * 可能会丢弃其他诊断，包括其他严重程度为错误的诊断。
    * 生成一个程序错误。
        * 如果诊断在着色器模块创建时触发，错误是一个着色器创建错误。
        * 如果诊断在管线创建时触发，错误是一个管线创建错误。
6. 如果在着色器模块创建期间进行处理，剩余的诊断将填充WebGPU GPUCompilationInfo对象的GPUCompilationInfo/messages成员。
7. 如果在管线创建期间进行处理，严重程度为错误的诊断将导致WebGPU验证失败，验证GPUProgrammableStage。

注意：规则允许实现在检测到错误后停止处理WGSL模块。
此外，针对特定警告的分析可以在第一个警告上停止，
针对特定信息诊断的分析可以在第一次出现时停止。
WGSL不指定执行不同种类分析的顺序，或在单个分析中的顺序。
因此，对于相同的WGSL模块，不同的实现可能报告相同严重程度的不同诊断实例。

### 可过滤的触发规则 ### {#filterable-triggering-rules}

大多数诊断信息都会直接报告给WebGPU应用程序。
某些类型的诊断信息可以通过命名其诊断/触发规则来进行[[#diagnostic-filtering|过滤]]。
以下表格列出了可以进行过滤的标准触发规则集。

<table class='data'>
  <caption>可筛选的诊断触发规则</caption>
  <thead>
    <tr><th>可筛选的触发规则<th>默认的严重性<th>触发位置<th>描述
  </thead>

  <tr>
    <td><dfn noexport dfn-for="trigger">derivative_uniformity</dfn>
    <td>[=severity/error=]
    <td>The location of the [=call site=] for any
        [=builtin functions that compute a derivative|builtin function that computes a derivative=].
        That is, the location of a call to any of:
        * the [[#derivative-builtin-functions|derivative builtin functions]]
        * [[#texturesample|textureSample]]
        * #texturesamplebias|textureSampleBias
        * [[#texturesamplecompare|textureSampleCompare]]

    <td>一个对内置函数的调用会计算出导数，但是[=uniformity analysis=]无法证明该调用发生在[=uniform control flow=]中。

    见 [[#uniformity]].
</table>

使用一个单一的[=diagnostic name-token=]组成的未识别的触发规则应该触发用户代理的警告。


实现可以支持此处未指定的触发规则，只要它们使用[=syntax/diagnostic_rule_name=]的多令牌形式拼写。
使用多令牌形式拼写的未识别的触发规则本身可能触发诊断。


未来版本的规范可能会删除特定的规则或降低其默认严重程度
（即用较轻的默认值替换其当前默认值），但仍被视为满足向后兼容性要求。
例如，未来版本的WGSL可能会将[=trigger/derivative_uniformity=]的默认严重程度从"错误"更改为"警告"或"信息"。
在规范更改后，先前有效的程序仍将保持有效。

### 诊断过滤 ### {#diagnostic-filtering}


一旦具有可过滤的诊断和触发规则的诊断被触发，WGSL提供机制来丢弃诊断或修改其严重性。

一个诊断过滤器DF有三个参数：

* AR：称为受影响范围的源文本范围
* NS：新的诊断严重性
* TR：触发规则

将诊断过滤器DF（AR，NS，TR）应用于诊断D具有以下效果：

* 如果D的触发位置在AR内，且D的触发规则为TR，则将D的严重性属性设置为NS。
* 否则，D保持不变。

范围诊断过滤器是一个受影响范围为指定源文本范围的诊断过滤器。
范围诊断过滤器指定为开始处的@diagnostic属性，如下表所示。
@diagnostic属性不能出现在其他位置。

范围诊断过滤器的放置位置和受影响范围如下表所示。

注意：以下也是复合语句：函数体、case子句、default-alone子句、while和for循环的循环体，if子句、else_if子句和else子句的主体。

例如，在纹理采样上使用范围诊断过滤器的示例：

var<private> d: f32;
fn helper() -> vec4<f32> {
  // 在"if"的主体中禁用derivative_uniformity诊断。
  if (d < 0.5) @diagnostic(off,derivative_uniformity) {
    return textureSample(t,s,vec2(0,0));
  }
  return vec4(0.0);
}

全局诊断过滤器可以用于将诊断过滤器应用于整个WGSL模块。


例如，具有导数一致性的全局诊断过滤器的示例：

diagnostic(off,derivative_uniformity);
var<private> d: f32;
fn helper() -> vec4<f32> {
  if (d < 0.5) {
    // 通过全局诊断过滤器在此处禁用导数一致性诊断。
    return textureSample(t,s,vec2(0,0));
  } else {
    // 导数一致性诊断设置为警告级别。
    @diagnostic(warning,derivative_uniformity) {
      return textureSample(t,s,vec2(0,0));
    }
  }
  return vec4(0.0);
}

两个诊断过滤器DF1（AR1，NS1，TR1）和DF2（AR2，NS2，TR2）冲突，当：

* （AR1 = AR2），且
* （TR1 = TR2），且
* （NS1 ≠ NS2）。

诊断过滤器不能冲突。

WGSL的诊断过滤器设计为受影响范围完美嵌套。
如果DF1的受影响范围与DF2的受影响范围重叠，那么DF1的受影响范围要么完全包含在DF2的受影响范围内，要么反之亦然。

对于源位置L和触发规则TR，如果存在最近的封闭诊断过滤器，则是诊断过滤器DF（AR，NS，TR），其中：

L位于受影响范围AR内，且
如果有另一个过滤器DF’（AR’，NS’，TR），其中L位于AR’内，则AR包含在AR’内。

因为受影响范围可以嵌套，最近的封闭诊断是唯一的或不存在。

## 限制 ## {#limits}

一个WGSL实现将支持满足以下限制的着色器。
一个WGSL实现可以支持超出指定限制的着色器。

注意：如果一个WGSL实现不支持超出指定限制的着色器，应该发出错误。

<table class=‘data’>
  <caption>可量化的着色器复杂度限制</caption>
  <thead>
    <tr><th>限制<th>最小支持值
  </thead>
  <tr><td>结构类型中的成员最大数量<td>16383
  <tr><td>复合类型的最大嵌套深度<td>255
  <tr><td>函数中花括号包围语句的最大嵌套深度<td>127
  <tr><td>函数的最大形式参数数量<td>255
  <tr><td>switch语句中的case选择器的最大数量<td>16383
  <tr><td>在地址空间/函数或地址空间/私有地址空间中实例化的数组类型的最大字节大小
          对于这个限制，bool类型的大小为1字节。
      <td>65535
  <tr><td>在地址空间/工作组地址空间中实例化的数组类型的最大字节大小。
          对于这个限制，bool类型的大小为1字节，并且当替代覆盖值时，固定尺寸的数组被视为创建固定尺寸的数组。
          这将WebGPU的支持限制maxComputeWorkgroupStorageSize映射到一个独立的WGSL限制。
          注意：虽然满足这个限制的多个工作组变量仍然可以组合超过API限制。
      <td>[=supported limits/maxComputeWorkgroupStorageSize|16384=]
  <tr><td>数组类型的常量表达式中的最大元素数量<td>65535
</table>

# 文本结构 # {#textual-structure}

text/wgsl 媒体类型用于将内容标识为 WGSL 模块。
参见[[#text-wgsl-media-type]]。

WGSL 模块是使用 UTF-8 编码的 Unicode 文本，没有字节顺序标记（BOM）。

WGSL 模块文本由一系列 Unicode [=码点=] 组成，这些码点分组为连续非空的集合，形成：

* [=注释=]
* [=标记=]
* [=空白字符=]

程序文本 [=着色器创建错误|不得=] 包含空代码点（U+0000）。

## 解析 ## {#parsing}

解析WGSL模块的步骤如下:
  <blockquote>
    1. 移除[=comments=]：
        * 用空格代码点(U+0020)替换第一个注释。
        * 重复此过程直到没有注释为止。
    2. 使用[[#template-lists-sec]]中的[=template list discovery=]算法，寻找[=template lists=]。
    3. 解析整个文本，尝试匹配[=syntax/translation_unit=]语法规则。 解析使用了一个LALR(1)解析器(一次向前看一个标记) [[!DeRemer1969]]，以下是定制内容:
        * Tokenization与解析交错进行，并且具有上下文感知功能。 当解析器请求下一个标记时:
            * 消耗并忽略一系列以[=blankspace=]代码点开头的字符。
            * 如果下一个代码点是[=template list=]的开始，消耗它并返回[=syntax_sym/_template_args_start=]。
            * 如果下一个代码点是[=template list=]的结束，消耗它并返回[=syntax_sym/_template_args_end=]。
            * 否则:
                * 一个<dfn>token candidate</dfn>是由剩下未消耗代码点的非空前缀构成的WGSL[=token=]。
                * 返回的标记是最长的、同时也是当前解析器状态的有效向前看标记的[=token candidate=]。[[!VanWyk2007]]
  </blockquote>


如果发生[=shader-creation error=]，则可能是因为:
* 整个源代码无法转换为有效标记的有限序列，或者
* [=syntax/translation_unit=]语法规则与整个标记序列不匹配。

## 空白处和换行 ## {#blankspace-and-line-breaks}

<dfn>空格</dfn>是来自Unicode的一个或多个代码点的组合。
下面是Unicode版本14.0.0的[=Unicode标准附录＃31：Pattern_White_Space=]属性中的代码点集合：

* 空格（U+0020）
* 水平制表符（U+0009）
* 换行符（U+000A）
* 垂直制表符（U+000B）
* 换页符（U+000C）
* 回车符（U+000D）
* 下一行（U+0085）
* 从左到右的标记（U+200E）
* 从右到左的标记（U+200F）
* 行分隔符（U+2028）
* 段落分隔符（U+2029）

<dfn>换行符</dfn>是一系列[=空格=]代码点的连续序列，表示行的结束。
它被定义为[=UAX14第6.1节不可调整的换行规则=]中定义的一个"强制换行"信号，即[=UAX14 LB4|LB4=]和[=UAX14 LB5|LB5=]。
换行符可以是以下之一：

* 换行符（U+000A）
* 垂直制表符（U+000B）
* 换页符（U+000C）
* 回车符（U+000D），但未跟随换行符（U+000A）
* 回车符（U+000D）后跟换行符（U+000A）
* 下一行（U+0085）
* 行分隔符（U+2028）
* 段落分隔符（U+2029）

注意：以行号报告源文本位置的诊断应使用[=换行符=]来计算行数。

## 注释 ## {#comments}

一个<dfn>注释(comment)</dfn>是一段文本，它不会影响WGSL程序的有效性或含义，除非它能够分隔[=标记(tokens)=]。着色器作者可以使用注释来对他们的程序进行文档记录。

一个<dfn noexport>行尾注释(line-ending comment)</dfn>是一种注释，由两个代码点// (U+002F后跟U+002F)和随后的代码点组成，直到但不包括:

* 下一个[=换行符(line break)=]，或
* 程序结束。

一个<dfn noexport>块注释(block comment)</dfn>是一种注释，由以下组成:

* 两个代码点/* (U+002F后跟U+002A)
* 任意序列:
    * 一个[=块注释(block comment)=]，或
    * 不包含*/ (U+002A后跟U+002F)或/* (U+002F后跟U+002A)的文本
* 两个代码点*/ (U+002A后跟U+002F)

注意：块注释可以嵌套。由于块注释需要匹配的开始和结束文本序列，并且允许任意嵌套，因此无法使用正则表达式识别块注释。这是正则语言泵引理的一个结果。

<div class='example wgsl' heading='Comments'>
  <xmp>
  const f = 1.5; // This is line-ending comment.
  const g = 2.5; /* This is a block comment
                  that spans lines.
                  /* Block comments can nest.
                   */
                  But all block comments must terminate.
                 */
  </xmp>
</div>

## 令牌 ## {#tokens}
一个<dfn>标记</dfn>是由连续的代码点形成的一种：

* 一个[=文字=]。
* 一个[=关键词=]。
* 一个[=保留字=]。
* 一个[=语法标记=]。
* 一个[=标识符=]。
* 一个[=上下文相关名称=]。

## 字面量 ## {#literals}

一个<dfn>字面量</dfn>是以下之一：

* 一个<dfn noexport>布尔字面量</dfn>：要么是true，要么是false。
* 一个<dfn>数值字面量</dfn>：要么是一个整数字面量，要么是一个浮点数字面量， 用来表示一个数字。

<pre class=include>
path: syntax/literal.syntax.bs.include
</pre>

### 布尔字面量 ### {#boolean-literals}

<div class='example wgsl bool-literals' heading='boolean literals'>
  <xmp>
    const a = true;
    const b = false;
  </xmp>
</div>

<pre class=include>
path: syntax/bool_literal.syntax.bs.include
</pre>

### 数值字面量 ### {#numeric-literals}

数字字面值的形式是通过模式匹配来定义的。

一个整数字面值是：

* 一个表示整数的方式，可以是以下任意一种：
    * 0
    * 一串十进制数字，其中第一个数字不是0。
    * 0x或0X后跟一个十六进制数字序列。
* 然后是可选的i或u后缀。

<pre class=include>
path: syntax/int_literal.syntax.bs.include
</pre>

<pre class=include>
path: syntax/decimal_int_literal.syntax.bs.include
</pre>

<div class='example wgsl decimal-int-literals' heading='decimal integer literals'>
  <xmp>
    const a = 1u;
    const b = 123;
    const c = 0;
    const d = 0i;
  </xmp>
</div>

<pre class=include>
path: syntax/hex_int_literal.syntax.bs.include
</pre>

<div class='example wgsl hexadecimal-int-literals' heading='hexadecimal integer literals'>
  <xmp>
    const a = 0x123;
    const b = 0X123u;
    const c = 0x3f;
  </xmp>
</div>

<dfn>浮点数字面值</dfn>是指十进制浮点数字面值或十六进制浮点数字面值。

<pre class=include>
path: syntax/float_literal.syntax.bs.include
</pre>

一个浮点数字面量有两个逻辑部分：表示分数的尾数和一个可选的指数。
大致上，字面量的值等于尾数乘以一个基础值的给定指数次方。
如果一个尾数数字非零，或者它的左边和右边都有非零的尾数数字，那么这个数字就是【尾数】中的【有效数字】。
有效数字从左到右进行计数：第n个有效数字左边有n-1个有效数字。

一个<dfn noexport>十进制浮点数字面量</dfn>是：

* 一个尾数，由一系列数字指定，其中可以选用一个小数点（.）放置在其中某个位置。 尾数表示一个十进制数分数。
* 然后是一个可选的指数后缀，包括：
    * e 或 E。
    * 然后是一个十进制数指定的指数，可以带有可选的符号（+ 或 -）。
    * 然后是一个可选的 f 或 h 后缀。
* 小数点、指数或 f 或 h 后缀中至少要有一个。 如果没有其中任何一个，则该标记实际上是一个整数字面值。

<pre class=include>
path: syntax/decimal_float_literal.syntax.bs.include
</pre>

<div class='example wgsl decimal-float-literals' heading='decimal floating point literals'>
  <xmp>
    const a = 0.e+4f;
    const b = 01.;
    const c = .01;
    const d = 12.34;
    const f = .0f;
    const g = 0h;
    const h = 1e-3;
  </xmp>
</div>

<div algorithm="mathematical value of decimal floating point literal">

一个十进制浮点字面量的数学值计算如下：
* 根据 |mantissa| 计算出 |effective_mantissa|：
    * 如果 |mantissa| 有20个或更少的有效数字，那么 |effective_mantissa| 就是 |mantissa|。
    * 否则：
        * 令 |truncated_mantissa| 与 |mantissa| 相同，除了第20个有效数字右边的每个数字被替换为0。
        * 令 |truncated_mantissa_next| 与 |mantissa| 相同，除了：
            * 第20个有效数字增加1，并将进位传递到左侧，以确保每个数字仍在0到9的范围内，
            * 第20个有效数字右边的每个数字被替换为0。
        * 将 |effective_mantissa| 设置为 |truncated_mantissa| 或 |truncated_mantissa_next|。这是一个实现选择。
* 字面量的数学值是以十进制小数形式表示的 |effective_mantissa| 的数学值，乘以10的指数次方。 当未指定指数时，假定指数为0。

</div>

注意：小数尾数在20位小数后被截断，保留了大约log(10)/log(2)×20约等于66.4个有效位数的小数部分。

一个<dfn noexport>十六进制浮点字面量</dfn>包括：

* 一个以0x或0X开头的前缀
* 之后是一个尾数，表示为一串十六进制数字，其中可以选择包含一个十六进制小数点（.）。 尾数表示一个十六进制的分数。
* 之后是一个可选的指数后缀，包括：
    * p或P
    * 之后是一个指数，表示为一个十进制数字，可以选择带有一个可选的符号（+或-）。
    * 之后是一个可选的f或h后缀。
* 十六进制小数点或指数中至少有一个必须存在。 如果两者都不存在，则该标记实际上是一个整数字面量。

<pre class=include>
path: syntax/hex_float_literal.syntax.bs.include
</pre>

<div class='example wgsl hexadecimal-float-literals' heading='hexadecimal floating point literals'>
  <xmp>
    const a = 0xa.fp+2;
    const b = 0x1P+4f;
    const c = 0X.3;
    const d = 0x3p+2h;
    const e = 0X1.fp-4;
    const f = 0x3.2p+2h;
  </xmp>
</div>

<div algorithm="mathematical value of hexadecimal floating point literal">
十六进制浮点数文字的数学值计算如下：

* 根据尾数计算有效尾数：
    * 如果尾数有16位或更少的有效数字，则有效尾数等于尾数。
    * 否则：
        * 将截断后的尾数设为与尾数相同，除了第16位有效数字右边的每一位都被替换为0。
        * 将截断后的下一个尾数设为与尾数相同，除了：
            * 第16位有效数字增加1，并根据需要向左传播进位，以确保每一位数字保持在0到f的范围内，以及
            * 第16位有效数字右边的每一位都被替换为0。
        * 将有效尾数设为截断尾数或截断后的下一个尾数之一。这是一个实现选择。
* 文字的数学值是以十六进制分数的形式表示的有效尾数的数学值，乘以2的指数次方。 如果没有指定指数，则假定指数为0。

</div>

注意：十六进制尾数在16个十六进制数字后被截断，保留大约64个有效比特的小数部分。

当一个数值字面量有后缀时，这个字面量表示特定标量类型的值。
否则，字面量表示下面定义的一个抽象数值类型的值。
无论哪种情况，字面量表示的值是将其转换为目标类型后的数学值，
遵循[[#floating-point-conversion]]中的规则。

<table class=data>
  <caption>Mapping numeric literals to types</caption>
  <thead>
    <tr><th>Numeric Literal<th>Suffix<th>Type<th>Examples
  </thead>

  <tr><td>[=integer literal=]<td>`i`<td>[=i32=]<td>42i
  <tr><td>[=integer literal=]<td>`u`<td>[=u32=]<td>42u
  <tr><td>[=integer literal=]<td><td>[=AbstractInt=]<td>124
  <tr><td>[=floating point literal=]<td>`f`<td>[=f32=]<td>42f 1e5f 1.2f 0x1.0p10f
  <tr><td>[=floating point literal=]<td>`h`<td>[=f16=]<td>42h 1e5h 1.2h 0x1.0p10h
  <tr><td>[=floating point literal=]<td><td>[=AbstractFloat=]<td>1e5 1.2 0x1.0p10
</table>

如果发生以下情况之一，将导致"shader-creation error"：

* 带有"i"或"u"后缀的整数字面量无法由目标类型表示。
* 带有"f"或"h"后缀的十六进制浮点数字面量溢出或无法被目标类型准确表示。
* 带有"f"或"h"后缀的十进制浮点数字面量溢出目标类型。
* 在未启用"extension/f16|f16 extension"时使用带有"h"后缀的浮点数字面量。

注意：十六进制浮点值"0x1.00000001p0"需要33个尾数位才能准确表示，而"f32"只有23个显式尾数位。


注意：如果您想使用"f"后缀强制将十六进制浮点数字面量标记为某种类型，字面量还必须使用二进制指数。例如，写作"0x1p0f"。相比之下，"0x1f"是一个十六进制整数字面量。

## Keywords ## {#keywords}

一个<dfn>关键字</dfn>是指一个预定义的语言概念的[=标记=]。
请参阅[[#keyword-summary]]以获取WGSL关键字列表。

## 标识符 ## {#identifiers}

标识符是一种被用作名称的令牌。参见[[#declaration-and-scope]]。

WGSL使用两种语法非终结符来区分用例：

* 语法非终结符"ident"用于命名一个声明的对象。
* 语法非终结符"member_ident"用于命名一个结构类型的成员。

<pre class=include>
path: syntax/ident.syntax.bs.include
</pre>
<pre class=include>
path: syntax/member_ident.syntax.bs.include
</pre>

标识符的形式基于《Unicode标准附录 #31 - Unicode版本14.0.0》中描述的规范，并有以下详细说明。

标识符使用根据《UAX31语法》描述的以下配置文件。

```
<Identifier> := <Start> <Continue>* (<Medial> <Continue>+)*

<Start> := XID_Start + U+005F
<Continue> := <Start> + XID_Continue
<Medial> :=
```

这意味着像Δέλτα，réflexion，Кызыл，𐰓𐰏𐰇，朝焼け，سلام，검정，שָׁלוֹם，गुलाबी，փիրուզ这样具有非ASCII代码点的标识符是有效的。

With the following exceptions:
* An identifier [=shader-creation error|must not=] have the same spelling as a [=keyword=] or as a [=reserved word=].
* An identifier [=shader-creation error|must not=] be `_` (a single underscore, `U+005F`).
* An identifier [=shader-creation error|must not=] start with `__` (two underscores, `U+005F` followed by `U+005F`).

<pre class=include>
path: syntax/ident_pattern_token.syntax.bs.include
</pre>

[=Unicode Character Database for Unicode Version 14.0.0=] 包含了非规范性的列表，其中包含了所有有效的编码点，包括 [=UAX31 Lexical Classes|XID_Start=] 和 [=UAX31 Lexical Classes|XID_Continue=]。

注意：一些内建函数的返回类型是结构类型，这些结构类型的名称在WGSL源代码中不能使用。这些结构类型被描述得好像它们是以两个下划线开头的预声明类型。结果值可以使用类型推断保存到新声明的let或var中，或者可以立即通过名称提取其中的一个成员。请参阅frexp和modf的描述中的示例用法。

### 标识符比较 ### {#identifier-comparison}

如果且仅当两个WGSL标识符由相同的代码点序列组成时，它们才是相同的。


注意：本规范不允许对值进行Unicode归一化以进行比较。
视觉上和语义上相同但使用不同Unicode字符序列的值将不匹配。
建议内容作者在选择值时要么始终使用相同的编码序列，要么避免使用可能会引起问题的字符。
有关更多信息，请参阅[[CHARMOD-NORM]]。


注意：当一个WGSL模块的含义会随着将所有标识符的实例替换为该标识符的形状相同的标识符之一而发生改变时，用户代理应发出开发者可见的警告。
（同形异意是一串代码点的序列，可能对读者来说与另一串代码点的序列看起来相同。
检测同形异意的映射示例包括前一段中提到的转换、映射和匹配算法。如果标识符可以通过重复替换子序列来将一个序列转换为另一个序列，则这两个序列是同形异意的。）

## 依赖上下文的名称 ## {#context-dependent-names}

一个<dfn>上下文相关名称（context-dependent name）</dfn>是一个用于命名概念的<b><dfn>标记（token）</dfn></b>，但仅在特定的语法上下文中使用。
这个标记的拼写可能与<b><dfn>标识符（identifier）</dfn></b>相同，但该标记并不会<b><dfn>解析（resolve）</dfn></b>为一个已声明的对象。

章节[[#context-dependent-name-tokens]]列出了所有这样的标记。

## 诊断规则名称 ## {#diagnostic-rule-names}
<dfn noexport>诊断性名词令牌</dfn>是诊断触发规则名称中使用的令牌。令牌的拼写可能与标识符相同，但不会解析为已声明的对象。该令牌不能是关键字或保留字。

参见[[#diagnostics]]。

<pre class=include>
path: syntax/diagnostic_name_token.syntax.bs.include
</pre>

## 模板列表 ## {#template-lists-sec}

<dfn noexport>模板参数化</dfn>是一种指定修改常规概念的参数的方式。
要编写一个模板参数化，先写出常规概念，然后是一个[=模板列表=]。

忽略[=注释=]和[=空格=]，一个<dfn noexport>模板列表</dfn>由以下部分组成：

* 一个初始的'<'（U+003C）代码点，然后
* 一个[=syntax_sym/comma=]分隔的一个或多个<dfn noexport>模板参数</dfn>的列表，然后
* 一个可选的尾部[=syntax_sym/comma=]，然后
* 一个终止的'>'（U+003E）代码点。

一个[=模板参数=]的形式是通过下面的[=模板列表发现=]算法隐式定义的。
通常，它们是名称、表达式或类型。

注意：例如，短语vec3<f32>是一个模板参数化，其中vec3是被修改的常规概念，
而<f32>是包含一个参数的模板列表，该参数是类型[=f32=]。
一起来看，vec3<f32>表示一个特定的[=向量=]类型。

注意：例如，短语var<storage,read_write>用模板参数storage和read_write修改了通用的var概念。

<div class=note>
  <span class=marker>注意：</span>例如，短语array<vec4<f32>>有两个模板参数化：

  * vec4<f32>用模板参数f32修改了通用的vec4概念。
  * array<vec4<f32>>用模板参数vec4<f32>修改了通用的array概念。

</div>

将界定模板列表的'<'（U+003C）和'>'（U+003E）代码点，也用于拼写：

* 在[=syntax/relational_expression=]中的比较操作符。
* 在[=syntax/shift_expression=]中的移位操作符。
* 在执行移位操作后进行赋值的[=syntax/compound_assignment_operator=]。

在语法上，会优先解决模板列表的歧义：

* 在解析的早期阶段，模板列表会在[=declarations=]、[=expressions=]、[=statements=]解析之前被发现。
* 在后续的词法标记化过程中， 模板列表的初始'<'（U+003C）被映射为[=syntax_sym/_template_args_start=]标记，而 模板列表的结束'>'（U+003E）被映射为[=syntax_sym/_template_args_end=]标记。

以下是[=template list discovery=]算法。
算法使用以下假设和属性：

1. 模板参数是一个表达式，因此不以'<'（U+003C）或'='（U+003D）代码点开头。
2. 表达式不包含代码点';'（U+003B）、'{'（U+007B）或':'（U+003A）。
3. 表达式不包含[=statement/assignment=]。
4. '='（U+003D）代码点仅用于比较操作，即出现在下列其中之一中：
    <a for=syntax_sym lt=less_than_equal>'<='</a>，
    <a for=syntax_sym lt=greater_than_equal>'>='</a>，
    <a for=syntax_sym lt=equal_equal>'=='</a>或 <a for=syntax_sym lt=not_equal>'!='</a>。
    否则，'='（U+003D）代码点将用于赋值。
5. 模板列表的分隔符会考虑由括号’(…)‘和数组索引’[…]'形成的嵌套表达式。 模板列表的起始和结束必须出现在相同的嵌套级别。

<blockquote algorithm="template list discovery">
**Algorithm:** <dfn noexport>Template list discovery</dfn>

**Input:** 程序源文本.

**Record types:**

定义一个记录类型|UnclosedCandidate|包含：
* |position|，源文本中的位置
* |depth|，一个整数，表示在|position|处的表达式嵌套深度


定义一个记录类型|TemplateList|包含：
* |start_position|，表示此模板列表开始的’<’ (U+003C)字符的源位置
* |end_position|，表示此模板列表结束的’>’ (U+003E)字符的源位置


输出： |DiscoveredTemplateLists|，一个包含|TemplateList|记录的列表。

**Algorithm:**
* 将|DiscoveredTemplateLists|初始化为空列表。
* 将|Pending|变量初始化为空的|UnclosedCandidate|记录的堆栈。
* 将|CurrentPosition|整数变量初始化为0。 它编码了正在检查的代码点的位置，以源文本开始后的代码点数为计数。
    * 在执行算法时，该变量会向前移动文本。 当到达文本末尾时，立即终止算法，并使其返回|DiscoveredTemplateLists|。
* 将|NestingDepth|整数变量初始化为0。
* 重复以下步骤：
    * 将 |CurrentPosition| 推进过 [=blankspace=]、[=comments=] 和 [=literals=]。
    * 如果 [=syntax/ident_pattern_token=] 与 |CurrentPosition| 处的文本匹配，则：
        * 将 |CurrentPosition| 推进过 [=syntax/ident_pattern_token=]。
        * 如果有空格和注释，将 |CurrentPosition| 推进过它们。
        * 如果 |CurrentPosition| 处出现 '<' (U+003C)，则：
            * 注意：这个代码点有可能是模板列表的开始。 保存足够的状态以便在输入中稍后出现的 '>' (U+003E) 进行匹配。
            * 将 |UnclosedCandidate|(|position|=|CurrentPosition|,|depth|=|NestingDepth|) 推入 |Pending| 栈。
            * 将 |CurrentPosition| 推进到下一个代码点。
            * 如果 |CurrentPosition| 处出现 '<' (U+003C)，则：
                * 注意：根据假设1，没有模板参数以 '<' (U+003C) 开始，因此前一个代码点不能是模板列表的开始。 因此当前和前一个代码点必须是 <a for=syntax_sym lt=shift_left>'<<'</a> 运算符。
                * 弹出 |Pending| 栈中的顶部条目。
                * 将 |CurrentPosition| 推进过这个代码点，并开始下一次循环迭代。
            * 如果 |CurrentPosition| 处出现 '=' (U+003D)，则：
                * 注意：根据假设1，没有模板参数以 '=' (U+003C) 开始，因此前一个代码点不能是模板列表的开始。 假设当前和前一个代码点组成一个 <a for=syntax_sym lt=less_than_equal>'<='</a> 比较运算符。 跳过 '=' (U+003D) 代码点，以防后续步骤错误地将其视为赋值运算符。
                * 弹出 |Pending| 栈中的顶部条目。
                * 将 |CurrentPosition| 推进过这个代码点，并开始下一次循环迭代。
    * 如果‘>’（U+003E）出现在|CurrentPosition|处，则：
        * 注意：该代码点有可能是模板列表的结尾候选项。
        * 如果|Pending|不为空，则令|T|为其顶部项，如果|T|的|depth|等于|NestingDepth|，则：
            * 注意：该代码点结束了以|T|记录的当前模板列表的开头。
            * 将|TemplateList|（|start_position|=|T|.|position|，|end_position|=|CurrentPosition|）添加到|DiscoveredTemplateLists|中。
            * 从|Pending|栈中弹出|T|。
            * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
        * 否则，该代码点不结束模板列表：
            * 将|CurrentPosition|向前移动至此代码点的下一个位置。
            * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
                * 注意：假设当前代码点和前一个代码点形成一个<a for=syntax_sym lt=greater_than_equal>'>='</a>比较运算符。 跳过‘=’（U+003D）代码点，以免在后面的步骤中将其误认为是一个赋值。
                * 将|CurrentPosition|向前移动至此代码点的下一个位置。
                * 开始循环的下一次迭代。
    * 如果‘(’（U+0028）或‘[’（U+005B）出现在|CurrentPosition|处，则：
        * 注意：进入一个嵌套表达式。
        * 在|NestingDepth|上加1。
        * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果‘)’（U+0029）或‘]’（U+005D）出现在|CurrentPosition|处，则：
        * 注意：退出一个嵌套表达式。
        * 从|Pending|栈中弹出条目，直到它为空，或者直到其顶部条目的|depth| < |NestingDepth|为止。
        * 将|NestingDepth|设置为0或|NestingDepth| − 1中的较大值。
          * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果‘!’（U+0021）出现在|CurrentPosition|处，则：
        * 将|CurrentPosition|向前移动至此代码点的下一个位置。
        * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
            * 注意：假设当前代码点和前一个代码点形成一个<a for=syntax_sym lt=not_equal>'!='</a>比较运算符。 跳过‘=’（U+003D）代码点，以免在后面的步骤中将其误认为是一个赋值。
            * 将|CurrentPosition|向前移动至此代码点的下一个位置。
        * 开始循环的下一次迭代。
    * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
        * 将|CurrentPosition|向前移动至此代码点的下一个位置。
        * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
            * 注意：假设当前代码点和前一个代码点形成一个<a for=syntax_sym lt=equal_equal>'=='</a>比较运算符。 跳过‘=’（U+003D）代码点，以免在后面的步骤中将其误认为是一个赋值。
            * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
        * 注意：假设此代码点是赋值的一部分，它不能作为表达式的一部分出现，因此不能出现在模板列表中。 清除未完成的候选项。
        * 将|NestingDepth|设置为0。
        * 从|Pending|栈中删除所有条目。
        * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果‘;’（U+003B）或‘{’（U+007B）或‘:’（U+003A）出现在|CurrentPosition|处，则：
        * 注意：这些不能出现在表达式的中间，因此不能出现在模板列表中。 清除未完成的候选项。
        * 将|NestingDepth|设置为0。
        * 从|Pending|栈中删除所有条目。
        * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果<a for=syntax_sym lt=and_and>'&&'</a>或<a for=syntax_sym lt=or_or>'||'</a>与|CurrentPosition|处的文本匹配，则：
        * 注意：这些是低于比较运算符优先级的运算符。拒绝当前表达式级别中未完成的候选项。
        * 注意：按此规则，在程序片段 `a<b || c>d` 中，将找不到模板列表。 而它将被识别为两个比较运算的短路或运算。
        * 从|Pending|栈中弹出条目，直到它为空，或者直到其顶部条目的|depth| < |NestingDepth|为止。
        * 将|CurrentPosition|向前移动两个代码点，并开始循环的下一次迭代。
    * 将|CurrentPosition|向前移动至当前代码点的下一个位置。

</blockquote>

<div class=note algorithm="find template paramters">
<span class=marker>Note:</span>算法可以修改为找到[=模板参数=]的源范围，如下所示：

* 修改|UnclosedCandidate|，添加以下字段：
    * |parameters|，模板参数的源范围列表。
    * |parameter_start_position|，源位置。
* 修改|TemplateList|，添加一个字段：
    * |parameters|，模板参数的源范围列表。
* 当将新的|UnclosedCandidate|推入|待处理|栈时：
    * 将其|parameters|字段设置为空列表。
    * 将|parameter_start_position|设置为|CurrentPosition|的下一个代码点。
* 当将|TemplateList|，|TL|，添加到<var ignore>DiscoveredTemplateLists</var>中时：
    * 让|T|成为栈|Pending|的顶部，就像原算法中一样。
    * 将从|T|.|parameter_start_position|开始到|CurrentPosition|−1结束的源范围推入|T|.|parameters|中。
    * 按照原算法准备|TL|。
    * 将|TL|.|parameters|设置为|T|.|parameters|。
* 在循环结束之前，在推进到当前代码点之前插入一个检查：
    * 如果在|CurrentPosition|处出现了’,'（U+002C），并且|Pending|不为空，则：
      * 让|T|成为栈|Pending|的顶部。
      * 将从|T|.|parameter_start_position|开始到|CurrentPosition|−1结束的源范围推入|T|.|parameters|中。
      * 将|T|.|parameter_start_position|设置为|CurrentPosition|+1。

</div>
注意：该算法显式跳过字面值，因为有些数值字面值以字母结尾，例如1.0f。终止的f不应该被误认为是一个[=syntax/ident_pattern_token=]的开始。


注意：在短语A ( B < C, D > ( E ) )中，段落< C, D >是一个[=template list=]。


注意：该算法遵循表达式嵌套：特定模板列表的起始和结束不可以出现在不同的表达式嵌套层级上。
例如，在array<i32,select(2,3,a>b)>中，模板列表有三个参数，其中最后一个是select(2,3,a>b)。
a>b中的'>'并不终止模板列表，因为它被括在调用select函数的表达式的括号部分中。


注意：模板列表的两端必须出现在同一个[=indexing expression=]中。例如，a[b<d]>()不包含合法的模板列表。


注意：在短语A<B<<C>中，短语B<<C被解析为B后面跟着左移运算符 <a for=syntax_sym lt=shift_left>'<<'</a> 然后是C。
模板发现算法开始检查B，然后是'<' (U+003C)，但是发现紧接着的'<' (U+003C)不可能是模板参数的开始，因此
紧接在B后面的'<'并不是模板列表的开始。
初始的'<'和最后的'>'是唯一的模板列表分界符，它有模板参数B<<C。


注意：短语A<B<=C>的解析和前面的说明类似，因此短语B<=C被解析为B后面跟着小于或等于的运算符 <a for=syntax_sym lt=less_than_equal>'<='</a> 然后是C。
模板发现算法开始检查B，然后是'<' (U+003C)，但是发现紧接着的'=' (U+003D) 不可能是模板参数的开始，因此
紧接在B后面的'<'并不是模板列表的开始。
初始的'<'和最后的'>'是唯一的模板列表分界符，它有模板参数B<=C。


注意：在检查短语A<(B>=C)>时，有一个模板列表，起始于第一个'<' (U+003C) 代码点，并以最后一个'>' (U+003E) 代码点结束，参数为B>=C。
在检查到第一个'>' (U+003E) 代码点（在B之后）后，需要特殊识别'=' (U+003D) 代码点，以免被认为是赋值的一部分。


注意：在检查短语A<(B!=C)>时，有一个模板列表，起始于第一个'<’ (U+003C) 代码点，并以最后一个'>' (U+003E) 代码点结束，参数为B!=C。
在检查到'!' (U+0021) 代码点（在'B'之后）后，需要特殊识别'=' (U+003D) 代码点，以免被认为是赋值的一部分。


注意：在检查短语A<(B==C)>时，有一个模板列表，起始于第一个'<' (U+003C) 代码点，并以最后一个'>' (U+003E) 代码点结束，参数为B==C。
在检查到第一个'=' (U+003D) 代码点（在'B'之后）后，需要特殊识别第二个'=' (U+003D) 代码点，以免被认为是赋值的一部分。


在[=template list discovery=]完成后，
[[#parsing|parsing]] [=behavioral requirement|将会=] 尝试将每个模板列表与[=syntax/template_list=]语法规则匹配。

<pre class=include>
path: syntax/template_list.syntax.bs.include
</pre>

<pre class=include>
path: syntax/template_arg_comma_list.syntax.bs.include
</pre>

<pre class=include>
path: syntax/template_arg_expression.syntax.bs.include
</pre>

# 指令 # {#directives}

<dfn noexport>指令</dfn>是一系列的令牌，用于修改WGSL程序在WebGPU实现中的处理方式。


指令是可选的。
如果存在，则必须在任何声明或常量断言之前出现所有指令。

<pre class=include>
path: syntax/global_directive.syntax.bs.include
</pre>

## 扩展 ## {#extensions}

预计WGSL会随着时间的推移进行演变。

[=扩展=]是对WGSL规范进行一致性修改的命名分组，可以包含以下任意组合：

* 通过新的语法添加新的概念和行为，包括：
    * 声明、语句、属性和内置函数。
* 删除当前规范或先前发布的扩展中的限制。
* 用于减少可行行为集的语法。
* 对程序的某个部分可用功能进行限制的语法。
* 描述扩展与现有规范以及可能与其他扩展交互的方式。

假设，扩展可以：

* 添加数值标量类型，如不同位宽的整数。
* 添加语法以限制浮点数的舍入模式。
* 添加语法以表示着色器不使用原子类型。
* 添加新的语句类型。
* 添加新的内置函数。
* 添加语法以限制着色器执行方式。
* 添加新的着色器阶段。

有两种类型的扩展：[=启用扩展=]和[=语言扩展=]。

### 启用扩展 ### {#enable-extensions-sec}

一个<dfn noexport>enable-extension</dfn>是一种[=扩展=]，其功能仅在满足以下条件时才可用：


* 实现支持它，且
* 着色器通过一个[=enable指令=]明确请求它，且
* 在创建{{GPUDevice}}时，相应的WebGPU {{GPUFeatureName}}是所请求的必需功能之一。

[=Enable-extensions=]旨在公开不是普遍可用的硬件功能。


一个<dfn noexport>enable指令</dfn>是一个[=指令=]，它开启对一个或多个enable-extensions的支持。
如果实现不支持列出的所有enable-extensions，则会产生一个[=着色器创建错误=]。

<pre class=include>
path: syntax/enable_directive.syntax.bs.include
</pre>
<pre class=include>
path: syntax/enable_extension_list.syntax.bs.include
</pre>

与其他指示符一样，如果存在 [=enable directive=]，则它必须出现在所有 [=declarations=] 和 [[#const-assert-statement|const assertions]] 之前。
扩展名不是 [=identifiers=]：它们不会 [=resolve=] 为 [=declarations=]。

The valid [=enable-extensions=] are listed in the following table.
<table class='data'>
  <caption>Enable-extensions</caption>
  <thead>
    <tr><th>WGSL enable-extension
        <th>WebGPU {{GPUFeatureName}}
        <th>Description
  </thead>
  <tr><td><dfn noexport dfn-for="extension">`f16`</dfn>
      <td>`"shader-f16"`
      <td>在WGSL模块中使用"f16"类型是有效的。否则，直接或间接使用"f16"将会导致着色器创建错误.
</table>

<div class='example wgsl using extensions expect-error' heading="Using hypothetical enable-extensions">
  <xmp>
    // Enable a hypothetical extension for arbitrary precision floating point types.
    enable arbitrary_precision_float;
    enable arbitrary_precision_float; // A redundant enable directive is ok.

    // Enable a hypothetical extension to control the rounding mode.
    enable rounding_mode;

    // Assuming arbitrary_precision_float enables use of:
    //    - a type f<E,M>
    //    - as a type in function return, formal parameters and let-declarations
    //    - as a value constructor from AbstractFloat
    //    - operands to division operator: /
    // Assuming @rounding_mode attribute is enabled by the rounding_mode enable directive.
    @rounding_mode(round_to_even)
    fn halve_it(x : f<8, 7>) -> f<8, 7> {
      let two = f<8, 7>(2);
      return x / 2; // uses round to even rounding mode.
    }
  </xmp>
</div>

### 语言扩展 ### {#language-extensions-sec}

如果实现支持，<dfn noexport>语言扩展</dfn>是自动可用的 [=extension=]。程序不必显式请求它。

[=语言扩展=] 包含了在任何WebGPU实现中都可以合理支持的功能。
如果该功能不是普遍可用，那是因为某些WebGPU实现尚未实现它。


注意：例如，do-while循环可以是一种语言扩展。

WebGPU对象的{{GPU/wgslLanguageFeatures}}成员列出了实现支持的一组[=语言扩展=]。


<dfn noexport>requires-directive</dfn>是一条[=指令=]，记录了程序对一个或多个[=语言扩展=]的使用。它不会改变实现所暴露的功能。如果实现不支持某个所需的扩展，那么会导致[=着色器创建错误=]。


WGSL模块可以使用[=requires-directive=]来表示可能的不可移植性，并且表示意图的最低可移植性要求。


注意：WebGPU实现之外的工具可以检查一个程序中使用的所有[=语言扩展=]是否都被程序中的[=requires-directive=]覆盖。

<pre class=include>
path: syntax/requires_directive.syntax.bs.include
</pre>
<pre class=include>
path: syntax/software_extension_list.syntax.bs.include
</pre>

与其他指示符一样，如果存在[=requires-directive=]，它必须出现在所有[=declarations=]和[[#const-assert-statement|const assertions]]之前。
扩展名不是[=identifiers=]：它们不能[=resolves|resolve=]为[=declarations=]。

<table class='data'>
  <caption>Language extensions</caption>
  <thead>
    <tr><th style="width:30%">WGSL language extension
        <th>Description
  </thead>
  <tr><td>readonly_and_readwrite_storage_textures
      <td>允许在类型/存储纹理中使用"访问/读取"和"访问/读写"访问模式。
          此外，还添加了"textureBarrier"内建函数。
</table>

注意：WGSL 的目的是随着时间的推移，定义包含当时常见的语言扩展的所有功能的语言扩展。
在一个 "requires-directive" 中，这些扩展作为一种简化方式，用于列出所有这些常见功能。
它们代表着逐步增加的功能集合，可以将其视为一种语言版本。

## 全局诊断过滤器 ## {#global-diagnostic-directive}

全局诊断筛选器是一个其受影响范围为整个WGSL模块的诊断筛选器。
它是一个指令，因此出现在任何模块范围声明之前。
它的拼写类似于属性形式，但没有前导的@（U+0040）代码点，并以分号结尾。

<pre class=include>
path: syntax/diagnostic_directive.syntax.bs.include
</pre>

# 声明和范围 # {#declaration-and-scope}

<dfn noexport>声明</dfn>将一个标识符与以下类型的对象之一关联起来：

* 一个类型
* 一个类型生成器
* 一个值声明
* 一个变量
* 一个函数
* 一个形式参数
* 一个枚举值

换句话说，声明为对象引入了一个名称。

如果声明出现在程序源代码中，但在任何其他声明的文本之外，则该声明处于模块范围内。


函数声明出现在模块范围内。
函数声明包含形式参数的声明（如果有的话），并且它可以在函数体内包含变量和值的声明。
因此，这些包含的声明不在模块范围内。


注意：唯一包含另一个声明的声明是函数声明。

WebGPU实现提供了某些对象，并将其视为在WGSL模块源代码开始之前声明过。我们称这样的对象为<dfn noexport>预声明</dfn>。例如，WGSL预声明了：

* 内置函数，
* 内置类型如i32和f32，
* 内置类型生成器如"array"、"ptr"和"texture_2d"，以及
* 枚举值如"access/read_write"、"interpolation type/perspective"和"texel format/rgba8unorm"。

声明的范围是指声明标识符可能指代其关联对象的程序源位置的集合。我们说标识符在这些源位置上是<dfn noexport>有效范围内</dfn>的（对于该声明）。

声明出现的位置决定了其范围：

* 预声明的对象和在模块范围内声明的对象在整个程序源代码中都是有效范围内的。
* 用户声明的函数的每个形式参数在相应的函数体中都是有效范围内的。详见[[#function-declaration-sec]]。
* 否则，范围是从声明的结束位置之后开始的一段文本。详见[[#var-and-value]]。

同一个WGSL源程序中的两个声明不能同时：

* 引入相同的标识符名称，并且
* 拥有相同的作用域结束位置。

注意：预声明的对象在WGSL源代码中没有声明。
因此，模块范围内或函数内的用户指定声明可以和预声明对象具有相同的名称。

标识符的使用方式如下，根据语法上下文进行区分：

* 与[=syntax/ident=]语法元素匹配的标记：
    * 用于声明中，作为正在声明的对象的名称，或
    * 作为名称使用，表示在其他地方声明的对象。这是常见情况。
* 与[=syntax/member_ident=]语法元素匹配的标记：
    * 用于结构类型声明中，作为成员的名称，或
    * 作为名称使用，表示结构值的成员，或表示对结构成员的引用。参见[[#struct-access-expr]]。

当一个[=syntax/ident=]标记作为表示在其他地方声明的对象的名称时，
它在某个声明中必须处于范围之内。
标识符标记所表示的对象由以下方式确定：

* 如果该标记在至少一个非模块范围声明的范围之内， 则该标记表示与最近的那个声明相关联的对象。

    注意：最近的这样的声明会出现在标识符标记之前。

* 否则，如果存在具有该名称的模块范围声明，则该标记 表示已声明的对象。

    注意：模块范围的声明可以出现在标识符标记之前或之后。

* 否则，如果存在具有该名称的预声明对象，则该标记表示该对象。

当上述算法用于将标识符映射到声明时，我们说该标识符解析到该声明。类似地，我们也说标识符解析到所声明的对象。

如果任何模块范围的声明是递归的，那么这是一个着色器创建错误。也就是说，声明之间不能存在循环：

> 考虑以下有向图：
> * 每个节点对应一个声明 D。
> * 当 D 的定义提到一个解析为 T 的标识符时，存在从声明 D 到声明 T 的边。
>
>       这个图不能有循环。

注意：函数体是函数声明的一部分，因此函数不能是递归的，无论是直接还是间接递归。

注意：非模块范围的标识符声明必须在文本中使用之前。

<div class='example wgsl' heading='Valid and invalid declarations'>
  <xmp>
    // Valid, user-defined variables can have the same name as a built-in function.
    var<private> modf: f32 = 0.0;

    // Valid, foo_1 is in scope for the entire program.
    var<private> foo: f32 = 0.0; // foo_1

    // Valid, bar_1 is in scope for the entire program.
    var<private> bar: u32 = 0u; // bar_1

    // Valid, my_func_1 is in scope for the entire program.
    // Valid, foo_2 is in scope until the end of the function.
    fn my_func(foo: f32) { // my_func_1, foo_2
      // Any reference to 'foo' resolves to the function parameter.

      // Invalid, modf resolves to the module-scope variable.
      let res = modf(foo);

      // Invalid, the scope of foo_2 ends at the of the function.
      var foo: f32; // foo_3

      // Valid, bar_2 is in scope until the end of the function.
      var bar: u32; // bar_2
      // References to 'bar' resolve to bar_2
      {
        // Valid, foo_4 is in scope until the end of the compound statement.
        var foo : f32; // foo_4

        // Valid, bar_3 is in scope until the end of the compound statement.
        var bar: u32; // bar_3
        // References to 'bar' resolve to bar_3

        // Invalid, bar_4 has the same end scope as bar_3.
        var bar: i32; // bar_4

        // Valid, i_1 is in scope until the end of the for loop
        for ( var i: i32 = 0; i < 10; i++ ) { // i_1
          // Invalid, i_2 has the same end scope as i_1.
          var i: i32 = 1; // i_2.
        }
      }

      // Invalid, bar_5 has the same end scope as bar_2.
      var bar: u32; // bar_5

      // Valid, later_def, a module scope declaration, is in scope for the entire program.
      var early_use : i32 = later_def;
    }

    // Invalid, bar_6 has the same scope as bar_1.
    var<private> bar: u32 = 1u; // bar_6

    // Invalid, my_func_2 has the same end scope as my_func_1.
    fn my_func() { } // my_func_2

    // Valid, my_foo_1 is in scope for the entire program.
    fn my_foo( //my_foo_1
      // Valid, my_foo_2 is in scope until the end of the function.
      my_foo: i32 // my_foo_2
    ) { }

    var<private> later_def : i32 = 1;
  </xmp>
</div>

<div class='example wgsl' heading='Shadowing predeclared objects'>
  <xmp>
     // This declaration hides the predeclared 'min' built-in function.
     // Since this declaration is at module-scope, it is in scope over the entire
     // source.  The built-in function is no longer accessible.
     fn min() -> u32 { return 0; }

     const rgba8unorm = 12; // This shadows the predeclared 'rgba8unorm' enumerant.
  </xmp>
</div>

# 类型 # {#types}

程序计算值。

在WGSL中，<dfn noexport>类型</dfn>是一组值，每个值都属于且只属于一个类型。
值的类型确定了可以对该值执行的操作的语法和语义。

例如，数学中的1在WGSL中对应于以下不同的值：

* 32位有符号整数值1i,
* 32位无符号整数值1u,
* 32位浮点值1.0f,
* 如果启用了[f16扩展|f16 extension]，则为16位浮点值1.0h,
* [=AbstractInt=]值1，以及
* [=AbstractFloat=]值1.0

WGSL将它们视为不同，因为它们的机器表示和操作不同。

类型要么是[=预定义=]的，要么是通过WGSL源代码中的[=声明=]创建的。

一些类型被表示为[=模板参数化=]。
<dfn noexport>类型生成器</dfn>是一个[=预定义=]对象，当用[=模板列表=]参数化时，表示一个类型。
例如，类型atomic<u32>将类型生成器atomic与模板列表<u32>组合起来。


我们区分类型的概念和WGSL中表示该类型的语法。
在许多情况下，此规范中类型的拼写与其在WGSL中的语法相同。
例如：

32位无符号整数值集合在此规范中拼写为u32，在WGSL模块中也是如此。
结构类型或包含结构的类型的拼写不同。

一些WGSL类型仅用于分析源程序和确定程序的运行时行为。
本规范将描述这些类型，但它们不会出现在WGSL源代码中。


注意：[=引用类型=]不会在WGSL模块中编写。参见[[#ref-ptr-types]]。

## 类型检查 ## {#type-checking-section}

计算WGSL值是通过评估表达式来实现的。
表达式是源文本的一部分，被解析为以"expression"结尾的WGSL语法规则之一。
表达式E可以包含子表达式，这些子表达式是外部表达式E中正确包含的表达式。
顶层表达式是一个不是自己的子表达式的表达式。
参见[[#expression-grammar]]。


表达式评估产生的特定值取决于：

* 静态上下文：表达式周围的源文本，以及
* 动态上下文：评估表达式的调用状态，以及调用所在的执行上下文。

通过评估特定表达式可能得到的值将始终属于特定的WGSL类型，即表达式的静态类型。
WGSL的规则设计使得表达式的静态类型仅取决于表达式的静态上下文。

类型断言是将某个WGSL源表达式映射到一个WGSL类型的操作。
表示为

> *e* : *T*

这个类型断言表示WGSL表达式e的静态类型为T。

注意：类型断言是关于程序文本的一个事实陈述，它不是运行时的检查。

语句通常使用表达式，并可能对这些表达式的静态类型有要求。
例如：
* if语句的条件表达式必须是bool类型。
* 在具有指定显示类型的let声明中，初始化表达式必须求值为该类型。

对成功解析的WGSL模块进行类型检查是将每个表达式映射到它的静态类型，并验证每个语句的类型要求是否满足的过程。
如果类型检查失败，将出现一种特殊情况下的着色器创建错误，称为类型错误。

类型检查可以通过递归地应用类型规则到句法短语来进行，其中句法短语可以是表达式或语句。
类型规则描述了句法短语的静态上下文如何确定该短语中包含的表达式的静态类型。

一个[= 类型规则 =] 有两个部分：
* 一个[= 类型规则结论 =]。
    * 如果短语是一个表达式，结论是该表达式的[= 类型断言 =]。
    * 如果短语是一个语句，结论是一组[= 类型断言 =]，每个断言对应语句的[= 顶层表达式 =]。
    * 在这两种情况下，使用斜体的名称来指定[= 句法短语 =]， 来表示子表达式或其他语法确定的参数。
* [= 类型规则前提条件 =]，包括：
    * 对于表达式：
        * 当它具有子表达式时，对子表达式的类型断言。 每个断言可以通过直接满足或通过[= 可行的自动转换 =]（在[[ #conversion-rank ]]中定义）满足。
        * 表达式在语句中的使用方式。
    * 对于语句：
        * 语句的句法形式以及
        * 语句中的[= 顶层表达式 =]的类型断言。
    * 其他示意参数的条件（如果有）。
    * 可选的其他静态上下文。

类型规则在其前提条件和结论中可以包含[= 类型参数 =]。
当类型规则的结论或前提条件包含类型参数时，
我们说它是[= 参数化的 =]。
当它们不包含类型参数时，我们说该规则是[= 完全展开的 =]。
我们可以通过为规则的每个类型参数替换类型，
并在规则中的所有相同参数出现处使用相同的类型，
从参数化的规则生成一个完全展开的类型规则。
给规则的类型参数分配类型被称为[= 替换 =]。

例如，这是逻辑取反的类型规则（形式为!|e|）：

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论
  </thead>
  <tr algorithm="example boolean negation"><td>|e|: |T|<br>
  |T| 为 bool 或 vec|N|&lt;bool&gt;
  <td>`!`|e|`:` |T|
</table>

这是一个带参数的规则，因为它包含类型参数|T|，可以代表四种类型之一[=bool=]、vec2<bool>、vec3<bool>或vec4<bool>。
应用将|T|映射到vec3<bool>的替换，得到完全详细的类型规则：

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论
  </thead>
  <tr algorithm="example2 boolean negation"><td>|e|`: vec3<bool>`<br>
  <td>`!`|e|`: vec3<bool>`
</table>

我们通过应用满足规则其他条件的一些替换来从参数化规则中产生的每个完全阐述的规则被称为参数化规则的<dfn noexport>重载</dfn>。例如，布尔取反规则有四个重载，因为有四种可能的方式来为其类型参数|T|分配类型。

注意：
换句话说，参数化类型规则为一组完全阐述的类型规则提供了模式，每个模式通过对参数化规则应用不同的替换而产生。

当一个规则的结论与一个[=语法短句=]的有效解析相匹配，并且规则的前提条件得到满足时，一个类型规则将适用于该语法短句。

如果存在一个[=替换=]产生一个[=完全阐述=]的适用于该表达式的类型规则，那么一个[=参数化=]类型规则将适用于该表达式。

考虑表达式 1u+2u。
它有两个面值表达式：1u 和 2u，都是类型 u32。
[=顶层表达式=] 是一个加法。
参考算术表达式中的规则，加法的类型规则适用于该表达式，因为：

* 1u+2u 与 |e1|+|e2| 格式的解析相匹配，其中 |e1| 表示 1u，|e2| 表示 2u，并且
* |e1| 是类型 u32，而且
* |e2| 是类型 u32，而且
* 我们可以将 u32 替换类型参数 |T| 在类型规则中， 从而得到一个[=完全阐述=]的规则，适用于整个表达式。

在分析语法短语时，可能会出现三种情况：

* 表达式没有适用的类型规则。这会导致类型错误。
* 表达式只适用一个完全扩展的类型规则。 在这种情况下，规则的类型规则结论被断定，确定表达式的静态类型。
* 适用多个类型规则。也就是说，满足了多个重载的前提条件。 在这种情况下，使用[[#overload-resolution-section]]中描述的解决冲突的过程。
    * 如果重载解析成功，则确定一个适用于表达式的重载。 在该重载的类型规则结论中断言类型规则，并因此确定表达式或语法短语中的表达式的类型。
    * 如果重载解析失败，则会导致类型错误。

继续上面的例子，表达式1u+2u只适用一条类型规则，因此类型检查接受该类型规则的结论，即1u+2u的类型为u32。


当满足以下条件时，WGSL源程序被称为是"类型良好"的：

* 通过应用类型规则可以确定程序中每个表达式的静态类型。
* 满足每个语句的类型要求。

否则，存在类型错误，源程序不是有效的WGSL模块。

WGSL是一种"静态类型语言"，因为对WGSL模块进行类型检查要么成功，要么发现类型错误，而只需要检查程序源文本。

### 类型规则表 ### {#typing-tables-section}

表达式的WGSL[=类型规则=]按照<dfn noexport>类型规则表</dfn>进行组织，每个类型规则占据一行。


<dfn noexport>表达式的语义</dfn>是对该表达式进行评估的效果，主要是产生一个结果值。
适用于表达式的类型规则的描述列将指定表达式的语义。
语义通常取决于类型规则参数的值，包括任何子表达式的假定值。
有时，表达式的语义包括除产生结果值之外的其他影响，例如其子表达式的非结果值影响。

<div class='example' heading="Side-effect of an expression">
  <xmp>
    fn foo(p : ptr<function, i32>) -> i32 {
      let x = *p;
      *p += 1;
      return x;
    }

    fn bar() {
      var a: i32;
      let x = foo(&a); // the call to foo returns a value
                       // and updates the value of a
    }
  </xmp>
</div>

### 转化排名 ### {#conversion-rank}

当一个类型断言|e|:|T|被用作[=类型规则前提条件=]时，有以下情况时它被满足：

* |e|已经是类型|T|，或者
* |e|是类型|S|，并且类型|S|可以自动转换成类型|T|，如下所定义。

该规则由下表中定义的对类型对的<dfn>ConversionRank</dfn>函数所编码。
[=ConversionRank=]函数表达了自动转换一个类型(Src)到另一个类型(Dest)的偏好和可行性。
较低的rank更优先。

一个<dfn>可行的自动转换</dfn>将一个值从类型Src转换为类型Dest，并且当[=ConversionRank=]是有限的时允许进行。
这样的转换会保持值不变，但受到[[#floating-point-evaluation]]中描述的限制。

注意：自动转换只发生在两种情况下。
首先，当将一个[=const-expression=]转换为可以在GPU上使用的对应的类型化数值时。
其次，当从引用内存加载时，产生的值是存储在该内存中的值。

注意：无限rank的转换是不可行的，即不允许的。

注意：当没有进行转换时，转换rank为零。

<table class='data'>
  <caption>
    ConversionRank from one type to another
  </caption>
  <thead>
    <tr><th>Src
        <th>Dest
        <th>ConversionRank(Src,Dest)
        <th>Description
  </thead>
  <tr algorithm="conversion rank identity">
      <td>|T|
      <td>|T|
      <td>0
      <td>Identity. No conversion performed.
  <tr algorithm="conversion rank from reference via load rule">
      <td>ref&lt;|AS|,|T|,|AM|&gt;<br>for [=address space=] |AS|,
          and where [=access mode=] |AM| is [=access/read=] or [=access/read_write=].
      <td>|T|
      <td>0
      <td>Apply the [=Load Rule=] to load a value from a memory reference.
  <tr algorithm="conversion rank abstract float to f32">
      <td>[=AbstractFloat=]
      <td>f32
      <td>1
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract float to f16">
      <td>[=AbstractFloat=]
      <td>f16
      <td>2
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract int to i32">
      <td>[=AbstractInt=]
      <td>i32
      <td>3
      <td>Identity if the value is in [=i32=].
          Produces a [=shader-creation error=] otherwise.
  <tr algorithm="conversion rank abstract int to u32">
      <td>[=AbstractInt=]
      <td>u32
      <td>4
      <td>Identity if the value is in [=u32=].
          Produces a [=shader-creation error=] otherwise.
  <tr algorithm="conversion rank abstract int to abstract float">
      <td>[=AbstractInt=]
      <td>[=AbstractFloat=]
      <td>5
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract int to f32">
      <td>[=AbstractInt=]
      <td>f32
      <td>6
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f32
  <tr algorithm="conversion rank abstract int to f16">
      <td>[=AbstractInt=]
      <td>f16
      <td>7
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f16
  <tr algorithm="conversion rank abstract vector">
      <td>vec|N|&lt;|S|&gt;
      <td>vec|N|&lt;|T|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component type.
  <tr algorithm="conversion rank abstract matrix">
      <td>mat|C|x|R|&lt;|S|&gt;
      <td>mat|C|x|R|&lt;|T|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component type.
  <tr algorithm="conversion rank abstract array">
      <td>array&lt;|S|,|N|&gt;
      <td>array&lt;|T|,|N|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component type.
      Note: Only [=fixed-size arrays=] may have an [=type/abstract=] component type.
  <tr algorithm="conversion rank for frexp result">
      <td>__frexp_result_abstract
      <td>__frexp_result_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for frexp result f16">
      <td>__frexp_result_abstract
      <td>__frexp_result_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for frexp result vector">
      <td>__frexp_result_vecN_abstract
      <td>__frexp_result_vecN_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for frexp result vector f16">
      <td>__frexp_result_vecN_abstract
      <td>__frexp_result_vecN_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for modf result">
      <td>__modf_result_abstract
      <td>__modf_result_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for modf result f16">
      <td>__modf_result_abstract
      <td>__modf_result_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for modf result vector">
      <td>__modf_result_vecN_abstract
      <td>__modf_result_vecN_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for modf result vector f16">
      <td>__modf_result_vecN_abstract
      <td>__modf_result_vecN_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for non-convertible cases">
      <td><var ignore>S</var>
      <td><var ignore>T</var><br>where above cases don't apply
      <td>infinity
      <td>There are no automatic conversions between other types.
</table>

如果类型T是类型S的具体化，则满足以下条件：

* T是具体类型，且
* T不是引用类型，且
* ConversionRank(S, T)是有限的，且
* 对于任何其他非引用类型T2，有 ConversionRank(S, T2) > ConversionRank(S, T)

一个类型为T的值e的具体化是通过对e应用将T映射到具体化的可行转换得到的值。


备注：将类型转换为f32始终优先于f16，因此仅当模块中启用了f16扩展时，自动转换才会产生f16。

### 过载解析 ### {#overload-resolution-section}

当一个句法短语拥有多个类型规则适用时，需要使用一种决策过程来确定哪个规则生效。这个过程被称为重载解析（overload resolution），并假设类型检查已成功找到了句法短语的静态类型。

考虑一个句法短语P，以及适用于P的所有类型规则。重载解析算法将这些类型规则称为重载候选。对于每个候选：

* 它的前提条件已经直接或通过可行的自动转换得到满足。
* 它的结论具有：与P的有效解析匹配的句法形式，以及与P中每个顶级表达式相对应的类型断言。

对于P的重载解析的步骤如下，目标是找到一个最适合的重载候选：

1. 对于每个候选C，在句法短语中枚举子表达式的转换等级。候选的前提条件已经满足，因此对于P中的第i个子表达式：

    * 其静态类型已计算。
    * 存在一种从表达式的静态类型到前提条件中所需类型的可行自动转换。
        让C.R(i)是该转换的转换等级。

1. 消除任何其中一个子表达式在可行自动转换后解析为抽象类型，但候选的另一个子表达式不是常量表达式的情况。

    注：作为后果，如果短语中的任何子表达式不是常量表达式，则短语中的所有子表达式都必须具有具体类型。


1. 对候选进行排名：给定两个重载候选C1和C2，如果C1在C2之前执行，则C1优先于C2的定义如下：

    * 对于P中的每个表达式位置i，C1.R(i)≤C2.R(i)。
        * 即，将C1应用于P所需的每个表达式转换至少与将C2应用于P所需的相应表达式转换一样优先。
    * 至少存在一个表达式位置i，其中C1.R(i)<C2.R(i)。
        * 即，至少存在一个将C1应用所需的表达式转换比将C2应用所需的相应转换更优先的情况。

1. 如果存在一个候选C，它在所有其他候选之上都是最优的，则重载解析成功，得到候选类型规则C。否则，重载解析失败。

## 简单类型 ## {#plain-types-section}

[=Plain types=] 是用于机器表示的布尔值、数字、向量、矩阵或这些值的聚合的类型。

一个 <dfn>plain type</dfn> 可以是一个 [=scalar=] 类型，一个 [=atomic type|atomic=] 类型，或者一个 [=composite=] 类型。

注意：WGSL 中的 Plain types 类似于 C++ 中的 Plain-Old-Data types，但也包括原子类型和抽象数值类型。

### 抽象数字类型 ### {#abstract-types}

这些类型在WGSL源代码中不能被拼写出来，它们只用于类型检查。


某些表达式在着色器模块创建时进行求值，其数值范围和精度可能大于GPU直接实现的范围。


WGSL为这些求值定义了两个<dfn>抽象数值类型</dfn>：
* <dfn noexport>AbstractInt</dfn>类型是整数|i|的集合，满足-2<sup>63</sup> ≤ |i| < 2<sup>63</sup>。
* <dfn noexport>AbstractFloat</dfn>类型是可以表示在[[!IEEE-754|IEEE-754]] binary64（双精度）格式中的有限浮点数集。


在这些类型之一的表达式求值中，不能溢出或产生无限或NaN值。


如果一个类型是抽象数值类型或包含抽象数值类型，则该类型是<dfn dfn-for="type" noexport>抽象的</dfn>。
如果一个类型不是抽象类型，则该类型是<dfn dfn-for="type" noexport>具体的</dfn>。


没有后缀的[=numeric literal=]表示一个[=abstract numeric type=]中的值：
* 没有i或u后缀的[=integer literal=]表示[=AbstractInt=]值。
* 没有f或h后缀的[=floating point literal=]表示[=AbstractFloat=]值。


例子：表达式log2(32)的分析如下：


* log2(32)被解析为对具有操作数[=AbstractInt=]值32的内建函数log2的函数调用。
* log2没有带有[=integer scalar=]形式参数的重载。
* 取而代之的是，进行[=overload resolution=]，考虑三个可能的重载和[=feasible automatic conversions=]：
  * [=AbstractInt=]转换为[=AbstractFloat=]。（转换秩为4）
  * [=AbstractInt=]转换为[=f32=]。（转换秩为5）
  * [=AbstractInt=]转换为[=f16=]。（转换秩为6）
  * 结果计算为[=AbstractFloat=]（例如log2(32.0)）。

例子：表达式1 + 2.5的分析如下：

* 1 + 2.5被解析为加法运算，其子表达式为[=AbstractInt=]值1和[=AbstractFloat=]值2.5。
* 没有整数类型和浮点类型的|===|运算重载。
* 但是，使用可行的自动转换，有三个潜在的重载：
    * 1被转换为[=AbstractFloat=]值1.0（秩为4）且2.5保持不变为[=AbstractFloat=]（秩为0）。
    * 1被转换为[=f32=]值1.0f（秩为5）且2.5被转换为[=f32=]值2.5f（秩为1）。
    * 1被转换为[=f16=]值1.0f（秩为6）且2.5被转换为[=f16=]值2.5h（秩为2）。
    * 第一个重载是[=preferable candidate=]，类型检查成功。
    * 结果计算为[=AbstractFloat=] 1.0 + 2.5。

例子：let x = 1 + 2.5;


这个例子与上面的例子类似，只是x不能解析为[=abstract numeric type=]。
因此，存在两个可行的重载候选：使用[=f32=]或[=f16=]进行加法运算。
[=preferable candidate=]使用[=f32=]。
声明的效果就像写作let x：f32 = 1.0 + 2.5f;一样。

例子：1u + 2.5会导致[=shader-creation error=]：
* 1u项是一个类型为[=u32=]的表达式。
* 2.5项是一个类型为[=AbstractFloat=]的表达式。
* 没有有效的重载候选：
    * 没有可行的自动将GPU实例化的[=integer scalar=]类型转换为浮点类型。
    * 没有类型规则能够匹配将e+f，其中e为[=integer scalar=]类型，f为浮点类型。

<div class='example literals' heading="Type inference for literals">
  <xmp>
    // Explicitly-typed unsigned integer literal.
    var u32_1 = 1u; // variable holds a u32

    // Explicitly-typed signed integer literal.
    var i32_1 = 1i; // variable holds a i32

    // Explicitly-typed floating point literal.
    var f32_1 = 1f; // variable holds a f32

    // Explicitly-typed unsigned integer literal cannot be negated.
    var u32_neg = -1u; // invalid: unary minus does not support u32

    // When a concrete type is required, but no part of the statement or
    // expression forces a particular concrete type, an integer literal is
    // interpreted as an i32 value:
    //   Initializer for a let-declaration must be constructible (or pointer).
    //   The most preferred automatic conversion from AbstractInt to a constructible type
    //   is AbstractInt to i32, with conversion rank 2.  So '1' is inferred as i32.
    let some_i32 = 1; // like let some_i32: i32 = 1i;

    // Inferred from declaration type.
    var i32_from_type : i32 = 1; // variable holds i32.  AbstractInt to i32, conversion rank 2
    var u32_from_type : u32 = 1; // variable holds u32.  AbstractInt to u32, conversion rank 3

    // Unsuffixed integer literal can convert to floating point when needed:
    //   Automatically convert AbstractInt to f32, with conversion rank 5.
    var f32_promotion : f32 = 1; // variable holds f32

    // Invalid: no feasible conversion from floating point to integer
    var i32_demotion : i32 = 1.0; // Invalid

    // Inferred from expression.
    var u32_from_expr = 1 + u32_1; // variable holds u32
    var i32_from_expr = 1 + i32_1; // variable holds i32

    // Values must be representable.
    let u32_too_large   : u32 = 1234567890123456890; // invalid, overflow
    let i32_too_large   : i32 = 1234567890123456890; // invalid, overflow
    let u32_large : u32 = 2147483649; // valid
    let i32_large : i32 = 2147483649; // invalid, overflow
    let f32_out_of_range1 = 0x1p500; // invalid, out of range
    let f32_hex_lost_bits = 0x1.0000000001p0; // invalid, not exactly representable in f32

    // Minimum integer: unary negation over AbstractInt, then infer i32.
    // Most preferred conversion from AbstractInt to a constructible type (with lowest
    // conversion rank) is AbstractInt to i32.
    let i32_min = -2147483648;  // has type i32

    // Invalid.  Select AbstractInt to i32 as above, but the value is out of
    // range, producing shader-creation error.
    let i32_too_large_2 = 2147483648; // Invalid.

    // Subexpressions can resolve to AbstractInt and AbstractFloat.
    // The following examples are all valid and the value of the variable is 6u.
    var u32_expr1 = (1 + (1 + (1 + (1 + 1)))) + 1u;
    var u32_expr2 = 1u + (1 + (1 + (1 + (1 + 1))));
    var u32_expr3 = (1 + (1 + (1 + (1u + 1)))) + 1;
    var u32_expr4 = 1 + (1 + (1 + (1 + (1u + 1))));

    // Inference based on built-in function parameters.

    // Most-preferred candidate is clamp(i32,i32,i32)->i32
    let i32_clamp = clamp(1, -5, 5);
    // Most preferred candidate is clamp(u32,u32,u32).
    // Literals use automatic conversion AbstractInt to u32.
    let u32_clamp = clamp(5, 0, u32_from_expr);
    // Most preferred candidate is clamp(f32,f32,f32)->f32
    // literals use automatic conversion AbstractInt to f32.
    let f32_clamp = clamp(0, f32_1, 1);

    // The following examples all promote to f32 with an initial value of 10f.
    let f32_promotion1 = 1.0 + 2 + 3 + 4;
    let f32_promotion2 = 2 + 1.0 + 3 + 4;
    let f32_promotion3 = 1f + ((2 + 3) + 4);
    let f32_promotion4 = ((2 + (3 + 1f)) + 4);

    // Type rule violations.

    // Invalid, the initializer can only resolve to f32:
    // No feasible automatic conversion from AbstractFloat to u32.
    let mismatch : u32 = 1.0;

    // Invalid. There is no overload of clamp that allows mixed sign parameters.
    let ambiguous_clamp = clamp(1u, 0, 1i);

    // Inference completes at the statement level.

    // Initializer for a let-declaration must be constructible (or pointer).
    // The most preferred automatic conversion from AbstractInt to a constructible type
    // is AbstractInt to i32, with conversion rank 2.  So '1' is inferred as i32.
    let some_i32 = 1; // like let some_i32: i32 = 1i;

    let some_f32 : f32 = some_i32; // Type error: i32 cannot be assigned to f32

    // Another overflow case
    let overflow_u32 = (1 -2) + 1u; // invalid, -1 is out of range of u32

    // Ideal value out of range of 32-bits, but brought back into range
    let out_and_in_again = (0x1ffffffff / 8);

    // Similar, but invalid
    let out_of_range = (0x1ffffffff / 8u); // requires computation is done in 32-bits,
                                           // making 0x1ffffffff out of range.

  </xmp>
</div>

### 布尔类型 ### {#bool-type}

<dfn noexport>bool</dfn> 类型包括值 `true` 和 `false`.

<table class='data'>
  <caption>Boolean literal type rules</caption>
  <thead>
    <tr><th>前提条件<th>结论<th>描述
  </thead>
  <tr><td><td>`true`: bool<td>The true value.
  <tr><td><td>`false`: bool<td>The false value.
</table>

### 整数类型 ### {#integer-types}

<dfn noexport>u32</dfn>类型是由32位无符号整数组成的集合。

<dfn noexport>i32</dfn>类型是由32位有符号整数组成的集合。它使用二进制补码表示，其中符号位位于最高有效位的位置。

<table class='data'>
  <caption>整数类型的极值</caption>
  <thead>
    <tr><th>Type<th>最小值<th>最大值
  </thead>
    <tr><td rowspan=2>i32<td>i32(-2147483648)<td>2147483647i
    <tr><td>i32(-0x80000000)<td>0x7fffffffi
    <tr><td rowspan=2>u32<td>0u<td>4294967295u
    <tr><td>0x0u<td>0xffffffffu
</table>

注意：[=AbstractInt=]也是一种整数类型。

### 浮点数类型 ### {#floating-point-types}

<f32>类型是[[!IEEE-754|IEEE-754]]二进制32位浮点格式（单精度）的32位浮点值集合。有关详细信息，请参见[[#floating-point-evaluation]]。


<f16>类型是[[!IEEE-754|IEEE-754]]二进制16位浮点格式（半精度）的16位浮点值集合。如果在程序中未包含enable f16;指令以启用[=extension/f16|f16扩展=]，则使用<f16>类型会引发[=shader-creation error=]。有关详细信息，请参见[[#floating-point-evaluation]]。


下表列出了浮点类型的某些极限值。每个值都有对应的负值。
<table class='data'>
  <caption>Extreme values for floating point types</caption>
  <thead>
    <tr><th>Type<th>Smallest positive denormal<th>Smallest positive normal<th>Largest positive finite<th>Largest finite power of 2
  </thead>
    <tr><td rowspan=2>f32<td>1.40129846432481707092e-45f<td>1.17549435082228750797e-38f<td>3.40282346638528859812e+38f<td rowspan=2>0x1p+127f
    <tr><td>0x1p-149f<td>0x1p-126f<td>0x1.fffffep+127f
    <tr><td rowspan=2>f16<td>5.9604644775390625e-8h<td>0.00006103515625h<td>65504.0h<td rowspan=2>0x1p+15h
    <tr><td>0x1p-24h<td>0x1p-14h<td>0x1.ffcp+15h
</table>

注意：[=AbstractFloat=]也是一种浮点类型。

### 标量类型 ### {#scalar-types}

<dfn noexport>标量</dfn>类型有bool、AbstractInt、AbstractFloat、i32、u32、f32和f16。


数值标量类型有AbstractInt、AbstractFloat、i32、u32、f32和f16。


整数标量类型有AbstractInt、i32和u32。

### 向量类型 ### {#vector-types}

<dfn noexport>向量</dfn>是由2、3或4个[=标量=]组成的序列。
components.

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr><td>vec*N*<*T*><td>类型为T的N个组件的向量。N必须取{2, 3, 4}之一，而T必须是标量类型之一。我们将T称为向量的<dfn noexport>组件类型</dfn>。
</table>

如果一个向量的组件类型是标量数值类型，那么它就是一个数值向量。


向量的主要用途包括：

* 表示方向和大小。
* 表示空间中的位置。
* 在某种颜色空间中表示颜色。 例如，各个分量可以表示红、绿、蓝的强度，而第四个分量可以表示 alpha（透明度）值。

向量上的许多操作都是组件逐个进行的，即通过独立地对每个分量进行操作来形成结果向量。

<div class='example wgsl type-scope' heading='Vector'>
  <xmp>
    vec2<f32>  // is a vector of two f32s.
  </xmp>
</div>

<div class='example wgsl function-scope component-wise addition' heading='Component-wise addition'>
  <xmp>
    let x : vec3<f32> = a + b; // a and b are vec3<f32>
    // x[0] = a[0] + b[0]
    // x[1] = a[1] + b[1]
    // x[2] = a[2] + b[2]
  </xmp>
</div>

WGSL还预声明了以下类型别名：

<table class='data'>
  <thead>
    <tr>
        <th>Predeclared alias
        <th>Original type
        <th>Restrictions
  </thead>
  <tr>
      <td><dfn noexport>vec2i</dfn>
      <td>vec2&lt;i32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec3i</dfn>
      <td>vec3&lt;i32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec4i</dfn>
      <td>vec4&lt;i32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec2u</dfn>
      <td>vec2&lt;u32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec3u</dfn>
      <td>vec3&lt;u32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec4u</dfn>
      <td>vec4&lt;u32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec2f</dfn>
      <td>vec2&lt;f32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec3f</dfn>
      <td>vec3&lt;f32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec4f</dfn>
      <td>vec4&lt;f32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec2h</dfn>
      <td>vec2&lt;f16&gt;
      <td rowspan=3>Requires the [=extension/f16|f16 extension=].
  <tr>
      <td><dfn noexport>vec3h</dfn>
      <td>vec3&lt;f16&gt;
  <tr>
      <td><dfn noexport>vec4h</dfn>
      <td>vec4&lt;f16&gt;
</table>

### 矩阵类型 ### {#matrix-types}

一个矩阵是由2、3或4个浮点向量组成的分组序列。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="matrix type">
    <td>mat|C|x|R|&lt;|T|&gt;
    <td>类型为 |T| 的 |C| 列和 |R| 行的矩阵，其中 |C| 和 |R| 都在 {2, 3, 4} 中，而 |T| 必须为 [=f32=]、[=f16=] 或 [=AbstractFloat=]。
等价地，它可以被视为类型为 vec|R|<T> 的 |C| 列向量。
</table>

矩阵的关键用途是体现线性变换。
在这个解释中，矩阵的向量被视为列向量。

乘法运算符（*）被用于以下操作之一：

* 通过标量大小缩放变换。
* 对向量应用变换。
* 将变换与另一个矩阵结合。

参见[[#arithmetic-expr]]。

<div class='example wgsl type-scope' heading='Matrix'>
  <xmp>
    mat2x3<f32>  // This is a 2 column, 3 row matrix of 32-bit floats.
                 // Equivalently, it is 2 column vectors of type vec3<f32>.
  </xmp>
</div>

WGSL也[=指定预定义预定义=]以下[=类型别名=]：

<table class='data'>
  <thead>
    <tr>
        <th>Predeclared alias
        <th>Original type
        <th>Restrictions
  </thead>
  <tr> <td><dfn noexport>mat2x2f</dfn> <td>mat2x2&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat2x3f</dfn> <td>mat2x3&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat2x4f</dfn> <td>mat2x4&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat3x2f</dfn> <td>mat3x2&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat3x3f</dfn> <td>mat3x3&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat3x4f</dfn> <td>mat3x4&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat4x2f</dfn> <td>mat4x2&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat4x3f</dfn> <td>mat4x3&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat4x4f</dfn> <td>mat4x4&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat2x2h</dfn> <td>mat2x2&lt;f16&gt; <td rowspan=9>Requires the [=extension/f16|f16 extension=].
  <tr> <td><dfn noexport>mat2x3h</dfn> <td>mat2x3&lt;f16&gt;
  <tr> <td><dfn noexport>mat2x4h</dfn> <td>mat2x4&lt;f16&gt;
  <tr> <td><dfn noexport>mat3x2h</dfn> <td>mat3x2&lt;f16&gt;
  <tr> <td><dfn noexport>mat3x3h</dfn> <td>mat3x3&lt;f16&gt;
  <tr> <td><dfn noexport>mat3x4h</dfn> <td>mat3x4&lt;f16&gt;
  <tr> <td><dfn noexport>mat4x2h</dfn> <td>mat4x2&lt;f16&gt;
  <tr> <td><dfn noexport>mat4x3h</dfn> <td>mat4x3&lt;f16&gt;
  <tr> <td><dfn noexport>mat4x4h</dfn> <td>mat4x4&lt;f16&gt;
</table>

### 原子类型 ### {#atomic-types}

一个原子类型(encapsulates)封装了一个具体的整数标量类型，具体而言：

* 原子对象提供给并发观察者[[#memory-model|某些保证]]，
* 原子对象上唯一有效的操作是[[#atomic-builtin-functions|原子内置函数]]。

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr algorithm="atomic type"><td>atomic&lt;|T|&gt;
    <td>Atomic of type |T|. |T| [=shader-creation error|must=] be either [=u32=] or [=i32=].
</table>

表达式不得评估为原子类型。


原子类型只能由地址空间中的变量或具有读写访问模式的存储缓冲变量实例化。
对该类型的操作的内存范围由它实例化的地址空间确定。
地址空间中的原子类型具有"工作组"内存范围，而地址空间/存储中的原子类型具有"队列族"内存范围。


原子修改是对原子对象进行的任何操作，该操作设置对象的内容。
即使新值与对象的现有值相同，该操作也被视为修改。


在WGSL中，针对每个对象，原子修改是相互有序的。
也就是说，在着色器阶段执行期间，对于每个原子对象A，所有代理观察到对A应用的修改操作的相同顺序。
不同原子对象的排序可能没有任何关联；不暗示任何因果关系。
请注意，地址空间/工作组空间中的变量在计算着色器阶段/工作组内共享，但在不同工作组之间不共享。


### 数组类型 ### {#array-types}

一个<dfn noexport>数组</dfn>是一个可索引的元素值序列。

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr><td algorithm="fixed-size array type">array&lt;|E|,|N|&gt;
      <td>A <dfn>具有 |N| 个元素，类型为 |E| 的定长数组。<br> |N| 被称为数组的元素计数。
  <tr><td algorithm="runtime-sized array type">array&lt;|E|&gt;
      <td>A <dfn noexport>runtime-sized</dfn> 元素类型为|E|的数组。这些数组只能出现在特定的上下文中。
</table>

数组中的第一个元素位于索引0，每个后续元素位于下一个整数索引位置。
参见[[#array-access-expr]]。

一个表达式[=shader-creation error|不能=]求值为运行时大小的数组类型。

固定大小数组的元素计数表达式|N|受到以下约束：

* 它[=shader-creation error|必须=]是一个[=override-expression=]。
* 它[=shader-creation error|必须=]求值为[=type/concrete=]的[=integer scalar=]。
* 如果|N|不大于零，这是一个[=pipeline-creation error=]。

注意：元素计数的值在[=pipeline creation=]时完全确定。


注意：为了符合类型等效性，任何非const表达式的override表达式必须是一个identifier。
参见<a href="#example-workgroup-variables-sized-by-override">通过可重写常量确定尺寸的工作组变量</a>


运行时大小数组的元素数量由与相应的[=storage buffer=]变量相关联的缓冲绑定的大小确定。
参见[[#buffer-binding-determines-runtime-sized-array-element-count]]。

数组元素类型[=shader-creation error|必须=]是以下之一：

* [=scalar=]类型
* [=vector=]类型
* [=matrix=]类型
* [=atomic type|atomic=]类型
* 具有[=creation-fixed footprint=]的[=array=]类型
* 具有[=creation-fixed footprint=]的[=structure=]类型。

注意：元素类型必须是[=plain type=]。


当且仅当以下所有条件为真时，两个数组类型才相同：

* 它们具有相同的元素类型。
* 它们的元素计数规格匹配，即以下之一为真：
    * 它们都是运行时大小的。
    * 它们都是具有[=creation-fixed footprint=]的固定大小，且元素计数相等，即使其中一个是有符号的，另一个是无符号的。 (在这种情况下，有符号和无符号值是可比较的，因为元素计数始终为正数。)
    * 它们都是具有以标识符[=resolves|resolving=]到相同的[=pipeline-overridable=]常量声明的元素计数的固定大小。

<div class='example wgsl fixed-size array types' heading='Example fixed-size array types, non-overridable element count'>
  <xmp>
    // array<f32,8> and array<i32,8> are different types:
    // different element types
    var<private> a: array<f32,8>;
    var<private> b: array<i32,8>;
    var<private> c: array<i32,8u>;  // array<i32,8> and array<i32,8u> are the same type

    const width = 8;
    const height = 8;

    // array<i32,8>, array<i32,8u>, and array<i32,width> are the same type.
    // Their element counts evaluate to 8.
    var<private> d: array<i32,width>;

    // array<i32,height> and array<i32,width> are the same type.
    var<private> e: array<i32,width>;
    var<private> f: array<i32,height>;
  </xmp>
</div>

注意: 唯一有效的使用可受覆盖常量调整大小的数组类型是作为地址空间/工作组地址空间中的[内存视图]。
这包括工作组变量的存储类型。
请参见[[#var-and-value]]。

<div class='example wgsl global-scope'
   heading="Workgroup variables sized by overridable constants"
   id="example-workgroup-variables-sized-by-override">
  <xmp>
    override blockSize = 16;

    var<workgroup> odds: array<i32,blockSize>;
    var<workgroup> evens: array<i32,blockSize>; // Same type

    // None of the following have the same type as 'odds' and 'evens'.

    // Different type: Not the identifier 'blockSize'
    var<workgroup> evens_0: array<i32,16>;
    // Different type: Uses arithmetic to express the element count.
    var<workgroup> evens_1: array<i32,(blockSize * 2 / 2)>;
    // Different type: Uses parentheses, not just an identifier.
    var<workgroup> evens_2: array<i32,(blockSize)>;

    // An invalid example, because the overridable element count may only occur
    // at the outer level.
    // var<workgroup> both: array<array<i32,blockSize>,2>;

    // An invalid example, because the overridable element count is only
    // valid for workgroup variables.
    // var<private> bad_address_space: array<i32,blockSize>;
  </xmp>
</div>

### 结构类型 ### {#struct-types}

一个<dfn noexport>结构</dfn>是具有命名的<dfn noexport>成员</dfn>值的命名分组。

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr algorithm="structure type">
      <td>`struct`&nbsp;|AStructName|&nbsp;{<br>
           &nbsp;&nbsp;<var ignore>M<sub>1</sub></var> : <var ignore>T<sub>1</sub></var>,<br>
           &nbsp;&nbsp;...<br>
           &nbsp;&nbsp;<var ignore>M<sub>N</sub></var> : <var ignore>T<sub>N</sub></var>,<br>
           }
      <td> 一个名为[=identifier=] |AStructName| 的结构类型的声明，
          该结构类型具有|N|个成员，
          其中成员<var ignore>i</var>的名称由标识符<var ignore>M<sub>|i|</sub></var>确定，
          并且是类型<var ignore>T<sub>|i|</sub></var>。


          |N| [=shader-creation error|必须=]至少为1。

          同一类型的两个成员[=shader-creation error|不能=]具有相同的名称。
</table>

结构类型在模块作用域下声明。
程序源代码中，结构类型由其标识符名称表示。
请参见[[#declaration-and-scope]]。

两个结构类型仅在它们具有相同的名称时才相同。

结构成员类型必须是以下之一：

* 标量类型
* 向量类型
* 矩阵类型
* 原子类型
* 具有固定大小的数组类型和固定的创建大小
* 但仅当它是结构的最后一个成员时，它可以是运行时大小数组类型
* 具有固定创建大小的结构类型

注意：所有用户声明的结构类型都是具体类型。


注意：每个成员类型必须是纯类型。


一些限制结构成员和数组元素类型的后果包括：

* 指针、纹理或采样器不能在数组或结构的嵌套级别中出现。
* 当运行时大小数组是较大类型的一部分时，它只能出现在结构的最后一个元素中，而结构本身不能是外部数组或结构的一部分。

<div class='example wgsl global-scope' heading="Structure">
  <xmp>
    // A structure with three members.
    struct Data {
      a: i32,
      b: vec2<f32>,
      c: array<i32,10>, // last comma is optional
    }

    // Declare a variable storing a value of type Data.
    var<private> some_data: Data;
  </xmp>
</div>

<pre class=include>
path: syntax/struct_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/struct_body_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/struct_member.syntax.bs.include
</pre>

可以应用以下属性到结构成员：

* [=attribute/align=]（对齐）
* [=attribute/builtin=]（内建）
* [=attribute/location=]（位置）
* [=attribute/interpolate=]（插值）
* [=attribute/invariant=]（不变性）
* [=attribute/size=]（大小）

属性[=attribute/builtin=]，[=attribute/location=]，[=attribute/interpolate=]和[=attribute/invariant=]是IO属性。
在结构体S的成员上使用IO属性仅在S用作形式参数或入口点的返回类型时生效。
参见[[#stage-inputs-outputs]]。


属性[=attribute/align=]和[=attribute/size=]是布局属性，
如果结构类型用来定义统一缓冲区或存储缓冲区，则可能需要这些属性。
参见[[#memory-layouts]]。

<div class='example wgsl global-scope' heading='Structure declaration'>
  <xmp>
    struct my_struct {
      a: f32,
      b: vec4<f32>
    }
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Structure used to declare a buffer'>
  <xmp>
    // Runtime Array
    alias RTArr = array<vec4<f32>>;
    struct S {
      a: f32,
      b: f32,
      data: RTArr
    }
    @group(0) @binding(0) var<storage> buffer: S;
  </xmp>
</div>

### 组合类型 ### {#composite-types}

如果一个类型有作为其他类型组合的内部结构，则它是复合类型。内部部分不重叠，并且被称为组件。复合值可以被分解为其组件。参见[[#composite-value-decomposition-expr]]。


复合类型包括：

* 向量类型
* 矩阵类型
* 数组类型
* 结构类型

对于一个复合类型|T|，其嵌套深度|T|的定义为：

* 向量类型的嵌套深度为1
* 矩阵类型的嵌套深度为2
* 数组类型（元素类型为|E|）的嵌套深度为1 + NestDepth(|E|)
* 结构类型（成员类型为M<sub>1</sub>，…，M<sub>N</sub>）的嵌套深度为1 + max(NestDepth(M<sub>1</sub>)，…，NestDepth(M<sub>N</sub>))


### 可构建类型 ### {#constructible-types}

许多种类的值可以被创建、加载、存储、传递到函数中，并从函数中返回。
我们将这些称为"可构造的"。


如果类型属于以下之一，则称其为"可构造的"：

* 标量类型
* 向量类型
* 矩阵类型
* 如果固定大小数组类型具有"已创建的固定占用空间"属性，并且其元素类型是可构造的，则此类型也属于可构造的。
* 如果结构类型的所有成员都是可构造的，则此类型也属于可构造的。

注：所有可构造类型都具有"已创建的固定占用空间"属性。


注：原子类型和运行时大小的数组类型不可构造。
不可构造包含原子和运行时大小数组的复合类型。

### 固定足迹类型 ### {#fixed-footprint-types}

变量的<dfn noexport>内存占用</dfn>是用于存储变量内容的内存空间的数量。
变量的内存占用取决于其存储类型，并在着色器生命周期的某个时刻确定。
大多数变量在着色器模块创建时就确定大小。
有些变量可能在管线创建时确定大小，而其他变量可能在着色器执行开始时确定大小。

如果某个类型的具体化大小在着色器模块创建时完全确定，那么它具有"creation-fixed footprint"。
如果某个类型的大小在管线创建时完全确定，那么它具有"fixed footprint"。

注意：所有具有"creation-fixed footprint"和"fixed footprint"的类型都是可存储的。

注意：管线的创建依赖于着色器的创建，因此具有"creation-fixed footprint"的类型也具有"fixed footprint"。


具有"creation-fixed footprint"的类型有：

* 标量类型
* 矢量类型
* 矩阵类型
* 原子类型
* 固定大小数组类型，满足以下条件：
* 其元素数量是一个常量表达式。
* 结构类型，如果其所有成员都具有"creation-fixed footprint"。

注意：可构造的类型具有"creation-fixed footprint"。

具有"fixed footprint"的纯类型包括：

* 具有"creation-fixed footprint"的类型
* 固定大小数组类型（不进一步约束其元素数量）

注意：固定大小数组的唯一有效用途是作为地址空间/工作组地址空间中的内存视图。
这包括工作组变量的存储类型。

注意：固定占用的类型可以直接或间接地包含原子类型，而可构造类型则不能。

注意：固定占用的类型不包括运行时大小的数组，以及包含运行时大小数组的任何结构。

## Enumeration Types ## {#enumeration-types}

<dfn noexport>枚举</dfn>类型是一组有限的命名值。
枚举用于区分特定概念的可能性集合，例如有效的[=纹理格式=]集合。


枚举值是枚举中的一个命名值。
每个枚举值与所有其他枚举值以及所有其他类型的值都是不同的。


在WGSL源代码中没有声明新的枚举值或新的枚举类型的机制。


注意：枚举值用作[=模板参数=]。


<div class=note>
  <span class=marker>注意：</span>无法复制枚举值或为其创建替代名称的方法：


  * [[#var-and-value|变量或值]]声明不能将枚举作为其[=存储类型=]或[=有效值类型=]。
  * 函数形式参数不能是枚举类型，部分原因是枚举不可构造。

</div>

### 预先声明的枚举值 ### {#predeclared-enumerants}

以下表格列出了WGSL中的枚举类型及其预定义的枚举元素。
这些枚举类型是存在的，但是在WGSL源码中无法表示。

<table class=data>
<caption>
  预先声明的枚举值
</caption>
<thead>
  <tr><th>枚举<br>(Cannot be spelled in WGSL)<th>预先声明的枚举值
</thead>
  <tr><td rowspan=3>[=access mode=]<td>[=access/read=]
  <tr><td>[=access/write=]
  <tr><td>[=access/read_write=]
  <tr><td rowspan=5>[=address space=]

      Note: The `handle` address space is never written in a WGSL source.
      <td>[=address spaces/function=]
  <tr><td>[=address spaces/private=]
  <tr><td>[=address spaces/workgroup=]
  <tr><td>[=address spaces/uniform=]
  <tr><td>[=address spaces/storage=]
  <tr><td rowspan=3>[=interpolation type=]
      <td>[=interpolation type/perspective=]
  <tr><td>[=interpolation type/linear=]
  <tr><td>[=interpolation type/flat=]
  <tr><td rowspan=3>[=interpolation sampling=]
      <td>[=interpolation sampling/center=]
  <tr><td>[=interpolation sampling/centroid=]
  <tr><td>[=interpolation sampling/sample=]
  <tr><td rowspan=12>[=built-in value=]
      <td>[=built-in values/vertex_index=]
  <tr><td>[=built-in values/instance_index=]
  <tr><td>[=built-in values/position=]
  <tr><td>[=built-in values/front_facing=]
  <tr><td>[=built-in values/frag_depth=]
  <tr><td>[=built-in values/local_invocation_id=]
  <tr><td>[=built-in values/local_invocation_index=]
  <tr><td>[=built-in values/global_invocation_id=]
  <tr><td>[=built-in values/workgroup_id=]
  <tr><td>[=built-in values/num_workgroups=]
  <tr><td>[=built-in values/sample_index=]
  <tr><td>[=built-in values/sample_mask=]
  <tr><td rowspan=17>[=texel format=]
      <td>[=texel format/rgba8unorm=]
  <tr><td>[=texel format/rgba8snorm=]
  <tr><td>[=texel format/rgba8uint=]
  <tr><td>[=texel format/rgba8sint=]
  <tr><td>[=texel format/rgba16uint=]
  <tr><td>[=texel format/rgba16sint=]
  <tr><td>[=texel format/rgba16float=]
  <tr><td>[=texel format/r32uint=]
  <tr><td>[=texel format/r32sint=]
  <tr><td>[=texel format/r32float=]
  <tr><td>[=texel format/rg32uint=]
  <tr><td>[=texel format/rg32sint=]
  <tr><td>[=texel format/rg32float=]
  <tr><td>[=texel format/rgba32uint=]
  <tr><td>[=texel format/rgba32sint=]
  <tr><td>[=texel format/rgba32float=]
  <tr><td>[=texel format/bgra8unorm=]
</table>

## 记忆视图 ## {#memory-views}

除了使用普通类型值进行计算外，WGSL程序还经常从[[#memory|memory]]中读取值或将值写入memory，通过内存访问操作进行。每个内存访问都是通过内存视图进行的。


一个内存视图包括：

* 特定地址空间中的一组内存位置，
* 一个[[#memory-model-reference|内存模型引用]]，
* 将这些位置的内容解释为WGSL类型的存储类型，称为<dfn noexport>store type</dfn>，
* 一个访问模式。

内存视图的访问模式[=shader-creation error|必须=]由地址空间支持。参见[[#var-and-value]]。

### 可存储类型 ### {#storable-types}

存储在变量中的值必须是可存储类型的值。
可存储类型可以通过WGSL来定义明确的表示，参见[[#internal-value-layout]]，
或者可以是不透明的，例如纹理资源和采样器资源。

如果一个类型同时满足以下条件，则被称为<dfn noexport>可存储</dfn>类型：

* 标量类型
* 向量类型
* 矩阵类型
* 原子类型
* 数组类型
* 结构体类型
* 纹理类型
* 采样器类型

注意：可存储类型包括标量类型、纹理类型和采样器类型。

### 可共享的主机类型 ### {#host-shareable-types}

可与主机共享的类型用于描述主机与GPU之间共享的缓冲区的内容，或在主机和GPU之间进行复制时不进行格式转换。在此目的下使用时，该类型还可以应用[=layout attributes=]，如[[#memory-layouts]]所述。如[[#var-decls]]所述，[=uniform buffer=]和[=storage buffer=]变量的[=store type=]必须可与主机共享。


如果类型既是[=type/concrete=]，又符合以下条件之一，该类型就是<dfn noexport>可与主机共享</dfn>的：

* [=numeric scalar=]类型
* [=numeric vector=]类型
* [=matrix=]类型
* [=atomic type|atomic=]类型
* [=fixed-size array=]类型，如果它具有[=creation-fixed footprint=]并且其元素类型可与主机共享
* [=runtime-sized=]数组类型，如果它的元素类型可与主机共享
* [=structure=]类型，如果其所有成员均可与主机共享

注：关于中间阶段输入和输出类型的限制，可以参考[[#stage-inputs-outputs]]和后续部分。这些类型也具有大小，但计数方式可能不同。


注：[[#texture-sampler-types|纹理和采样器]]也可以在主机和GPU之间共享，但它们的内容是不透明的。本节中的可与主机共享类型专门用于[=storage buffer|storage=]和[=uniform buffer|uniform=]缓冲区中的使用。

### 引用和指针类型 ### {#ref-ptr-types}

WGSL有两种类型来表示[内存视图]：[引用类型]和[指针类型]。

<table class='data'>
  <thead>
    <tr><th>限制<th>Type<th>描述
  </thead>
  <tr algorithm="memory reference type">
    <td style="width:25%">|AS| 是一个地址空间，
                          |T| 是一个可存储的类型，
                          |AM| 是一种访问模式。
    <td>ref&lt;|AS|,|T|,|AM|&gt;
    <td><dfn noexport>引用类型</dfn>被定义为一组在|AS|中存储着类型为|T|的值的内存视图，支持由模式|AM|描述的内存访问。
        在这里，|T|是[=存储类型=]。
        引用类型不会在WGSL源代码中直接出现；它们被用于分析WGSL模块。
  <tr algorithm="pointer type">
    <td>|AS| 是一个地址空间，
        |T| 是一个可存储类型，
        |AM| 是一个访问模式。
    <td>ptr&lt;|AS|,|T|,|AM|&gt;
    <td>指针类型指的是在AS中保存类型为T的值的内存位置的一组内存视图，支持由AM模式描述的内存访问。
        这里，T是存储类型。
        指针类型可以出现在WGSL源代码中。
</table>

只有当两个指针类型具有相同的地址空间、存储类型和访问模式时，它们才是相同的。


在分析 WGSL 模块时，引用和指针类型是由地址空间、可存储类型和访问模式完全参数化的。
在本规范中的代码示例中，注释显示了这种完全参数化的形式。


然而，在 WGSL 源文本中：

* 引用类型 [=shader-creation error|不能出现=]。
* 指针类型可以出现。
    * 指针类型的拼写方式为参数化：
        * [=地址空间=]，
        * [=存储类型=]，
        * 有时也由 [=访问模式=] 参数化，如 [[#address-space]] 中所指定的。
* 如果程序源代码中出现指针类型，则该类型的变量声明也要在程序的某个地方有效，包括 [=地址空间=]、[=存储类型=] 和 [=访问模式=]。

注意：此限制禁止了某些永远不会在运行时使用的 [=type aliases=] 和函数 [=formal parameters=] 的声明。 如果没有这个限制，声明指针类型的别名将是有效的，但永远不能创建该类型的指针值。 同样，声明一个带有指针形式参数的函数将是有效的，但永远不能调用该函数。

<div class='example wgsl' heading='Pointer type'>
  <xmp>
    fn my_function(
      /* 'ptr<function,i32,read_write>' is the type of a pointer value that references
         memory for keeping an 'i32' value, using memory locations in the 'function'
         address space.  Here 'i32' is the store type.
         The implied access mode is 'read_write'.
         See "Address Space" section for defaults. */
      ptr_int: ptr<function,i32>,

      // 'ptr<private,array<f32,50>,read_write>' is the type of a pointer value that
      // refers to memory for keeping an array of 50 elements of type 'f32', using
      // memory locations in the 'private' address space.
      // Here the store type is 'array<f32,50>'.
      // The implied access mode is 'read_write'.
      // See the "Address space section for defaults.
      ptr_array: ptr<private, array<f32, 50>>
    ) { }
  </xmp>
</div>

引用类型和指针类型都是一组内存视图：
特定的内存视图与唯一的引用值和唯一的指针值相关联：

<blockquote algorithm="pointer reference correspondence">
每个类型为ptr<|AS|,|T|,|AM|>的指针值|p|对应于类型为ref<|AS|,|T|,|AM|>的唯一引用值|r|，
反之亦然，
其中|p|和|r|描述相同的内存视图。
</blockquote>

### 有效和无效的内存引用 ### {#valid-invalid-memory-references}

一个引用类型的值可以是有效引用或无效内存引用。

引用的形成如详细描述在[[#forming-references-and-pointers]]中。
通常，一个有效引用可以通过以下方式形成：

* 命名一个变量，或
* 对一个有效指针应用间接（一元*）操作，或
* 一个以有效引用为基础的命名分量表达式，或
* 一个以有效引用为基础的索引表达式，并使用合法索引。

通常，一个无效内存引用可以通过以下方式形成：

* 对一个无效指针应用间接运算符，或
* 一个以无效内存引用为基础的命名分量表达式，或
* 一个以引用为基础的索引表达式，并且要么：
    * 基础为无效内存引用，或
    * 索引为越界索引。

一个合法指针是指对应于有效引用的指针。
一个无效指针是指对应于无效内存引用的指针。

### 起始变量 ### {#originating-variable-section}

<div algorithm="defining orginating variable">
对于参考值|R|，<dfn noexport>起源变量</dfn>的定义如下：

* 当|R|是一个变量时，它就是这个变量。
* 当|R|是指针值|P|的间接操作符（一元*）的应用时，它就是|P|的起源变量。
* 当|R|是一个[=named component expression=]或一个[=indexing expression=]时，它就是[=decomposition/base=]的起源变量。

</div>

一个指针值的初始变量被定义为对应引用值的初始变量。

注意：初始变量是一个动态概念。
函数的形式参数的初始变量取决于函数的调用点。
不同的调用点可能提供指向不同初始变量的指针。

一个有效的引用始终对应于某个变量的一个或多个内存位置的非空内存视图。

<div class=note>
<span class=marker>Note:</span> 一个引用可以对应于变量内部的内存位置，但仍然可能是无效的。
当索引超过被索引的类型的范围时，就会发生这种情况，但是被引用的位置却在后续的兄弟数据成员内。


在下面的例子中，引用 the_particle.position[i] 当且仅当 i 为0或1时是有效的。
当 i 是2时，引用将是一个无效的内存引用，但在其他情况下，它会对应于 the_particle.color_index 的内存位置。
<div class='example wgsl' heading='Invalid memory reference still inside a variable'>
<span id="example-invalid-ref"></span>
  <xmp>
    struct Particle {
       position: vec2f,
       velocity: vec2f,
       color_index: i32,
    }

    @group(0) @binding(0)
    var<storage,read_write> the_particle: Particle;

    fn particle_velocity_component(p: Particle, i: i32) -> f32 {
      return the_particle.velocity[i]; // A valid reference when i is 0 or 1.
    }
  </xmp>
</div>
</div>

### 越界访问 ### {#out-of-bounds-access-sec}

一个访问无效内存引用的操作被称为"越界访问"。


越界访问是程序中的一个缺陷，因为如果按照写下的方式执行，通常会出现以下情况：

* 读取或写入变量之外的内存位置
* 将这些位置的内容解释为错误的存储类型
* 导致意外的数据竞争

因此，实现不会按照写下的方式执行此访问。执行越界访问会生成动态错误。


注意：在前一节的示例中，出现了解释错误存储类型的示例。当i为2时，表达式the_particle.velocity[i]的类型为ref<storage,f32,read_write>，意味着它是一个以f32为存储类型的内存视图。然而，内存位置被分配给color_index成员，因此实际存储的值是i32类型。

<div class=note>
  <span class=marker>注意：</span>越界访问会导致动态错误，可能会出现多种可能的结果。


  这些结果包括但不限于以下情况：


  <dfn noexport>陷阱</dfn>：
  着色器调用立即终止，[=着色器阶段输出=]被设置为零值。


  <dfn noexport>无效的加载</dfn>：
  从无效引用中加载可能返回以下之一：
  * 当原始变量是一个统一缓冲区或存储缓冲区时，
  * 来自原始变量绑定的WebGPU {{GPUBuffer}}的任何[=内存位置|内存位置=]的值
  * 当原始变量不是统一缓冲区或存储缓冲区时，
  * 来自原始变量中的任何[=内存位置|内存位置=]的值
  * 引用的存储类型的[=零值=]
  * 如果加载的值是一个向量，则为值(0, 0, 0, x)，其中x是：
  * 对于整数分量，为0、1或最大正值
  * 对于浮点分量，为0.0或1.0


  <dfn noexport>无效的存储</dfn>：
  对无效引用的[=语句/赋值|存储=]行为可能是以下之一：
  * 当原始变量是一个存储缓冲区时，
  * 将值存储到绑定到原始变量的WebGPU {{GPUBuffer}}的任何[=内存位置|内存位置=]
  * 当原始变量不是存储缓冲区时，
  * 将值存储到原始变量中的任何[=内存位置|内存位置=]
  * 不执行


  如果将无效的加载或存储重定向到共享地址空间变量内部的不同位置，
  则可能发生数据竞争。
  例如，几个并发执行的调用的访问可能会被重定向到数组的第一个元素。
  如果至少有一个访问是写入的，并且它们没有被同步，
  则结果是数据竞争，因此也是动态错误。


  越界访问使得[[#uniformity|一致性分析]]的假设失效。
  例如，如果一个调用由于越界访问而提前终止，那么它将无法参与集合操作。
  特别是，对[[#sync-builtin-functions|workgroupBarrier]]的调用可能会导致着色器挂起，而导数可能会产生无效的结果。
</div>

### 参考和指针的用途 ### {#ref-ptr-use-cases}

参考和指针的区别在于它们的用法：
* 变量的类型是引用类型。
* 取地址操作（一元运算符&）将引用值转换为其相应的指针值。
* 解引用操作（一元运算符*）将指针值转换为其相应的引用值。
* let声明可以是指针类型，但不能是引用类型。
* 形式参数可以是指针类型，但不能是引用类型。
* 简单赋值语句通过引用执行写访问操作来更新内存的内容，其中：
* 赋值语句的左侧必须是引用类型，并具有访问模式为access/write或access/read_write。
* 赋值语句的右侧必须求值为左侧的存储类型。
* 载入规则：在函数内部，引用会自动解引用（读取）以满足类型规则：
* 在函数中，当使用具有存储类型为T的引用表达式|r|的语句或表达式时，其中
* |r|的访问模式为access/read或access/read_write，并且
* 唯一可能匹配的类型规则要求|r|具有类型为T的值，则
* 认为已满足该类型规则要求，并且
* 在该上下文中评估|r|的结果是存储在|r|引用的内存位置上的值（类型为T）。 即，执行读访问以产生结果值。

以这种方式定义引用使得变量的使用变得简单而惯用。

<div class='example wgsl' heading='Reference types enable simple use of variables'>
  <xmp>
    @compute @workgroup_size(1)
    fn main() {
      // 'i' has reference type ref<function,i32,read_write>
      // The memory locations for 'i' store the i32 value 0.
      var i: i32 = 0;

      // 'i + 1' can only match a type rule where the 'i' subexpression is of type i32.
      // So the expression 'i + 1' has type i32, and at evaluation, the 'i' subexpression
      // evaluates to the i32 value stored in the memory locations for 'i' at the time
      // of evaluation.
      let one: i32 = i + 1;

      // Update the value in the locations referenced by 'i' so they hold the value 2.
      i = one + 1;

      // Update the value in the locations referenced by 'i' so they hold the value 5.
      // The evaluation of the right-hand-side occurs before the assignment takes effect.
      i = i + 3;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Returning a reference returns the value loaded via the reference'>
  <xmp>
    var<private> age: i32;
    fn get_age() -> i32 {
      // The type of the expression in the return statement must be 'i32' since it
      // must match the declared return type of the function.
      // The 'age' expression is of type ref<private,i32,read_write>.
      // Apply the Load Rule, since the store type of the reference matches the
      // required type of the expression, and no other type rule applies.
      // The evaluation of 'age' in this context is the i32 value loaded from the
      // memory locations referenced by 'age' at the time the return statement is
      // executed.
      return age;
    }

    fn caller() {
      age = 21;
      // The copy_age constant will get the i32 value 21.
      let copy_age: i32 = get_age();
    }
  </xmp>
</div>

以这种方式定义指针可以实现两个关键应用场景：
* 使用具有指针类型的let声明，以形成变量内容的一部分的简短名称。
* 使用函数的形式参数来引用对调用函数可访问的变量的内存。
      * 对于这样的函数调用，必须为该操作数提供指针值。 这通常需要使用地址运算符（一元&）来获取变量内容的指针。

<div class='example wgsl' heading='Using a pointer as a short name for part of a variable'>
  <xmp>
    struct Particle {
      position: vec3<f32>,
      velocity: vec3<f32>
    }
    struct System {
      active_index: i32,
      timestep: f32,
      particles: array<Particle,100>
    }
    @group(0) @binding(0) var<storage,read_write> system: System;

    @compute @workgroup_size(1)
    fn main() {
      // Form a pointer to a specific Particle in storage memory.
      let active_particle: ptr<storage,Particle> =
          &system.particles[system.active_index];

      let delta_position: vec3<f32> = (*active_particle).velocity * system.timestep;
      let current_position: vec3<f32>  = (*active_particle).position;
      (*active_particle).position = delta_position + current_position;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Using a pointer as a formal parameter'>
  <xmp>
    fn add_one(x: ptr<function,i32>) {
      /* Update the locations for 'x' to contain the next higher integer value,
         (or to wrap around to the largest negative i32 value).
         On the left-hand side, unary '*' converts the pointer to a reference that
         can then be assigned to. It has a read_write access mode, by default.
         /* On the right-hand side:
            - Unary '*' converts the pointer to a reference, with a read_write
              access mode.
            - The only matching type rule is for addition (+) and requires '*x' to
              have type i32, which is the store type for '*x'.  So the Load Rule
              applies and '*x' evaluates to the value stored in the memory for '*x'
              at the time of evaluation, which is the i32 value for 0.
            - Add 1 to 0, to produce a final value of 1 for the right-hand side. */
         Store 1 into the memory for '*x'. */
      *x = *x + 1;
    }

    @compute @workgroup_size(1)
    fn main() {
      var i: i32 = 0;

      // Modify the contents of 'i' so it will contain 1.
      // Use unary '&' to get a pointer value for 'i'.
      // This is a clear signal that the called function has access to the memory
      // for 'i', and may modify it.
      add_one(&i);
      let one: i32 = i;  // 'one' has value 1.
    }
  </xmp>
</div>

### 形成引用和指针值 ### {#forming-references-and-pointers}

引用值可以通过以下方式之一形成：

* [=标识符=] 通过解析为在作用域内的变量 v 的引用值来指示 v 的内存。
* 在指针上使用间接操作（一元 *）。
* 在对复合引用上使用命名成分表达式：
    * 给定一个带有向量存储类型的引用，添加一个单字母向量访问短语将导致指向向量的命名成分的引用。
    * 给定一个带有结构存储类型的引用，添加一个成员访问短语将导致指向结构的命名成员的引用。
* 在对复合引用上使用索引表达式：
    * 给定一个带有向量存储类型的引用，添加一个数组索引访问短语将导致指向向量的索引成分的引用。
    * 给定一个带有矩阵存储类型的引用，添加一个数组索引访问短语将导致指向矩阵的索引列向量的引用。
    * 给定一个带有数组存储类型的引用，添加一个数组索引访问短语将导致指向数组的索引元素的引用。

在所有情况下，结果的访问模式与原始引用的访问模式相同。

<div class='example wgsl' heading='Component reference from a composite reference'>
  <xmp>
    struct S {
        age: i32,
        weight: f32
    }
    var<private> person: S;
    // Elsewhere, 'person' denotes the reference to the memory underlying the variable,
    // and will have type ref<private,S,read_write>.

    fn f() {
        var uv: vec2<f32>;
        // For the remainder of this function body, 'uv' denotes the reference
        // to the memory underlying the variable, and will have type
        // ref<function,vec2<f32>,read_write>.

        // Evaluate the left-hand side of the assignment:
        //   Evaluate 'uv.x' to yield a reference:
        //   1. First evaluate 'uv', yielding a reference to the memory for
        //      the 'uv' variable. The result has type ref<function,vec2<f32>,read_write>.
        //   2. Then apply the '.x' vector access phrase, yielding a reference to
        //      the memory for the first component of the vector pointed at by the
        //      reference value from the previous step.
        //      The result has type ref<function,f32,read_write>.
        // Evaluating the right-hand side of the assignment yields the f32 value 1.0.
        // Store the f32 value 1.0 into the storage memory locations referenced by uv.x.
        uv.x = 1.0;

        // Evaluate the left-hand side of the assignment:
        //   Evaluate 'uv[1]' to yield a reference:
        //   1. First evaluate 'uv', yielding a reference to the memory for
        //      the 'uv' variable. The result has type ref<function,vec2<f32>,read_write>.
        //   2. Then apply the '[1]' array index phrase, yielding a reference to
        //      the memory for second component of the vector referenced from
        //      the previous step.  The result has type ref<function,f32,read_write>.
        // Evaluating the right-hand side of the assignment yields the f32 value 2.0.
        // Store the f32 value 2.0 into the storage memory locations referenced by uv[1].
        uv[1] = 2.0;

        var m: mat3x2<f32>;
        // When evaluating 'm[2]':
        // 1. First evaluate 'm', yielding a reference to the memory for
        //    the 'm' variable. The result has type ref<function,mat3x2<f32>,read_write>.
        // 2. Then apply the '[2]' array index phrase, yielding a reference to
        //    the memory for the third column vector pointed at by the reference
        //    value from the previous step.
        //    Therefore the 'm[2]' expression has type ref<function,vec2<f32>,read_write>.
        // The 'let' declaration is for type vec2<f32>, so the declaration
        // statement requires the initializer to be of type vec2<f32>.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the vec2<f32> value loaded
        // from the memory locations referenced by 'm[2]' at the time the declaration
        // is executed.
        let p_m_col2: vec2<f32> = m[2];

        var A: array<i32,5>;
        // When evaluating 'A[4]'
        // 1. First evaluate 'A', yielding a reference to the memory for
        //    the 'A' variable. The result has type ref<function,array<i32,5>,read_write>.
        // 2. Then apply the '[4]' array index phrase, yielding a reference to
        //    the memory for the fifth element of the array referenced by
        //    the reference value from the previous step.
        //    The result value has type ref<function,i32,read_write>.
        // The let-declaration requires the right-hand-side to be of type i32.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the i32 value loaded from
        // the memory locations referenced by 'A[4]' at the time the declaration
        // is executed.
        let A_4_value: i32 = A[4];

        // When evaluating 'person.weight'
        // 1. First evaluate 'person', yielding a reference to the memory for
        //    the 'person' variable declared at module scope.
        //    The result has type ref<private,S,read_write>.
        // 2. Then apply the '.weight' member access phrase, yielding a reference to
        //    the memory for the second member of the memory referenced by
        //    the reference value from the previous step.
        //    The result has type ref<private,f32,read_write>.
        // The let-declaration requires the right-hand-side to be of type f32.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the f32 value loaded from
        // the memory locations referenced by 'person.weight' at the time the
        // declaration is executed.
        let person_weight: f32 = person.weight;
    }
  </xmp>
</div>

指针值可以通过以下方式之一形成：

* 在引用上使用[=取地址=]（一元&）操作符。
    * 只有当原始引用是[=有效引用=]时，结果才是[=有效指针=]。
    * 有效结果的[=原始变量=]被定义为引用的原始变量。
* 如果一个函数[=形式参数=]具有指针类型，则在运行时调用函数时，形式参数的使用表示传递给调用函数中相应操作数的指针值。
    * 形式参数在运行时表示的值只有在调用点的指针值是[=有效指针=]时才是[=有效指针=]。
    * 有效指针形式参数在运行时的[=原始变量=]被定义为调用点处指针操作数的原始变量。

在所有情况下，结果的[=访问模式=]与原始指针的访问模式相同。

<div class='example wgsl' heading='Pointer from a variable'>
  <xmp>
    // Declare a variable in the private address space, for storing an f32 value.
    var<private> x: f32;

    fn f() {
        // Declare a variable in the function address space, for storing an i32 value.
        var y: i32;

        // The name 'x' resolves to the module-scope variable 'x',
        // and has reference type ref<private,f32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode is the same as the access mode of the original variable, so
        // the fully specified type is ptr<private,f32,read_write>.  But read_write
        // is the default access mode for function address space, so read_write does not
        // have to be spelled in this case
        let x_ptr: ptr<private,f32> = &x;

        // The name 'y' resolves to the function-scope variable 'y',
        // and has reference type ref<private,i32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode defaults to 'read_write'.
        let y_ptr: ptr<function,i32> = &y;

        // A new variable, distinct from the variable declared at module scope.
        var x: u32;

        // Here, the name 'x' resolves to the function-scope variable 'x' declared in
        // the previous statement, and has type ref<function,u32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode defaults to 'read_write'.
        let inner_x_ptr: ptr<function,u32> = &x;
    }
  </xmp>
</div>

### 与其他语言中的引用和指针的比较 ### {#pointers-other-languages}

本节是信息性的，而不是规范性的。


在WGSL中，引用和指针的限制比其他语言更严格。具体而言：
* 在WGSL中，引用不能直接声明为对另一个引用或变量的别名，无论是作为变量还是作为形式参数。
* 在WGSL中，指针和引用不能存储。也就是说，WGSL的变量声明的内容不能包含指针或引用。
* 在WGSL中，函数着色器不能返回指针或引用。
* 在WGSL中，没有办法在整数值和指针值之间进行转换。
* 在WGSL中，没有办法强制将指针值的类型更改为另一种指针类型。
    * 复合组件引用表达式是不同的： 它获取对复合值的引用，并产生对复合值内部的一个组件或元素的引用。 在WGSL中，尽管它们在更低级别的实现抽象中可能具有相同的机器地址，但它们被认为是不同的引用。
* 在WGSL中，没有办法强制将引用值的类型更改为另一种引用类型。
* 在WGSL中，没有办法更改指针或引用的访问模式。
    * 相比之下，C++会自动将非const指针转换为const指针，并使用const_cast将const值转换为非const值。
* 在WGSL中，没有办法从"堆"中分配新的内存。
* 在WGSL中，没有办法显式销毁变量。只有当变量超出作用域时，WGSL变量的内存才变得不可访问。

注意：根据上述规则，无法形成"悬空"指针，即不引用"活动"源变量的指针。[=memory view=]可能是一个[=invalid memory reference=]，但它[=behavioral requirement|绝不会=]访问与[=originating variable=]或缓冲区无关的[=memory locations=]。

## 纹理类型和采样器类型 ## {#texture-sampler-types}

<dfn noexport>纹素</dfn>是指作为纹理中最小独立可访问元素的标量或矢量。纹素是纹素元素的缩写。

<dfn noexport>纹理</dfn>是一组支持用于渲染的特殊操作的纹素集合。在WGSL中，这些操作通过纹理内置函数调用。请参阅[[#texture-builtin-functions]]获取完整列表。

WGSL纹理对应WebGPU的{{GPUTexture}}。

纹理具有以下特征：

: [=纹理格式=]
:: 每个纹素的数据表示。参见纹素格式。
: <dfn dfn-for=texture noexport>维度性</dfn>：网格坐标的维度数量以及坐标的解释方式。
:: 维度数量可以是1、2或3。
: 大多数纹理使用笛卡尔坐标。
:: 立方体纹理具有六个正方形面，并且通过从原点指向以原点为中心的立方体的三维坐标进行采样解释为方向向量。 详见{{GPUTextureViewDimension}}。
: 尺寸：沿每个维度的网格坐标的范围。这是一个与mip等级有关的函数。
:: <dfn dfn-for=texture noexport>mip等级数量</dfn>
    对于采样纹理和深度纹理，mip等级数量至少为1，对于存储纹理等级数量等于1。
    mip等级0包含纹理的全尺寸版本。
    每个后续的mip等级包含前一个mip等级的一半大小（舍入）的滤波版本。 在对纹理进行采样时，使用显式或隐式计算的细节级别来选择从中读取纹素数据的mip等级，然后通过滤波组合生成采样值。
: <dfn dfn-for=texture noexport>是否是数组纹理</dfn>
:: 非数组纹理是纹素的网格。
    * 数组纹理是纹素网格的一致数组。
: <dfn dfn-for=texture noexport>数组大小/dfn>
:: 如果纹理是数组纹理，则是一致网格的数量。
: <dfn dfn-for=texture noexport>采样次数</dfn>
:: 如果纹理是多重采样的，是采样数量。

纹理中的每个像素与一个唯一的"逻辑纹素地址"相关联，这是一个整数元组，具有以下特征：
* 一个[=mip level=]在[0, [=texture/mip level count=]]的范围内。
* 一定数量的分量，由[=texture/dimensionality=]控制，每个分量的值在[0, S<sub>i</sub>)的范围内，其中S<sub>i</sub>是第i个分量的[=texture/size=]。
* 如果纹理是[=texture/arrayed=]，则有一个在[0, [=texture/array size=]]的范围内的数组索引。请注意，[=texture/size=]是[=mip level=]的一个函数。
* 如果纹理是[[#multisampled-texture-type|multisampled]]，则有一个在[0, [=texture/sample count=]]的范围内的样本索引。

纹理的物理组织通常针对渲染操作进行了优化。为了实现这一点，很多细节对程序员来说是隐藏的，包括数据布局、数据类型以及不能直接在着色器语言中表达的内部操作。

因此，着色器不能直接访问[=texture resource|texture variable=]中的纹素内存。相反，访问是通过一个不透明的句柄进行的。

* 在着色器内部：
    * 声明一个模块作用域变量，其中[=存储类型=]是后面章节中描述的纹理类型之一。该变量存储底层纹理内存的不透明句柄，并自动放置在[=地址空间/句柄=]地址空间中。
    * 在函数内部，调用其中一个纹理内建函数，并将纹理变量或函数参数作为纹理内建函数的第一个参数提供。

* 构建WebGPU管道时，纹理变量的存储类型和绑定须与相应的绑定组布局条目兼容。


通过这种方式，纹理类型的支持操作集由具有该纹理类型[=形式参数=]的纹理内建函数的可用性决定。


注意：纹理变量存储的句柄不能由着色器改变。也就是说，该变量是只读的，即使它提供访问的底层纹理可能是可变的（例如，写入仅[=类型/存储纹理=]）。


<dfn>纹理类型</dfn>是在以下定义的一组类型：
* 采样纹理类型
* 多重采样纹理类型
* 外部纹理类型
* 纹理存储
* 纹理深度

采样器是一个不透明的句柄，用于控制从采样纹理或深度纹理中访问像素。

WGSL采样器映射到WebGPU的{{GPUSampler}}。

通过采样器的几个属性来控制像素的访问方式：

: 寻址模式
:: 控制如何解决纹理边界和越界坐标的问题。
: 每个纹理维度的寻址模式可以独立设置。
:: 详见WebGPU的{{GPUAddressMode}}。
: 过滤模式
:: 控制访问哪些像素以生成最终结果。
    过滤可以使用最近的像素或在多个像素之间进行插值。
    可以独立设置多个过滤模式。
    详见WebGPU的{{GPUFilterMode}}。
: LOD（Level of Detail）夹持
:: 控制访问的最小和最大细节级别。
: 比较
:: 控制用于比较采样器的类型。
    详见WebGPU的{{GPUCompareFunction}}。
: 最大各向异性
:: 控制采样器使用的最大各向异性值。

在WGSL模块中无法创建采样器，并且它们的状态（例如上述列出的属性）在着色器内部是不可变的，只能通过WebGPU API进行设置。

如果使用具有非可过滤格式的纹理与使用插值过滤的采样器（即任何采样器）一起使用，则会出现[=pipeline-creation error=]。

注意：着色器无法更改采样器变量存储的句柄。

### 纹理格式 ### {#texel-formats}

在WGSL中，某些纹理类型由纹素格式进行参数化。


<dfn noexport>纹素格式</dfn>具有以下特征：


: <dfn noexport>通道</dfn>
:: 每个通道包含一个标量。
    纹素格式最多有四个通道：r、g、b和a，通常对应于红色、绿色、蓝色和透明度通道的概念。
: <dfn noexport>通道格式</dfn>
:: 通道中位数的数量以及如何解释这些位数。


WGSL中的每种纹素格式都对应于具有相同名称的WebGPU {{GPUTextureFormat}}。


只有某些纹素格式在WGSL源代码中使用。
用于定义这些纹素格式的通道格式列在通道格式表中。
最后一列指定了从存储的通道位到着色器中使用的值之间的转换。
这也被称为<dfn noexport>通道传输函数</dfn>或CTF。


注意：8unorm的通道传输函数将{0，…，255}映射到浮点数范围[0.0，1.0]。


注意：8snorm的通道传输函数将{-128，…，127}映射到浮点数范围[-1.0，1.0]。

<table class='data'>
  <caption>Channel Formats</caption>
  <thead>
    <tr><th>Channel format
        <th>Number of stored bits
        <th>Interpretation of stored bits
        <th>Shader type<td style="width:25%">Shader value
(Channel Transfer Function)
  </thead>
  <tr><td>8unorm<td>8<td>unsigned integer |v| &isinv; {0,...,255}<td>f32<td> |v| &div; 255
  <tr><td>8snorm<td>8<td>signed integer |v| &isinv; {-128,...,127}<td>f32<td> max(-1, |v| &div; 127)
  <tr><td>8uint<td>8<td>unsigned integer |v| &isinv; {0,...,255}<td>u32<td> |v|
  <tr><td>8sint<td>8<td>signed integer |v| &isinv; {-128,...,127}<td>i32<td> |v|
  <tr><td>16uint<td>16<td>unsigned integer |v| &isinv; {0,...,65535}<td>u32<td> |v|
  <tr><td>16sint<td>16<td>signed integer |v| &isinv; {-32768,...,32767}<td>i32<td> |v|
  <tr><td>16float<td>16<td>[[!IEEE-754|IEEE-754]] binary16 16-bit floating point value |v|, with 1 sign bit, 5 exponent bits, 10 mantissa bits<td>f32<td>|v|
  <tr><td>32uint<td>32<td>32-bit unsigned integer value |v|<td>u32<td>|v|
  <tr><td>32sint<td>32<td>32-bit signed integer value |v|<td>i32<td>|v|
  <tr><td>32float<td>32<td>[[!IEEE-754|IEEE-754]] binary32 32-bit floating point value |v|<td>f32<td>|v|
</table>

存储纹理的像素格式在<dfn lt="storage-texel-formats">存储纹理的Texel格式</dfn>表中列出，对应支持WebGPU纯色格式的WebGPU GPUTextureUsage/STORAGE_BINDING使用。这些像素格式用于参数化在texture-storage中定义的类型/存储纹理类型。


当像素格式不具有四个通道时：

* 在读取像素时：
* 如果像素格式没有绿色通道，则着色器值的第二个分量为0。
* 如果像素格式没有蓝色通道，则着色器值的第三个分量为0。
* 如果像素格式没有alpha通道，则着色器值的第四个分量为1。
* 在写入像素时，将忽略缺失通道的着色器值分量。

下表中的最后一列使用了来自通道格式表的特定格式的通道转换函数。

<table class='data'>
  <caption>Texel Formats for Storage Textures</caption>
  <thead>
    <tr><th>Texel format
        <th>Channel format
        <th>Channels in memory order
        <th style="width:50%">Corresponding shader value
  </thead>
  <tr><td><dfn for="texel format">rgba8unorm</dfn><td>8unorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba8snorm</dfn><td>8snorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba8uint</dfn><td>8uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba8sint</dfn><td>8sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba16uint</dfn><td>16uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba16sint</dfn><td>16sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba16float</dfn><td>16float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">r32uint</dfn><td>32uint<td>r<td>vec4&lt;u32&gt;(CTF(r), 0u, 0u, 1u)
  <tr><td><dfn for="texel format">r32sint</dfn><td>32sint<td>r<td>vec4&lt;i32&gt;(CTF(r), 0, 0, 1)
  <tr><td><dfn for="texel format">r32float</dfn><td>32float<td>r<td>vec4&lt;f32&gt;(CTF(r), 0.0, 0.0, 1.0)
  <tr><td><dfn for="texel format">rg32uint</dfn><td>32uint<td>r, g<td>vec4&lt;u32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td><dfn for="texel format">rg32sint</dfn><td>32sint<td>r, g<td>vec4&lt;i32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td><dfn for="texel format">rg32float</dfn><td>32float<td>r, g<td>vec4&lt;f32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td><dfn for="texel format">rgba32uint</dfn><td>32uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba32sint</dfn><td>32sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba32float</dfn><td>32float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">bgra8unorm</dfn><td>8unorm<td>b, g, r, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
</table>

WGSL为表中的每种纹理格式[=predeclared|predeclares=]一个[=enumerant=]。

### 采样纹理类型 ### {#sampled-texture-type}

一个"采样纹理"可以与"采样器类型"一起被访问。它也可以在不使用采样器的情况下被访问。采样纹理只允许读访问。


"纹素格式"是绑定到纹理变量的"GPUTexture"的"format"属性。WebGPU会在纹理、绑定组布局的"GPUTextureBindingLayout/sampleType"以及纹理变量的"采样类型"之间进行验证以确保兼容性。


纹理由一个"采样类型"参数化，且必须是"f32"、"i32"或"u32"。

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_1d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"1d"|1D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_2d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_2d_array</dfn><*T*>
      <td>{{GPUTextureViewDimension/"2d-array"|2D}}
      <td>Yes
  <tr><td><dfn noexport dfn-for='type'>texture_3d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"3d"|3D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_cube</dfn><*T*>
      <td>{{GPUTextureViewDimension/"cube"|Cube}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_cube_array</dfn><*T*>
      <td>{{GPUTextureViewDimension/"cube-array"|Cube}}
      <td>Yes
</table>

* T 是[=采样类型=]。
* 图像的参数化类型是从采样转换后的类型。 例如，您可以有一个具有8位非规范化分量的纹素图像，但是当您对它们进行采样时，您会得到一个32位浮点数结果（或者f32向量）。

### 多重采样纹理类型 ### {#multisampled-texture-type}

一个多样本纹理具有一个或多个纹理采样点。
尽管名字是这样，但它不能与采样器一起使用。
如果忽略采样索引，它有效地按每个逻辑纹素地址存储多个像素值的数据。


纹素格式是绑定到纹理变量的GPUTexture的format属性。
WebGPU通过验证纹理、绑定组布局的GPUTextureBindingLayout/sampleType以及纹理变量的采样类型之间的兼容性。


纹理由采样类型参数化，必须是f32、i32或u32。

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_multisampled_2d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_depth_multisampled_2d</dfn>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
</table>

T 是被抽样的类型。

### 外部采样纹理类型 ### {#external-texture-type}

一个<dfn noexport dfn-for=‘type’>外部纹理</dfn>是一个不透明的二维浮点数-[=type/sampled texture=]类型，类似于texture_2d<f32>，但可能具有不同的表示形式。
可以使用[[#textureload|textureLoad]]或[[#textureSampleBaseClampToEdge|textureSampleBaseClampToEdge]]内置函数来读取它们，这些函数可以处理这些不同的表示形式。

见 [[WebGPU#gpuexternaltexture]].

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_external</dfn>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
</table>

### 存储纹理类型 ### {#texture-storage}

一种存储纹理支持无需使用采样器即可访问单个纹素值。

* 一个只写的存储纹理支持写入单个纹素，将着色器值自动转换为存储的纹素值。
* 一个只读的存储纹理支持读取单个纹素，将存储的纹素值自动转换为着色器纹素值。
* 一个读写的存储纹理支持读取和写入单个纹素，着色器纹素值和存储纹素值之间自动进行转换。

存储纹理类型必须通过[存储纹素格式]之一进行参数化。纹素格式决定了转换函数，如纹素格式中所述。


在向存储纹理写入纹素时，使用与转换函数相反的函数将着色器值转换为存储的纹素。


<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_storage_1d</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"1d"|1D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_storage_2d</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_storage_2d_array</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"2d-array"|2D}}
      <td>Yes
  <tr><td><dfn noexport dfn-for='type'>texture_storage_3d</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"3d"|3D}}
      <td>No
</table>

* Format 必须是存储纹理的像素格式之一
* Access 必须是访问模式中的一个枚举值。

### 深度纹理类型 ### {#texture-depth}

一个深度纹理（depth texture）可以与类型/采样器比较结合使用，可以被访问。它也可以在不使用采样器的情况下被访问。深度纹理仅允许读取访问。


纹理的像素格式在GPUTextureBindingLayout中被定义。

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_depth_2d</dfn>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_depth_2d_array</dfn>
      <td>{{GPUTextureViewDimension/"2d-array"|2D}}
      <td>Yes
  <tr><td><dfn noexport dfn-for='type'>texture_depth_cube</dfn>
      <td>{{GPUTextureViewDimension/"cube"|Cube}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_depth_cube_array</dfn>
      <td>{{GPUTextureViewDimension/"cube-array"|Cube}}
      <td>Yes
</table>

### 采样器类型 ### {#sampler-type}

一个<dfn>采样器（sampler）</dfn>通过执行以下操作来调节对于[=type/sampled texture=]或[=type/depth texture=]的访问：
* 坐标变换。
* 可选地修改mip级别的选择。
* 对于[=type/sampled texture=]，可选地对检索到的纹素值进行滤波。
* 对于[=type/depth texture=]，确定要应用于检索到的纹素的比较函数。

<dfn noexport>采样器类型（sampler types）</dfn>有：
* [=type/sampler=]
* [=type/sampler_comparison=]

<table class=‘data’>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr algorithm="sampler type">
  <td><dfn dfn-for="type">sampler</dfn>
  <td>采样器。调节对于[=type/sampled texture=]的访问。</td>
  <tr algorithm="comparison sampler type">
  <td><dfn dfn-for="type">sampler_comparison</dfn>
  <td>比较采样器。调节对于[=type/depth texture=]的访问。</td>
</table>


采样器在WebGPU API中创建时进行参数化。
它们不能由WGSL模块修改。

采样器只能被[[#texture-builtin-functions|纹理内置函数]]使用。

<pre class='def'>
sampler
sampler_comparison
</pre>

## 所有类型 类型 ## {#alltypes-type}

<dfn noexport>AllTypes</dfn>类型是所有WGSL类型的集合。


在WGSL源代码中无法直接编写AllTypes类型。


请参阅[[#predeclared-types]]以获取所有预定义类型和类型生成器的列表。


<div class=note>
<span class=marker>注意：</span>类型在一般意义上不是一个值。
它不是在运行时由着色器操作的数据。


<p>
相反，AllTypes类型存在是为了使类型检查规则适用于可能包含一般值的任何短语。
WGSL通过将类型定义为一种值的类型，并允许表达式表示一个类型来使规则保持一致。


<p>
动机案例是一个"模板参数"，在各种上下文中可以表示多种事物，包括一个"类型"、一个"枚举值"或一个"基本类型值"。
特别是，"syntax/template_arg_expression"语法规则会展开为"syntax/expression"语法非终结符。
</div>

## 类型别名 ## {#type-aliases}

一个<dfn noexport>类型别名</dfn>为现有类型声明了一个新名称。
声明必须出现在模块范围内，并且其作用域为整个程序。


当类型T被定义为结构类型S的一个类型别名时，
S的成员的所有属性，包括特性，都会传递给T的成员。

<pre class=include>
path: syntax/type_alias_decl.syntax.bs.include
</pre>

<div class='example wgsl global-scope' heading='Type Alias'>
  <xmp>
    alias Arr = array<i32, 5>;

    alias RTArr = array<vec4<f32>>;

    alias single = f32;     // Declare an alias for f32
    const pi_approx: single = 3.1415;
    fn two_pi() -> single {
      return single(2) * pi_approx;
    }
  </xmp>
</div>

## 类型指示语法 ## {#type-specifiers}

请参见[[#type-expr]]。


<pre class=include>
path: syntax/type_specifier.syntax.bs.include
</pre>


<pre class=include>
path: syntax/template_elaborated_ident.syntax.bs.include
</pre>


注意：通过展开的方式，[=expression=]也可以表示一种类型，通过扩展语法/primary_expression=]的语法规则到[syntax/template_elaborated_ident=]，以及通过[[#parenthesized-expressions|parenthesization]]的方式。

## 预声明类型和类型生成器总结 ## {#predeclared-types}

在WGSL源代码中可以拼写的预定义类型包括：
* [=bool=]
* [=f16=]
* [=f32=]
* [=i32=]
* [=type/sampler=]
* [=type/sampler_comparison=]
* [=type/texture_depth_2d=]
* [=type/texture_depth_2d_array=]
* [=type/texture_depth_cube=]
* [=type/texture_depth_cube_array=]
* [=type/texture_depth_multisampled_2d=]
* [=type/texture_external=]
* [=u32=]

WGSL还预先声明了[[#frexp-builtin|frexp]]、[[#modf-builtin|modf]]和[[#atomic-rmw|atomicCompareExchangeWeak]]内建函数的返回类型。
然而，这些类型在WGSL源代码中不能拼写。


以下表格列出了预声明的类型生成器：
<table class=data>
<caption>
  Predeclared type generators
</caption>
<thead>
  <tr><th>Predeclared type-generator<th>Cross-reference
</thead>
  <tr><td>array<td>See [[#array-types]]
  <tr><td>atomic<td>See [[#atomic-types]]
  <tr><td>mat2x2<td rowspan=9>See [[#matrix-types]], which also lists
     predeclared [=type aliases|aliases=] for matrix types.

     Note: These are also used in [=value constructor=] expressions
     to create matrices.
  <tr><td>mat2x3
  <tr><td>mat2x4
  <tr><td>mat3x2
  <tr><td>mat3x3
  <tr><td>mat3x4
  <tr><td>mat4x2
  <tr><td>mat4x3
  <tr><td>mat4x4
  <tr><td>ptr<td>See [[#ref-ptr-types]]
  <tr><td>texture_1d<td rowspan=6>See [[#sampled-texture-type]]
  <tr><td>texture_2d
  <tr><td>texture_2d_array
  <tr><td>texture_3d
  <tr><td>texture_cube
  <tr><td>texture_cube_array
  <tr><td>texture_multisampled_2d<td>See [[#multisampled-texture-type]]
  <tr><td>texture_storage_1d<td rowspan=4>See [[#texture-storage]]
  <tr><td>texture_storage_2d
  <tr><td>texture_storage_2d_array
  <tr><td>texture_storage_3d
  <tr><td>vec2<td rowspan=3>See [[#vector-types]], which also lists
     predeclared [=type aliases|aliases=] for vector types.

     Note: These are also used in [=value constructor=] expressions
     to create vectors.
  <tr><td>vec3
  <tr><td>vec4
</table>

# 变量和值的声明 # {#var-and-value}

[=变量声明|变量=]和[=值声明|值=]声明为数据值提供了名称。


<dfn noexport>值声明</dfn>创建一个值的名称，一旦声明，该值就是不可变的。
值声明有四种种类：const、override、let和形式参数声明，下面会进一步描述（见[[#value-decls]]）。


<dfn noexport>变量声明</dfn>为[=内存位置=]创建一个名称，用于存储值；如果变量具有[=访问/读写=]访问模式，那么存储在该位置的值可以被更新。
变量声明只有一种类型，即var，但可以在各种组合中选择[=地址空间=]和[=访问模式=]的选项，下面会进行描述（见[[#var-decls]]）。


注意：值声明没有关联的内存位置。例如，WGSL表达式无法形成指向该值的指针。


在任何函数定义之外出现的声明位于[=模块作用域=]中。它的名称在整个程序中[=在作用域内=]。


在函数定义中出现的声明位于<dfn noexport>函数作用域</dfn>中。
该名称在声明之后的语句中立即可用，直到声明所包含的大括号列表的结束。
函数作用域声明是一个[=动态上下文=]。


变量和值声明具有相似的总体语法：
<xmp>
  // Specific value declarations.
               const    name [: type]  = initializer ;
  [attribute]* override name [: type] [= initializer];
               let      name [: type]  = initializer ;

  // General variable form.
  [attribute]* var[<address_space[, access_mode]>] name [: type] [= initializer];

  // Specific variable declarations.
  // Function scope.
               var[<function>] name [: type] [= initializer];

  // Module scope.
               var<private>    name [: type] [= initializer];
               var<workgroup>  name : type;
  [attribute]+ var<uniform>    name : type;
  [attribute]+ var             name : texture_type;
  [attribute]+ var             name : sampler_type;
  [attribute]+ var<storage[, access_mode]> name : type;
</xmp>

每个这样的声明都必须具有显式指定的类型或初始化器。
可以同时指定类型和初始化器。
每个这样的声明确定与其关联的数据值的类型，被称为该声明的有效值类型。
该声明的有效值类型为：

* 如果显式指定了类型，则为声明的类型。
* 否则，如果初始化器表达式的类型为 T：
    * 对于 const 声明，有效值类型为 T 本身。
    * 对于 override、let 或 var 声明，有效值类型为 T 的具体化。

如果存在的话，每种值或变量声明方式可以对初始化器表达式的形式和有效值类型施加额外的约束。

<table class='data'>
<caption>
  Variable and Value Declaration Feature Summary.
</caption>
<thead>
  <tr><th>Declaration
      <th>Mutability
      <th>Scope
      <th>[=Effective-value-type=]<sup>1</sup>
      <th>Initializer Support
      <th>Initializer Expression<sup>2</sup>
      <th>Part of Resource Interface
</thead>
<tr><td>[=const-declaration|const=]
    <td>Immutable
    <td>[=module scope|Module=] or [=function scope|function=]
    <td>[=Constructible=] ([=type/concrete|Concrete=] or [=type/abstract|abstract=])
    <td>Required
    <td>[=const-expression=]
    <td>No

<tr><td>[=override-declaration|override=]
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=scalar=]
    <td>Optional<sup>3</sup>
    <td>[=const-expression=] or [=override-expression=]
    <td>No<sup>4</sup>

<tr><td>[=let-declaration|let=]
    <td>Immutable
    <td>[=function scope|Function=]
    <td>[=type/concrete|Concrete=] [=constructible=] or [=pointer type=]
    <td>Required
    <td>[=const-expression=], [=override-expression=], or [=runtime expression=]
    <td>No

<tr><td class="nowrap">
        [=variable|var=]&lt;[=address spaces/storage=], read&gt;<br>
        [=variable|var=]&lt;[=address spaces/storage=]&gt;
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=host-shareable=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=storage buffer=]

<tr><td class="nowrap">
        [=variable|var=]&lt;[=address spaces/storage=], read_write&gt;<sup>5,6</sup>
    <td>Mutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=host-shareable=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=storage buffer=]

<tr><td>[=variable|var=]&lt;[=address spaces/uniform=]&gt;
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=constructible=] [=host-shareable=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=uniform buffer=]

<tr><td>[=variable|var=]<sup>6</sup>
    <td>Immutable<sup>7</sup>
    <td>[=module scope|Module=]
    <td>[=texture type|Texture=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=texture resource=]

<tr><td>[=variable|var=]
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=sampler type|Sampler=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=sampler resource=]

<tr><td>[=variable|var=]&lt;[=address spaces/workgroup=]&gt;<sup>6,8</sup>
    <td>Mutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=plain type=] with a [=fixed footprint=]<sup>9</sup>
    <td>Disallowed<sup>10</sup>
    <td>
    <td>No

<tr><td>[=variable|var=]&lt;[=address spaces/private=]&gt;
    <td>Mutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=constructible=]
    <td>Optional<sup>10</sup>
    <td>[=const-expression=] or [=override-expression=]
    <td>No

<tr><td>[=variable|var=]&lt;[=address spaces/function=]&gt;<br>
        [=variable|var=]
    <td>Mutable
    <td>[=function scope|Function=]
    <td>[=type/concrete|Concrete=] [=constructible=]
    <td>Optional<sup>10</sup>
    <td>[=const-expression=], [=override-expression=], or [=runtime expression=]
    <td>No

</table>
1. 只有 [=const-declarations=] 可以是 [=type/abstract=] 类型，而且只有在类型没有明确指定的情况下。
1. 表达式的类型必须能够 [=可行自动转换|可行转换=] 为 [=effective-value-type=]。
1. 如果没有指定初始化器，则必须在 [=pipeline creation|pipeline-creation time=] 提供一个值。
1. [=Override-declarations=] 是着色器接口的一部分，但不是绑定的资源。
1. 具有与 [=access/read=] 不同的访问模式的 [=storage buffers=] 和 [=type/storage textures=] 不能在 [=vertex shader stage=] 中被 [=静态访问=]。
1. 参见 WebGPU {{GPUDevice/createBindGroupLayout()}}。
1. [=Atomic types=] 只能出现在可变的存储缓冲区或工作组变量中。
1. 具有 [=access/write=] 或 [=access/read_write=] [=access mode=] 的 [[#texture-storage|storage textures]] 中的数据是可变的，但只能通过 [[#texturestore|textureStore]] 内置函数来修改。
1. 变量本身不能被修改。
1. [=address spaces/workgroup=] 地址空间中的变量只能在 [=compute shader stage=] 中被 [=静态访问=]。
1. 最外层的 [=array=] 的 [=element count=] 可以是一个 [=override-expression=]。
1. 如果没有初始化器，则变量被 [=default initial value|default initialized=]。

## 变量与值 ## {#var-vs-value}

【变量声明】是WGSL模块中唯一可变的数据。【值声明】始终是不可变的。
变量可以作为【引用类型】和【指针类型】值的基础，因为变量有关联的【内存位置】，而值声明不能作为指针或引用值的基础。


使用变量通常比使用值声明更昂贵，因为使用变量需要额外的操作来读取或写入与变量关联的【内存位置】。


一般来说，作者应该优先使用以下声明方式，按照首选选项列出：
* 【const声明】
* 【override声明】
* 【let声明】
* 【变量声明】

这通常会导致着色器的整体性能最佳。

## 值声明 ## {#value-decls}

当[=标识符=]解析为[=值声明=]时，该标识符表示该值。


WGSL提供多种类型的值声明。
每种声明的值在[[#shader-lifecycle|着色器生命周期]]的不同点固定。
不同种类的值声明以及其值的固定时间是：
* [=常量声明=]，在[=着色器模块创建|创建着色器时=]
* [=覆盖声明=]，在[=管线创建|创建管线时=]
* [=局部声明=]，当它们被执行时
* [=形式参数=]声明，在关联的[=函数调用=]参数被执行时

注意：[=形式参数=]的描述在[[#functions]]中。

### `const` 声明 ### {#const-decls}

常量声明指定一个在着色器模块创建时固定的数据值的名称。每个常量声明都需要一个初始化器。常量声明可以在模块范围或函数范围内声明。初始化表达式必须是一个常量表达式。常量声明的类型必须是一个具体类型或可构造的抽象类型。常量声明是唯一一个有效值类型可以是抽象类型的声明。

注意：由于WGSL中无法明确表示抽象数值类型，因此只能通过类型推导来使用它们。

<div class='example wgsl global-scope' heading='const-declarations at module scope'>
  <xmp>
    const a = 4;                  // AbstractInt with a value of 4.
    const b : i32 = 4;            // i32 with a value of 4.
    const c : u32 = 4;            // u32 with a value of 4.
    const d : f32 = 4;            // f32 with a value of 4.
    const e = vec3(a, a, a);      // vec3 of AbstractInt with a value of (4, 4, 4).
    const f = 2.0;                // AbstractFloat with a value of 2.
    const g = mat2x2(a, f, a, f); // mat2x2 of AbstractFloat with a value of:
                                  // ((4.0, 2.0), (4.0, 2.0)).
                                  // The AbstractInt a converts to AbstractFloat.
                                  // An AbstractFloat cannot convert to AbstractInt.
    const h = array(a, f, a, f);  // array of AbstractFloat with 4 components:
                                  // (4.0, 2.0, 4.0, 2.0).
  </xmp>
</div>

### `override` 声明 ### {#override-decls}

一个覆盖声明指定了一个流水线可覆盖常量值的名称。流水线可覆盖常量的值在流水线创建时确定。这个值是由WebGPU流水线创建方法提供的，如果指定了的话；否则，它是其初始化表达式的具体化值。覆盖声明的有效值类型必须是一个具体化的标量类型。


初始化表达式是可选的。如果存在，它必须是一个覆盖表达式，并表示流水线可覆盖常量的默认值。如果没有指定初始化器，在流水线创建时如果没有提供一个值，将产生一个流水线创建错误。


如果声明应用了属性ID，字面操作数被称为流水线常量ID，并且必须是一个介于0和65535之间的唯一整数。也就是说，两个覆盖声明不能使用相同的流水线常量ID。


应用程序可以在流水线创建时为覆盖声明指定自己的值。流水线创建API接受一个从可覆盖常量到常量类型值的映射。常量由一个流水线可覆盖常量标识字符串来标识，如果指定了的话，它是流水线常量ID的十进制表示，否则是常量的声明名称。

<div class='example wgsl global-scope' heading='Module constants, pipeline-overrideable'>
  <xmp>
    @id(0)    override has_point_light: bool = true;  // Algorithmic control
    @id(1200) override specular_param: f32 = 2.3;     // Numeric control
    @id(1300) override gain: f32;                     // Must be overridden
              override width: f32 = 0.0;              // Specified at the API level using
                                                      // the name "width".
              override depth: f32;                    // Specified at the API level using
                                                      // the name "depth".
                                                      // Must be overridden.
              override height = 2 * depth;            // The default value
                                                      // (if not set at the API level),
                                                      // depends on another
                                                      // overridable constant.

  </xmp>
</div>


### `let` 声明 ### {#let-decls}

一个<dfn noexport> let-declaration </dfn>指定了一个值的名称，每次在运行时执行语句时都是固定的。
let声明只能在[=函数作用域=]中声明，因此是一个[=动态环境=]。
let声明必须具有初始化表达式。
该值是初始化器的[=value.concretized=]值的[=具体化=]。
let声明的[=有效值类型=]必须是一个[=type/concrete=]可[=构造=]类型或一个[=指针类型=]。

<div class='example wgsl let-declaration at function-scope' heading='let-declared constants at function scope'>
  <xmp>
    // 'blockSize' denotes the i32 value 1024.
    let blockSize: i32 = 1024;

    // 'row_size' denotes the u32 value 16u.  The type is inferred.
    let row_size = 16u;
  </xmp>
</div>

## `var` 声明 ## {#var-decls}

一个<dfn>变量</dfn>是指向内存的命名引用，可以包含特定的[=可存储=]类型的值。


一个变量与两种类型相关联：它的[=存储类型=]（可以放置在引用内存中的值的类型）和它的[=引用类型=]（变量本身的类型）。
如果一个变量的存储类型为T，[=地址空间=]为AS，[=访问模式=]为AM，那么它的引用类型为ref<AS,T,AM>。
一个变量的存储类型总是[=具体类型=]。


一个变量声明：
* 指定变量的[=名称=]。
* 确定变量的[=地址空间=]、[=存储类型=]和[=访问模式=]。 这些共同组成了变量的[=引用类型=]。
    * 存储类型是变量声明的[=有效值类型=]。
* 确保执行环境为存储类型的值在指定的地址空间中分配内存，并支持给定的访问模式，为变量的[=生命周期=]分配内存。
* 可选地具有初始化表达式，如果变量在[=地址空间/私有=]或[=地址空间/函数=]的地址空间中。 如果存在初始化表达式，则该初始化表达式必须求值为变量的存储类型。 如果存在，[=地址空间/私有=]变量的初始化表达式必须是[=const-expression=]或[=override-expression=]。 除[=地址空间/函数=]或[=地址空间/私有=]之外的地址空间中的变量[=着色器创建错误|=不能=]具有初始化器。

当一个[=标识符=]解析为一个变量声明时，该标识符是一个表示变量内存的引用的表达式，其类型是变量的[=引用类型=]。请参见[[#var-identifier-expr]]。

如果程序源代码中指定了变量声明的[=地址空间=]或[=访问模式=]，则它们在var关键字之后作为一个[=模板列表=]写入：
* 首先指定[=地址空间=]，作为预定义的地址空间[=枚举值=]之一。
* 其次指定[=访问模式=]，如果存在的话，作为预定义的地址模式[=枚举值=]之一。
    * 如果指定了访问模式，则必须指定地址空间。

[=地址空间/私有=]、[=地址空间/存储=]、[=地址空间/统一=]、[=地址空间/工作组=]和[=地址空间/句柄=]中的变量只能在[=模块作用域=]中声明，而[=地址空间/函数=]中的变量只能在[=函数作用域=]中声明。
除句柄和函数之外的所有地址空间都必须指定地址空间[=着色器创建错误|必须=]。
句柄地址空间[=着色器创建错误|不能=]被指定。
指定函数地址空间是可选的。


[=访问模式=]始终有一个默认值，除了[=地址空间/存储=]地址空间中的变量之外，[=着色器创建错误|不能=]在WGSL源代码中指定。
请参见[[#address-space]]。


[=地址空间/统一=]地址空间中的变量是一个<dfn noexport>统一缓冲区</dfn>变量。
它的[=存储类型=]必须是一个[=可主机共享=]的[=可构造=]类型，并且必须满足[[#address-space-layout-constraints|地址空间布局约束]]。


[=地址空间/存储=]地址空间中的变量是一个<dfn noexport>存储缓冲区</dfn>变量。
它的[=存储类型=]必须是一个[=可主机共享=]类型，并且必须满足[[#address-space-layout-constraints|地址空间布局约束]]。
该变量可以以[=访问/读=]或[=访问/读写=]访问模式声明；默认值是读。


一个<dfn>纹理资源</dfn>是一个[=有效值类型=]为[=纹理类型=]的变量。
它在[=模块作用域=]中声明。
它保存一个用于访问[=纹理=]中的基础纹素格子的不透明句柄。
句柄本身位于[=地址空间/句柄=]地址空间，并且始终是只读的。
在许多情况下，基础纹素是只读的，我们称纹理变量为不可变的。
对于[=类型/只写存储纹理=]和[=类型/读写存储纹理=]，基础纹素是可变的，按照惯例，我们称纹理变量为可变的。


一个<dfn>采样器资源</dfn>是一个[=有效值类型=]为[=采样器类型=]的变量。
它在[=模块作用域=]中声明，在[=地址空间/句柄=]地址空间中存在，并且是不可变的。


如[[#resource-interface]]所述，统一缓冲区、存储缓冲区、纹理和采样器形成了[=着色器的资源接口=]。

变量的"生命周期"是指在着色器执行期间与变量相关的内存位置的时间段。
模块作用域变量的生命周期是整个着色器阶段的执行过程。
每个调用都有一个独立版本的地址空间/私有和地址空间/函数变量。
函数作用域变量是一个动态上下文。
函数作用域变量的生命周期由其作用域确定：
* 当控制流进入变量定义时，它开始。
* 当名称不再处于任何部分的动态上下文的作用域内时，它结束。 也就是说，生命周期包括名称在作用域内时调用的任何函数。

两个资源变量可能具有重叠的内存位置，但如果其中任何一个变量是可变的，那么这将是一个动态错误。
具有重叠生命周期的其他变量不会有重叠的内存位置。
当变量的生命周期结束时，其内存可以用于另一个变量。


注意：WGSL确保变量的内容仅在变量的生命周期内可观察。


在地址空间/私有、地址空间/函数或地址空间/工作组中创建变量时，它将具有初始值。
如果没有指定初始化器，则初始值为默认初始值。
初始值的计算如下：
* 对于函数地址空间中的变量：
    * 如果变量声明没有指定初始化程序，则为存储类型的零值。
    * 否则，它是在程序执行的那个时间点计算出的值的具体化结果的初始化程序表达式的结果。
* 对于私有地址空间中的变量：
    * 如果变量声明没有指定初始化程序，则为存储类型的零值。
    * 否则，它是计算出的值的具体化结果的初始化程序表达式的结果。 初始化程序必须是一个"覆盖表达式"，所以它的值在"管道创建时间"之前是固定的。
* 对于工作组地址空间中的变量：
    * 当存储类型是可构造的时，使用存储类型的零值。
    * 如果存储类型是原子类型，则零值为底层类型的零值（具体的整数标量类型）。
    * 否则，如果存储类型不可构造，则零值通过递归地将这些规则应用于组合体的每个组件，直到遇到可构造类型来确定。
        * 注意：当使用具有"管道可覆盖"元素计数的数组或包含原子类型的组合体时，通常会发生这种情况。

其他地址空间中的变量是通过"绘制命令"或"调度命令"中的绑定设置的资源。

考虑以下的WGSL片段：
<div class='example wgsl function-scope' heading='Variable initial values'>
  <xmp>
    var i: i32;         // Initial value is 0.  Not recommended style.
    loop {
      var twice: i32 = 2 * i;   // Re-evaluated each iteration.
      i++;
      if i == 5 { break; }
    }
  </xmp>
</div>
循环体将执行六次。
变量 i 将取值0、1、2、3、4、5，而变量 twice 将取值0、2、4、6、8。

请考虑以下 WGSL 代码片段：
<div class='example wgsl function-scope' heading='Reading a variable multiple times'>
  <xmp>
    var x: f32 = 1.0;
    let y = x * x + x + 1;
  </xmp>
</div>
因为x是一个变量，所有对它的访问都变成了载入（load）和存储（store）操作。
然而，预期浏览器或驱动程序会优化这个中间表示，使冗余的载入操作被消除掉。

<div class='example wgsl global-scope' heading="Module scope variable declarations">
  <xmp>
    var<private> decibels: f32;
    var<workgroup> worklist: array<i32,10>;

    struct Params {
      specular: f32,
      count: i32
    }

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    @group(0) @binding(2)
    var<uniform> param: Params;    // A uniform buffer

    // A storage buffer, for reading and writing
    @group(0) @binding(0)
    var<storage,read_write> pbuf: array<vec2<f32>>;

    // Textures and samplers are always in "handle" space.
    @group(0) @binding(1)
    var filter_params: sampler;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Access modes for buffers'>
  <xmp>
    // Storage buffers
    @group(0) @binding(0)
    var<storage,read> buf1: Buffer;       // Can read, cannot write.
    @group(0) @binding(0)
    var<storage> buf2: Buffer;            // Can read, cannot write.
    @group(0) @binding(1)
    var<storage,read_write> buf3: Buffer; // Can both read and write.

    struct ParamsTable {weight: f32}

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    @group(0) @binding(2)
    var<uniform> params: ParamsTable;     // Can read, cannot write.
  </xmp>
</div>

<div class='example wgsl global-scope' heading="Function scope variables and constants">
  <xmp>
    fn f() {
       var<function> count: u32;  // A variable in function address space.
       var delta: i32;            // Another variable in the function address space.
       var sum: f32 = 0.0;        // A function address space variable with initializer.
       var pi = 3.14159;          // Infer the f32 store type from the initializer.
    }
  </xmp>
</div>

## 变量和值声明语法总结 ## {#var-and-value-decl-grammar}

<pre class=include>
path: syntax/variable_or_value_statement.syntax.bs.include
</pre>
<pre class=include>
path: syntax/variable_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/optionally_typed_ident.syntax.bs.include
</pre>
<pre class=include>
path: syntax/global_variable_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/global_value_decl.syntax.bs.include
</pre>

# 表达式 # {#expressions}

[=Expressions=]指定了值如何进行计算。


不同类型的值表达式在它们的计算时机和表达能力之间进行权衡。
计算越早，操作限制越大，但值能够在更多的地方使用。这种权衡导致了每种值声明类型的不同灵活性。
在执行GPU上的操作之前，会先评估[=const-expressions=]和[=override-expressions=]，因此在最终的GPU代码中只需要计算表达式的结果即可。
此外，由于[=const-expressions=]在[=shader module creation|shader-creation time=]时进行评估，因此它们可以在更多的情况下使用，例如在[=function scope=]中调整[=arrays=]的大小或进行[=variable declaration|variables=]。
<dfn noexport>运行时表达式</dfn>是指既不是[=const-expression=]也不是[=override-expression=]的表达式。
运行时表达式在Shader执行期间在GPU上进行计算。
尽管运行时表达式只能被更少的语法元素使用，但它们可以由更大类的表达式计算得出，例如其他运行时值。

## 早期评估表达式 ## {#early-eval-exprs}

WGSL定义了两种在运行时之前可以评估的表达式类型：

* [=const-expressions=]，在 [=着色器模块创建|着色器创建时间=]时评估
* [=override-expressions=]，在 [=管线创建|管线创建时间=]时评估

### `const` 表达式 ### {#const-expr}

在[=shader module creation|shader-creation time=]可以评估的表达式被称为<dfn noexport>常量表达式</dfn>。
如果一个表达式的所有[=identifiers=]都解析为以下类型之一，那么它就是一个常量表达式：
* [=const-declarations=]，或
* [=const-functions=]，或
* [=type aliases=]，或
* [=structure=]名称。

const表达式的类型必须符合[=creation-fixed footprint=]的类型规则。


注意：[=type/abstract|抽象类型=]可以是常量表达式的推断类型。


如果且仅当满足以下条件之一，常量表达式 |E| 将被评估：
* |E| 是一个[=top-level expression=]，或
* |E| 是表达式 |OuterE| 的一个[=subexpression=]，并且 |OuterE| 的评估将被执行，并且 |OuterE| 的评估需要 |E| 被评估。

注意：评估规则意味着短路运算符 && 和 || 会防止对它们右侧的子表达式进行评估。

一个const表达式可以由实现WebGPU API方法的CPU进行评估。
因此，在操作[=AbstractFloat=]值时，准确性要求不再严格，只要满足常见的WebGPU运行环境的要求，比如WebAssembly[[WASM-CORE-2]]和ECMAScript[[ECMASCRIPT]]。
具体浮点类型（例如f32）的准确性要求在[[#concrete-float-accuracy]]中指定。

例如：(42)的分析如下：
* 术语42是[=AbstractInt=]值42。
* 把该术语用括号括起来生成一个新的表达式（42），它的类型是[=AbstractInt=]，值为42。

例如：-5的分析如下：
* 术语5是[=AbstractInt=]值5。
* 在该术语之前加上'-'生成一个新的表达式-5，它的类型是[=AbstractInt=]，值为-5。

示例：-2147483648的分析如下：
* 术语2147483648是一个[=AbstractInt=]值2147483648。 请注意，此值不适合32位有符号整数。
* 在该术语前面加上’-'会产生一个新的表达式-2147483648，其类型为[=AbstractInt=]，值为-2147483648。

示例：const minint = -2147483648;的分析如下：
* 如上所述，-2147483648求得一个[=AbstractInt=]值-2147483648。
* [=const-declaration=]允许初始化器是一个[=abstract numeric type=]。
* 结果是minint被声明为一个[=AbstractInt=]值-2147483648。

示例：let minint = -2147483648;的分析如下：
* 如上所述，-2147483648求得一个[=AbstractInt=]值-2147483648。
* [=let-declaration=]要求初始化器是一个[=type/concrete=] [=constructible=]类型或者是一个指针类型。
* let-declaration没有显式类型，因此使用[=overload resolution=]。 适用的重载候选项使用[=AbstractInt=]到[=i32=]，[=u32=]或[=f32=]的[=feasible automatic conversions=]。 最低等级的一个是到[=i32=]的，因此 [AbstractInt=] -2147483648值被转换为[=i32=]值-2147483648。
* 结果是minint被声明为i32值-2147483648。

示例：false && (10i < i32(5 * 1000 * 1000 * 1000)) 的分析如下:

* 整个表达式是一个常量表达式。
* 然而，逻辑运算符 && 的短路规则适用： 左侧评估为 false，因此右侧的表达式不会被评估。
* 评估 i32(5 * 1000 * 1000 * 1000) 会导致一个[=shader-creation error=]， 因为[=AbstractInt=] 的值 5000000000 溢出了 [=i32=] 类型。


### `override` 表达式 ### {#override-expr}

在[=流水线创建=]时间可评估的表达式被称为<dfn noexport>覆盖表达式</dfn>。
如果一个表达式的所有[=标识符=]都能[=解析=]到以下内容，则该表达式为覆盖表达式：
* [=覆盖声明=]，或
* [=常量声明=]，或
* [=常量函数=]，或
* [=类型别名=]，或
* [=结构名称=]。

注：所有[=常量表达式=]也是覆盖表达式。

当且仅当满足以下条件时，覆盖表达式|E|将会被评估：
* |E|是[=顶层表达式=]，或
* |E|是表达式|OuterE|的[=子表达式=]，且表达式|OuterE|将会被评估， 且|OuterE|的评估需要对|E|进行评估。

注意：并非所有的覆盖表达式都可以用作[=override-declaration=]的初始化器，因为这样的初始化器必须[=type rules|resolve=]为一个[=type/concrete=]的[=scalar=]类型。


例如：override x = 42;的分析如下：
* 术语42是一个[=AbstractInt=]值42。
* 一个[=override-declaration=]需要一个[=type/concrete=]的[=scalar=]类型。
* 通过[=feasible automatic conversion=]将42转换为[=i32=]。

例如：let y = x + 1;的分析如下：
* 从上面可知，x的类型是[=i32=]。
* 表达式x + 1是一个覆盖表达式，因为它由一个[=override-declaration=]和一个[=integer literal=]组成。
* 表达式的类型是[=i32=]，并在[=pipeline creation=]时进行评估。 它的值取决于x是否在管道创建时被覆盖。

示例：'vec3(x,x,x)'的分析如下：
* 从上面来看，'x’是一个类型为’i32’的重写声明。
* 'vec3(x,x,x)'是一个重写表达式，因为只有标识符可以解析为重写声明。
* 表达式的类型是’i32’类型的三个分量的向量（‘vec3<i32>’）。

## 不确定的值 ## {#indeterminate-values}

在有限的情况下，可以使用不支持的值对运行时表达式进行评估。


在这种情况下，评估的结果是表达式的静态类型的一个不确定值，这意味着某个静态类型的任意实现选定的值。


对于表达式的每个唯一的动态上下文，可以生成一个不同的值。例如，如果评估在循环的每次迭代中发生，可能为每个循环迭代计算一个不同的值。


注意：如果类型是浮点类型并且实现支持NaN值，则运行时产生的不确定值可能是NaN值。

<div class='example wgsl global-scope' heading="Indeterminate value example">
  <xmp>
    fn fun() {
       var extracted_values: array<i32,2>;
       const v = vec2<i32>(0,1);

       for (var i: i32 = 0; i < 2 ; i++) {
          // A runtime-expression used to index a vector, but outside the
          // indexing bounds of the vector, produces an indeterminate value
          // of the vector component type.
          let extract = v[i+5];

          // Now 'extract' is any value of type i32.

          // Save it for later.
          extracted_values[i] = extract;

          if extract == extract {
             // This is always executed
          }
          if extract < 2 {
             // This might be executed, but might not be executed.
             // Even though the original vector components are 0 and 1,
             // the extracted value might not be either of those values.
          }
       }
       if extracted_values[0] == extracted_values[1] {
          // This might be executed, but might not be executed.
       }
    }

    fn float_fun(runtime_index: u32) {
       const v = vec2<f32>(0,1); // A vector of floating point values

       // As in the previous example, 'float_extract' is an indeterminate value.
       // Since it is a floating point type, it may be a NaN.
       let float_extract: f32 = v[runtime_index+5];

       if float_extract == float_extract {
          // This *might not* be executed, because:
          //  -  'float_extract' may be NaN, and
          //  -  a NaN is never equal to any other floating point number,
          //     even another NaN.
       }
    }
  </xmp>
</div>


## 字面量表达式 ## {#literal-expressions}

<table class='data'>
  <caption>Scalar literal type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr><td>
      <td>`true`: bool
      <td>`true` boolean value.
  <tr><td>
      <td>`false`: bool
      <td>`false` boolean value.
  <tr><td>|e| is an [=integer literal=] with no suffix
      <td>|e|: AbstractInt
      <td>Abstract integer literal value.
  <tr><td>|e| is a [=floating point literal=] with no suffix
      <td>|e|: AbstractFloat
      <td>Abstract float literal value.
  <tr><td>|e| is an [=integer literal=] with `i` suffix
      <td>|e|: i32
      <td>32-bit signed integer literal value.
  <tr><td>|e| is an [=integer literal=] with `u` suffix
      <td>|e|: u32
      <td>32-bit unsigned integer literal value.
  <tr><td>|e| is an [=floating point literal=] with `f` suffix
      <td>|e|: f32
      <td>32-bit floating point literal value.
  <tr><td>|e| is an [=floating point literal=] with `h` suffix
      <td>|e|: f16
      <td>16-bit floating point literal value.
</table>

## 括号表达式 ## {#parenthesized-expressions}

<table class='data'>
  <caption>Parenthesized expression type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="parenthesized expression">
      <td>|e| : |T|
      <td>`(` |e| `)` : |T|
      <td>Evaluates to |e|.<br>
          Use parentheses to isolate an expression from the surrounding text.
</table>

## 复合值分解表达式 ## {#composite-value-decomposition-expr}
本节描述了获取复合值的一个组成部分的表达式，以及从包含复合值的引用中获取到该组成部分的引用类型的表达式。对于这个讨论，复合值或者对复合值的引用被称为"基础(base)"。

有两种方法可以做到这一点：
: 命名组成部分表达式：基础(B)的表达式后跟一个句点"."（U+002E），然后是组成部分的名称。
:: 当B是矢量(vector)或结构(structure)类型，或者是对矢量或结构类型的引用时，支持这种表达式。
    * 有效的名称取决于B的类型。
: 索引表达式：
:: 基础的表达式后跟一个左括号"["（U+005B），然后是索引表达式，最后是右括号"]"（U+005D）。
    * 基础可以是矢量、矩阵(matrix)、固定大小数组(fixed-size array)类型，或者是对矢量、矩阵、固定大小数组或运行时大小数组(runtime-sized array)类型的引用。
    * 索引表达式必须是整数标量(integer scalar)类型。

从语法上讲，这两种形式体现了使用"syntax/component_or_swizzle_specifier"语法规则。

<div algorithm="out of bounds index">
一个[=索引表达式=]的索引值|i|是一个<dfn noexport>在边界内的索引</dfn>，如果0 ≤ |i| < |N|，其中|N|是复合类型的组件（元素）的数量：
* 当基类型是向量或者是一个向量的引用时，|N|是向量类型的组件数。
* 当基类型是矩阵或者是一个矩阵的引用时，|N|是矩阵类型的列数。
* 当基类型是固定大小的数组或者是一个固定大小数组的引用时，|N|是固定大小数组的元素数量。
* 当基类型是一个运行时大小的数组的引用时，|N|是基类型的运行时大小。

当索引值不是一个[=在边界内的索引=]时，它是一个<dfn noexport>超出边界的索引</dfn>。
超出边界的索引通常是一个程序缺陷，并且往往会引发错误。
详见下文。
</div>

此外，向量类型还支持使用[=swizzle|swizzling=]语法，从另一个向量的分量创建一个新的向量值。

### 矢量访问表达式 ### {#vector-access-expr}

访问向量的组件可以通过以下两种方式进行：

* 使用数组下标（例如v[2]），
* 使用一组方便的名称（称为<dfn noexport>swizzle</dfn>名称），其表示为一系列映射到源向量组件的方便名称。
    * 方便名称的颜色集：r、g、b、a分别对应向量分量0、1、2和3。
    * 方便名称的尺寸集：x、y、z、w分别对应向量分量0、1、2和3。

可以使用.符号来访问方便名称（例如color.bgra）。
方便名称不应混用。例如，不能使用.rybw。
方便名称不能访问超出向量结尾的组件。
可以以任何顺序应用方便名称，包括根据需要重复使用字母。
提供的字母数必须介于1和4之间。
也就是说，使用方便名称只能生成有效的向量类型。
结果类型取决于提供的字母数。假设一个vec4<f32>

<table>
  <thead>
    <tr><th>Accessor<th>Result type
  </thead>
  <tr><td>r<td>`f32`
  <tr><td>rg<td>`vec2<f32>`
  <tr><td>rgb<td>`vec3<f32>`
  <tr><td>rgba<td>`vec4<f32>`
</table>

<div class='example wgsl function-scope'>
  <xmp>
    var a: vec3<f32> = vec3<f32>(1., 2., 3.);
    var b: f32 = a.y;          // b = 2.0
    var c: vec2<f32> = a.bb;   // c = (3.0, 3.0)
    var d: vec3<f32> = a.zyx;  // d = (3.0, 2.0, 1.0)
    var e: f32 = a[1];         // e = 2.0
  </xmp>
</div>

#### 向量单组件选择 #### {#vector-single-component}

<table class=‘data’>
<caption>矢量分解：单个分量选取</caption>
<thead>
<tr><th>前提<th>结论<th>描述
</thead>
<tr algorithm="第一个矢量分量选取"><td>|e|: vec|N|<|T|><br>
<td class="nowrap">
|e|.x: |T|<br>
|e|.r: |T|
<td>选取矢量|e|的第一个分量
<tr algorithm="第二个矢量分量选取"><td>|e|: vec|N|<|T|><br>
<td class="nowrap">
|e|.y: |T|<br>
|e|.g: |T|
<td>选取矢量|e|的第二个分量
<tr algorithm="第三个矢量分量选取"><td>|e|: vec|N|<|T|><br>
|N| 为 3 或 4
<td class="nowrap">
|e|.z: |T|<br>
|e|.b: |T|
<td>选取矢量|e|的第三个分量
<tr algorithm="第四个矢量分量选取"><td>|e|: vec4<|T|>
<td class="nowrap">
|e|.w: |T|<br>
|e|.a: |T|
<td>选取矢量|e|的第四个分量


<tr algorithm="具体矢量索引分量选取">
<td>|e|: vec|N|<|T|><br>
|i|: [INT]<br>
|T| 为 [=type/concrete=]
<td class="nowrap">
|e|[|i|]: |T|
<td>选取矢量的第|i|个分量<br>
第一个分量的索引为|i|=0。


       如果|i|超出范围[0,|N|-1]：<br>
       * 如果|i|是一个常量表达式，则为一个[=shader-creation error=]。
       * 如果|i|是一个覆盖表达式，则为一个[=pipeline-creation error=]。
       * 否则可能返回一个[=indeterminate value=]。

<tr algorithm="抽象矢量索引分量选取">
<td>|e|: vec|N|<|T|><br>
|i|: [INT]<br>
|T| 为 [=type/abstract=]<br>
|i| 为一个 [=const-expression=]
<td class="nowrap">
|e|[|i|]: |T|
<td>选取矢量的第|i|个分量<br>
第一个分量的索引为|i|=0。


       如果|i|超出范围[0,|N|-1]，则为一个[=shader-creation error=]。

       注意：当一个抽象矢量值|e|被一个非[=const-expression=]表达式索引时，
       在应用索引之前，矢量将先进行[=concretization of a value|concretized=]。

</table>

#### 矢量多组件选择 #### {#vector-multi-component}

<table class=‘data’>
<caption>矢量分解：多组件选择
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="使用.x.y进行双组分矢量选择">
<td class="nowrap">
|e|：vec|N|<|T|><br>
|I|为字母x，y，z或w<br>
|J|为字母x，y，z或w<br>
<td class="nowrap">
|e|.|I||J|：vec2<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|的双组分矢量。<br>
当|N|为3或4时，字母"z"才有效。<br>
当|N|为4时，字母"w"才有效。
<tr algorithm="使用.r.g进行双组分矢量选择">
<td class="nowrap">
|e|：vec|N|<|T|><br>
|I|为字母r，g，b或a<br>
|J|为字母r，g，b或a<br>
<td class="nowrap">
|e|.|I||J|：vec2<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|的双组分矢量。<br>
当|N|为3或4时，字母"b"才有效。<br>
当|N|为4时，字母"a"才有效。
<tr algorithm="使用.x.y进行三组分矢量选择">
<td class="nowrap">
|e|：vec|N|<|T|><br>
|I|为字母x，y，z或w<br>
|J|为字母x，y，z或w<br>
|K|为字母x，y，z或w<br>
<td class="nowrap">
|e|.|I||J||K|：vec3<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|，第三个分量为|e|.|K|的三组分矢量。<br>
当|N|为3或4时，字母"z"才有效。<br>
当|N|为4时，字母"w"才有效。
<tr algorithm="使用.r.g进行三组分矢量选择">
<td class="nowrap">
|e|：vec|N|<|T|><br>
|I|为字母r，g，b或a<br>
|J|为字母r，g，b或a<br>
|K|为字母r，g，b或a<br>
<td class="nowrap">
|e|.|I||J||K|：vec3<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|，第三个分量为|e|.|K|的三组分矢量。<br>
当|N|为3或4时，字母"b"才有效。<br>
当|N|为4时，字母"a"才有效。
<tr algorithm="使用.x.y进行四组分矢量选择">
<td class="nowrap">
|e|：vec|N|<|T|><br>
|I|为字母x，y，z或w<br>
|J|为字母x，y，z或w<br>
|K|为字母x，y，z或w<br>
|L|为字母x，y，z或w<br>
<td class="nowrap">
|e|.|I||J||K||L|：vec4<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|，第三个分量为|e|.|K|，第四个分量为|e|.|L|的四组分矢量。<br>
当|N|为3或4时，字母"z"才有效。<br>
当|N|为4时，字母"w"才有效。
<tr algorithm="使用.r .g进行四组分矢量选择">
<td class="nowrap">
|e|：vec|N|<|T|><br>
|I|为字母r，g，b或a<br>
|J|为字母r，g，b或a<br>
|K|为字母r，g，b或a<br>
|L|为字母r，g，b或a<br>
<td class="nowrap">
|e|.|I||J||K||L|：vec4<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|，第三个分量为|e|.|K|，第四个分量为|e|.|L|的四组分矢量。<br>
当|N|为3或4时，字母"b"才有效。<br>
当|N|为4时，字母"a"才有效。
</table>

#### 从向量引用中的组件参考 #### {#component-reference-from-vector-reference}

对于向量的组件的写访问可能会访问与该向量关联的所有内存位置。


注意：这意味着如果至少有一个访问是写访问，那么不同调用对向量的不同组件的访问必须进行同步。请参阅［内建同步函数］。

<table class=‘data’>
<caption>从向量引用获取组件引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="first vector component reference selection">
<td>|r|: ref<|AS|,vec|N|<|T|>,|AM|><br>
<td class="nowrap">
|r|.x: ref<|AS|,|T|,|AM|><br>
|r|.r: ref<|AS|,|T|,|AM|><br>
<td>计算对由引用|r|引用的向量的第一个分量的引用。<br>
结果引用的[=来源变量=]与|r|的来源变量相同。
<tr algorithm="second vector component reference selection">
<td>|r|: ref<|AS|,vec|N|<|T|>,|AM|><br>
<td class="nowrap">
|r|.y: ref<|AS|,|T|,|AM|><br>
|r|.g: ref<|AS|,|T|,|AM|><br>
<td>计算对由引用|r|引用的向量的第二个分量的引用。<br>
结果引用的[=来源变量=]与|r|的来源变量相同。
<tr algorithm="third vector component reference selection">
<td>|r|: ref<|AS|,vec|N|<|T|>,|AM|><br>
|N|为3或4
<td class="nowrap">
|r|.z: ref<|AS|,|T|,|AM|><br>
|r|.b: ref<|AS|,|T|,|AM|><br>
<td>计算对由引用|r|引用的向量的第三个分量的引用。<br>
结果引用的[=来源变量=]与|r|的来源变量相同。
<tr algorithm="fourth vector component reference selection">
<td>|r|: ref<|AS|,vec4<|T|>,|AM|><br>
<td class="nowrap">
|r|.w: ref<|AS|,|T|,|AM|><br>
|r|.a: ref<|AS|,|T|,|AM|><br>
<td>计算对由引用|r|引用的向量的第四个分量的引用。<br>
结果引用的[=来源变量=]与|r|的来源变量相同。
<tr algorithm="vector indexed component reference selection">
<td>|r|: ref<|AS|,vec|N|<|T|>,|AM|><br>
|i|: [INT]
<td class="nowrap">
|r|[|i|] : ref<|AS|,|T|,|AM|>
<td>计算对由引用|r|引用的向量的第|i|个分量的引用。


       如果|i|超出范围[0,|N|-1]：<br>
       * 如果|i|是[=const-expression=]，则为[=着色器创建错误=]。
       * 如果|i|是[=override-expression=]，则为[=管道创建错误=]。
       * 否则，表达式的求值结果为[=无效内存引用=]。

       结果引用的[=来源变量=]与|r|的来源变量相同。

</table>

### 矩阵访问表达式 ### {#matrix-access-expr}

<table class=‘data’>
<caption>列向量提取</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="matrix indexed column vector selection concrete">
<td class="nowrap">
|e|: mat|C|x|R|<|T|><br>
|i|: [INT]<br>
|T| 是 [=具体类型=]
<td class="nowrap">
|e|[|i|]: vec|R|<|T|>
<td>结果是 |e| 的第 |i| 列向量。


       如果 |i| 在范围 [0,|C|-1] 之外：<br>
       * 如果 |i| 是一个 [=常数表达式=]，则是一个 [=着色器创建错误=]。
       * 如果 |i| 是一个 [=覆盖表达式=]，则是一个 [=管线创建错误=]。
       * 否则，可能返回一个 vec|R|&lt;|T|&gt; 的 [=不确定值=]。

<tr algorithm="matrix indexed column vector selection abstract">
<td class="nowrap">
|e|: mat|C|x|R|<|T|><br>
|i|: [INT]<br>
|T| 是 [=抽象类型=]<br>
|i| 是一个 [=常数表达式=]
<td class="nowrap">
|e|[|i|]: vec|R|<|T|>
<td>结果是 |e| 的第 |i| 列向量。


       如果 |i| 在范围 [0,|C|-1] 之外，它是一个 [=着色器创建错误=]。

       注意：当一个抽象矩阵值 |e| 被一个非 [=常数表达式=] 的表达式索引时，
       在应用索引之前，矩阵会被进行 [=值的具体化|具体化=]。

</table>

<table class='data'>
  <caption>从对矩阵的引用中获取对列向量的引用</caption>
  <thead>
    <tr><th>前提条件<th>结论<th>描述
  </thead>
  <tr algorithm="matrix indexed column vector reference selection">
       <td class="nowrap">
          |r|: ref&lt;|AS|,mat|C|x|R|&lt;|T|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,vec|R|&lt;|T|&gt;,|AM|&gt;
       <td>计算对引用|r|所引用的矩阵的第|i|列向量的引用。


            如果|i|不在范围[0,|C|-1]之内：
            * 如果|i|是一个常数表达式，则为[=shader-creation error=]。
            * 如果|i|是一个覆盖表达式，则为[=pipeline-creation error=]。
            * 否则，该表达式将求值为[=invalid memory reference=]。

            结果引用的来源变量与|r|的来源变量相同。
</table>

### 数组访问表达式 ### {#array-access-expr}
<table class=‘data’>
<caption>数组元素提取</caption>
<thead>
<tr><th>前提<th>结论<th>描述
</thead>
<tr algorithm="fixed-size array indexed element selection concrete">
<td class="nowrap">
|e|：array<|T|,|N|><br>
|i|：[INT]<br>
|T| 是 [=type/concrete=]
<td class="nowrap">
|e|[|i|]：|T|
<td>结果是数组值 |e| 的第 |i| 个元素的值。


       如果 |i| 超出范围 [0,|N|-1]：<br>
       * 如果 |i| 是一个 [=const-expression=]，那么它是一个 [=shader-creation error=]。
       * 如果 |i| 是一个 [=override-expression=]，那么它是一个 [=pipeline-creation error=]。
       * 否则，可能返回一个对于 |T| 的 [=indeterminate value=]。

<tr algorithm="fixed-size array indexed element selection abstract">
<td class="nowrap">
|e|：array<|T|,|N|><br>
|i|：[INT]<br>
|T| 是 [=type/abstract=]<br>
|i| 是一个 [=const-expression=]
<td class="nowrap">
|e|[|i|]：|T|
<td>结果是数组值 |e| 的第 |i| 个元素的值。


       如果 |i| 超出范围 [0,|N|-1]，那么它是一个 [=shader-creation error=]。

       注意：当一个抽象数组值 |e| 被一个不是 [=const-expression=] 的表达式索引时，索引应用之前数组会进行 [=concretization of a value|concretized=]。

</table>

<table class=‘data’>
<caption>获取引用数组元素的引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="fixed-size array indexed reference selection">
<td class="nowrap">
|r|: ref<|AS|,array<|T|,|N|>,|AM|><br>
|i|: [INT]
<td class="nowrap">
|r|[|i|] : ref<|AS|,|T|,|AM|>
<td>计算引用的引用所引用的数组的第|i|个元素的引用。


       如果|i|在范围[0,|N|-1]之外：<br>
       * 如果|i|是一个[=const-expression=]，则为[=shader-creation error=]。
       * 如果|i|是一个[=override-expression=]，则为[=pipeline-creation error=]。
       * 否则，表达式将评估为[=invalid memory reference=]。

       结果引用的[=源变量=]与|r|的[=源变量=]相同。

<tr algorithm="array indexed reference selection">
<td>|r|: ref<|AS|,array<|T|>,|AM|><br>
|i|: [INT]
<td class="nowrap">
|r|[|i|] : ref<|AS|,|T|,|AM|>
<td>计算引用的引用所引用的运行时大小的数组的第|i|个元素的引用。


       如果在运行时数组有|N|个元素，并且|i|在范围[0,|N|-1]之外，则表达式将评估为[=invalid memory reference=]。

       如果|i|为有符号整数，并且|i|小于0：<br>
       * 如果|i|是一个[=const-expression=]，则为[=shader-creation error=]。
       * 如果|i|是一个[=override-expression=]，则为[=pipeline-creation error=]。

       结果引用的[=源变量=]与|r|的[=源变量=]相同。

</table>


### 结构访问表达式 ### {#struct-access-expr}

<table class=‘data’>
<caption>结构成员提取</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="结构成员提取">
<td class="nowrap">
|S| 是结构类型<br>
|M| 是|S|的成员的标识符名称，具有类型|T|<br>
|e|: |S|<br>
<td class="nowrap">
|e|.|M|: |T|
<td>结果是从结构值|e|提取的具有名称|M|的成员的值。
</table>


<table class=‘data’>
<caption>从结构引用中获取对结构成员的引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="结构成员引用选择">
<td class="nowrap">
|S| 是结构类型<br>
|M| 是|S|的成员的标识符名称，具有类型|T|<br>
|r|: ref<|AS|,|S|,|AM|><br>
<td class="nowrap">
|r|.|M|: ref<|AS|,|T|,|AM|>
<td>给定一个对结构的引用，结果是对具有标识符名称|M|的结构成员的引用。<br>
结果引用的[=起源变量=]与|r|的起源变量相同。
</table>

## 逻辑表达式 ## {#logical-expr}
<table class=‘data’>
<caption>一元逻辑运算</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="boolean negation"><td>|e|：T<br>|T| 是布尔型或者向量|N|<bool>
<td>!|e|：|T|
<td>逻辑非。
当 |e| 为 false 时结果为 true，当 |e| 为 true 时结果为 false。
当 |T| 为向量时进行[=逐分量运算=]。
</table>


<table class=‘data’>
<caption>二元逻辑表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="short-circuiting or"><td>|e1|：bool<br>|e2|：bool<td>|e1| || |e2|：bool  <td>短路逻辑"或"。当 |e1| 或 |e2| 任一为true时结果为true；   仅当 |e1| 为 `false` 时才计算 |e2|。


<tr algorithm="short-circuiting and"><td>|e1|：bool<br>|e2|：bool
<td>|e1| && |e2|：bool  <td>短路逻辑"与"。当 |e1| 和 |e2| 同时为true时结果为true；   仅当 |e1| 为 `true` 时才计算 |e2|。


<tr algorithm="logical or"><td>|e1|：|T|<br>|e2|：|T|<br>|T| 是布尔型或者向量|N|<bool>
<td>|e1| | |e2|：|T|
<td>逻辑"或"。当 |T| 是向量时进行[=逐分量运算=]。计算 |e1| 和 |e2|。


<tr algorithm="logical and"><td>|e1|：|T|<br>|e2|：|T|<br>|T| 是布尔型或者向量|N|<bool>
<td>|e1| & |e2|：|T|
<td>逻辑"与"。当 |T| 是向量时进行[=逐分量运算=]。计算 |e1| 和 |e2|。
</table>


## 算术表达式 ## {#arithmetic-expr}

<table class=‘data’>
<caption>一元算术表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="negation"><td>|e|: |T|<br>
|T|是AbstractInt、AbstractFloat、i32、f32、f16、vec|N|<AbstractInt>、vec|N|<AbstractFloat>、vec|N|<i32>、vec|N|<f32>或vec|N|<f16>
<td>-|e|: |T|
<td>否定。当|T|为向量时，逐分量执行。
如果|T|是一个整数标量类型，并且|e|评估为最大的负值，则结果为|e|。
</table>


<table class=‘data’>
<caption>二元算术表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>


<tr algorithm="addition">
<td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
<td>|e1| + |e2| : |T|
<td>加法。当|T|为向量时，逐分量执行。
如果|T|是一个具体整数标量类型，结果为模2的32次方。


<tr algorithm="subtraction">
<td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
<td>|e1| - |e2| : |T|
<td>减法。当|T|为向量时，逐分量执行。
如果|T|是一个具体整数标量类型，结果为模2的32次方。


<tr algorithm="multiplication">
<td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
<td>|e1| * |e2| : |T|
<td>乘法。当|T|为向量时，逐分量执行。
如果|T|是一个具体整数标量类型，结果为模2的32次方。


<tr algorithm="division">
<td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
<td>|e1| / |e2| : |T|
<td>除法。当|T|为向量时，逐分量执行。


    如果|T|是有符号的整数标量类型，评估为：
    * 如果|e2|为零：
        * 如果|e2|是一个常量表达式，则是一个着色器创建错误。
        * 如果|e2|是一个覆写表达式，则是一个管道创建错误。
        * 否则，为|e1|。
    * 如果|e1|是|T|中最小的负值，并且|e2|为-1：
        * 如果|e1|和|e2|是常量表达式，则是一个着色器创建错误。
        * 如果|e1|和|e2|是覆写表达式，则是一个管道创建错误。
        * 否则，为|e1|。
    * 否则，为[=truncate=](|x|)，其中|x|是实值商|e1|&nbsp;&div;&nbsp;|e2|。

    注意：
    为了确保截断行为，可能需要执行比计算无符号除法更多的操作。
    当两个操作数具有相同符号时，请使用无符号除法。

    <!--
           where MINIT = |T|中最小的负值
           where Divisor = select(e2, 1, (e2==0) | ((e1 == MININT) & (e2 == -1)))
           结果为truncate(e1/Divisor)
    -->

    如果|T|是一个无符号整数标量类型，评估为：
    * 如果|e2|为零：
        * 如果|e2|是一个常量表达式，则是一个着色器创建错误。
        * 如果|e2|是一个覆写表达式，则是一个管道创建错误。
        * 否则，为|e1|。
</table>

<table class=‘data’>
<caption>使用混合标量和向量操作数的二进制算术表达式</caption>
<thead>
<th>前提<th>结论<th>语义
</thead>
<tr algorithm="向量-标量算术，任何标量类型">
<td rowspan="10">|S| 是 AbstractInt、AbstractFloat、f32、f16、i32、u32 之一<br>
|V| 是 vec|N|<|S|><br>
|es|: |S|<br>
|ev|: |V|
<td>|ev| + |es|: |V|
<td>|ev| + |V|(|es|)
<tr>
<td>|es| + |ev|: |V|
<td>|V|(|es|) + |ev|
<tr>
<td>|ev| - |es|: |V|
<td>|ev| - |V|(|es|)
<tr>
<td>|es| - |ev|: |V|
<td>|V|(|es|) - |ev|
<tr>
<td>|ev| * |es|: |V|
<td>|ev| * |V|(|es|)
<tr>
<td>|es| * |ev|: |V|
<td>|V|(|es|) * |ev|
<tr>
<td>|ev| / |es|: |V|
<td>|ev| / |V|(|es|)
<tr>
<td>|es| / |ev|: |V|
<td>|V|(|es|) / |ev|
<tr>
<td>|ev| % |es|: |V|
<td>|ev| % |V|(|es|)
<tr>
<td>|es| % |ev|: |V|
<td>|V|(|es|) % |ev|
</table>


<table class=‘data’>
<caption>矩阵算术</caption>
<thead>
<th>前提<th>结论<th>语义
</thead>
<tr algorithm="矩阵加法">
<td rowspan=2>|e1|, |e2|: mat|C|x|R|<|T|&gt<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|e1| + |e2|: mat|C|x|R|<|T|&gt<br>
<td>矩阵加法：结果的第 |i| 列为 |e1|[i] + |e2|[i]
<tr algorithm="矩阵减法">
<td>|e1| - |e2|: mat|C|x|R|<|T|&gt
<td>矩阵减法：结果的第 |i| 列为 |e1|[|i|] - |e2|[|i|]
<tr algorithm="矩阵-标量乘法">
<td rowspan=2>|m|: mat|C|x|R|<|T|&gt<br>
|s|: |T|<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|m| * |s|:  mat|C|x|R|<|T|&gt<br>
<td>逐分量缩放：(|m| * |s|)[i][j] 为 |m|[i][j] * |s|
<tr algorithm="标量-矩阵乘法">
<td>|s| * |m|:  mat|C|x|R|<|T|&gt<br>
<td>逐分量缩放：(|s| * |m|)[i][j] 为 |m|[i][j] * |s|
<tr algorithm="矩阵列-向量乘法">
<td>|m|: mat|C|x|R|<|T|&gt<br>
|v|: vec|C|<|T|&gt<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|m| * |v|:  vec|R|<|T|&gt<br>
<td>线性代数矩阵列-向量乘积：
结果的第 |i| 个分量为 dot(transpose(|m|)[|i|],|v|)
<tr algorithm="矩阵行-向量乘法">
<td>
|m|: mat|C|x|R|<|T|&gt<br>
|v|: vec|R|<|T|&gt<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|v| * |m|:  vec|C|<|T|&gt<br>
<td>线性代数行-向量-矩阵乘积：<br>
[=transpose=](transpose(|m|) * transpose(|v|))
<tr algorithm="矩阵乘法">
<td>|e1|: mat|K|x|R|<|T|&gt<br>
|e2|: mat|C|x|K|<|T|&gt<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|e1| * |e2|:  mat|C|x|R|<|T|&gt<br>
<td>线性代数矩阵乘积。


</table>

## 比较表达式 ## {#comparison-expr}

<table class=‘data’>
<caption>Comparisons</caption>
<thead>
<tr><th>Precondition<th>Conclusion<th>Description
</thead>


<tr algorithm="equality">
<td>|e1|: |T|<br>|e2|: |T|<br>
|S| is AbstractInt, AbstractFloat, bool, i32, u32, f32, or f16<br>
|T| is |S| or vec|N|<|S|><br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class="nowrap">|e1| == |e2|: |TB|
<td>Equality. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm="inequality">
<td>|e1|: |T|<br>|e2|: |T|<br>
|S| is AbstractInt, AbstractFloat, bool, i32, u32, f32, or f16<br>
|T| is |S| or vec|N|<|S|><br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class="nowrap">|e1| != |e2|: |TB|
<td>Inequality. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm="less than">
<td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class="nowrap">|e1| < |e2|: |TB|
<td>Less than. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm="less than equal">
<td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class="nowrap">|e1| <= |e2|: |TB|
<td>Less than or equal. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm="greater than">
<td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class="nowrap">|e1| > |e2|: |TB|
<td>Greater than. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm="greater than equal">
<td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class="nowrap">|e1| >= |e2|: |TB|
<td>Greater than or equal. [=Component-wise=] when |T| is a vector.
</tr>


</table>

## 比特表达式 ## {#bit-expr}

<table class=‘data’>
<caption>按位一元操作</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="complement">
<td>|e|: |T|<br>
[ALLINTEGRALDECL]
<td class="nowrap">~|e| : |T|
<td>对|e|进行按位取反操作。
结果中的每一位都是|e|中对应位的相反值。
当|T|为向量时为逐分量操作。
</table>


<table class=‘data’>
<caption>按位二元操作</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="bitwise or">
<td>|e1|: |T|<br>
|e2|: |T|<br>
[ALLINTEGRALDECL]
<td class="nowrap">|e1| | |e2|: |T|
<td>按位或。当|T|为向量时为逐分量操作。
<tr algorithm="bitwise and">
<td>|e1|: |T|<br>
|e2|: |T|<br>
[ALLINTEGRALDECL]
<td class="nowrap">|e1| & |e2|: |T|
<td>按位与。当|T|为向量时为逐分量操作。
<tr algorithm="bitwise exclusive or">
<td>|e1|: |T|<br>
|e2|: |T|<br>
[ALLINTEGRALDECL]
<td class="nowrap">|e1| ^ |e2|: |T|
<td>按位异或。当|T|为向量时为逐分量操作。
</table>


<table class=‘data’>
<caption>按位移动表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>


<tr algorithm="concrete shift left">
<td>|e1|: |T|<br>
|e2|: |TS|<br>
|S| is [INT]<br>
|T| is |S| or vec|N|<|S|><br>
|TS| is u32 when |T| is |S|, otherwise |TS| is vec|N|<u32>
<td class="nowrap">|e1| << |e2|: |T|
<td>向左移位（移位值为具体的）：


    将|e1|向左移位，最低有效位插入零位，丢弃最高有效位。

    移位的位数为|e2|的值对|e1|的位宽取模。
    如果|e2|大于等于|e1|的位宽，则：
    * 如果|e2|是一个常量表达式，则是一个[=shader-creation error=]。
    * 如果|e2|是一个[=override-expression=]，则是一个[=pipeline-creation error=]。

    当|e1|和|e2|在[=shader execution start=]之前都已知时，结果不能溢出：
    * 如果|T|是有符号整数类型，并且|e1|的|e2|+1个最高有效位的值不同，则：
        * 如果|e1|和|e2|是[=const-expressions=]，则是一个[=shader-creation error=]。
        * 如果|e1|和|e2|是[=override-expressions=]，则是一个[=pipeline-creation error=]。
    * 如果|T|是无符号整数类型，并且|e1|的任何|e2|个最高有效位的值为1，则：
        * 如果|e1|和|e2|是[=const-expressions=]，则是一个[=shader-creation error=]。
        * 如果|e1|和|e2|是[=override-expressions=]，则是一个[=pipeline-creation error=]。

    当|T|为向量时逐分量操作。

<tr algorithm="abstract shift left">
<td>|e1|: |T|<br>
|e2|: |TS|<br>
|T| is AbstractInt or vec|N|<AbstractInt><br>
|TS| is u32 when |T| is AbstractInt, otherwise |TS| is vec|N|<u32>
<td class="nowrap">|e1| << |e2|: |T|
<td>向左移位（移位值为抽象的）：


    将|e1|向左移位，最低有效位插入零位，丢弃最高有效位。

    移位的位数为|e2|的值。

    |e1|的|e2|+1个最高有效位必须具有相同的位值，否则会发生溢出。
    这个条件意味着所有丢弃的位必须与原始值的符号位和最终值的符号位相同。

    当|T|为向量时逐分量操作。

<tr algorithm="concrete shift right">
<td>|e1|: |T|<br>
|e2|: |TS|<br>
|S| is [INT]<br>
|T| is |S| or vec|N|<|S|><br>
|TS| is u32 when |T| is |S|, otherwise |TS| is vec|N|<u32>
<td class="nowrap">|e1| >> |e2|: |T|
<td>向右移位（移位值为具体的）。


    将|e1|向右移位，丢弃最低有效位。

    如果|S|是无符号类型，插入零位到最高有效位。
    如果|S|是有符号类型：
    * 如果|e1|为负数，则插入的每一位为1，因此结果也是负数。
    * 否则，插入的每一位为0。

    移位的位数为|e2|的值对|e1|的位宽取模。

    如果|e2|大于等于|e1|的位宽，则：
    * 如果|e2|是一个常量表达式，则是一个[=shader-creation error=]。
    * 如果|e2|是一个[=override-expression=]，则是一个[=pipeline-creation error=]。

    当|T|为向量时逐分量操作。

<tr algorithm="abstract shift right">
<td>|e1|: |T|<br>
|e2|: |TS|<br>
|T| is AbstractInt or vec|N|<AbstractInt><br>
|TS| is u32 when |T| is AbstractInt, otherwise |TS| is vec|N|<u32>
<td class="nowrap">|e1| >> |e2|: |T|
<td>向右移位（抽象的）。


    将|e1|向右移位，丢弃最低有效位。

    如果|e1|为负数，则插入的每一位为1，因此结果也是负数。
    否则，插入的每一位为0。

    移位的位数为|e2|的值。

    当|T|为向量时逐分量操作。

</table>

## 函数调用表达式 ## {#function-call-expr}

函数调用表达式执行一个调用函数，被调用的函数具有返回类型。如果被调用的函数没有返回值，应该使用函数调用语句。参见[[#function-call-statement]]。

## 变量标识符表达式 ## {#var-identifier-expr}

<table class=‘data’>
<caption>通过变量名获取引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="variable reference">
<td>
|v| 是一个解析为在 [=address space=] |AS| 中使用 [=store type=] |T| 且使用 [=access mode=] |AM| 声明的 [=in scope|in-scope=] 变量的 [=identifier=]
<td class="nowrap">
|v|: ref<|AS|,|T|,|AM|>
<td>结果是指向命名变量 |v| 的内存的引用。
</table>

## 形式参数表达式  ## {#formal-parameter-expr}

<table class=‘data’>
<caption>获取函数的形式参数声明的标识符的值</caption>
<thead>
<tr><th>前提<th>结论<th>描述
</thead>
<tr algorithm="formal parameter value">
<td>
|a|是一个[=标识符=]，并且[=解析为|解析=]具有类型|T|的[=范围内|in-scope=]的形式参数声明
<td class="nowrap">
|a|: |T|
<td>结果是在调用该函数实例的[=调用点=]中为相应函数调用操作数提供的值。
</table>

## 地址运算符  ## {#address-of-expr}

<dfn noexport>address-of</dfn> 运算符将引用转换为相应的指针。


<table class=‘data’>
<caption>从引用获取指针</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="address-of expression">
<td>
|r|: ref<|AS|,|T|,|AM|>
<td class="nowrap">
&|r|: ptr<|AS|,|T|,|AM|>
<td>结果是与引用值 |r| 相同[=内存视图=]的指针值。


       如果 |r| 是[=无效的内存引用=]，那么结果指针也是一个无效的内存引用。

       如果 |AS| 是[=地址空间/句柄=]地址空间，那么这是一个[=着色器创建错误=]。

       如果 |r| 是一个[[#component-reference-from-vector-reference|矢量分量的引用]]，那么这是一个[=着色器创建错误=]。

</table>

## 间接表达式  ## {#indirection-expr}

<dfn noexport>间接</dfn>运算符将指针转换为其相应的引用。


<table class=‘data’>
<caption>从指针获取引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="间接表达式">
<td>
|p|: ptr<|AS|,|T|,|AM|>
<td class="nowrap">
*|p|: ref<|AS|,|T|,|AM|>
<td>结果是与指针值 |p| 相同的[=内存视图=]对应的引用值。


      如果 |p| 是一个[=无效的内存引用=]，那么结果引用也将是一个无效的内存引用。

</table>

## 值声明的标识符表达式  ## {#value-identifier-expr}

<table class=‘data’>
<caption>获取 const-, override-, 或 let-声明的标识符的值</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="const-declared value">
<td>
|c| 是一个具有类型 |T| 的在范围内的 const 声明标识符
<td class="nowrap">
|c|: |T|
<td>结果是初始化表达式计算出的值。
表达式是一个 const 表达式，并且在着色器模块创建时进行求值。


<tr algorithm="pipeline-overridable constant value">
<td>
|c| 是一个具有类型 |T| 的在范围内的 override 声明标识符
<td class="nowrap">
|c|: |T|
<td>如果管线创建时指定了一个值给 [=pipeline constant ID|constant ID=]，
那么结果是该值。
对于不同的管线实例，这个值可能是不同的。


       否则，结果是初始化表达式计算出的值。
       可以覆盖管线的常量出现在模块范围，所以求值发生在着色器开始执行之前。

       注意：如果在 API 调用中没有指定初始值且 `let` 声明没有初始化表达式，则管线创建将失败。

<tr algorithm="let-declared value">
<td>
|c| 是一个具有类型 |T| 的在范围内的 let 声明标识符
<td class="nowrap">
|c|: |T|
<td>结果是初始化表达式计算出的值。
[=let-declaration=] 出现在函数体内部，并且每次控制流到达声明时都会求值。<br>
</table>

## 枚举表达式 ## {#enum-expr}

<table class=‘data’>
<caption>枚举表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm="枚举表达式">
<td>|e| 是一个[=标识符=]，解析为一个[=预定义=]的[=枚举值=]，属于[=枚举类型=] |E|
<td>|e| : |E|
<td>见#预定义枚举值
</table>

## 类型表达式 ## {#type-expr}

<table class=‘data’>
<caption>Type expressions</caption>
<thead>
<tr><th>Precondition<th>Conclusion<th>Description
</thead>
<tr algorithm="predeclared type expression">
<td>|t| is an [=identifier=] [=resolves|resolving=] to a [=predeclared=] [=type=]
<td>|t| : [=AllTypes=]
<td>See [[#predeclared-types]]
<tr algorithm="type alias expression">
<td>|a| is an [=identifier=] [=resolves|resolving=] to a [=type alias=].
<td>|a| : [=AllTypes=]
<td>Additionally, |a| denotes the type to which it is aliased.
<tr algorithm="structure type expression">
<td>|s| is an [=identifier=] [=resolves|resolving=] to the declaration of a [=structure=] type.
<td>|s| : [=AllTypes=]
<td>Additionally, |s| denotes the structure type.
<tr algorithm="predeclared type generator expression no trailing comma">
<td rowspan=2>|tg| is an [=identifier=] [=resolves|resolving=] to a [=type-generator=]


        |e1|: |T1|<br>
          ...<br>
        |eN|: <var ignore>TN</var>
    <td>|tg| [=syntax_sym/_template_args_start=]<br>|e1|,<br>...,<br>|eN|<br> [=syntax_sym/_template_args_end=]<br>: [=AllTypes=]
    <td rowspan=2>Each [=type-generator=] has its own requirements on the template parameters it requires and accepts,
        and defines how the template parameters help determine the resulting type.

        The expressions |e1| through |eN| are the [=template parameters=] for the type-generator.

        For example, the type expression `vec2<f32>` is the [=vector=] of two [=f32=] elements.

        See [[#predeclared-types]] for the list of predeclared type-generators.

        Note: The two variants here differ only in whether they have a trailing comma after |eN|.
<tr algorithm="predeclared type generator expression trailing comma">
    <td><var ignore>tg</var> [=syntax_sym/_template_args_start=]<br>|e1|,<br>...,<br>|eN|,<br> [=syntax_sym/_template_args_end=]<br>: [=AllTypes=]

</table>

## 表达语法概述 ## {#expression-grammar}

当一个[=标识符=]是一个[=语法/调用短语=]中的第一个[=标记=]时，它可以是以下之一：
* 作为[=函数调用=]中的[=用户定义的函数=]或[=内置函数=]的名称。
* 作为[=值构造函数=]表达式中的[=类型=]、=类型别名=或者=类型生成器=的名称。

[[#declaration-and-scope|Declaration and scope]] 规则确保这些名称始终是不同的。

<pre class=include>
path: syntax/primary_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/call_expression.syntax.bs.include
</pre>
Note: The [=syntax/call_expression=] rule exists to ensure [=type checking=] applies to the call expression.
<pre class=include>
path: syntax/call_phrase.syntax.bs.include
</pre>

<pre class=include>
path: syntax/paren_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/argument_expression_list.syntax.bs.include
</pre>
<pre class=include>
path: syntax/expression_comma_list.syntax.bs.include
</pre>
<pre class=include>
path: syntax/component_or_swizzle_specifier.syntax.bs.include
</pre>
<pre class=include>
path: syntax/unary_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/singular_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/lhs_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/core_lhs_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/multiplicative_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/multiplicative_operator.syntax.bs.include
</pre>
<pre class=include>
path: syntax/additive_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/additive_operator.syntax.bs.include
</pre>
<pre class=include>
path: syntax/shift_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/relational_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/short_circuit_and_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/short_circuit_or_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/binary_or_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/binary_and_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/binary_xor_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/bitwise_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/expression.syntax.bs.include
</pre>

## 运算符优先级和结合性 ## {#operator-precedence-associativity}

整个子章节属于非规范性内容。


WGSL表达式中的操作符优先级和结合性源自它们的语法摘要。右侧表达式通过分组操作符来组织它们，如下图所示：

<div class=operators1>
  <figure>
    <figcaption>运算符优先级和结合性图表</figcaption>
    <object type="image/svg+xml" data="img/operators_1.mmd.svg"></object>
  </figure>
</div>

为了提高可读性，以下组织不与其他组织相关联：

* [=syntax/short_circuit_or_expression|Short-circuit OR=]
    (can associate with [=syntax/short_circuit_or_expression|self=] and [=syntax/relational_expression|relational=] weakly),
* [=syntax/short_circuit_and_expression|Short-circuit AND=]
    (can associate with [=syntax/short_circuit_and_expression|self=] and [=syntax/relational_expression|relational=] weakly),
* [=syntax/binary_or_expression|Binary OR=]
    (can associate with [=syntax/binary_or_expression|self=] and [=syntax/unary_expression|unary=] weakly),
* [=syntax/binary_and_expression|Binary AND=]
    (can associate with [=syntax/binary_and_expression|self=] and [=syntax/unary_expression|unary=] weakly),
* [=syntax/binary_xor_expression|Binary XOR=]
    (can associate with [=syntax/binary_xor_expression|self=] and [=syntax/unary_expression|unary=] weakly).

以下这些组之间不形成自我关联：


[=syntax/shift_expression|Shift=] （可以与[=syntax/unary_expression|unary=]弱关联），
[=syntax/relational_expression|Relational=] （可以与[=syntax/additive_expression|additive=]和[=syntax/shift_expression|shift=]弱关联）。

要将上述两个组一起关联，需要使用括号明确设置关系。
以下是这些规则在注释中使表达式无效的示例。

<div class='example wgsl function-scope' heading='Operator precedence corner cases'>
  <xmp>
    let a = x & (y ^ (z | w)); // Invalid: x & y ^ z | w
    let b = (x + y) << (z >= w); // Invalid: x + y << z >= w
    let c = x < (y > z); // Invalid: x < y > z
    let d = x && (y || z); // Invalid: x && y || z
  </xmp>
</div>

新出现的优先级控制了一个表达式的隐含括号，其中优先级更高的运算符将在与优先级较低的运算符在一起时，表现得好像被括号包围。例如，比加法运算符优先级更高的乘法运算符将从表达式a + b * c推断出(a + (b * c))。同样，新出现的关联性控制了这些隐含括号的方向。例如，从表达式a + b + c中，从左到右的关联性推断出((a + b) + c)，而从右到左的关联性推断出(* (* a))。


下表总结了运算符的优先级、关联性和绑定，按从最强到最弱的顺序排列。绑定列包含给定运算符的较强的表达式，意思是，例如，如果值为"All above"，则该运算符可以包括任何较强的表达式。但是，例如，如果值为"Unary"，则比该行运算符较弱但比一元运算符更强的任何内容都需要使用括号与该运算符绑定。这一列对于线性列出运算符是必要的。

<table class=‘data’>
<caption>
操作符优先级、结合性和右手表达式的绑定，从强到弱排序<br>
</caption>
<thead>
<tr><th>Name
<th>Operators
<th>Associativity
<th>Binding
</thead>
<tr><td>[=syntax/paren_expression|Parenthesized=]
<td><code>(…)</code>
<td>
<td>
<tr><td>[=syntax/primary_expression|Primary=]
<td><code>a()</code>, <code>a[]</code>, <code>a.b</code>
<td>从左到右
<td>
<tr><td>[=syntax/unary_expression|Unary=]
<td><code>-a</code>, <code>!a</code>, <code>~a</code>, <code>a</code>, <code>&a</code>
<td>从右到左
<td>上述所有
<tr><td>[=syntax/multiplicative_expression|Multiplicative=]
<td><code>ab</code>, <code>a/b</code>, <code>a%b</code>
<td>从左到右
<td>上述所有
<tr><td>[=syntax/additive_expression|Additive=]
<td><code>a+b</code>, <code>a-b</code>
<td>从左到右
<td>上述所有
<tr><td>[=syntax/shift_expression|Shift=]
<td><code>a<<b</code>, <code>a>>b</code>
<td>需要括号
<td>一元
<tr><td>[=syntax/relational_expression|Relational=]
<td><code>a<b</code>, <code>a>b</code>, <code>a<=b</code>, <code>a>=b</code>, <code>a==b</code>, <code>a!=b</code>
<td>需要括号
<td>上述所有
<tr><td>[=syntax/binary_and_expression|Binary AND=]
<td><code>a&b</code>
<td>从左到右
<td>一元
<tr><td>[=syntax/binary_xor_expression|Binary XOR=]
<td><code>a^b</code>
<td>从左到右
<td>一元
<tr><td>[=syntax/binary_or_expression|Binary OR=]
<td><code>a|b</code>
<td>从左到右
<td>一元
<tr><td>[=syntax/short_circuit_and_expression|Short-circuit AND=]
<td><code>a&&b</code>
<td>从左到右
<td>关系
<tr><td>[=syntax/short_circuit_or_expression|Short-circuit OR=]
<td><code>a||b</code>
<td>从左到右
<td>关系
</table>

# 语句 # {#statements}

一个<dfn>语句</dfn>是控制执行的程序片段。通常情况下，语句按顺序执行；然而，#控制流程|控制流程语句 可能导致程序以非顺序的方式执行。

## 复合语句 ## {#compound-statement-section}

一个复合语句是一个由花括号括起来的零个或多个语句的序列。
当一个声明是这些语句之一时，它的标识符在下一个语句的开始到复合语句的结束之间都处于作用域内。

<pre class=include>
path: syntax/compound_statement.syntax.bs.include
</pre>

[=syntax/continuing_compound_statement=]是复合语句的一种特殊形式，用于构成[[#continuing-statement|continuing]]语句的主体，并允许在末尾添加可选的[[#break-if-statement|break-if]]语句。

## 赋值语句 ## {#assignment}

一个<dfn noexport dfn-for="statement">赋值</dfn>语句会评估一个表达式，如果需要的话会将其存储在内存中（从而更新变量的内容）。


<pre class=include>
path: syntax/assignment_statement.syntax.bs.include
</pre>

操作符符号左侧的文本是"左侧"，而操作符符号右侧的表达式是"右侧"。

### 简单的分配 ### {#simple-assignment-section}

当左边是一个表达式且操作符为等号（‘=’）时，一个语句/赋值就是一个简单赋值。在这种情况下，右边的值被写入左边引用的内存中。

<table class=‘data’>
<thead>
<tr><th style="width:40%">前提条件<th>语句<th>描述
</thead>
<tr algorithm="updating assignment">
<td>|e|: |T|,<br>
|T| 是一个[=类型/具体=]的可构造类型,<br>
|r|: ref<|AS|,|T|,|AM|>,<br>
|AS| 是一个可写的[=地址空间=],<br>
[=访问模式=] |AM| 是[=访问/写入=]或[=访问/读写=]<br>
<td class="nowrap">|r| = |e|
<td>先求值 |r|，然后求值 |e|，然后将为 |e| 计算出的值写入被 |r| 引用的[=内存位置=]。


    注意: 如果引用是一个[=无效的内存引用=]，则写操作可能不会执行，或者可能写入与预期不同的内存位置。

</table>

在最简单的情况下，左边是一个变量的名称。
有关其他情况，请参阅[[#forming-references-and-pointers]]。

    <div class='example wgsl' heading='Assignments'>
      <xmp>
        struct S {
            age: i32,
            weight: f32
        }
        var<private> person: S;

        fn f() {
            var a: i32 = 20;
            a = 30;           // Replace the contents of 'a' with 30.

            person.age = 31;  // Write 31 into the age field of the person variable.

            var uv: vec2<f32>;
            uv.y = 1.25;      // Place 1.25 into the second component of uv.

            let uv_x_ptr: ptr<function,f32> = &uv.x;
            *uv_x_ptr = 2.5;  // Place 2.5 into the first component of uv.

            var sibling: S;
            // Copy the contents of the 'person' variable into the 'sibling' variable.
            sibling = person;
        }
      </xmp>
    </div>

### 伪装任务 ### {#phony-assignment-section}

一个[=语句/赋值语句=]是一个<dfn noexport>虚假赋值语句</dfn>，当[=左侧=]是下划线(<a for=syntax_sym lt=equal>'_'</a>)标记时。在这种情况下，[=右侧=]将被计算，然后被忽略。


<table class=‘data’>
<thead>
<tr><th>前置条件<th>语句<th>描述
</thead>
<tr algorithm="phony-assignment">
<td>|e|: |T|,<br>
|T| 是可[=构造的=]，一个[=指针类型=]，一个[=纹理类型=]或一个[=采样器类型=]
<td class="nowrap">_ = |e|
<td>计算 |e|。


    注意: 结果值不会被存储。
    下划线 `_` 标记不是一个标识符，因此不能在表达式中使用。

</table>

虚假赋值语句是有用的场景:
* 调用返回值的函数，但明确表示结果值是不需要的。
* [=静态访问=]一个变量，从而将其作为[=着色器资源接口=]的一部分。
    注意：一个缓冲变量的存储类型可能无法被构造，例如它包含原子类型或者是一个运行时大小的数组。在这些情况下，可以使用指向变量内容的指针。



<div class='example wgsl global-scope' heading='Using phony-assignment to throw away an un-needed function result'>
  <xmp>
    var<private> counter: i32;

    fn increment_and_yield_previous() -> i32 {
      let previous = counter;
      counter = counter + 1;
      return previous;
    }

    fn user() {
      // Increment the counter, but don't use the result.
      _ = increment_and_yield_previous();
    }
  </xmp>
</div>


<div class='example wgsl global-scope' heading='Using phony-assignment to occupy bindings without using them'>
  <xmp>
    struct BufferContents {
        counter: atomic<u32>,
        data: array<vec4<f32>>
    }
    @group(0) @binding(0) var<storage> buf: BufferContents;
    @group(0) @binding(1) var t: texture_2d<f32>;
    @group(0) @binding(2) var s: sampler;

    @fragment
    fn shade_it() -> @location(0) vec4<f32> {
      // Declare that buf, t, and s are part of the shader interface, without
      // using them for anything.
      _ = &buf;
      _ = t;
      _ = s;
      return vec4<f32>();
    }
  </xmp>
</div>

### 复合赋值 ### {#compound-assignment-sec}

当"左侧"是一个表达式，操作符是一种"复合赋值操作符"之一时，一个"语句/赋值语句"被称为"复合赋值语句"。

<pre class=include>
path: syntax/compound_assignment_operator.syntax.bs.include
</pre>

每个语句的类型要求、语义和行为被定义为如下表所示的复合赋值展开时的情况，除非：
* 引用表达式 |e1| 仅被评估一次，
* 用于 |e1| 的 [=引用类型=] 必须具有 [=访问/读写=] [=访问模式=]。

<table class='data'>
  <thead>
    <tr><th>Statement<th>Expansion
  </thead>
<tr algorithm="add-assign">
    <td class="nowrap">|e1| += |e2|
    <td>|e1| = |e1| + (|e2|)
<tr algorithm="subtract-assign">
    <td class="nowrap">|e1| -= |e2|
    <td>|e1| = |e1| - (|e2|)
<tr algorithm="multiply-assign">
    <td class="nowrap">|e1| *= |e2|
    <td>|e1| = |e1| * (|e2|)
<tr algorithm="divide-assign">
    <td class="nowrap">|e1| /= |e2|
    <td>|e1| = |e1| / (|e2|)
<tr algorithm="modulus-assign">
    <td class="nowrap">|e1| %= |e2|
    <td>|e1| = |e1| % (|e2|)
<tr algorithm="bitwise-and-assign">
    <td class="nowrap">|e1| &= |e2|
    <td>|e1| = |e1| & (|e2|)
<tr algorithm="bitwise-or-assign">
    <td class="nowrap">|e1| |= |e2|
    <td>|e1| = |e1| | (|e2|)
<tr algorithm="bitwise-xor-assign">
    <td class="nowrap">|e1| ^= |e2|
    <td>|e1| = |e1| ^ (|e2|)
<tr algorithm="bitwise-shiftright-assign">
    <td class="nowrap">|e1| >>= |e2|
    <td>|e1| = |e1| >> (|e2|)
<tr algorithm="bitwise-shiftleft-assign">
    <td class="nowrap">|e1| <<= |e2|
    <td>|e1| = |e1| << (|e2|)
</table>

注意：语法不允许将复合赋值和虚假赋值合并在一起。


注意：尽管引用 |e1| 只被评估一次，但它的基础内存被访问了两次：
首先进行一次读取访问以获取旧值，然后进行一次写入访问来存储更新后的值。

<div class='example wgsl global-scope' heading="Compound assignment">
  <xmp>
    var<private> next_item: i32 = 0;

    fn advance_item() -> i32 {
       next_item += 1;   // Adds 1 to next_item.
       return next_item - 1;
    }

    fn bump_item() {
      var data: array<f32,10>;
      next_item = 0;
      // Adds 5.0 to data[0], calling advance_item() only once.
      data[advance_item()] += 5.0;
      // next_item will be 1 here.
    }

    fn precedence_example() {
      var value = 1;
      // The right-hand side of a compound assignment is its own expression.
      value *= 2 + 3; // Same as value = value * (2 + 3);
      // 'value' now holds 5.
    }
  </xmp>
</div>

<div class=note><span class=marker>注意：</span>
可以将复合赋值重写为使用"[=简单赋值=]"的不同WGSL代码。
其思想是使用指针来保存对引用求值的结果。

<p algorithm="translation compound assignment not vector component">For example,
when |e1| is *not* a reference to a component inside a vector, then
<blockquote>
|e1|` += `|e2|;
</blockquote>
can be rewritten as
<blockquote>
`{ let p = &(`|e1|`); *p = *p + (`|e2|`); }`
</blockquote>
where the identifier `p` is chosen to be different from all other identifiers in the program.
</p>

<p algorithm="translation compound assignment vector component">When
|e1| is a reference to a component inside a vector, the above technique
needs to be modified because WGSL does not allow [[#address-of-expr|taking the address]] in that case.
For example, if <var ignore>ev</var> is a reference to a vector, the statement
<blockquote>
|ev|`[`|c|`] += ` |e2|;
</blockquote>
can be rewritten as
<blockquote>
`{ let p = &(`|ev|`); let c0 = ` |c|`; (*p)[c0] = (*p)[c0] + (`|e2|`); }`
</blockquote>
where identifiers `c0` and `p` are chosen to be different from all other identifiers in the program.
</div>
</div>

## 递增和递减语句 ## {#increment-decrement}

一个<dfn noexport>增量语句</dfn>将1添加到变量的内容。
一个<dfn noexport>递减语句</dfn>从变量的内容中减去1。

<pre class=include>
path: syntax/increment_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/decrement_statement.syntax.bs.include
</pre>

这个表达式必须求值为具有整数标量存储类型和读写访问方式的引用。

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="increment statement">
    <td class="nowrap">|r| : ref&lt;|AS|,|T|,[=access/read_write=]&gt;,<br>
        |T| is a [=type/concrete=] [=integer scalar=]<br>
    <td class="nowrap">|r|`++`
    <td>Adds 1 to the contents of memory referenced by |r|.
        <br>Same as |r| += |T|(1)
  <tr algorithm="decrement statement">
    <td class="nowrap">|r| : ref&lt;|AS|,|T|,[=access/read_write=]&gt;,<br>
        |T| is a [=type/concrete=] [=integer scalar=]<br>
    <td class="nowrap">|r|`--`
    <td>Subtracts 1 from the contents of memory referenced by |r|.
        <br>Same as |r| -= |T|(1)
</table>

    <div class='example wgsl' heading='Increment and decrement'>
      <xmp>
        fn f() {
            var a: i32 = 20;
            a++;
            // Now a contains 21
            a--;
            // Now a contains 20
        }
      </xmp>
    </div>

## 控制流 ## {#control-flow}

控制流语句可以导致程序以非顺序的顺序执行。

### If 语句 ### {#if-statement}

一个<dfn noexport dfn-for="statement">if</dfn>语句根据条件表达式的评估情况有条件地执行至多一个[=复合语句=]。


一个if语句有一个if子句，后跟零个或多个else if子句，其后可以是一个可选的else子句。

<pre class=include>
path: syntax/if_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/if_clause.syntax.bs.include
</pre>

<pre class=include>
path: syntax/else_if_clause.syntax.bs.include
</pre>

<pre class=include>
path: syntax/else_clause.syntax.bs.include
</pre>

[=类型规则前提条件=]:
每个if和else if子句中的表达式必须为bool类型。


if语句的执行如下：

* 评估与if子句关联的条件。 如果结果为true，控制转移到条件表达式后的第一个复合语句。
* 否则，按文本顺序评估下一个存在的else if子句的条件， 如果结果为true，控制转移到相关的复合语句。
    * 该行为对所有else if子句都重复，直到某个条件评估为true。
* 如果没有条件评估为true，则控制转移到与else子句关联的复合语句（如果存在）。

### Switch 语句 ### {#switch-statement}

一个<dfn noexport dfn-for="statement">switch</dfn>语句根据选择器表达式的计算结果，将控制转移到一组[=case子句=]中的一个，或转移到[=default子句=]。

<pre class=include>
path: syntax/switch_statement.syntax.bs.include
</pre>
<pre class=include>
path: syntax/switch_body.syntax.bs.include
</pre>
<pre class=include>
path: syntax/switch_clause.syntax.bs.include
</pre>
<pre class=include>
path: syntax/case_clause.syntax.bs.include
</pre>
<pre class=include>
path: syntax/default_alone_clause.syntax.bs.include
</pre>
<pre class=include>
path: syntax/case_selectors.syntax.bs.include
</pre>
<pre class=include>
path: syntax/case_selector.syntax.bs.include
</pre>

一个<dfn noexport>case子句</dfn>是由'case'关键字后跟以逗号分隔的一系列[=syntax/case_selector|case选择器=]和以复合语句形式的主体组成。


一个<dfn noexport>default-alone子句</dfn>是以'default'关键字开头，后跟以复合语句形式的主体。


一个<dfn noexport>default子句</dfn>可以是以下两种情况之一：
* 一个包含'default'作为其选择器之一的[=case子句=]，或者
* 一个[=default-alone子句=]。

每个switch语句必须有且仅有一个default子句。


"default"关键字在单个语法/选择器列表中不得出现多次。


类型规则前提条件：
对于单个switch语句，选择器表达式和所有case选择器表达式必须是相同的整数标量类型。


语法/选择器中的表达式必须是常量表达式。


同一个switch语句中的两个不同case选择器表达式的值不能相同。


如果选择器的值等于语法/选择器列表中的表达式的值，则控制流转到该case子句的主体。如果选择器的值不等于任何case选择器的值，则控制流转到default子句的主体。


当控制流到达某个子句的主体末尾时，控制流转到switch语句之后的第一个语句。


当子句的主体中的语句之一是声明时，它遵循复合语句中声明的正常作用域和生存期规则。也就是说，主体是一系列语句，如果其中一个是声明，则该声明的作用域从序列中下一个语句的开始延伸到主体的末尾。当到达声明时，它将被执行，创建一个新的变量声明或值声明的实例，并进行初始化。

<div class='example wgsl function-scope' heading='WGSL Switch'>
  <xmp>
    var a : i32;
    let x : i32 = generateValue();
    switch x {
      case 0: {      // The colon is optional
        a = 1;
      }
      default {      // The default need not appear last
        a = 2;
      }
      case 1, 2, {   // Multiple selector values can be used
        a = 3;
      }
      case 3, {      // The trailing comma is optional
        a = 4;
      }
      case 4 {
        a = 5;
      }
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading='WGSL Switch with default combined'>
  <xmp>
    const c = 2;
    var a : i32;
    let x : i32 = generateValue();
    switch x {
      case 0: {
        a = 1;
      }
      case 1, c {       // Const-expression can be used in case selectors
        a = 3;
      }
      case 3, default { // The default keyword can be used with other clauses
        a = 4;
      }
    }
  </xmp>
</div>

### Loop 语句 ### {#loop-statement}

<pre class=include>
path: syntax/loop_statement.syntax.bs.include
</pre>

一个循环语句（loop statement）会反复执行一个循环体（loop body）；循环体被指定为一个复合语句（compound statement）。每次执行循环体被称为一次迭代（iteration）。


这个重复过程可以通过 break 语句或 return 语句来中断。


循环体中的最后一条语句可以选择是一个 continuing 语句。


当循环体中的某个语句是一个声明语句时，它遵循在复合语句中声明的正常作用域和生命周期规则。也就是说，循环体是一系列语句，如果其中一条是一个声明语句，那么该声明的作用域从序列中下一条语句的开始一直延伸到循环体的结束。每次到达该声明时都会执行它，因此每次新的迭代都会创建一个新的变量声明或值声明的实例，并重新初始化它。


注意：循环语句是与其他着色器语言最大的不同之一。


这种设计直接表达了编译代码中常见的循环习惯用法。特别是将循环更新语句放在循环体末尾，使其可以自然地使用在循环体内定义的值。

<div class='example glsl' heading='GLSL Loop'>
  <xmp>
    int a = 2;
    for (int i = 0; i < 4; i++) {
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;      // <1>
    loop {
      if i >= 4 { break; }

      a = a * 2;

      i++;
    }
  </xmp>
</div>
* <1> The initialization is listed before the loop.

<div class='example glsl' heading='GLSL Loop with continue'>
  <xmp>
    int a = 2;
    int step = 1;
    for (int i = 0; i < 4; i += step) {
      if (i % 2 == 0) continue;
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }

      let step: i32 = 1;

      i = i + step;
      if i % 2 == 0 { continue; }

      a = a * 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue and continuing">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }

      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {   // <2>
        i = i + step;
      }
    }
  </xmp>
</div>
* <2> The continue construct is placed at the end of the `loop`

### For 语句 ### {#for-statement}

<pre class=include>
path: syntax/for_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/for_header.syntax.bs.include
</pre>

<pre class=include>
path: syntax/for_init.syntax.bs.include
</pre>
<pre class=include>
path: syntax/for_update.syntax.bs.include
</pre>

for（initializer; condition; update_part）{ body }是for语句的形式，并且在相同的body部分上附加了语法糖以作为循环语句的替代品。
此外：

* 如果initializer不为空，则在第一次迭代之前在额外的作用域内执行。初始化器中的声明的作用域延伸到循环体的结尾。
* 类型规则前提条件：如果条件不为空，则必须是bool类型的表达式。
    * 如果条件存在，则在执行循环体之前立即评估条件。如果条件为假，则执行中断语句，结束循环的执行。此检查在每次循环迭代开始时执行。
* 如果update_part不为空，则它将成为循环体末尾的continuing语句。

for循环的initializer在执行循环之前执行一次。当initializer中出现声明时，其标识符在body末尾之前都在作用域内。与body中的声明不同，声明不会在每次迭代中重新初始化。

按照condition、body和update_part的顺序执行，形成一个循环迭代。body是一种特殊的复合语句。在body的下一条语句的开始到body的结尾期间，声明的标识符都在作用域内。每次到达声明时都会执行该声明，因此每次新的迭代都会创建一个变量或常量的新实例，并重新初始化它。

<div class='example wgsl function-scope' heading="For to Loop transformation: before">
  <xmp>
    var a: i32 = 2;
    for (var i: i32 = 0; i < 4; i++) {
      if a == 0 {
        continue;
      }
      a = a + 2;
    }
  </xmp>
</div>

转换为：

<div class='example wgsl function-scope' heading="For to Loop transformation: after">
  <xmp>
    var a: i32 = 2;
    { // Introduce new scope for loop variable i
      var i: i32 = 0;
      loop {
        if !(i < 4) {
          break;
        }

        if a == 0 {
          continue;
        }
        a = a + 2;

        continuing {
          i++;
        }
      }
    }
  </xmp>
</div>

### While 语句 ### {#while-statement}

<pre class=include>
path: syntax/while_statement.syntax.bs.include
</pre>

while语句是一种由条件参数化的循环。
在每次循环[=迭代=]开始时，会评估一个布尔条件。
如果条件为false，则while循环结束执行。
否则，将执行剩余的迭代。


[=类型规则前提条件=]：条件[=shader-creation error|必须=]是[=bool=]类型。


while循环可以被看作是一个语法糖，用于表示[=statement/loop=]或[=statement/for=]语句。
以下语句形式是等价的：
* while condition { body_statements }
* loop { if ! condition {break;} body_statements }
* for (; condition ;) { body_statements }

### Break 语句 ### {#break-statement}

<pre class=include>
path: syntax/break_statement.syntax.bs.include
</pre>

一个break语句将控制转移至最近的包含循环或switch语句的主体之后，从而结束循环或switch语句的执行。


break语句只能在循环、for、while和switch语句内部使用。


不得将break语句放置在会从循环的"继续语句"中退出的位置。应改为使用break-if语句。

<div class='example wgsl function-scope' heading="WGSL Invalid loop break from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        if i >= 4 { break; } // Invalid.  Use break-if instead.
      }
    }
  </xmp>
</div>

### Break-If 语句 ### {#break-if-statement}

<pre class=include>
path: syntax/break_if_statement.syntax.bs.include
</pre>
一个<dfn noexport dfn-for="statement">break-if</dfn>语句评估一个布尔条件；

如果条件为真，则控制权转移到最近封闭的[=语句/循环=]语句的主体之后，结束该循环的执行。


[=类型规则前提条件=]：条件[=着色器创建错误|必须=]是[=bool=]类型。


注意：break-if语句只能作为[[#continuing-statement|continuing]]语句主体中的最后一条语句出现。

<div class='example wgsl function-scope' heading="WGSL Valid loop break-if from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        break if i >= 4;
      }
    }
  </xmp>
</div>

### Continue 语句 ### {#continue-statement}

<pre class=include>
path: syntax/continue_statement.syntax.bs.include
</pre>

<dfn noexport dfn-for="statement">continue</dfn>语句将控制权转移到最近的封闭[=语句/循环=]中：
* 如果存在，转移到该循环体末尾的[=语句/continuing=]语句。
* 否则，向后转移到循环体中的第一条语句，开始下一次[=迭代=]。

continue语句只能在[=语句/循环=]、[=语句/for=]或[=语句/while=]语句中使用。
不能将continue语句放在会转移控制到封闭的[=语句/continuing=]语句的位置。
（当转移到continuing语句时，这是一个"前向"分支。）


不能将continue语句放在会跳过目标[=语句/continuing=]语句中使用的声明的位置。


注意：只有当continue用于在continuing语句中嵌套的另一个循环中传递控制流时，才能在continuing语句中使用continue。也就是说，continue不能用于将控制转移到当前执行的continuing语句的开头。

<div class='example wgsl function-scope expect-error' heading="Invalid continue bypasses declaration">
  <xmp>
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }
      if i % 2 == 0 { continue; } // <3>

      let step: i32 = 2;

      continuing {
        i = i + step;
      }
    }
  </xmp>
</div>
* <3> The `continue` is invalid because it bypasses the declaration of `step` used in the `continuing` construct

### Continuing 语句 ### {#continuing-statement}

<pre class=include>
path: syntax/continuing_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/continuing_compound_statement.syntax.bs.include
</pre>

一个"continuing"语句指定了一个在循环迭代结束时执行的复合语句。这个结构是可选的。

复合语句不能包含返回语句在任何嵌套层。

### Return 语句 ### {#return-statement}

<pre class=include>
path: syntax/return_statement.syntax.bs.include
</pre>

一个<dfn noexport dfn-for="statement">return</dfn>语句会结束当前函数的执行。
如果该函数是一个[=入口点=]，那么当前着色器调用将被终止。
否则，在当前函数调用的[=调用点=]求值之后，继续对下一个表达式或语句进行求值。


如果函数没有[=返回类型=]，那么[=语句/返回=]语句是可选的。如果为这样的函数提供了返回语句，它[=创建错误|不能=]提供一个值。
否则，表达式[=创建错误|必须存在=]，并且被称为<dfn>返回值</dfn>。在这种情况下，该函数调用的调用点求值为返回值。
返回值的类型[=创建错误|必须=]与函数的返回类型相匹配。

### Discard 语句 ### {#discard-statement}

一个"discard"语句将调用转换为一个[=辅助调用=]并丢弃该片段。
"discard"语句只能在[=片段=]着色器阶段中使用。


更准确地说，执行"discard"语句会：
* 将当前调用转换为一个[=辅助调用=]，
* 阻止当前片段在[=GPURenderPipeline=]中继续处理。

只有在"discard"语句之前执行的语句才会产生可观察的效果。


注意：任何一个[=片段阶段的函数=]都可以执行"discard"语句，其效果相同：片段将被丢弃。

<div class='example wgsl' heading='Using the discard statement to throw away a fragment'>
  <xmp>
  @group(0) @binding(0)
  var<storage, read_write> will_emit_color : u32;

  fn discard_if_shallow(pos: vec4<f32>) {
    if pos.z < 0.001 {
      // If this is executed, then the will_emit_color variable will
      // never be set to 1 because helper invocations will not write
      // to shared memory.
      discard;
    }
    will_emit_color = 1;
  }

  @fragment
  fn main(@builtin(position) coord_in: vec4<f32>)
    -> @location(0) vec4<f32>
  {
    discard_if_shallow(coord_in);

    // Set the value to 1 and emit red, but only if the helper function
    // did not execute the discard statement.
    will_emit_color = 1;
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
  }
  </xmp>
</div>

## 函数调用语句 ## {#function-call-statement}

<pre class=include>
path: syntax/func_call_statement.syntax.bs.include
</pre>

一个函数调用语句执行一个函数调用。


如果被调用的函数具有属性/必须使用属性，则会导致一个着色器创建错误。


注意：如果函数返回一个值，并且函数没有属性/必须使用属性，则该值会被忽略。

## Const断言语句 ## {#const-assert-statement}

如果表达式求值为 `false` ，则"const assertion"语句将产生一个shader创建错误。该表达式必须是一个常量表达式。该语句可以满足shader中静态访问的条件，但对编译后的shader没有其他影响。该语句可以在模块作用域和函数作用域内使用。

[=Type rule precondition=]:
The expression [=shader-creation error|must=] be of [=bool=] type.

<pre class=include>
path: syntax/const_assert_statement.syntax.bs.include
</pre>

<div class='example wgsl global-scope' heading="Static assertion examples">
  <xmp>
    const x = 1;
    const y = 2;
    const_assert x < y; // valid at module-scope.
    const_assert(y != 0); // parentheses are optional.

    fn foo() {
      const z = x + y - 2;
      const_assert z > 0; // valid in functions.
      let a  = 3;
      const_assert a != 0; // invalid, the expresion must be a const-expression.
    }
  </xmp>
</div>

## 语句语法总结 ## {#statements-summary}

该[=syntax/statement=]规则匹配可以在函数体内大多数位置使用的语句。

<pre class=include>
path: syntax/statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/variable_updating_statement.syntax.bs.include
</pre>

此外，某些陈述仅可在非常特定的情境中使用：
* [=syntax/break_if_statement=]
* [=syntax/continuing_compound_statement=]

## 语句行为分析 ## {#behaviors}

### 规则 ### {#behaviors-rules}

一些影响控制流的语句只在某些上下文中有效。例如，在循环语句、for循环语句或while循环语句之外，[=statement/continue=]是无效的。此外，统一性分析（参见[[#uniformity]]）需要知道控制流何时可以以多种不同方式退出语句。


这两个目标可以通过一个对语句执行行为进行总结的系统来实现。行为分析将每个语句映射到在该语句评估完成后执行进行的可能方式的集合。与对值和表达式进行类型分析一样，行为分析是从下往上进行的：首先确定某些基本语句的行为，然后通过应用组合规则确定更高级结构的行为。


<dfn export>行为</dfn>是一个集合，其元素可以是：
- 返回（Return）
- 跳出（Break）
- 继续（Continue）
- 下一步（Next）

这些都对应于从复合语句中退出的方式：要么通过关键字，要么通过跳到下一条语句（"Next"）。


我们使用"s: B"表示s遵守行为规则，并具有行为B。


对于每个函数：
- 它的主体必须符合这些规则而成为有效的语句。
- 如果函数有返回类型，则其主体的行为必须为{Return}。
- 否则，其主体的行为必须是{Next, Return}的子集。

我们为每个函数分配一个行为：它是其主体的行为（将主体视为普通语句），其中任何"Return"都被替换为"Next"。根据以上规则，函数行为始终为{}或{Next}之一。


行为分析能够确定每个语句和函数的非空行为。

<table class='data'>
  <caption>Rules for analyzing and validating the behaviors of statements</caption>
  <thead>
    <tr><th>Statement<th>Preconditions<th>Resulting behavior
  </thead>
  <tr>
    <td class="nowrap">*empty statement*
    <td>
    <td class="nowrap">{Next}
  <tr algorithm="braced statement behavior">
    <td class="nowrap">{|s|}
    <td>|s|: |B|
    <td class="nowrap">|B|
  <tr algorithm="statement sequence behavior with next">
    <td class="nowrap" rowspan=2>|s1| |s2|

        Note: |s1| often ends in a semicolon.

    <td class="nowrap">|s1|: |B1|<br>
        Next in |B1|<br>
        |s2|: |B2|
    <td class="nowrap">(|B1|&#x2216;{Next}) &cup; |B2|
  <tr algorithm="statement sequence behavior without next">
    <td class="nowrap">|s1|: |B1|<br>
        Next not in |B1|<br>
        |s2|: <var ignore>B2</var>
    <td class="nowrap">|B1|
  <tr algorithm="variable declaration behavior">
    <td class="nowrap">var x:T;
    <td>
    <td>{Next}
  <tr algorithm="let-declaration behavior">
    <td class="nowrap">let x = |e|;
    <td>
    <td>{Next}
  <tr algorithm="initialized variable declaration behavior">
    <td class="nowrap">var x = |e|;
    <td>
    <td>{Next}
  <tr algorithm="assignment behavior">
    <td class="nowrap">x = |e|;
    <td>
    <td>{Next}
  <tr algorithm="phony assignment behavior">
    <td class="nowrap">_ = |e|;
    <td>
    <td>{Next}
  <tr algorithm="function call statement behavior">
    <td class="nowrap">|f|(|e1|, ..., |en|);
    <td class="nowrap">|f| has behavior |B|
    <td class="nowrap">|B|
  <tr algorithm="return behavior">
    <td>return;
    <td>
    <td>{Return}
  <tr algorithm="return value behavior">
    <td class="nowrap">return |e|;
    <td>
    <td>{Return}
  <tr algorithm="discard behavior">
    <td class="nowrap">discard;
    <td>
    <td>{Next}
  <tr algorithm="break behavior">
    <td>break;
    <td>
    <td>{Break}
  <tr algorithm="break if behavior">
    <td>break if |e|;
    <td>
    <td>{Break, Next}
  <tr algorithm="continue behavior">
    <td>continue;
    <td>
    <td>{Continue}
  <tr algorithm="if statement behavior">
    <td class="nowrap">if |e| |s1| else |s2|
    <td class="nowrap">
        |s1|: |B1|<br>
        |s2|: |B2|
    <td class="nowrap">|B1| &cup; |B2|
  <tr algorithm="loop with continuing without break behavior">
    <td class="nowrap" rowspan=2>loop {|s1| continuing {|s2|}}
    <td class="nowrap">
        |s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return} are in |B2|<br>
        Break is not in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1| &cup; |B2|)&#x2216;{Continue, Next}
  <tr algorithm="loop with continuing with break behavior">
    <td class="nowrap">
        |s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return} are in |B2|<br/>
        Break is in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1| &cup; |B2| &cup; {Next})&#x2216;{Break, Continue}
  <tr algorithm="switch behavior">
    <td class="nowrap" rowspan=2>switch |e|  {case <var ignore>c1</var>: |s1| ... case <var ignore>cn</var>: |sn|}
    <td class="nowrap">
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Break is not in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">|B1| &cup; ... &cup; |Bn|
  <tr algorithm="switch with break behavior">
    <td class="nowrap">
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Break is in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">(|B1| &cup; ... &cup; |Bn| &cup; {Next})&#x2216;Break
</table>

注意：∪表示集合的并操作，∖表示集合的差操作。


注意：当一个循环的主体为空，或者一个for循环缺少初始化或更新语句时，就会出现空语句的情况。


在这个分析中：
- for循环被展开（参见[[#for-statement]]）
- while循环被展开（参见[[#while-statement]]）
- loop {s} 被处理为 loop {s continuing {}}
- 如果语句没有else分支，则处理为有一个空的else分支（其行为会添加Next）
- 如果语句有else if分支，则处理为嵌套的简单if/else语句
- 以default开头的switch语句的行为与以case _ 开头的switch语句相同

每个内置函数的行为为Next。
对于表格中未列出的运算符应用，其行为与使用相同操作数的函数调用相同，并且函数的行为为Next。


函数的行为必须遵守上述规则。


注意：分析表达式的行为是不必要的，因为它们总是Next，或者先前分析的函数会产生错误。

### 注意 ### {#behaviors-notes}

这节是信息性的，非规范性的。


行为分析可能会导致程序在以下方面被拒绝（重新陈述上述要求）：
- 一个函数的主体（被视为常规语句）具有不包含在 {Next, Return} 中的行为。
- 一个带有返回类型的函数的主体具有不为 {Return} 的行为。
- 一个持续块的行为包含任何一个Continue或Return。
- 一些明显无限循环的行为集为空，因此是无效的。

这个分析可以在线性时间内运行，通过自底向上分析调用图（因为一个函数调用的行为可能依赖于函数的代码）。

### 示例 ### {#behaviors-examples}

以下是一些示例展示了这种分析的效果：
<div class='example wgsl expect-error' heading='Trivially dead code is allowed'>
   <xmp>
    fn simple() -> i32 {
      var a: i32;
      return 0;  // Behavior: {Return}
      a = 1;     // Valid, statically unreachable code.
                 //   Statement behavior: {Next}
                 //   Overall behavior (due to sequential statements): {Return}
      return 2;  // Valid, statically unreachable code. Behavior: {Return}
    } // Function behavior: {Return}
   </xmp>
</div>

<div class='example wgsl expect-error' heading='Compound statements are supported'>
   <xmp>
    fn nested() -> i32 {
      var a: i32;
      {             // The start of a compound statement.
        a = 2;      // Behavior: {Next}
        return 1;   // Behavior: {Return}
      }             // The compound statement as a whole has behavior {Return}
      a = 1;        // Valid, statically unreachable code.
                    //   Statement behavior: {Next}
                    //   Overall behavior (due to sequential statements): {Return}
      return 2;     // Valid, statically unreachable code. Behavior: {Return}
    }
   </xmp>
</div>

<div class='example wgsl' heading='if/then behaves as if there is an empty else'>
   <xmp>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        }             // Behavior of the whole if compound statement: {Break, Next},
                      //   as the if has an implicit empty else
        a = a + 1;    // Valid, as the previous statement had "Next" in its behavior
      }
    }
   </xmp>
</div>

<div class='example wgsl expect-error' heading='if/then/else has the behavior of both sides'>
   <xmp>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        } else {
          continue;   // Behavior: {Continue}
        }             // Behavior of the whole if compound statement: {Break, Continue}
        a = a + 1;    // Valid, statically unreachable code.
                      //   Statement behavior: {Next}
                      //   Overall behavior: {Break, Continue}
      }
    }
   </xmp>
</div>

<div class='example wgsl' heading='if/else if/else behaves like a nested if/else'>
   <xmp>
    fn if_example() {
      var a: i32 = 0;
      loop {
        // if e1 s1 else if e2 s2 else s3
        // is identical to
        // if e1 else { if e2 s2 else s3 }
        if a == 5 {
          break;      // Behavior: {Break}
        } else if a == 42 {
          continue;   // Behavior: {Continue}
        } else {
          return;     // Behavior {Return}
        }             // Behavior of the whole if compound statement:
                      //   {Break, Continue, Return}
      }               // Behavior of the whole loop compound statement {Next, Return}
    }                 // Behavior of the whole function {Next}
   </xmp>
</div>

<div class='example wgsl' heading='Break in switch becomes Next'>
   <xmp>
    fn switch_example() {
      var a: i32 = 0;
      switch a {
        default: {
          break;   // Behavior: {Break}
        }
      }            // Behavior: {Next}, as switch replaces Break by Next
      a = 5;       // Valid, as the previous statement had Next in its behavior
    }
   </xmp>
</div>

<div class='example wgsl' heading='Obviously infinite loops'>
   <xmp>
    fn invalid_infinite_loop() {
      loop { }     // Behavior: { }.  Invalid because it's empty.
    }
   </xmp>
</div>

<div class='example wgsl' heading='Discard will not terminate a loop'>
  <xmp>
    fn invalid_infinite_loop() {
      loop {
        discard; // Behavior { Next }.
      }          // Invalid, behavior of the whole loop is { }.
    }
  </xmp>
</div>

<div class='example wgsl' heading='A conditional continue with continuing statement'>
   <xmp>
    fn conditional_continue() {
      var a: i32;
      loop {
        if a == 5 { break; } // Behavior: {Break, Next}
        if a % 2 == 1 {      // Valid, as the previous statement has Next in its behavior
          continue;          // Behavior: {Continue}
        }                    // Behavior: {Continue, Next}
        a = a * 2;           // Valid, as the previous statement has Next in its behavior
        continuing {         // Valid as the continuing statement has behavior {Next}
                             //  which does not include any of:
                             //  {Break, Continue, Return}
          a = a + 1;
        }
      }                      // The loop as a whole has behavior {Next},
                             //  as it absorbs "Continue" and "Next",
                             //  then replaces "Break" with "Next"
    }
   </xmp>
</div>

<div class='example wgsl' heading='A redundant continue with continuing statement'>
   <xmp>
    fn redundant_continue_with_continuing() {
      var a: i32;
      loop {
        if a == 5 { break; }
        continue;   // Valid. This is redundant, branching to the next statement.
        continuing {
          a = a + 1;
        }
      }
    }
   </xmp>
</div>

<div class='example wgsl' heading='A continue at the end of a loop body'>
   <xmp>
    fn continue_end_of_loop_body() {
      for (var i: i32 = 0; i < 5; i++ ) {
        continue;   // Valid. This is redundant,
                    //   branching to the end of the loop body.
      }             // Behavior: {Next},
                    //   as loops absorb "Continue",
                    //   and "for" loops always add "Next"
    }
   </xmp>
</div>
`for`循环会变成一个具有条件中断的loop。如前面的例子所示，条件中断拥有{Break, Next}的行为，这会导致在循环的行为中添加"Next"。

<div class='example wgsl expect-error' heading='return required in functions that have a return type'>
   <xmp>
    fn missing_return () -> i32 {
      var a: i32 = 0;
      if a == 42 {
        return a;       // Behavior: {Return}
      }                 // Behavior: {Next, Return}
    }                   // Error: Next is invalid in the body of a
                        //   function with a return type
   </xmp>
</div>

<div class='example wgsl expect-error' heading='continue must be in a loop'>
   <xmp>
    fn continue_out_of_loop () {
      var a: i32 = 0;
      if a > 0  {
        continue;       // Behavior: {Continue}
      }                 // Behavior: {Next, Continue}
    }                   // Error: Continue is invalid in the body of a function
   </xmp>
</div>
如果将continue替换为break，同样的例子也会因相同原因而无效。

# 函数 # {#functions}

当调用一个函数时，它会执行计算工作。


函数可以通过以下方式之一被调用：
* 通过评估函数调用表达式。见[[#function-call-expr]]。
* 通过执行函数调用语句。见[[#function-call-statement]]。
* 一个"入口点"函数通过WebGPU实现来执行"着色器阶段"在"管线"中的工作。见[[#entry-points]]。

有两种类型的函数：
* "内置函数"由WGSL实现提供，始终可用于WGSL模块。见[[#builtin-functions]]。
* "用户自定义函数"在WGSL模块中声明。

## 声明一个用户定义的函数n ## {#function-declaration-sec}

一个<dfn noexport>函数声明</dfn>通过指定以下内容创建一个<dfn noexport>用户定义函数</dfn>：
* 一个可选的[=属性=]集合。
* 函数的名称。
* 形式参数列表：一个有序的零个或多个[=形式参数=]声明，可以应用属性，由逗号分隔，并用括号括起来。
* 可选的<dfn noexport>返回类型</dfn>，可以应用属性。
* <dfn noexport>函数体</dfn>。这是在函数被[=函数调用|调用=]时要执行的一组语句。

函数声明[=着色器创建错误|必须=]只能在[=模块范围=]内发生。
函数名称在整个程序中[=处于作用域=]。


注意：每个[=用户定义函数=]只有一个[=重载=]。

一个【正式参数】的[声明]指定了一个标识符名称和一个类型，用于在调用函数时提供一个值。
一个正式参数可以具有属性。
参见【#function-calls】。
标识符的【作用域】是【函数体】。
对于给定函数，两个正式参数【不能】具有相同的名称。


注意：一些内置函数可能允许参数为【抽象数值类型】；然而，目前不支持用户声明函数的这种功能。


【返回类型】如果指定，【必须】是可构造的。

WGSL定义了可应用于函数声明的以下属性:
* [=shader stage attributes=]: [=attribute/vertex=], [=attribute/fragment=]和[=attribute/compute=]
* [=attribute/workgroup_size=]

WGSL定义了可应用于函数参数和返回类型的以下属性：
* [=attribute/builtin=]
* [=attribute/location=]
* [=attribute/interpolate=]
* [=attribute/invariant=]

<pre class=include>
path: syntax/function_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/function_header.syntax.bs.include
</pre>
<pre class=include>
path: syntax/param_list.syntax.bs.include
</pre>
<pre class=include>
path: syntax/param.syntax.bs.include
</pre>

<div class='example wgsl' heading='Simple functions'>
  <xmp>
    // Declare the add_two function.
    // It has two formal parameters, i and b.
    // It has a return type of i32.
    // It has a body with a return statement.
    fn add_two(i: i32, b: f32) -> i32 {
      return i + 2;  // A formal parameter is available for use in the body.
    }

    // A compute shader entry point function, 'main'.
    // It has no specified return type.
    // It invokes the add_two function, and captures
    // the resulting value in the named value 'six'.
    @compute @workgroup_size(1)
    fn main() {
       let six: i32 = add_two(4, 5.0);
    }
  </xmp>
</div>

## 函数调用 ## {#function-calls}

一个<dfn noexport>函数调用</dfn>是一个调用函数的语句或表达式。


包含函数调用的函数是<dfn>调用函数</dfn>，或者<dfn noexport>调用者</dfn>。
被调用的函数是<dfn>被调用函数</dfn>，或者<dfn noexport>被调用者</dfn>。


函数调用：
* 命名了[=被调用函数=]，并且
* 提供了一个用括号括起来的、逗号分隔的参数值表达式列表。

函数调用[=shader-creation error|必须=]提供与[=被调用函数=]中的[=形式参数|形式参数=]数量相同的参数值。
每个参数值[=shader-creation error|必须=]按位置与相应的形式参数具有相同的类型进行求值。


总之，当调用一个函数时：
1. [=调用函数=]的执行被暂停。
2. 被调用函数执行直到它[=返回=]。
3. [=调用函数=]的执行继续。

一个被调用的函数的返回方式如下：
* 内置函数在工作完成后返回。
* 带有返回类型的用户定义函数在执行return语句后返回。
* 没有返回类型的用户定义函数在执行return语句或达到函数体末尾时返回。

详细地说，当一个函数调用被执行时，以下步骤会发生：
1. 函数调用的参数值被求值。 参数值的相对顺序是从左到右。
1. 调用函数的执行被暂停。 所有的函数范围变量和常量保持其当前值。
1. 如果被调用的函数是用户定义函数，为该函数范围的每个变量分配内存。
1. 如[[#var-decls]]所述，进行初始化。
1. 被调用函数的形式参数值通过按位置匹配函数调用的参数值来确定。 例如，被调用函数的第一个形式参数将具有调用点的第一个参数的值。
1. 控制权转移到被调用函数。 如果被调用函数是用户定义函数，执行将从函数体的第一条语句开始。
1. 被调用函数被执行，直到它返回。
1. 控制权转回到调用函数，并且被调用函数的执行被恢复。 如果被调用函数有返回值，返回值将作为函数调用表达式的值提供。

函数调用的位置被称为调用点，特指在解析的syntax/call_phrase语法规则实例中首个令牌的位置。
调用点是一个动态上下文。
因此，相同的文本位置可能表示多个调用点。


注意：在一个片段着色器中，如果四个子像素中所有的执行都被丢弃，可能会导致函数调用永远不返回。
在这种情况下，控制权不会返回给调用函数。

## `const` 函数 ## {#const-funcs}

带有[=attribute/const=]属性声明的函数可以在着色器模块创建时进行评估。这些函数被称为<dfn noexport>const-functions（常量函数）</dfn>。对这些函数的调用可以作为[=const-expressions=]的一部分。


如果函数包含任何非[=const-expressions=]的表达式或任何非[=const-declarations=]的声明，则它将导致一个着色器创建错误。


注意：[=attribute/const=]属性不能应用于用户声明的函数。

<div class='example wgsl' heading='const-functions'>
  <xmp>
    const first_one = firstLeadingBit(1234 + 4567); // Evaluates to 12
                                                    // first_one has the type i32, because
                                                    // firstLeadingBit cannot operate on
                                                    // AbstractInt

    @id(1) override x : i32;
    override y = firstLeadingBit(x); // const-expressions can be
                                     // used in override-expressions.
                                     // firstLeadingBit(x) is not a
                                     // const-expression in this context.

    fn foo() {
      var a : array<i32, firstLeadingBit(257)>; // const-functions can be used in
                                                // const-expressions if all their
                                                // parameters are const-expressions.
    }
  </xmp>
</div>

## 功能限制 ## {#function-restriction}

一个顶点着色器[=shader-creation error|必须=]返回内置的值/位置内置的输出值。
* 入口点[=shader-creation error|不能=]成为函数调用的目标。
* 如果函数有返回类型，它[=shader-creation error|必须=]是可构造的类型。
* 函数的形参[=shader-creation error|必须=]是以下类型之一：
    * 可构造类型
    * 指针类型
    * 纹理类型
    * 采样器类型
* 每个函数调用参数[=shader-creation error|必须=]求值为对应的函数参数类型。
* 特别地，作为指针的参数[=shader-creation error|必须=]与形参在地址空间、存储类型和访问模式方面一致。
* 对于自定义函数，指针类型的参数[=shader-creation error|必须=]在以下地址空间之一：
    * 函数地址空间
    * 私有地址空间
* 对于内置函数，指针类型的参数[=shader-creation error|必须=]在以下地址空间之一：
    * 函数地址空间
    * 私有地址空间
    * 工作组地址空间
    * 存储地址空间
* 每个指向自定义函数的指针类型参数[=shader-creation error|必须=]具有与其根标识符相同的内存视图。
    * 注意：这意味着当从参数通过所有的let声明追溯回根标识符时，不能应用向量、矩阵、数组或结构访问表达式来产生根标识符的内存视图。

注意：不允许递归，因为不允许在任何类型的声明之间存在循环。

<div class='example wgsl' heading='Valid and invalid pointer arguments'>
  <xmp>
    fn bar(p : ptr<function, f32>) {
    }

    fn baz(p : ptr<private, i32>) {
    }

    fn bar2(p : ptr<function, f32>) {
      let a = &*&*(p);

      bar(p); // Valid
      bar(a); // Valid
    }

    struct S {
      x : i32
    }

    var usable_priv : i32;
    var unusable_priv : array<i32, 4>;
    fn foo() {
      var usable_func : f32;
      var unusable_func : S;

      let a_priv = &usable_priv;
      let b_priv = a_priv;
      let c_priv = &*&usable_priv;
      let d_priv = &(unusable_priv.x);
      let e_priv = d_priv;

      let a_func = &usable_func;
      let b_func = &unusable_func;
      let c_func = &(*b_func)[0];
      let d_func = c_func;
      let e_func = &*a_func;

      baz(&usable_priv); // Valid, address-of a variable.
      baz(a_priv);       // Valid, effectively address-of a variable.
      baz(b_priv);       // Valid, effectively address-of a variable.
      baz(c_priv);       // Valid, effectively address-of a variable.
      baz(d_priv);       // Invalid, memory view has changed.
      baz(e_priv);       // Invalid, memory view has changed.

      bar(&usable_func); // Valid, address-of a variable.
      bar(c_func);       // Invalid, memory view has changed.
      bar(d_func);       // Invalid, memory view has changed.
      bar(e_func);       // Valid, effectively address-of a variable.
    }
  </xmp>
</div>

### 别名分析 ### {#alias-analysis}

#### 根标识符 #### {#root-ident-sec}

[=Memory locations=] 在函数执行期间可以使用 [=memory views=] 进行访问。
在函数内部，每个 [=memory view=] 都有一个特定的【根标识符】，用于标识在该函数中首次提供对该内存的访问的变量或形式参数。


派生于函数内的【引用类型】或【指针类型】的本地表达式可能会为特定的根标识符引入新的名称，但是每个表达式都有一个静态可确定的根标识符。

    <p algorithm="finding a root identifier">
      给定一个类型为指针类型或引用类型的表达式|E|，"根标识符"是指在以下情况下找到的原始变量或形式参数的指针类型：
      * 如果|E|是一个解析为变量的标识符，那么根标识符就是该变量。
      * 如果|E|是一个解析为指针类型形式参数的标识符，那么根标识符就是该形式参数。
      * 如果|E|是一个具有初始值|E2|的let-declaration的标识符，那么根标识符就是|E2|的根标识符。
      * 如果|E|的形式是(|E2|)，&|E2|，*|E2|或|E2|[<var ignore>Ei</var>]，那么根标识符就是|E2|的根标识符。
      * 如果|E|是具有形式|E2|.|swiz|的向量访问表达式，其中|swiz|是一个swizzle名称，那么根标识符就是|E2|的根标识符。
      * 如果|E|是具有形式|E2|.<var ignore>member_name</var>的结构体访问表达式，那么根标识符就是|E2|的根标识符。</p>

#### Aliasing #### {#aliasing}

虽然一个根标识符的来源变量是一个动态概念，取决于函数的调用点，但是可以静态地分析WGSL模块以确定每个根标识符的所有可能的来源变量集合。


当两个根标识符具有相同的来源变量时，它们被称为"别名"。
在WGSL函数的执行过程中，不能通过别名的根标识符可能访问内存，其中一个访问是写入访问，另一个访问是读取或写入访问。
这是通过从调用图的叶子到根的分析（即拓扑顺序）来确定的。
对于每个函数，分析记录以下集合：
* 在这个函数中调用的函数中写入的模块范围变量。
* 在这个函数中调用的函数中读取的模块范围变量。
* 作为内存视图的根标识符参数，在这个函数或调用的函数中被写入的。
* 作为内存视图的根标识符参数，在这个函数或调用的函数中被读取的。

在函数的每个调用点，如果出现以下情况之一，就会出现"shader-creation error"：
* 两个指针类型的参数具有相同的根标识符，并且相应的参数位于写入参数集合中。
* 指针类型的参数的根标识符是一个模块范围变量，其中：
    * 相应的指针参数位于写入指针参数集合中，并且
    * 模块范围变量位于被调用函数的读取集合中。
* 指针类型的参数的根标识符是一个模块范围变量，其中：
    * 相应的指针参数位于写入指针参数集合中，并且
    * 模块范围变量位于被调用函数的写入集合中。
* 指针类型的参数的根标识符是一个模块范围变量，其中：
    * 相应的指针参数位于读取指针参数集合中，并且
    * 模块范围变量位于被调用函数的写入集合中。

<div class='example wgsl' heading='Alias analysis'>
  <xmp>
    var<private> x : i32 = 0;

    fn f1(p1 : ptr<function, i32>, p2 : ptr<function, i32>) {
      *p1 = *p2;
    }

    fn f2(p1 : ptr<function, i32>, p2 : ptr<function, i32>) {
      f1(p1, p2);
    }

    fn f3() {
      var a : i32 = 0;
      f2(&a, &a);  // Invalid. Cannot pass two pointer parameters
                   // with the same root identifier when one or
                   // more are written (even by a subfunction).
    }

    fn f4(p1 : ptr<function, i32>, p2 : ptr<function, i32>) -> i32 {
      return *p1 + *p2;
    }

    fn f5() {
      var a : i32 = 0;
      let b = f4(&a, &a); // Valid. p1 and p2 in f4 are both only read.
    }

    fn f6(p : ptr<private, i32>) {
      x = *p;
    }

    fn f7(p : ptr<private, i32>) -> i32 {
      return x + *p;
    }

    fn f8() {
      let a = f6(&x); // Invalid. x is written as a global variable and
                      // read as a parameter.
      let b = f7(&x); // Valid. x is only read as both a parameter and
                      // a variable.
    }
  </xmp>
</div>

# 属性 # {#attributes}

一个属性修改一个对象。
WGSL提供了应用属性的统一语法。
属性用于各种不同的目的，比如指定与API的接口。


一般来说，从语言的角度来看，属性在类型和语义检查方面可以被忽略。
此外，属性名称是一个上下文相关的名称，一些属性参数也是上下文相关的名称。


除非在下面明确允许，否则一个属性不能在一个对象或类型中指定多次。

<table class=‘data’>
<caption>在WGSL中定义的属性</caption>
<thead>
<tr><th>属性<th>有效值<th>描述
</thead>


<tr><td><dfn noexport dfn-for="attribute">align</dfn>
<td>[=shader-creation error|必须=]是一个等于[=const-expression=]的表达式，该表达式的类型必须解析为[=i32=]或[=u32=]。<br>
[=shader-creation error|必须=]是正数。
<td>[=shader-creation error|必须=]只能应用于结构体类型的成员。


[=shader-creation error|必须=]是2的幂次。

注意：此属性影响封闭结构体类型的值在内存中的表现方式：
结构体本身和其组成成员在哪些字节地址上可以出现。
特别是，在[[#memory-layouts]]中的规则结合起来，暗示了以下约束：

<p class="note" algorithm="implied constraint on align attribute">
如果将 `align(`|n|`)` 应用于类型为 |T| 的 |S| 结构体的成员，
并且 |S| 是所在地址空间为 |C| 的变量的存储类型，或为存储类型，
则 |n| [shader-creation error|必须满足]=：
|n|&nbsp;=&nbsp;|k|&nbsp;&times;&nbsp;[=RequiredAlignOf=](|T|,|C|)
其中 |k| 是正整数。
</p>

<tr><td><dfn noexport dfn-for="attribute">binding</dfn>
<td>[=shader-creation error|必须=]是一个等于[=const-expression=]的表达式，该表达式的类型必须解析为[=i32=]或[=u32=]。<br>
[=shader-creation error|必须=]是非负数。
<td>[=shader-creation error|必须=]只能应用于资源变量。


指定绑定分组中资源的绑定号。
参见[[#resource-interface]]。

<tr><td><dfn noexport dfn-for="attribute">builtin</dfn>
<td>[=shader-creation error|必须=]是一个[=built-in value=]的[=enumerant=]。
<td>[=shader-creation error|必须=]只能应用于入口点函数参数、入口点返回类型或结构体的成员。


指定关联对象是一个内置值，由指定的[=enumerant=]表示。
参见[[#builtin-inputs-outputs]]。

<tr><td><dfn noexport dfn-for="attribute">const</dfn>
<td>无
<td>只能应用于函数声明。


指定该函数可以用作[=const-function=]。
该属性[=shader-creation error|不能=]应用于用户自定义函数。

注意：此属性用作描述可以在[=const-expressions=]中使用哪些内置函数的符号约定。

<tr><td><dfn noexport dfn-for="attribute">diagnostic</dfn>
<td>两个参数。


    第一个参数是一个[=syntax/severity_control_name=]。

    第二个参数是一个[=syntax/diagnostic_rule_name=]令牌，
    指定一个[=diagnostic/triggering rule=]。

<td>指定一个[=range diagnostic filter=]。参见[[#diagnostics]]。

    一个语法形式上可以指定多个[=attribute/diagnostic=]属性，
    但它们[=shader-creation error|必须区分]=不同的[=diagnostic/triggering rules=]。

<tr><td><dfn noexport dfn-for="attribute">group</dfn>
<td>[=shader-creation error|必须=]是一个等于[=const-expression=]的表达式，该表达式的类型必须解析为[=i32=]或[=u32=]。<br>
[=shader-creation error|必须=]是非负数。
<td>[=shader-creation error|必须=]只能应用于资源变量。


指定资源的绑定组。
参见[[#resource-interface]]。

<tr><td><dfn noexport dfn-for="attribute">id</dfn>
<td>[=shader-creation error|必须=]是一个等于[=const-expression=]的表达式，该表达式的类型必须解析为[=i32=]或[=u32=]。<br>
[=shader-creation error|必须=]是非负数。
<td>[=shader-creation error|必须=]只能应用于[=scalar=]类型的[=override-declaration=]。


指定一个数值标识符作为[=pipeline-overridable=]常量的替代名称。

<tr><td><dfn noexport dfn-for="attribute">interpolate</dfn>
<td>一个或两个参数。


第一个参数[=shader-creation error|必须=]是一个[=interpolation type=]的[=enumerant=]。

如果第二个参数存在，则第二个参数[=shader-creation error|必须=]是一个[=interpolation sampling=]的[=enumerant=]。

<td>[=shader-creation error|必须=]只能应用于具有[=attribute/location=]属性的声明。

指定如何对用户定义的IO进行插值。
该属性只对用户定义的[=vertex=]输出和[=fragment=]输入有效。
参见[[#interpolation]]。

<tr><td><dfn noexport dfn-for="attribute">invariant</dfn>
<td>无
<td>[=shader-creation error|必须=]只能应用于[=built-in values/position=]的内置值。


当应用于顶点着色器的内置输出值的内置输出值时，结果的计算在不同程序和相同入口点的不同调用之间是不变的。
也就是说，如果两个不同入口点中的 `position` 输出的数据和控制流匹配，则结果值保证相同。
对 `position` 的内置输入值没有影响。

注意：此属性映射到HLSL中的 `precise` 限定符，以及GLSL中的 `invariant` 限定符。
<tr><td><dfn noexport dfn-for="attribute">location</dfn>
<td>[=shader-creation error|必须]是一个解析为[=i32=]或[=u32=]的[=const-expression=]。<br>
[=shader-creation error|必须]为非负数。
<td>[=shader-creation error|必须]仅应用于入口点函数参数的声明，入口点返回类型，或[=structure=]类型的成员。
[=shader-creation error|必须]仅应用于具有[=numeric scalar=]或[=numeric vector=]类型的对象的声明。
不得与[=compute=]着色器阶段一起使用。


指定入口点的用户定义IO的一部分。
参见[[#input-output-locations]]。

<tr><td><dfn noexport dfn-for="attribute">must_use</dfn>
<td>None
<td>[=shader-creation error|必须]仅应用于具有[=return type=]的[=function/function=]的声明。


    指定对该函数的[=function call|调用=]必须用作[=expression=]。
    也就是说，对该函数的调用不能是一个[[#function-call-statement|函数调用语句]]的全部内容。

    注意：许多函数返回一个值并且没有副作用。
    将这样的函数作为函数调用语句中的唯一内容调用通常是编程缺陷。
    具有这些属性的内置函数被声明为 `@ must_use`。
    用户定义的函数也可以具有 `@ must_use` 属性。

    注意：为了刻意规避 `@ must_use` 规则，使用[=phony assignment=]或使用函数调用作为初始化器[=value declaration|声明一个值=]。

<tr><td><dfn noexport dfn-for="attribute">size</dfn>
<td>[=shader-creation error|必须]为一个将解析为[=i32=]或[=u32=]的[=const-expression=]。<br>
[=shader-creation error|必须]为正数。
<td>[=shader-creation error|必须]仅应用于[=structure=]类型的成员。
成员类型[=shader-creation error|必须]具有[=creation-fixed footprint=]。


在结构体中为此成员保留的字节数。

此数值[=shader-creation error|必须]至少为成员类型的[=byte-size=]：
<p algorithm="byte-size constraint">
如果将 `size( `|n|` )` 应用于类型为|T|的成员，则[=SizeOf=](|T|)&nbsp;&leq;&nbsp;|n|。
</p>

参见[[#memory-layouts]]

<tr><td><dfn noexport dfn-for="attribute">workgroup_size</dfn>
<td>一个、两个或三个参数。


每个参数[=shader-creation error|必须]是一个[=const-expression=]或[=override-expression=]。
所有参数[=shader-creation error|必须]为相同的类型，要么是[=i32=]，要么是[=u32=]。

如果任何指定的参数是[=const-expression=]，且其计算结果为非正数值，则会产生[=shader-creation error=]。

如果任何指定的参数计算结果为非正数值，或超过WebGPU API指定的上限，或者参数值的乘积超过WebGPU API指定的上限，则会产生[=pipeline-creation error=]（参见[[WebGPU#limits]]）。
<td>[=shader-creation error|必须]应用于[=compute shader stage|compute shader=]的入口点函数。
不得应用于任何其他对象。

指定计算着色器的[=workgroup grid=]的x、y和z维度。

第一个参数指定了x维度。
如果提供了第二个参数，则指定了y维度；否则假定为1。
如果提供了第三个参数，则指定了z维度；否则假定为1。

</table>

以下的<dfn noexport>Shader阶段属性</dfn>将一个函数指定为特定Shader阶段的[=入口点=]。
这些属性[=着色器创建错误|必须=]只能应用于 [=函数声明=]，且一个函数上最多只能有一个该属性。
它们不带参数。

<table class=‘data’>
<caption>着色器阶段属性</caption>
<thead>
<tr><th>属性<th>描述
</thead>


<tr><td><dfn noexport dfn-for="attribute">vertex</dfn><br>
<td>声明该函数为[顶点着色器阶段]的入口点。


<tr><td><dfn noexport dfn-for="attribute">fragment</dfn><br>
<td>声明该函数为[片段着色器阶段]的入口点。


<tr><td><dfn noexport dfn-for="attribute">compute</dfn><br>
<td>声明该函数为[计算着色器阶段]的入口点。


</table>

<pre class=include>
path: syntax/attribute.syntax.bs.include
</pre>
<pre class=include>
path: syntax/attrib_end.syntax.bs.include
</pre>
<pre class=include>
path: syntax/diagnostic_control.syntax.bs.include
</pre>

# 入口点 # {#entry-points}

一个"入口点"是一个由用户定义的函数，它执行特定着色器阶段的工作。

## 着色器阶段 ## {#shader-stages-sec}

WebGPU将工作以绘画命令或调度命令的形式发送给GPU。这些命令在一组着色器阶段的上下文中执行管线，包括着色器阶段的输入、输出和附加资源。


<dfn noexport>管线（Pipeline）</dfn>描述了在GPU上执行的工作，作为一系列阶段的顺序，其中一些是可编程的。在WebGPU中，在调度绘画或调度命令之前创建管线进行执行。有两种类型的管线：GPUComputePipeline和GPURenderPipeline。


<dfn noexport>调度命令（Dispatch Command）</dfn>使用<dfn noexport>GPUComputePipeline</dfn>在一个逻辑点网格上运行一个可控并行度的<dfn noexport>计算着色器阶段</dfn>，同时读取和可能更新缓冲区和图像资源。


<dfn noexport>绘画命令（Draw Command）</dfn>使用<dfn noexport>GPURenderPipeline</dfn>运行一个多阶段过程，其中包括两个可编程阶段和其他固定功能阶段：

* 顶点着色器阶段（vertex shader stage）将一个顶点的输入属性映射为该顶点的输出属性。
* 固定功能阶段将顶点映射为图形基元（例如三角形），然后对其进行光栅化以产生片段。
* 片段着色器阶段（fragment shader stage）处理每个片段，并可能产生片段输出。
* 固定功能阶段消耗片段输出，可能更新外部状态，例如颜色附件和深度和模板缓冲区。

WebGPU规范更详细地描述了管线。


WGSL定义了三个<dfn noexport>着色器阶段</dfn>，对应于管线的可编程部分：

* <dfn noexport>计算</dfn>
* <dfn noexport>顶点</dfn>
* <dfn noexport>片元</dfn>

每个着色器阶段都有自己的功能和限制，这些在其他地方进行了描述。

## 入口点声明 ## {#entry-point-decl}

创建入口点时，需要使用着色器阶段属性声明自定义函数。


在WebGPU API中配置管道时，入口点函数的名称映射到WebGPU GPUProgrammableStage对象的entryPoint属性。


入口点的形式参数表示阶段的着色器阶段输入。如果指定了入口点的返回值，则表示阶段的着色器阶段输出。


每个形式参数的类型，以及入口点的返回类型，必须是以下之一：
* bool
* 数值标量
* 数值向量
* 结构，其成员类型可以是bool、数值标量或数值向量。

结构类型可用于将用户自定义输入数据与其他数据和可选的内置输入值分组。结构类型也可作为返回类型，用于将用户自定义输出数据与其他数据和可选的内置输出值分组。


注意：用户自定义输入和输出不允许使用bool类型。bool类型仅允许用于内置值（如front_facing）。


注意：计算的入口点永远不具有返回类型。

<div class='example wgsl global-scope' heading='Entry Point'>
  <xmp>
    @vertex
    fn vert_main() -> @builtin(position) vec4<f32> {
      return vec4<f32>(0.0, 0.0, 0.0, 1.0);
    }

    @fragment
    fn frag_main(@builtin(position) coord_in: vec4<f32>) -> @location(0) vec4<f32> {
      return vec4<f32>(coord_in.x, coord_in.y, 0.0, 1.0);
    }

    @compute @workgroup_size(1)
    fn comp_main() { }
  </xmp>
</div>

着色器阶段中的<dfn noexport>函数集</dfn>是以下的并集：

* 阶段的入口点函数。
* 非论此调用是否被执行，在着色器阶段内的函数体内被调用的函数的目标。

这个并集会不断重复应用，直到达到稳定状态为止。
它将在有限的步骤内达到稳定状态。

### 入口点的功能属性 ### {#entry-point-attributes}

WGSL定义了可以应用于入口点声明的以下属性：
* [=shader stage attributes=]：[=attribute/vertex=]、[=attribute/fragment=]和[=attribute/compute=]
* [=attribute/workgroup_size=]

<div class='example wgsl global-scope' heading='workgroup_size Attribute'>
  <xmp>
    @compute @workgroup_size(8,4,1)
    fn sorter() { }

    @compute @workgroup_size(8u)
    fn reverser() { }

    // Using an pipeline-overridable constant.
    @id(42) override block_width = 12u;
    @compute @workgroup_size(block_width)
    fn shuffler() { }

    // Error: workgroup_size must be specified on compute shader
    @compute
    fn bad_shader() { }
  </xmp>
</div>

## Shader接口 ## {#shader-interface}

着色器接口是着色器访问外部数据的一组对象，这些数据可以用于读取或写入，并用于配置着色器的管线可重写常量。接口包括：
* 着色器阶段输入
* 着色器阶段输出
* 覆盖声明
* 附加资源，包括：
    * 统一缓冲区
    * 存储缓冲区
    * 纹理资源
    * 采样器资源

当以下情况发生时，声明D将被着色器进行<dfn>静态访问</dfn>：
* 任何着色器阶段函数的函数声明中的标识符解析为D。
* 用于定义[静态访问]声明的类型的标识符解析为D。
* 在[静态访问]声明的初始化器中使用解析为D的标识符。
* [静态访问]声明使用的属性由解析为D的属性使用。

<div class="note"><span class=marker>注意：</span>静态访问是递归定义的，考虑以下内容：
* 函数声明的所有部分，包括属性、形式参数、返回类型和函数体。
* 定义上述内容所需的任何类型，包括以下类型别名。
* 作为帮助定义类型的一个特例，静态访问的变量在地址空间/工作组地址空间中的数组类型的[元素数量]由用于[元素数量]的[覆盖声明]使用， 当变量本身是静态访问的时候。
* 用于支持上述任何内容中覆盖表达式求值的覆盖声明。
* 用于上述任何内容中的任何属性。 </div>

我们现在可以精确地定义着色器的接口，其中包括：
- 着色器入口的形式参数。这些表示着色器阶段的输入。
- 入口点的返回值。这表示着色器阶段的输出。
- 着色器静态访问的统一缓冲区、存储缓冲区、纹理资源和采样器资源变量。
- 着色器静态访问的覆盖声明。

### 跨阶段输入和输出接口 ### {#stage-inputs-outputs}
一个着色器阶段输入是从管线上游提供给着色器阶段的数据。
每个数据可以是内置输入值或用户定义的输入数据。


一个着色器阶段输出是着色器提供给下游进一步处理的数据。
每个数据可以是内置输出值或用户定义的输出数据。


IO属性用于将对象标识为着色器阶段输入或着色器阶段输出，或者进一步描述输入或输出的属性。
IO属性包括：
* [=attribute/builtin=]
* [=attribute/location=]
* [=attribute/interpolate=]
* [=attribute/invariant=]

#### 内置输入和输出 #### {#builtin-inputs-outputs}

内建输入值提供对系统生成的控制信息的访问。
入口点不得包含重复的内建输入。


对于阶段S的名称为X和类型为T<sub>X</sub>的内建输入，可以通过以下两种方式之一在对于着色器阶段S的入口点的形式参数中进行访问：


参数具有属性builtin(X)并且类型为T<sub>X</sub>。
参数具有结构类型，在结构成员中之一具有属性builtin(X)并且类型为T<sub>X</sub>。

相反，当入口点的参数或参数的成员具有=attribute/builtin=属性时，相应的内建着色器创建错误就必须成为入口点的着色器阶段的输入。


内建输出值由着色器用于向管线中的后续处理步骤传递控制信息。
入口点不得包含重复的内建输出。


对于阶段S的名称为Y和类型为T<sub>Y</sub>的内建输出，可以通过以下两种方式之一设置在对于着色器阶段S的入口点的返回值中：


入口点的返回类型具有属性builtin(Y)并且类型为T<sub>Y</sub>。
入口点的返回类型具有结构类型，在结构成员中之一具有属性builtin(Y)并且类型为T<sub>Y</sub>。

相反，当入口点的返回类型或返回类型的成员具有=attribute/builtin=属性时，相应的内建着色器创建错误就必须成为入口点的着色器阶段的输出。


注意：内建值=built-in values/position=既是顶点着色器的输出，也是片段着色器的输入。


总体而言，内建输入和内建输出值被统称为内建值。


下表总结了可用的内建值。
每个内建值都是预定义的枚举值。
每个内建值在后续章节中详细描述。

<table class='data'>
  <caption>Built-in input and output values</caption>
  <thead>
    <tr><th>Predeclared Name<th>Stage<th>Direction<th>Type
  </thead>

  <tr><td>[=built-in values/vertex_index=]
      <td>vertex
      <td>input
      <td>u32

  <tr><td>[=built-in values/instance_index=]
      <td>vertex
      <td>input
      <td>u32

  <tr><td rowspan=2>[=built-in values/position=]
      <td>vertex
      <td>output
      <td>vec4&lt;f32&gt;

  <tr>
      <td>fragment
      <td>input
      <td>vec4&lt;f32&gt;

  <tr><td>[=built-in values/front_facing=]
      <td>fragment
      <td>input
      <td>bool

  <tr><td>[=built-in values/frag_depth=]
      <td>fragment
      <td>output
      <td>f32

  <tr><td>[=built-in values/sample_index=]
      <td>fragment
      <td>input
      <td>u32

  <tr><td rowspan=2>[=built-in values/sample_mask=]
      <td>fragment
      <td>input
      <td>u32

  <tr>
      <td>fragment
      <td>output
      <td>u32

  <tr><td>[=built-in values/local_invocation_id=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;

  <tr><td>[=built-in values/local_invocation_index=]
      <td>compute
      <td>input
      <td>u32

  <tr><td>[=built-in values/global_invocation_id=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;

  <tr><td>[=built-in values/workgroup_id=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;

  <tr><td>[=built-in values/num_workgroups=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
</table>

<div class='example wgsl global-scope' heading="Declaring built-in values">
  <xmp>
    struct VertexOutput {
      @builtin(position) my_pos: vec4<f32>
    }

    @vertex
    fn vs_main(
      @builtin(vertex_index) my_index: u32,
      @builtin(instance_index) my_inst_index: u32,
    ) -> VertexOutput {}

    struct FragmentOutput {
      @builtin(frag_depth) depth: f32,
      @builtin(sample_mask) mask_out: u32
    }

    @fragment
    fn fs_main(
      @builtin(front_facing) is_front: bool,
      @builtin(position) coord: vec4<f32>,
      @builtin(sample_index) my_sample_index: u32,
      @builtin(sample_mask) mask_in: u32,
    ) -> FragmentOutput {}

    @compute @workgroup_size(64)
    fn cs_main(
      @builtin(local_invocation_id) local_id: vec3<u32>,
      @builtin(local_invocation_index) local_index: u32,
      @builtin(global_invocation_id) global_id: vec3<u32>,
   ) {}
  </xmp>
</div>

##### `frag_depth` ##### {#frag-depth-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">frag_depth</dfn>
<tr><td style="width:10%">阶段
<td>[=fragment shader stage|片段=]
<tr><td style="width:10%">类型
<td>f32
<tr><td style="width:10%">方向
<td>输出
<tr><td style="width:10%">描述
<td>
视口深度范围内片段的更新深度。


  详见[[WebGPU#coordinate-systems]]。

</table>

##### `front_facing` ##### {#front-facing-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">front_facing</dfn>
<tr><td style="width:10%">阶段
<td>[=片段着色器阶段|片段=]
<tr><td style="width:10%">类型
<td>布尔型
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
当前片段位于[=面向前方=]的基元上时为真。
否则为假。
</table>

##### `global_invocation_id` ##### {#global-invocation-id-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">global_invocation_id</dfn>
<tr><td style="width:10%">阶段
<td>[=计算着色器阶段|计算着色器=]
<tr><td style="width:10%">类型
<td>vec3<u32>
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
当前调用的[=全局调用ID=]，即其在[=计算着色器网格=]中的位置。[=内置值/global_invocation_id=]的值等于[=内置值/workgroup_id=] * [=属性/workgroup_size=] + [=内置值/local_invocation_id=]。
</table>

##### `instance_index` ##### {#instance-index-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">instance_index</dfn>
<tr><td style="width:10%">阶段
<td>[=vertex shader stage|vertex=]
<tr><td style="width:10%">类型
<td>u32
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
当前顶点在当前API级别的绘制命令中的实例索引。


  第一个实例的索引等于绘制命令中的 `firstInstance` 参数，无论是直接提供还是间接提供。
  每增加一个实例，索引就会增加一。 

</table>

##### `local_invocation_id` ##### {#local-invocation-id-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">local_invocation_id</dfn>
<tr><td style="width:10%">阶段
<td>[=计算着色器阶段|计算=]
<tr><td style="width:10%">类型
<td>vec3<u32>
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
当前调用的[=local invocation ID=]，即其在[=workgroup grid=]中的位置。
</table>

##### `local_invocation_index` ##### {#local-invocation-index-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">local_invocation_index</dfn>
<tr><td style="width:10%">阶段
<td>[=计算着色器阶段|compute=]
<tr><td style="width:10%">类型
<td>u32（32位无符号整数）
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
当前调用的[=本地调用索引=]，是调用在[=工作组网格=]内的位置的线性索引。
</table>

##### `num_workgroups` ##### {#num-workgroups-index-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">num_workgroups</dfn>
<tr><td style="width:10%">阶段
<td>[=计算着色器|计算=]
<tr><td style="width:10%">类型
<td>vec3<u32>
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
由API发送的计算着色器 WebGPU#计算通道编码器调度|调度 的[=调度大小=]，即 vec3<u32>(group_count_x, group_count_y,       group_count_z)。
</table>

##### `position` ##### {#position-builtin-value}

<table class='data'>
  <tr><td style="width:10%">名称
      <td><dfn noexport dfn-for="内置值">position</dfn>
  <tr><td style="width:10%">阶段
      <td>[=顶点着色器阶段|顶点=]
  <tr><td style="width:10%">类型
      <td>vec4&lt;f32&gt;
  <tr><td style="width:10%">方向
      <td>输出
  <tr><td style="width:10%">描述
      <td>
      当前顶点的[=剪裁位置=]，
      使用[=剪裁空间坐标=]表示。

      一个输出值（*x*，*y*，*z*，*w*）
      [=行为要求|会=]映射到WebGPU的[=标准设备坐标=]中的（*x*/*w*，*y*/*w*，*z*/*w*）。
      
      参见WebGPU#坐标系统和WebGPU#基本剪裁。
</table>

<table class='data'>
  <tr><td style="width:10%">名称
      <td>position
  <tr><td style="width:10%">阶段
      <td>[=片段着色器阶段|片段=]
  <tr><td style="width:10%">类型
      <td>vec4&lt;f32&gt;
  <tr><td style="width:10%">方向
      <td>输入
  <tr><td style="width:10%">描述
      <td>
      <div algorithm="片段位置计算">
      当前片段的输入位置。

      令|fp|为片段的输入位置。<br>
      令|rp|为片段的[=光栅化点=]。<br>
      令|vp|为绘制命令生效中的{{RenderState/[[viewport]]}}。

      然后如图所示：
      <blockquote>
      |fp|.xy = |rp|.[=光栅化点目标|目标=].[=片段目标位置|位置=]<br>
      |fp|.z = |rp|.[=光栅化点深度|深度=]<br>
      |fp|.w = |rp|.[=光栅化点透视除法因子|透视除法因子=]
      </blockquote>

      更详细地：
      * |fp|.x和|fp|.y是当前片段在[=帧缓冲区=]中的插值x和y坐标。

          帧缓冲区是一个二维像素网格，左上角为(0.0,0.0)，
          右下角为(|vp|.width, |vp|.height)。
          每个像素在x和y方向上都有1.0单位的范围，
          像素中心偏离整数坐标的(0.5,0.5)。

      * |fp|.z是当前片段的插值深度。
          例如：
          * 在[=标准设备坐标=]中深度为0映射到|fp|.z = |vp|.minDepth，
          * 在标准设备坐标中深度为1映射到|fp|.z = |vp|.maxDepth。

      * |fp|.w是片段的透视除数，
          即对顶点着色器的[=内置值/position=]输出的w分量的插值结果，表示为1.0 &divide; |vertex_w|。

      参见WebGPU#坐标系统和WebGPU#光栅化。
      </div>
</table>

##### `sample_index` ##### {#sample-index-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">sample_index</dfn>
<tr><td style="width:10%">阶段
<td>[=片段着色器阶段|片段=]
<tr><td style="width:10%">类型
<td>u32
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
当前片段的采样索引。该值的范围从0到 sampleCount-1，其中 sampleCount 是 GPU 渲染管线指定的 MSAA 样本数量。


  请参阅 [[WebGPU#gpurenderpipeline]]。

</table>

##### `sample_mask` ##### {#sample-mask-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">sample_mask</dfn>
<tr><td style="width:10%">阶段
<td>[=片段着色器阶段|片段=]
<tr><td style="width:10%">类型
<td>u32
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
当前片段的样本覆盖掩码。它包含一个位掩码，表示渲染的基元在此片段中覆盖的样本。


  参见[[WebGPU#sample-masking]]。

</table>


<table class=‘data’>
<tr><td style="width:10%">名称
<td>sample_mask
<tr><td style="width:10%">阶段
<td>[=片段着色器阶段|片段=]
<tr><td style="width:10%">类型
<td>u32
<tr><td style="width:10%">方向
<td>输出
<tr><td style="width:10%">描述
<td>
当前片段的样本覆盖掩码控制。对该变量写入的最后一个值将成为[=着色器输出掩码=]。写入值中的零位将导致相应颜色附件中的样本被丢弃。


  参见[[WebGPU#sample-masking]]。

</table>

##### `vertex_index` ##### {#vertex-index-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">vertex_index</dfn>
<tr><td style="width:10%">阶段
<td>[=顶点着色器阶段|顶点=]
<tr><td style="width:10%">类型
<td>u32
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
当前顶点在当前API级别绘制命令中的索引，独立于绘制实例化。


  对于非索引绘制，第一个顶点的索引等于绘制命令中的 `firstVertex` 参数，无论是直接提供还是间接提供。
  对于绘制实例中的每个额外顶点，索引增加一。

  对于索引绘制，索引等于顶点的索引缓冲区条目加上绘制命令中的 `baseVertex` 参数，无论是直接提供还是间接提供。

</table>

##### `workgroup_id` ##### {#workgroup-id-builtin-value}

<table class=‘data’>
<tr><td style="width:10%">名称
<td><dfn noexport dfn-for="built-in values">workgroup_id</dfn>
<tr><td style="width:10%">阶段
<td>[=计算着色器阶段|compute=]
<tr><td style="width:10%">类型
<td>vec3<u32>
<tr><td style="width:10%">方向
<td>输入
<tr><td style="width:10%">描述
<td>
当前执行的工作组ID，即在整个计算着色器网格中的工作组位置。


  同一工作组中的所有执行任务具有相同的工作组ID。

  工作组ID从(0,0,0)到([=group_count_x=] - 1,
  [=group_count_y=] - 1, [=group_count_z=] - 1)。

</table>

#### 用户定义的输入和输出 #### {#user-defined-inputs-outputs}

用户定义的数据可以作为管道的输入传递给管道的起始点，也可以在管道的各个阶段之间传递，或者作为管道的输出从管道的末端输出。


每个用户定义的输入数据和用户定义的输出数据必须满足以下要求：
* 是数字标量类型或数字向量类型；
* 指定了输入/输出位置。参见[[#input-output-locations]]。

计算着色器不允许有用户定义的输入或输出。

#### 输入输出位置 #### {#input-output-locations}

每个输入输出位置可以存储最多16字节的值。
类型的字节数是使用[[#alignment-and-size]]中的SizeOf列来定义的。
例如，四分量浮点向量占据一个位置。


IO位置是通过[=attribute/location=]属性来指定的。


每个用户定义的[=user-defined input datum|input=]和[=user-defined output datum|output=]在创建着色器时必须有明确指定的IO位置。
入口点IO中的每个结构成员都[=shader-creation error|必须=]是内置值之一
（参见[[#builtin-inputs-outputs]]），或者被分配一个位置。


以下每组中的位置[=shader-creation error|不能=]重叠：
* 结构类型中的成员。 这适用于任何结构，不仅仅是用于着色器阶段输入或输出的结构。
* 入口点的着色器阶段输入， 即其形式参数的位置，或者结构类型形式参数的成员的位置。

注意：输入和输出之间的位置编号是不同的：
入口点的着色器阶段输入的位置编号与入口点的着色器阶段输出的位置编号不冲突。


注意：在入口点的输出中不需要其他规则来防止位置重叠。
当输出是一个结构时，上述第一个规则防止了重叠。
否则，输出是一个标量或向量，只能为其分配一个位置。


注意：入口点的可用位置数量由WebGPU API来定义。

<div class='example wgsl applying location attribute' heading='Applying location attributes'>
  <xmp>
    struct A {
      @location(0) x: f32,
      // Despite locations being 16-bytes, x and y cannot share a location
      @location(1) y: f32
    }

    // in1 occupies locations 0 and 1.
    // in2 occupies location 2.
    // The return value occupies location 0.
    @fragment
    fn fragShader(in1: A, @location(2) in2: f32) -> @location(0) vec4<f32> {
     // ...
    }
  </xmp>
</div>

用户定义的IO可以与内置值混合在同一个结构中使用。例如，

<div class='example wgsl mixing builtins and user-defined IO' heading='Mixing builtins and user-defined IO'>
  <xmp>
    // Mixed builtins and user-defined inputs.
    struct MyInputs {
      @location(0) x: vec4<f32>,
      @builtin(front_facing) y: bool,
      @location(1) @interpolate(flat) z: u32
    }

    struct MyOutputs {
      @builtin(frag_depth) x: f32,
      @location(0) y: vec4<f32>
    }

    @fragment
    fn fragShader(in1: MyInputs) -> MyOutputs {
      // ...
    }
  </xmp>
</div>

<div class='example wgsl invalid locations' heading='Invalid location assignments'>
  <xmp>
    struct A {
      @location(0) x: f32,
      // Invalid, x and y cannot share a location.
      @location(0) y: f32
    }

    struct B {
      @location(0) x: f32
    }

    struct C {
      // Invalid, structures with user-defined IO cannot be nested.
      b: B
    }

    struct D {
      x: vec4<f32>
    }

    @fragment
    // Invalid, location cannot be applied to a structure type.
    fn fragShader1(@location(0) in1: D) {
      // ...
    }

    @fragment
    // Invalid, in1 and in2 cannot share a location.
    fn fragShader2(@location(0) in1: f32, @location(0) in2: f32) {
      // ...
    }

    @fragment
    // Invalid, location cannot be applied to a structure.
    fn fragShader3(@location(0) in1: vec4<f32>) -> @location(0) D {
      // ...
    }
  </xmp>
</div>

#### 插值 #### {#interpolation}
作者可以通过使用[=attribute/interpolate=]属性来控制用户定义的IO数据的插值方式。
WGSL提供了两个方面的插值控制：插值类型和插值采样。

[=shader-creation error|插值类型=]必须是以下[=predeclared=]枚举常量之一：
: <dfn for="interpolation type">perspective</dfn>
:: 按透视纠正的方式插值数值。
: <dfn for="interpolation type">linear</dfn>
:: 按线性非透视纠正的方式插值数值。
: <dfn for="interpolation type">flat</dfn>
:: 不进行插值。 不使用插值采样时选择flat插值方式。

[=shader-creation error|插值采样=]必须是以下[=predeclared=]枚举常量之一：
: <dfn for="interpolation sampling">center</dfn>
:: 在像素中心进行插值。
: <dfn for="interpolation sampling">centroid</dfn>
:: 在当前图元覆盖的所有片段的内部点进行插值。 这个值在图元的所有片段中都是相同的。
: <dfn for="interpolation sampling">sample</dfn>
:: 对每个采样点进行插值。 应用该属性时，[=fragment=]着色器会对每个采样点调用一次。

对于标量或矢量浮点类型的用户定义IO数据：
* 如果未指定插值属性，则默认为@interpolate(perspective, center)。
* 如果指定了插值属性和插值类型：
    * 如果插值类型是flat，则不能指定插值采样。
    * 如果插值类型是perspective或linear，则：
        * 可以使用任何插值采样。
        * 如果未指定插值采样，则默认为center。

标量或矢量整数类型的用户定义顶点输出和片段输入[=shader-creation error|必须=]指定为@interpolate(flat)。


相同的[=attribute/location=]分配在同一个[=pipeline=]中的顶点输出和片段输入之间的插值属性[=shader-creation error|必须=]匹配。


### 资源接口 ### {#resource-interface}

<dfn noexport>资源</dfn>是一个对象，它提供对外部数据的访问，不是一个覆盖声明，也不是一个着色器阶段的输入或输出。资源被所有着色器的调用共享。


资源分为四种类型：
* 统一缓冲区（Uniform buffers）
* 存储缓冲区（Storage buffers）
* 纹理资源（Texture resources）
* 采样器资源（Sampler resources）

<dfn noexport>着色器的资源接口</dfn>是一组在着色器阶段中在模块范围内通过函数静态访问的资源变量。


每个资源变量都必须使用 [=attribute/group=] 和 [=attribute/binding=] 属性进行声明。加上着色器的阶段信息，这些属性可以确定资源在着色器管线上的绑定地址。详见 [[WebGPU#gpupipelinelayout]]。


作为一对考虑时，两个不同的资源变量在一个着色器中的 [=attribute/group=] 和 [=attribute/binding=] 值不能相同。

### 资源布局兼容性 ### {#resource-layout-compatibility}

WebGPU要求着色器的资源接口与使用该着色器的管线的布局相匹配。

如果资源接口中的WGSL变量与不兼容的WebGPU绑定资源类型或绑定类型绑定，就会出现"创建管线错误"，其兼容性由以下表格定义。

<table class='data'>
  <caption>WebGPU binding type compatibility</caption>
  <thead>
    <tr><th>WGSL resource
        <th>WebGPU<br>[=binding resource type|resource type=]
        <th>WebGPU [=binding member=]
        <th colspan=2>WebGPU [=binding type=]
  </thead>
  <tr><td>[=uniform buffer=]
      <td rowspan=3>{{GPUBufferBinding}}
      <td rowspan=3>{{GPUBindGroupLayoutEntry/buffer}}
      <td rowspan=3>GPUBufferBindingType
      <td>{{GPUBufferBindingType/"uniform"}}
  <tr><td>[=storage buffer=] with [=access/read_write=] access
      <td>{{GPUBufferBindingType/"storage"}}
  <tr><td>[=storage buffer=] with [=access/read=] access
      <td>{{GPUBufferBindingType/"read-only-storage"}}
  <tr><td rowspan=2>[=type/sampler=]
      <td rowspan=3>{{GPUSampler}}
      <td rowspan=3>{{GPUBindGroupLayoutEntry/sampler}}
      <td rowspan=3>GPUSamplerBindingType
      <td>{{GPUSamplerBindingType/"filtering"}}
  <tr>
      <td>{{GPUSamplerBindingType/"non-filtering"}}
  <tr><td>[=type/sampler_comparison=]
      <td>{{GPUSamplerBindingType/"comparison"}}
  <tr><td rowspan=5>[=type/sampled texture=],
                    [=type/depth texture=], or
                    [=type/multisampled texture=]
      <td rowspan=5>{{GPUTextureView}}
      <td rowspan=5>{{GPUBindGroupLayoutEntry/texture}}
      <td rowspan=5>GPUTextureSampleType
      <td>{{GPUTextureSampleType/"float"}}
  <tr>
      <td>{{GPUTextureSampleType/"unfilterable-float"}}
  <tr>
      <td>{{GPUTextureSampleType/"sint"}}
  <tr>
      <td>{{GPUTextureSampleType/"uint"}}
  <tr>
      <td>{{GPUTextureSampleType/"depth"}}
  <tr><td>[=type/write-only storage texture=]
      <td rowspan=3>{{GPUTextureView}}
      <td rowspan=3>{{GPUBindGroupLayoutEntry/storageTexture}}
      <td rowspan=3>{{GPUStorageTextureAccess}}
      <td>{{GPUStorageTextureAccess/"write-only"}}
  <tr><td>[=type/read-write storage texture=]
      <td>{{GPUStorageTextureAccess/"read-write"}}
  <tr><td>[=type/read-only storage texture=]
      <td>{{GPUStorageTextureAccess/"read-only"}}
  <tr><td>[=type/external texture=]
      <td>{{GPUExternalTexture}}
      <td>{{GPUBindGroupLayoutEntry/externalTexture}}
      <td colspan=2>(not applicable)
</table>

请参阅[$validating GPUProgrammableStage|WebGPU API$]规范以了解接口验证要求。

### 缓冲绑定确定运行时大小的数组元素数量 ### {#buffer-binding-determines-runtime-sized-array-element-count}

当一个存储缓冲变量包含一个运行时大小的数组时，那么该数组中的元素数量由对应的GPUBufferBinding的大小决定：

运行时大小数组的元素数量（NRuntime）如下计算：
* 假设T是存储缓冲变量的存储类型，T是一个运行时大小的数组类型或包含一个运行时大小的数组类型。
* 假设EBS是绑定到存储缓冲变量对应的管道绑定地址的GPUBufferBinding的有效缓冲大小。
* 那么NRuntime，即运行时大小数组的元素数量，是满足 SizeOf(T) ≤ EBS 的最大整数。

更详细地说，对于类型为RAT的运行时大小数组，NRuntime的计算如下：
NRuntime = truncate((EBBS - array_offset) / array_stride)，其中：
* EBBS是与变量相关联的有效缓冲绑定大小。
* array_offset是运行时大小数组在变量的存储类型内的字节偏移量。
    * 如果存储类型是RAT（即运行时大小数组类型本身），则array_offset为0。
    * 否则，存储类型是一个结构体，且其最后一个成员是运行时大小数组。在这种情况下，array_offset是结构体内该成员的字节偏移量。
* array_stride是数组类型的步长，即StrideOf(RAT)。

着色器可以通过[[#arrayLength-builtin|arrayLength]]内置函数计算[=NRuntime=]。

<div class=note>
<span class=marker>注：</span>
此算法是明确定义的：
当运行时大小的数组是更大类型的一部分时，它只能出现在结构体的最后一个元素中，
该结构体本身不能是包含数组或结构体的一部分。


[=NRuntime=]由相应缓冲绑定的大小决定，对于每个[=draw command|draw=]或[=dispatch command=]都可能不同。


WebGPU验证规则确保1 ≤ [=NRuntime=]。


</div>


<div class=note>
在以下代码示例中：


weights 变量是一个[=storage buffer=]。
它的存储类型是运行时大小的数组类型 array<f32>。
数组偏移量为0。
数组步长是=StrideOf=，即4。

<div class=‘example wgsl’ heading=‘简单运行时大小数组的元素数量’>
<xmp>
@group(0) @binding(1) var<storage> weights: array<f32>;
</xmp>
</div>

下表显示了基于对应有效缓冲绑定大小的weights变量的[=NRuntime=]的示例。


<table class=‘data’>
<caption>简单运行时数组元素数量示例</caption>
<thead>
<tr><th style="width:15%">有效缓冲绑定大小<th>weights变量的[=NRuntime=]<td>计算
</thead>
<tr><td>1024<td>256<td>[=truncate=]( 1024 ÷ 4 )
<tr><td>1025<td>256<td>[=truncate=]( 1025 ÷ 4 )
<tr><td>1026<td>256<td>[=truncate=]( 1026 ÷ 4 )
<tr><td>1027<td>256<td>[=truncate=]( 1027 ÷ 4 )
<tr><td>1028<td>257<td>[=truncate=]( 1028 ÷ 4 )
</table>
</div>

<div class=note>
在下面的代码示例中：
* lights 变量是一个存储缓冲区。
* 它的存储类型是 LightStorage。
* LightStorage 的 point 成员是一个运行时大小的 array<PointLight> 类型的数组。
    * 该成员在变量的存储中的字节偏移量为16。
    * 数组的步幅是 StrideOf(array<PointLight>) = roundUp(AlignOf(PointLight),SizeOf(PointLight)) = roundUp(16,32) = 32。

<div class='example wgsl' heading='number of elements in a complex runtime sized array'>
  <xmp>
struct PointLight {                          //             align(16) size(32)
  position : vec3f,                          // offset(0)   align(16) size(12)
  // -- implicit member alignment padding -- // offset(12)            size(4)
  color : vec3f,                             // offset(16)  align(16) size(12)
  // -- implicit struct size padding --      // offset(28)            size(4)
}

struct LightStorage {                        //             align(16)
  pointCount : u32,                          // offset(0)   align(4)  size(4)
  // -- implicit member alignment padding -- // offset(4)             size(12)
  point : array<PointLight>,                 // offset(16)  align(16) elementsize(32)
}

@group(0) @binding(1) var<storage> lights : LightStorage;
  </xmp>
</div>

以下表格显示了"lights"变量的"point"成员的[=NRuntime=]示例。

<table class=‘data’>
<caption>复杂运行时大小数组元素示例数量</caption>
<thead>
<tr><th style="width:15%">有效缓冲绑定大小<th>lights变量的point成员的运行时<td>计算
</thead>
<tr><td>1024<td>31<td>[=截断=]( ( 1024 - 16 ) ÷ 32) )
<tr><td>1025<td>31<td>[=截断=]( ( 1025 - 16 ) ÷ 32) )
<tr><td>1039<td>31<td>[=截断=]( ( 1039 - 16 ) ÷ 32) )
<tr><td>1040<td>32<td>[=截断=]( ( 1040 - 16 ) ÷ 32) )
</thead>
</table>
</div>

# 内存 # {#memory}

在WGSL中，存储类型的值可以存储在内存中，供以后检索使用。
本节描述了内存的结构以及访问内存的操作语义。
请参阅[[#memory-views]]获取可存储在内存中的值的类型和用于执行内存访问的类型。

## 内存位置 ## {#memory-locations-section}

内存由一组不同的内存位置组成。
每个内存位置的大小为8个比特。
影响内存的操作与一组或多个内存位置交互。
对复合行为要求的内存操作不会访问填充内存位置。
因此，操作访问的内存位置集合可能不连续。


如果两组内存位置的交集非空，则它们的内存位置集合重叠。

## 内存访问模式 ## {#memory-access-mode}

内存访问是对内存位置进行操作的过程。

* 读取访问观察内存位置的内容。
* 写入访问设置内存位置的内容。

单个操作可以进行读取、写入或同时读取和写入。


特定的内存位置可能仅支持某些特定类型的访问，以内存的访问模式表示。

<table class='data'>
  <caption>Access Modes</caption>
  <thead>
    <tr><th>Access mode
        <th>Supported accesses
  </thead>
  <tr><td><dfn noexport dfn-for="access">read</dfn>
      <td>Supports read accesses, but not writes.
  <tr><td><dfn noexport dfn-for="access">write</dfn>
      <td>Supports write accesses, but not reads.
  <tr><td><dfn noexport dfn-for="access">read_write</dfn>
      <td>Supports both read and write accesses.
</table>

WGSL [=predeclared|predeclares=] the [=enumerants=] read, write, and read_write.

WGSL预先声明了read、write和read_write这些枚举值。

## 地址空间 ## {#address-space}

内存位置被分为地址空间。每个地址空间具有独特的属性，决定了可变性、可见性、可能包含的值以及如何与变量一起使用。有关详细信息，请参阅[[#var-and-value]]。


给定的[=memory view=]的访问模式通常由上下文确定：


地址空间支持[=access/read=]和[=access/read_write=]两种访问模式。
其他地址空间仅支持一种访问模式。
每个地址空间的默认访问模式在下表中描述。

<table class='data'>
  <caption>Address Spaces</caption>
  <thead>
    <tr><th>Address space
        <th>Sharing among invocations
        <th>Default access mode
        <th>Notes
  </thead>
  <tr><td><dfn noexport dfn-for="address spaces">function</dfn>
      <td>Same invocation only
      <td>[=access/read_write=]
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">private</dfn>
      <td>Same invocation only
      <td>[=access/read_write=]
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">workgroup</dfn>
      <td>Invocations in the same [=compute shader stage|compute shader=] [=compute shader stage/workgroup=]
      <td>[=access/read_write=]
      <td>The [=element count=] of an outermost array may be a [=pipeline-overridable=] constant.
  <tr><td><dfn noexport dfn-for="address spaces">uniform</dfn>
      <td>Invocations in the same [=shader stage=]
      <td>[=access/read=]
      <td>For [=uniform buffer=] variables
  <tr><td><dfn noexport dfn-for="address spaces">storage</dfn>
      <td>Invocations in the same [=shader stage=]
      <td>[=access/read=]
      <td>For [=storage buffer=] variables
  <tr><td><dfn noexport dfn-for="address spaces">handle</dfn>
      <td>Invocations in the same shader stage
      <td>[=access/read=]
      <td>For [=sampler resource|sampler=] and [=texture resource|texture=] variables.<br>
</table>

WGSL（WebGPU着色语言）为除handle地址空间以外的每个地址空间都[预先定义或预先声明]了一个枚举值。


[地址空间/工作组]中的[变量]只能在[计算着色器阶段]中进行[静态访问]。


[地址空间/存储]中的[变量]（即存储缓冲区）只有在访问模式为[访问/读取]时，才可以由[顶点着色器阶段]进行[静态访问]。如果存储类型是[类型/存储纹理]且[访问模式]为[访问/写入]或[访问/读写]，则这些变量就无法由[顶点着色器阶段]进行[静态访问]。详见WebGPU {{GPUDevice/createBindGroupLayout()}}。


注意：每个地址空间可能具有不同的性能特征。


在WGSL源代码中编写[变量声明]或[指针类型]时：
* 对于[地址空间/存储]，访问模式是可选的，并默认为[访问/读取]。
* 对于其他地址空间，访问模式[不能写入，否则会引发着色器创建错误]。

## 内存布局 ## {#memory-layouts}

WGSL中类型的布局与[=地址空间=]无关。
严格来说，只有可以由可主机共享的缓冲区观察到该布局。
[=Uniform buffer=]和[=storage buffer=]变量用于共享在内存中以字节序列组织的大块数据。
缓冲区在CPU和GPU之间共享，或者在管线的不同着色器阶段之间共享，或者在不同管线之间共享。


因为缓冲区数据是无需重新格式化或翻译地共享的，如果缓冲区的生产者和消费者在<dfn noexport>内存布局</dfn>上不一致，将是一种[=动态错误=]，内存布局描述了缓冲区中的字节如何组织成相应的WGSL类型的值。
这些字节是相对于共同基地址的值的[=内存位置=]。


缓冲区变量的[=存储类型=]在着色器的创建时[=必须=]是[=可主机共享=]的，具有完全阐述的内存布局，如下所述。


每个缓冲区变量[=必须=]在[=地址空间/统一=]或[=地址空间/存储=]地址空间中进行声明。


类型的内存布局仅在计算以下表达式时才重要：
* 在[=地址空间/统一=]或[=地址空间/存储=]地址空间中的变量中，
* 指向[=地址空间/统一=]或[=地址空间/存储=]地址空间的指针。

8位字节是[=可主机共享=]内存的最基本单元。
本节中定义的术语表示8位字节的计数。


我们将使用以下符号：
* <dfn noexport>AlignOf</dfn>(|T|) 是可主机共享类型 |T| 的[=对齐方式=]。
* <dfn noexport>AlignOfMember</dfn>(|S|, |i|) 是可主机共享结构体 |S| 的第 |i| 个成员的对齐方式。
* <dfn noexport>SizeOf</dfn>(|T|) 是可主机共享类型 |T| 的[=字节大小=]。
* <dfn noexport>SizeOfMember</dfn>(|S|, |i|) 是可主机共享结构体 |S| 的第 |i| 个成员的大小。
* <dfn noexport>OffsetOfMember</dfn>(|S|, |i|) 是可主机共享结构体 |S| 的第 |i| 个成员相对于结构体开始位置的偏移量。
* <dfn noexport>StrideOf</dfn>(|A|) 是可主机共享数组类型 |A| 的<dfn>元素步长</dfn>，定义为从一个数组元素的起始位置到下一个元素的起始位置的字节数。 它等于数组的元素类型的大小，向上舍入到元素类型的对齐方式： <p algorithm="array element stride"> [=StrideOf=](array<|E|, |N|>) = [=roundUp=](=AlignOf=, =SizeOf=)<br> =StrideOf= = [=roundUp=](=AlignOf=, =SizeOf=) </p>

### 对齐和大小 ###  {#alignment-and-size}

每个host-shareable或fixed footprint数据类型T都有一个对齐和大小。


类型的对齐是对该类型的值可以放置在内存中的位置的约束，表示为一个整数：
类型的对齐必须可以整除该类型的值的起始内存位置的字节地址，以避免shader创建错误。
对齐使得可以使用更高效的硬件指令来访问这些值，或者满足某些地址空间的更严格硬件要求。（参见地址空间布局约束）。


注意：每个对齐值总是2的幂，通过构造而得。


类型或结构成员的字节大小是为存储该类型或结构成员的值而在host-shareable内存中保留的连续字节数。
大小可能包括类型末尾的不可寻址填充。
因此，加载和存储值时可能访问的内存位置少于该值的大小。


host-shareable类型的对齐和大小在以下表中以递归方式定义：

<table class='data'>
  <caption>
    Alignment and size for host-shareable types<br>
  </caption>
  <thead>
    <tr><th>Host-shareable type |T|
        <th>[=AlignOf=](|T|)
        <th>[=SizeOf=](|T|)
  </thead>
  <tr><td>[=i32=], [=u32=], or [=f32=]
      <td>4
      <td>4
  <tr><td>[=f16=]
      <td>2
      <td>2
  <tr><td>[=atomic type|atomic&lt;|T|&gt;=]
      <td>4
      <td>4
  <tr><td>[=vector|vec=]2&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>8
      <td>8
  <tr><td>vec2&lt;f16&gt;
      <td>4
      <td>4
  <tr><td>vec3&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>12
  <tr><td>vec3&lt;f16&gt;
      <td>8
      <td>6
  <tr><td>vec4&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>16
  <tr><td>vec4&lt;f16&gt;
      <td>8
      <td>8
  <tr><td>[=matrix|mat=]|C|x|R| (col-major)<br>
      <p class="small">(General form)</p>
      <td>[=AlignOf=](vec|R|)
      <td>[=SizeOf=](array&lt;vec|R|, |C|&gt;)
  <tr><td>mat2x2&lt;f32&gt;
      <td>8
      <td>16
  <tr><td>mat2x2&lt;f16&gt;
      <td>4
      <td>8
  <tr><td>mat3x2&lt;f32&gt;
      <td>8
      <td>24
  <tr><td>mat3x2&lt;f16&gt;
      <td>4
      <td>12
  <tr><td>mat4x2&lt;f32&gt;
      <td>8
      <td>32
  <tr><td>mat4x2&lt;f16&gt;
      <td>4
      <td>16
  <tr><td>mat2x3&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x3&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x3&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x3&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x3&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x3&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>mat2x4&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x4&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x4&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x4&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x4&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x4&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>[=structure|struct=] |S| with members M<sub>1</sub>...M<sub>N</sub>
      <td>max([=AlignOfMember=](S,1), ... , [=AlignOfMember=](S,N))<br>
      <td>[=roundUp=]([=AlignOf=](|S|), justPastLastMember)<br><br>
          where justPastLastMember = [=OffsetOfMember=](|S|,N) + [=SizeOfMember=](|S|,N)
  <tr><td>[=array=]<|E|, |N|><br>
      <td>[=AlignOf=](|E|)
      <td>|N| &times; [=roundUp=]([=AlignOf=](|E|), [=SizeOf=](|E|))
  <tr><td>array<|E|><br>
      <td>[=AlignOf=](|E|)
      <td>[=NRuntime=] &times; [=roundUp=]([=AlignOf=](|E|),[=SizeOf=](|E|))<br><br>
          where NRuntime is the runtime-determined number of elements of |T|
</table>

### 结构成员布局 ###  {#structure-member-layout}

结构体的内部布局是根据其成员的大小和对齐方式计算的。默认情况下，成员紧密地、按顺序、不重叠地排列，同时满足成员对齐要求。


可以使用布局属性来覆盖默认的内部布局，这些属性包括：
* size 属性
* align 属性

结构体类型 S 的第 i 个成员具有大小和对齐方式，分别用 SizeOfMember(S, i) 和
AlignOfMember(S, i) 表示。成员的大小和对齐方式用于计算每个成员相对于结构体起始位置的字节偏移量，参见 [[#internal-value-layout]]。

<p algorithm="structure member size">
如果 S 的第 i 个成员具有 size 属性 (attribute/size)，则 SizeOfMember(S, i) 为 k。
否则，它为成员的类型 T 的 SizeOf(T)。
</p>

<p algorithm="structure member alignment">
如果 S 的第 i 个成员具有 align 属性 (attribute/align)，则 AlignOfMember(S, i) 为 k。
否则，它为成员的类型 T 的 AlignOf(T)。
</p>

如果结构体成员具有 size 属性，其值必须至少与成员类型的大小一样大，否则将产生编译错误：

<p algorithm="member size constraint">
SizeOfMember(S, i) ≥ SizeOf(T)<br>
其中 T 是 S 的第 i 个成员的类型。
</p>


第一个结构体成员相对于结构体起始位置的偏移量始终为零：
<p algorithm="offset of first structure member">
OffsetOfMember(S, 1) = 0
</p>

每个后续的成员都位于最低的偏移量上，以满足成员类型的对齐要求，并避免与前一个成员重叠。
对于每个成员索引 i > 1：
<p algorithm="structure member offset">
  [=OffsetOfMember=](|S|, |i|) = [=roundUp=]([=AlignOfMember=](|S|, |i| ), [=OffsetOfMember=](|S|, |i|-1) + [=SizeOfMember=](|S|, |i|-1))<br>
</p>

<div class='example wgsl' heading='Layout of structures using implicit member sizes and alignments'>
  <xmp>
    struct A {                                     //             align(8)  size(24)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        x: f32                                     // offset(16)  align(4)  size(4)
        // -- implicit struct size padding --      // offset(20)            size(4)
    }

    struct B {                                     //             align(16) size(160)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(4)
        e: A,                                      // offset(40)  align(8)  size(24)
        f: vec3<f32>,                              // offset(64)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(76)            size(4)
        g: array<A, 3>,    // element stride 24       offset(80)  align(8)  size(72)
        h: i32                                     // offset(152) align(4)  size(4)
        // -- implicit struct size padding --      // offset(156)           size(4)
    }

    @group(0) @binding(0)
    var<storage,read_write> storage_buffer: B;
  </xmp>
</div>

<div class='example wgsl' heading='Layout of structures with explicit member sizes and alignments'>
  <xmp>
    struct A {                                     //             align(8)  size(32)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        @size(16) x: f32                           // offset(16)  align(4)  size(16)
    }

    struct B {                                     //             align(16) size(208)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(12)
        @align(16) e: A,                           // offset(48)  align(16) size(32)
        f: vec3<f32>,                              // offset(80)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(92)            size(4)
        g: array<A, 3>,    // element stride 32       offset(96)  align(8)  size(96)
        h: i32                                     // offset(192) align(4)  size(4)
        // -- implicit struct size padding --      // offset(196)           size(12)
    }

    @group(0) @binding(0)
    var<uniform> uniform_buffer: B;
  </xmp>
</div>

### 数组布局示例 ###  {#array-layout-examples}

<div class='example wgsl function-scope' heading='Fixed-size array layout examples'>
  <xmp>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = roundUp(4,4)
    //   - size is 32 = stride * number_of_elements = 4 * 8
    var small_stride: array<f32, 8>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    //   - size is 128 = stride * number_of_elements = 16 * 8
    var bigger_stride: array<vec3<f32>, 8>;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Runtime-sized array layout examples'>
  <xmp>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = 4
    // If B is the effective buffer binding size for the binding on the
    // draw or dispatch command, the number of elements is:
    //   N_runtime = floor(B / element stride) = floor(B / 4)
    @group(0) @binding(0)
    var<storage> weights: array<f32>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    // If B is the effective buffer binding size for the binding on the
    // draw or dispatch command, the number of elements is:
    //   N_runtime = floor(B / element stride) = floor(B / 16)
    var<storage> directions: array<vec3<f32>>;
  </xmp>
</div>

### 值的内部布局 ###  {#internal-value-layout}

本节描述了在假设整个值的放置方式的情况下，值的内部如何放置在缓冲区的字节位置上。这些布局取决于值的类型以及结构成员的[=align属性和size属性]。


值所放置的缓冲区字节偏移量必须满足类型对齐要求：如果将类型T的值放置在缓冲区偏移量k处，则k = c × AlignOf(T)，其中c为非负整数。


数据的行为要求在地址空间不同的情况下都保持相同。


当将类型为u32或i32的值V放置在主机共享缓冲区的字节偏移量k处时：
* 字节k包含V的0至7位。
* 字节k+1包含V的8至15位。
* 字节k+2包含V的16至23位。
* 字节k+3包含V的24至31位。

注意：请记住，i32使用二进制补码表示，因此符号位位于位位置31。


类型为f32的值V以IEEE-754 binary32格式表示。它有1位符号位、8位指数位和23位小数位。将V放置在主机共享缓冲区的字节偏移量k处时：
* 字节k包含小数的0至7位。
* 字节k+1包含小数的8至15位。
* 字节k+2的0至6位包含小数的16至22位。
* 字节k+2的7位包含指数的0位。
* 字节k+3的0至6位包含指数的1至7位。
* 字节k+3的7位包含符号位。

类型为f16的值V以IEEE-754 binary16格式表示。它有1位符号位、5位指数位和10位小数位。将V放置在主机共享缓冲区的字节偏移量k处时：
* 字节k包含小数的0至7位。
* 字节k+1的0至1位包含小数的8至9位。
* 字节k+1的2至6位包含指数的0至4位。
* 字节k+1的7位包含符号位。

注意：上述规则意味着主机共享缓冲区中的数值以小端格式存储。


当将类型为atomic<T>的值V放置在主机共享缓冲区时，它具有与基本类型T相同的内部布局。


当将类型为vecN<T>的值V放置在主机共享缓冲区的字节偏移量k处时：
* V.x放置在字节偏移量k处
* V.y放置在字节偏移量k + SizeOf(T)处
* 如果N ≥ 3，则V.z放置在字节偏移量k + 2 × SizeOf(T)处
* 如果N ≥ 4，则V.w放置在字节偏移量k + 3 × SizeOf(T)处

当将类型为matC x R<T>的值V放置在主机共享缓冲区的字节偏移量k处时：
* V的第i列向量放置在字节偏移量k + i × AlignOf(vecR<T>)处

当将类型为数组A的值放置在主机共享内存缓冲区的字节偏移量k处时：
* 数组的第i个元素放置在字节偏移量k + i × StrideOf(A)处

当将类型为结构体S的值放置在主机共享内存缓冲区的字节偏移量k处时：
* 结构体值的第i个成员放置在字节偏移量k + OffsetOfMember(S,i)处。参见结构体成员布局。

### 地址空间布局约束 ###  {#address-space-layout-constraints}

"地址空间/存储"和"地址空间/统一"地址空间具有不同的缓冲区布局约束，本节将对其进行描述。


注意：除"地址空间/统一"外，所有地址空间的约束都与"地址空间/存储"相同。


所有直接或间接由变量引用的结构体和数组类型必须遵守变量所在地址空间的约束，违反地址空间约束将导致着色器创建错误。


在本节中，我们将<dfn noexport>RequiredAlignOf</dfn>(|S|, |C|)定义为在地址空间|C|中使用可在主机共享的类型|S|时的字节偏移量对齐要求。

<table class='data'>
  <caption>
    Alignment requirements of a host-shareable type for
    [=address spaces/storage=] and [=address spaces/uniform=] address spaces
  </caption>
  <thead>
    <tr><th>Host-shareable type |S|
        <th>[=RequiredAlignOf=](|S|, [=address spaces/storage=])
        <th>[=RequiredAlignOf=](|S|, [=address spaces/uniform=])
  </thead>
  <tr><td>[=i32=], [=u32=], [=f32=], or [=f16=]
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=atomic types|atomic=]&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=vector|vec=]N&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of a matrix with C columns and R rows">
      <td>[=matrix|mat=]CxR&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of an array">
      <td>[=array=]&lt;T, N&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of an runtime-sized array">
      <td>array&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of a structure">
      <td>[=structure|struct=] |S|
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))<br>
</table>

类型 |T| 的结构成员必须从结构的开始处具有字节偏移量，这个偏移量必须是地址空间 |C| 中所需对齐方式（RequiredAlignOf(T, C)）的倍数。

<p algorithm="structure member minimum alignment">
    [=OffsetOfMember=](|S|, |M|) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    Where |k| is a positive integer and |M| is a member of structure |S| with type |T|
</p>

元素类型为|T|的数组[=shader-creation error|必须=]具有对于地址空间|C|的[=元素步幅=]是|T|和|C|的[=RequiredAlignOf=]的倍数。

<p algorithm="array element minimum alignment">
    [=StrideOf=](array<|T|, |N|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    [=StrideOf=](array<|T|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    Where |k| is a positive integer
</p>

注意：[=RequiredAlignOf=](|T|, |C|)对于[=attribute/align=]属性允许的值不会加以任何额外限制，也不会影响=AlignOf=的规则。数据的布局遵循前面定义的规则，并根据[=RequiredAlignOf=](|T|, |C|)的规则进行验证。


[=地址空间/统一=]地址空间还要求：
* 数组元素需要按照16字节对齐。 即，=StrideOf= = 16 × |k|'（其中，|k|'是正整数）。
* 如果结构体成员本身是一个结构体类型S，那么该成员的起始地址到任何后续成员的起始地址之间的字节数必须至少为 [根据=SizeOf=向上取整到16的倍数].

注意：以下示例展示了如何使用[=attribute/align=]和[=attribute/size=]属性来满足统一缓冲区的布局要求。特别地，这些技巧可用于将具有std140布局的GLSL缓冲区转换为WGSL。

<div class='example wgsl global-scope' heading='Satisfying offset requirements for uniform address space'>
  <xmp>
    struct S {
      x: f32
    }
    struct Invalid {
      a: S,
      b: f32 // invalid: offset between a and b is 4 bytes, but must be at least 16
    }
    @group(0) @binding(0) var<uniform> invalid: Invalid;

    struct Valid {
      a: S,
      @align(16) b: f32 // valid: offset between a and b is 16 bytes
    }
    @group(0) @binding(1) var<uniform> valid: Valid;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Satisfying stride requirements for uniform address space'>
  <xmp>
    struct small_stride {
      a: array<f32,8> // stride 4
    }
    // Invalid, stride must be a multiple of 16
    @group(0) @binding(0) var<uniform> invalid: small_stride;

    struct wrapped_f32 {
      @size(16) elem: f32
    }
    struct big_stride {
      a: array<wrapped_f32,8> // stride 16
    }
    @group(0) @binding(1) var<uniform> valid: big_stride;     // Valid
  </xmp>
</div>

## 内存模型 ## {#memory-model}

In general, WGSL follows the [[!VulkanMemoryModel|Vulkan Memory Model]].
The remainder of this section describes how WGSL programs map to the
Vulkan Memory Model.

Note: The Vulkan Memory Model is a textual version of a [formal Alloy
model](https://github.com/KhronosGroup/Vulkan-MemoryModel/blob/master/alloy/spirv.als).

### Memory Operation ### {#memory-operation}

在WGSL中，[=read access=]等效于Vulkan内存模型中的内存读取操作。
在WGSL中，[=write access=]等效于Vulkan内存模型中的内存写入操作。


[=read access=] 在执行以下操作之一时发生：
* 对[=Load Rule=]进行评估
* 除以下函数外的任何[[#texture-builtin-functions|内置纹理函数]]：
    * [[#texturedimensions|textureDimensions]]
    * [[#texturestore|textureStore]]
    * [[#texturenumlayers|textureNumLayers]]
    * [[#texturenumlevels|textureNumLevels]]
    * [[#texturenumsamples|textureNumSamples]]
    * 除[[#atomic-store|atomicStore]]之外的任何原子内置函数
    * [[#workgroupUniformLoad-builtin|workgroupUniformLoad]]内置函数
    * [=compound assignment=]语句（对于[=left-hand side=]表达式）

[=write access=] 在执行以下操作之一时发生：
    * [=statement/assignment=]语句（[=simple assignment|simple=] 或 [=compound assignment|compound=]，对于[=left-hand side=]表达式）
    * [[#texturestore|textureStore]]内置函数
    * 除[[#atomic-load|atomicLoad]]之外的任何原子内置函数
        * 只有当返回结果的exchanged成员为true时，[[#atomic-rmw|atomicCompareExchangeWeak]]才执行写入操作

[[#atomic-rmw|原子读取-修改-写入]]内置函数执行一次既是[=读取访问=]又是[=写入访问=]的内存操作。


在任何其他情况下，都不会发生读取和写入访问。
读取和写入访问在Vulkan内存模型中被称为[=内存模型内存操作|内存操作=]。


内存操作仅访问与操作中所使用的特定[=内存视图=]相关联的[=内存位置|位置=]集合。例如，从包含多个成员的结构体中读取一个[=u32=]的内存读取仅读取与该u32成员相关联的内存位置。


注意：对向量的组成部分进行写入访问可能访问与该向量相关联的所有内存位置。

<div class='example wgsl memory locations accessed' heading="Accessing memory locations">
  <xmp>
    struct S {
      a : f32,
      b : u32,
      c : f32
    }

    @group(0) @binding(0)
    var<storage> v : S;

    fn foo() {
      let x = v.b; // Does not access memory locations for v.a or v.c.
    }
  </xmp>
</div>

### 内存模型参考 ### {#memory-model-reference}

每个模块范围的[资源]变量为唯一的[属性/组]和[属性/绑定]对形成了一个[内存模型引用]。
每个其他变量（即在[地址空间/函数]、[地址空间/私有]和[地址空间/工作组]地址空间中的变量）在其变量的生命周期中形成了一个唯一的[内存模型引用]。

### 范围操作 ### {#scoped-operations}

当调用执行作用域操作时，它将影响一个或两个调用集合。
这些集合是内存作用域和执行作用域。内存作用域指定受操作影响的内存内容更新的调用集合。
对于同步内置函数，这也意味着在该函数之前受影响的内存操作按程序顺序可见，在该函数之后受影响的操作按程序顺序可见。
执行作用域指定可能参与操作的调用集合。


原子内置函数映射到内存模型原子操作，其内存模型作用域为：
* 如果原子指针在工作组地址空间中，则为"工作组"
* 如果原子指针在存储地址空间中，则为"队列族"

同步内置函数映射到执行和内存控制屏障的作用域，都为"工作组"。


隐式和显式导数具有隐式的四元执行作用域。


注意：如果在生成的着色器中未启用Vulkan内存模型，则应该使用"设备"作用域代替"队列族"。

### 内存语义 ### {#memory-semantics}

所有原子内置函数都使用Relaxed[内存模型内存语义]，因此没有存储类语义。


注意：在WGSL中的地址空间等同于SPIR-V中的存储类。


workgroupBarrier使用AcquireRelease[内存模型内存语义]和WorkgroupMemory语义。
storageBarrier使用AcquireRelease[内存模型内存语义]和UniformMemory语义。
textureBarrier使用AcquireRelease[内存模型内存语义]和ImageMemory语义。


注意：组合的workgroupBarrier和storageBarrier使用AcquireRelease排序语义以及WorkgroupMemory和UniformMemory内存语义。


注意：没有任何原子或同步内置函数使用MakeAvailable或MakeVisible语义。

### 私有 vs 非私有 ### {#private-vs-non-private}

在[=地址空间/存储=]或[=地址空间/工作组=]地址空间中，所有非原子读访问都被视为[=内存模型非私有|非私有=]，并对应使用NonPrivatePointer | MakePointerVisible内存操作数进行读操作，范围为Workgroup。


在[=地址空间/存储=]或[=地址空间/工作组=]地址空间中，所有非原子写访问都被视为[=内存模型非私有|非私有=]，并对应使用NonPrivatePointer | MakePointerAvailable内存操作数进行写操作，范围为Workgroup。

# 执行 # {#execution}

[[#overview]]描述了如何调用着色器并将其划分为invocations。
本节进一步描述了invocations在个别和集体上的执行约束。

## 在调用中的程序顺序 ## {#program-order}

在执行过程中，WGSL模块中的每个语句可以执行零次或多次。
对于给定的调用，给定语句的每次执行代表一个唯一的动态语句实例。


当一个语句包含一个表达式时，语句的语义决定:


表达式是否作为语句执行的一部分进行评估。
在语句中独立表达式之间的评估相对顺序。

表达式嵌套定义了必须满足的数据依赖关系才能完成评估。
也就是说，嵌套的表达式必须在封闭表达式之前进行评估。
在WGSL中，一个表达式的操作数的评估顺序是从左到右的。
例如，foo() + bar() 必须在评估 bar()之前评估 foo()。
参见[[#expressions]]。


在WGSL模块中，语句按照控制流的顺序执行。
参见[[#statements]] 和 [[#function-calls]]。

## 一致性 ## {#uniformity}

一个[[#collective-operations|集合操作]]（例如屏障、导数或依赖于隐式计算的导数的纹理操作）需要在GPU上同时运行的不同调用之间进行协调。
当所有调用同时执行该操作时，即在[=统一控制流=]中，操作能够正确且可移植地执行。


相反，当一部分严格的调用执行该操作时，即在非统一控制流中，会出现错误或不可移植的行为。非统一控制流的控制依赖关系导致部分调用执行集合操作，而其他调用则没有执行该操作，或者没有在同一时间执行该操作。
非统一控制流的控制依赖关系是由于行为依赖于[=统一值|非统一值=]的控制流语句引起的。

> 例如，非均匀的控制依赖发生在不同调用计算条件的值时，比如[=语句/if=]，[=语句/break-if=]，[=语句/while=]或[=语句/for=]的情况，或者在不同调用计算[=语句/switch=]的选择器的值时，或者在短路二进制运算符（&&或||）的左操作数上。

这些非均匀的值通常可以追溯到某些未经静态证明的均匀源。这些源包括但不限于：
* 可变的（模块作用域的）变量
* 大多数内置值，除了num_workgroups和workgroup_id
* 用户定义的输入数据
* 某些内置函数（参见#uniformity-function-calls章节）

为了确保正确和可移植的行为，WGSL实现将执行静态的均匀性分析，试图证明每个集合操作在均匀的控制流中执行。后续的小节描述了这个分析过程。

当"一致性分析"无法证明特定的"集合操作"在"一致的控制流"中执行时，将触发"一致性失败"。

* 如果对于计算导数的内置函数触发了一致性失败，那么将触发一个"触发/导数一致性"诊断。
    * 诊断的"诊断触发位置"是该内置函数的调用位置。
    * 诊断的"诊断严重性"默认为"错误"，但可以通过"诊断过滤器"进行控制。
* 如果对于"同步内置函数"触发了一致性失败，则触发一个"错误"诊断。 这将导致"着色器创建错误"。

### 术语和概念 ### {#uniformity-concepts}

下面的定义仅为信息性定义，试图为接下来的子部分中的分析计算提供直观理解。
分析实际上定义了这些概念，并确定程序是否有效或违反了统一性规则。


对于给定的调用组：
- 如果给定作用域内的所有调用在程序的某个特定点上执行，就好像它们在同步执行，那么该点被称为具有均匀控制流。
    - 对于计算着色器阶段，均匀控制流的范围是同一计算着色器阶段/工作组中的所有调用。
    - 对于其他着色器阶段，均匀控制流的范围是同一绘制命令中该入口点的所有调用。
- 如果一个表达式在均匀控制流中执行，并且所有调用计算出相同的值，则该表达式被称为均匀值。
- 如果调用在变量的生存期内的每个点上具有相同的值，则该变量被称为均匀变量。

### 统一性分析概述 ### {#uniformity-overview}

其余的小节详细说明了一个静态分析，用来验证只有在统一的控制流下才执行[[#collective-operations|集体操作]]。


该分析假设不会发生动态错误。
一个带有动态错误的着色器阶段已经是非可移植的了，无论统一性分析的结果如何。

<div class="note"><span class=marker>Note:</span>This analysis has the following desirable properties:
      - Sound, meaning that a [=uniformity failure=] [=behavioral requirement|will=] be triggered for a program that would break the uniformity requirements of builtins.
      - Linear time complexity, in the number of tokens in the program.
      - Refactoring a piece of code into a function, or inlining a function, cannot make a shader invalid if it was valid before the transformation.
      - If the analysis refuses a program, it provides a straightforward chain of implications that can be used by the user agent to craft a good error message.
</div>

每个函数都被分析，试图确保两件事：
* 当调用其他函数时满足一致性要求，
* 每次被调用时都满足一致性要求。 如果其中任何一个检查失败，则会触发一次一致性失败检查。

在这项工作中，分析会计算关于函数的元数据，以帮助分析其调用者。
这意味着首先必须建立调用关系图，并且必须从叶子向上分析函数，即从不调用标准库以外函数的函数向入口点分析。
这样，每当分析一个函数时，已经计算了其所有被调用函数的元数据。
由于循环在该语言中是禁止的，所以不会陷入循环的风险。


注意：另一种表达方式是根据"是（可能是间接）被调用者"的部分顺序对函数进行拓扑排序，并按照这个顺序进行分析。


此外，对于每个函数调用，分析会计算和传播"可能触发的诊断规则"，如果该调用不能被证明处于一致的控制流中，则会触发这些规则。
我们称这个调用的"潜在触发集合"。

该集合的元素来自于两种可能性：
* 依赖于计算导数的函数的触发/导数一致性，
* 无法被过滤的一致性要求的匿名触发规则。 这用于依赖于同步函数的计算着色器函数。

### 分析函数的均匀性要求 ### {#uniformity-function}

每个函数都会经过两个阶段的分析。


第一阶段遍历函数的语法，在此过程中根据以下子节的规则建立一个有向图。
第二阶段探索该图，计算调用该函数的约束，并可能引发[统一性失败]。

<div class="note"><span class=marker>Note:</span>
除了四个特殊节点[=RequiredToBeUniform.error=]、[=RequiredToBeUniform.warning=]、[=RequiredToBeUniform.info=]和[=MayBeNonUniform=]，每个节点可以被理解为捕捉以下陈述之一的真值：
* 必须在一致的控制流中执行程序的特定点。
* 表达式必须是一致的值。
* 变量必须是一致的变量。
* 存储在内存中的值（可以通过指针加载）必须是一致的值。

边可以被理解为从源节点对应的陈述到目标节点对应的陈述的蕴涵关系。


例如，一个一致性要求是workgroupBarrier内置函数只能在一致的控制流中调用。为了表达这一点，我们从[=RequiredToBeUniform.error=]到对应于workgroupBarrier[调用点]的节点添加一条边。对这个的一种理解是[=RequiredToBeUniform.error=]对应于命题True，所以[=RequiredToBeUniform.error=] -> X等同于说X是真的。


反过来，为了表示我们无法保证某个东西（例如持有线程ID的变量）的一致性，我们从相应的节点添加一条边到[=MayBeNonUniform=]。一种理解方式是[=MayBeNonUniform=]对应于命题False，所以X -> [=MayBeNonUniform=]等同于说X是假的。


这种解释的一个结果是，从[=RequiredToBeUniform.error=]可达的每个节点对应于程序为有效需要一致的东西，而从可达[=MayBeNonUniform=]的每个节点对应于我们无法保证其一致性的东西。因此，如果存在从[=RequiredToBeUniform.error=]到[=MayBeNonUniform=]的路径，我们将触发一次一致性失败，引发一次[=uniformity failure=]。


节点[=RequiredToBeUniform.warning=]和[=RequiredToBeUniform.info=]的使用方式类似，但是它们有助于确定何时触发[=severity/warning=]或[=severity/info=]的[=diagnostics=]：
* 如果从[=RequiredToBeUniform.warning=]到[=MayBeNonUniform=]有一条路径，则会触发一个[=severity/warning=]的[=diagnostic=]。
* 如果从[=RequiredToBeUniform.info=]到[=MayBeNonUniform=]有一条路径，则会触发一个[=severity/info=]的[=diagnostic=]。

如[[#diagnostics]]中所述，如果已经生成了更高严重性的[=diagnostics=]，则较低严重性的[=diagnostics=]可能被丢弃。
</div>

对于每个函数，计算两个标签：
* 一个描述函数的调用点对控制流统一性要求的<dfn noexport>调用点标签</dfn>
* 一个描述函数对统一性的影响的<dfn noexport>函数标签</dfn>

对于函数的每个形式参数，计算一个或两个标签：
* <dfn noexport>参数标签</dfn>描述参数值的统一性要求。
* <dfn noexport>参数返回标签</dfn>描述参数的统一性如何影响函数的返回值。
* 当参数类型为指向[=地址空间/函数=]地址空间的指针时，会计算一个<dfn noexport>指针参数标签</dfn>。该标签描述了在函数调用执行过程中，参数所指向的内存中的值是否可能变成[=统一值/非统一值=]。

<table class=‘data’>
<caption>[=Call site tag=] 的值</caption>
<thead>
<tr><th>调用位置标签<th>描述
</thead>
<tr algorithm="CallSiteRequiredToBeUniform tag">
<td><dfn noexport>CallSiteRequiredToBeUniform.S</dfn>,<br>
其中 |S| 是严格程度之一：[=severity/error=]、[=severity/warning=] 或 [=severity/info=]。
<td>只能从 [=uniform control flow=] 调用此函数。
否则将触发严格程度为 |S| 的诊断。


      与一个 [=potential-trigger-set=] 关联。

<tr><td><dfn noexport>CallSiteNoRestriction</dfn>
<td>该函数可以从 [=uniform control flow|non-uniform control flow=] 调用。
</table>


<table class=‘data’>
<caption>[=Function tag=] 的值</caption>
<thead>
<tr><th>函数标签<th>描述
</thead>
<tr><td><dfn noexport>ReturnValueMayBeNonUniform</dfn>
<td>函数的 [=return value=] 可能是非一致的。
<tr><td><dfn noexport>NoRestriction</dfn>
<td>函数不引入非一致性。
</table>


<table class=‘data’>
<caption>[=Parameter tag=] 的值</caption>
<thead>
<tr><th>参数标签<th>描述
</thead>
<tr algorithm="ParameterRequiredToBeUniformValue tag">
<td><dfn noexport>ParameterRequiredToBeUniform.S</dfn>,<br>
其中 |S| 是严格程度之一：[=severity/error=]、[=severity/warning=] 或 [=severity/info=]。
<td>参数必须是一个 [=uniform value=]。
如果参数类型是指针，则内存视图（但不一定是其内容）必须是一致的。
否则将触发严格程度为 |S| 的诊断。


      与一个 [=potential-trigger-set=] 关联。

<tr algorithm="ParameterContentsRequiredToBeUniform tag">
<td><dfn noexport>ParameterContentsRequiredToBeUniform.S</dfn>,<br>
其中 |S| 是严格程度之一：[=severity/error=]、[=severity/warning=] 或 [=severity/info=]。
<td>指针参数指向的内存中存储的值必须是一个 [=uniform value=]。
否则将触发严格程度为 |S| 的诊断。


      与一个 [=potential-trigger-set=] 关联。

<tr><td><dfn noexport>ParameterNoRestriction</dfn>
<td>参数值没有一致性要求。
</table>


<table class=‘data’>
<caption>[=Parameter return tag=] 的值</caption>
<thead>
<tr><th>参数返回标签<th>描述
</thead>
<tr><td><dfn noexport>ParameterReturnContentsRequiredToBeUniform</dfn>
<td>此参数 [=shader-creation error|must=] 是一个 [=uniform value=]，以使得 [=return value=] 是一个一致值。
如果参数是指针，则指针指向的内存中存储的值也必须是 [=uniform value|uniform=]。
<tr><td><dfn noexport>ParameterReturnNoRestriction</dfn>
<td>参数值没有一致性要求。
</table>


<table class=‘data’>
<caption>[=Pointer parameter tag=] 的值</caption>
<thead>
<tr><th>指针参数标签<th>描述
</thead>
<tr><td><dfn noexport>PointerParameterMayBeNonUniform</dfn>
<td>指针参数指向的内存中存储的值可能在函数调用后是 [=uniform value|non-uniform=]。
<tr><td><dfn noexport>PointerParameterNoRestriction</dfn>
<td>指针参数指向的内存中存储的值的一致性不受函数调用的影响。
</table>

以下算法描述了如何为给定函数计算这些标签：
* 创建以下节点：
    * <dfn noexport>RequiredToBeUniform.error</dfn>、<dfn noexport>RequiredToBeUniform.warning</dfn> 和 <dfn noexport>RequiredToBeUniform.info</dfn>。 它们共同被称为 <dfn noexport>RequiredToBeUniform.S</dfn> 节点。
        * 每个此类节点都与一个[=潜在触发集合=]关联，该集合最初为空。
    * <dfn noexport>MayBeNonUniform</dfn>
    * <dfn noexport>CF_start</dfn>，表示函数开始执行时控制流的一致性要求。
    * <dfn noexport>param_i</dfn>，其中 i 覆盖函数的[=形式参数=]。
    * 如果函数有一个[=返回类型=]，创建一个名为 <dfn noexport>Value_return</dfn> 的节点。
* 按照[[#pointer-desugar]]中描述的方法对指针进行语法糖处理。
    * 对于在[=地址空间/函数=]地址空间中作为指针的每个形式参数，创建以下节点：
        * <dfn noexport>param_i_contents</dfn>：这代表内存视图内容的一致性。
        * <dfn noexport>Value_return_i_contents</dfn>：这代表函数对内存视图内容一致性的影响。

* 按照函数的语法进行遍历，在图中添加节点和边缘，遵循下一节的规则（[[#func-var-value-analysis]]、[[#uniformity-statements]]、[[#uniformity-function-calls]]、[[#uniformity-expressions]]），使用[=CF_start=]作为函数体的起始控制流。
    * 在此步骤中添加的节点称为<dfn noexport>内部节点</dfn>。
* 初始化如下：
    * [=function tag=] 初始化为 [=NoRestriction=]。
    * [=call site tag=] 初始化为 [=CallSiteNoRestriction=]。
    * 对于每一个 [=param_i=]，其 [=parameter tag=] 初始化为 [=ParameterNoRestriction=]。
    * 对于每一个 [=param_i=]，其 [=parameter return tag=] 初始化为 [=ParameterReturnNoRestriction=]。
    * 如果存在，对于每一个 [=param_i=] 的 [=pointer parameter tag=] 初始化为 [=PointerParameterNoRestriction=]。
* 按照 {[=severity/error=]，[=severity/warning=]，[=severity/info=]}的顺序，对每个严重度 S 执行以下操作：
    * 让 R.S 为从 [=RequiredToBeUniform.S=] 可达的未访问节点集合。
    * 将 R.S 中的 [=interior nodes=] 标记为已访问。
    * 让 PTS 为与 [=RequiredToBeUniform.S=] 关联的 [=potential-trigger-set=]。
    * 如果 R.S 包括节点 [=MayBeNonUniform=]，那么触发一个 [=uniformity failure=]：
        * 对于 PTS 中的每个 t，[=triggered|触发=] 一个严重度为 S 的诊断，并应用触发规则 t。
    * 否则：
        * 如果 R.S 包含 [=CF_start=]，并且 [=call site tag=] 自初始化后未更新，则 将 [=call site tag=] 设置为 [=CallSiteRequiredToBeUniform.S=]，并将其 [=potential-trigger-set=] 设置为 PTS。
        * 对于 R.S 中的每个 [=param_i=]，如果其相应的 [=parameter tag=] 自初始化后未更新，则 将该标签设置为 [=ParameterRequiredToBeUniform.S=]，并将其 [=potential-trigger-set=] 设置为 PTS。
        * 对于 R.S 中的每个 [=param_i_contents=]，如果其相应的 [=parameter tag=] 自初始化后未更新，则 将该标签设置为 [=ParameterContentsRequiredToBeUniform.S=]，并将其 [=potential-trigger-set=] 设置为 PTS。
* 将所有 [=interior nodes=] 标记为未访问。
* 如果 [=Value_return=] 存在，让 VR 为从 [=Value_return=] 可达的节点集合。
    * 如果 VR 包括 [=MayBeNonUniform=]，则将 [=function tag=] 设置为 [=ReturnValueMayBeNonUniform=]。
    * 对于 VR 中的每个 [=param_i=]，将相应的 [=parameter return tag=] 设置为 [=ParameterReturnContentsRequiredToBeUniform=]。
* 对于每个 [=Value_return_i_contents=] 节点，让 VRi 为从 [=Value_return_i_contents=] 可达的节点集合。
    * 如果 VRi 包括 [=MayBeNonUniform=]，将相应的 [=pointer parameter tag=] 设置为 [=PointerParameterMayBeNonUniform=]。

注意：此时整个图表可能会被破坏。上面描述的标签是我们需要记住的，以便分析这个函数的调用者。
然而，图表中包含的信息可以用来提供更多具有参考价值的诊断信息。
例如，在一个函数中的某个值可能无法证明是[=uniform value|统一的=]，
这可能会导致在另一个函数中触发一致性失败。
一个具有参考价值的诊断会描述该非统一值，以及在诊断的[=diagnostic/triggering location|触发位置=]发生的函数调用。

### 指针语法糖解析 ### {#pointer-desugar}

每个位于[=地址空间/函数=]地址空间中的[=形式参数|参数=]类型为[=指针类型=]，都会按照以下方法进行展开（desugared）：它被视为一个局部变量声明，其初始值相当于对参数进行解引用。也就是说，函数地址空间指针被视为局部变量声明的别名。初始值赋值产生一个指向[=param_i_contents=]的边，对于第i个参数（即*V(e)*等于[=param_i_contents=]）。


每个其[=有效值类型=]为[=指针类型=]的[=let声明=]，L，按以下方式进行展开（desugared）：
* 后序深度优先遍历L的初始化表达式中的每个子表达式SE：
    * 如果SE在[=类型检查=]期间调用了[=加载规则=]，并且[=根标识符=]是可变变量，则：
        * 紧接在L之前创建一个新的let声明，LSE，并用SE进行初始化。
        * 用由LSE组成的[[#value-identifier-expr|值标识符表达式]]替换L中的SE。
* 记录L的（可能更新过的）初始化表达式。
* 用记录的初始化表达式代替每个[=标识符=]，该标识符[=解析=]为L（包装在[[#parenthesized-expressions|括号表达式]]中）。

这种展开通过直接在每个使用点暴露出指针的[=根标识符=]，从而简化了随后的分析。


注意：为了分析的统一性，在这种展开发生之前和之后都描述了[=类型检查=]。

<div class='example wgsl' heading='pointers in the uniformity analysis'>
  <xmp>
    fn foo(p : ptr<function, array<f32, 4>>, i : i32) -> f32 {
      let p1 = p;
      var x = i;
      let p2 = &((*p1)[x]);
      x = 0;
      *p2 = 5;
      return (*p1)[x];
    }

    // This is the equivalent version of foo for the analysis.
    fn foo_for_analysis(p : ptr<function, array<f32, 4>>, i : i32) -> f32 {
      var p_var = *p;            // Introduce variable for p.
      let p1 = &p_var;           // Use the variable for p1
      var x = i;
      let x_tmp1 = x;            // Capture value of x
      let p2 = &(p_var[x_tmp1]); // Substitute p1's initializer
      x = 0;
      *(&(p_var[x_tmp1])) = 5;   // Substitute p2's initializer
      return (*(&p_var))[x];     // Substitute p1's initializer
    }
  </xmp>
</div>

### 函数范围变量值分析 ### {#func-var-value-analysis}

在某个特定语句中，每个[=function scope|函数作用域=] [=variable|变量=]的值可以通过到达它的赋值以及可能的初始值来分析。


如果以下条件之一成立，则赋值是一个<dfn noexport>完全赋值</dfn>：
* 变量的[=effective-value-type|有效值类型=]是一个[=scalar|标量=]类型，或者
* 变量的[=effective-value-type|有效值类型=]是一个[=composite|复合=]类型，并且复合类型的每个[=component|组件=]都被赋予了一个值。

否则，赋值是一个<dfn noexport>部分赋值</dfn>。


<dfn>完全引用</dfn>是指以下的[=reference type|引用类型=]表达式之一：
* 一个标识符x，它[=resolves|解析=]为一个变量，或者
* (r)，其中r是一个[=full reference|完全引用=]，或者
* *p，其中p是一个[=full pointer|完全指针=]。

<dfn>完全指针</dfn>是指以下的[=pointer type|指针类型=]表达式之一：
* &r，其中r是一个[=full reference|完全引用=]，或者
* 一个标识符p，它[=resolves|解析=]为一个经初始化为一个[=full pointer|完全指针=]的[=let-declaration|let声明=]，或者
* (p)，其中p是一个[=full pointer|完全指针=]。

注意：为了此项分析，我们不需要考虑指针类型的形式参数可能是一个完全指针的情况。


一个[=full reference|完全引用=]，以及类似地一个[=full pointer|完全指针=]，是所有对应的[=originating variable|起始变量=] x的内存位置的[=memory view|内存视图=]。


不是[=full reference|完全引用=]的引用是一个<dfn noexport>部分引用</dfn>。
因此，部分引用要么是：
* 一个内存视图，仅为对应的[=originating variable|起始变量=]的内存位置的严格子集，或者
* 一个内存视图，与对应的起始变量具有相同的位置集合，但具有不同的[=store type|存储类型=]。

<div class="note">
<span class=marker>Note:</span> 部分引用仍然可以覆盖与完全引用相同的所有内存位置，即变量声明使用的所有位置。当存储类型为只有一个成员的结构类型，或者当存储类型为只有一个元素的数组类型时，就会发生这种情况。


考虑一种只有一个成员的结构类型以及存储该类型的变量：

```
     struct S { member: i32; }
     fn foo () {
        var v: S;
     }
```

那么 v 是一个完整引用，而 v.member 是一个部分引用。
它们的内存视图覆盖相同的内存位置，但是 v 的存储类型是 S 而 v.s 的存储类型是 i32。


在仅有一个元素的数组中也出现了类似的情况：

```
     fn foo () {
        var arr: array<i32,1>;
     }
```

接着，arr 是一个完整引用而 arr[0] 是一个部分引用。它们的内存视图覆盖相同的内存位置，但 arr 的存储类型是 array<i32,1> 而 arr[0] 的存储类型是 i32。


为了简化分析，通过任何类型的[=部分引用=]进行的赋值都被视为其不修改关联的[=原始变量=]中的每个内存位置。这使分析变得保守，可能触发更多的程序出现[=一致性失败=]，而这比绝对必要的情况要多。


通过[=完整引用=]进行的赋值是一次[=完整赋值=]。


通过[=部分引用=]进行的赋值是一次[=部分赋值=]。


在后续部分的一致性规则提到以函数作用域变量作为[=RHSValue=]使用时，它指的是在评估RHSValue表达式之前变量的值。当后续部分的一致性规则提到以函数作用域变量作为[=LHSValue=]使用时，它指的是在包含该表达式的语句执行后变量的值。


由于[[#control-flow|控制流语句]]或部分赋值，多次对变量的赋值可能到达变量的使用位置。分析通过联合每个控制流出口达到的赋值集合，来合并多个赋值。


下表描述了合并赋值的规则。在一致性图中，每个合并都是从结果节点到代表值源的节点的边。它用一个任意变量 x 来表述。它使用以下符号：
* Vin(S) 是执行语句 S 之前 x 的值。
* Vout(S) 是执行语句 S 之后 x 的值。
* Vout(prev) 是执行当前语句之前 x 的值。
* Vin(next) 是执行下一个语句之前 x 的值。
* V(e) 是后续部分中作为表达式的一个值节点。
* V(0) 是 x 的[=有效值类型=]的零值。

<table class=‘data’>
<caption>加入多个赋值语句到函数作用域变量的规则。
<thead>
<tr><th>语句
<th>结果
<th>来自结果的边
</thead>
<tr><td>
var x;
<td>Vin(next)
<td>V(0)
<tr><td>
var x = e;<br>
<td rowspan=3>Vin(next)
<td rowspan=3>V(e)


      注：这是一个对*x*的[=完全赋值=]。

<tr><td>
x = e;<br>
<tr><td>
r = e;<br>
其中 r 是对变量 x 的[=完全引用=]
<tr><td>
r = e;<br>
其中 r 是对变量 x 的[=部分引用=]
<td>Vout(S)
<td>V(e), V(prev)


      注：这是对*x*的[=部分赋值=]。

      注：部分赋值包括前一个值。
      赋值要么只写入存储组件的一部分，
      要么写入值的类型与[=起源=]变量的[=存储类型=]不同。

<tr><td>s1 s2<br>
其中 Next 在 s1 的行为中。


      注：*s1* 通常以分号结束。
  <td>*Vin*(*s2*)
  <td>*Vout*(*s1*)

<tr><td>
if e s1 else s2<br>
其中 Next 在 s1 和 s2 的行为中
<td>Vin(next)
<td>Vout(s1), Vout(s2)
<tr><td>
if e s1 else s2<br>
其中 Next 在 s1 的行为中，但不在 s2 中
<td>Vin(next)
<td>Vout(s1)
<tr><td>
if e s1 else s2<br>
其中 Next 在 s2 的行为中，但不在 s1 中
<td>Vin(next)
<td>Vout(s2)
<tr><td>loop { s1 continuing { s2 } }
<td>Vin(s1)
<td>Vout(prev), Vout(s2)
<tr><td>loop { s1 continuing { s2 } }
<td>Vin(s2)
<td>Vout(s1),<br>
Vout(s<sub>i</sub>)<br>
对于 s1 中所有行为是 {Continue} 并且将控制权转移到 s2 的 s<sub>i</sub>
<tr><td>loop { s1 continuing { s2 } }
<td>Vin(next)
<td>Vout(s2),<br>
Vout(s<sub>i</sub>)<br>
对于 s1 中所有行为是 {Break} 并且将控制权转移到 next 的 s<sub>i</sub>
<tr><td>switch e {<br>
case _: s1<br>
case _: s2<br>
…<br>
case _: s3<br>
}<br>
<td>Vin(s<sub>i</sub>)
<td>Vout(prev)
<tr><td>switch e {<br>
case _: s1<br>
case _: s2<br>
…<br>
case _: s3<br>
}<br>
<td>Vin(next)
<td>Vout(s<sub>i</sub>),<br>
对于所有包含 Next 或 Break 行为的 s<sub>i</sub>，以及<br>
Vout(s<sub>j</sub>)<br>
对于 s<sub>j</sub> 内部所有行为是 {Break} 并且将控制权转移到 next 的语句
</table>

对于所有其他语句（函数调用除外），Vin(next) 和 Vout(prev) 是等效的。


注：与[[#behaviors|语句行为分析]]中相同的语法糖转换适用。

### 报表统一性规则 ### {#uniformity-statements}

分析语句的规则既接受语句本身作为参数，也接受对应于语句开始时控制流的节点（我们在下文中将其记作"CF"），并返回以下两个结果：
* 对应于语句退出时控制流的节点
* 要添加到图中的一组新节点和边

在下表中，"(CF1, S) => CF2"意味着"以控制流CF1开始对S运行分析，对图进行所需的更改，并将结果控制流命名为CF2"。
类似地，"(CF1, E) => (CF2, V)"意味着"以控制流CF1开始对表达式E进行分析，对图进行所需的更改，并将结果控制流节点命名为CF2和结果值节点命名为V"（有关表达式的分析，请参见下一节）。
这种表达式的评估用于任何不是[=statement/assignment=]的[=left-hand side=]部分的表达式，称为<dfn noexport>RHSValue</dfn>。


有一套类似的规则适用于作为[=statement/assignment=]的[=left-hand side=]部分的表达式，这些表达式称为<dfn noexport>LHSValue</dfn>，我们通过LHSValue: (CF, E) => (CF, L)表示。它不是计算与值的一致性对应的节点，而是计算与我们正在访问的变量的一致性对应的节点。


注意：[=LHSValues=]包括在[=increment statement|increment=]和[=decrement statement|decrement=]语句中的表达式。


注意：[=RHSValues=]包括作为[=statement/assignment=]语句的[=right-hand side=]部分的表达式或不属于赋值、[=increment statement|increment=]或[=decrement statement|decrement=]语句的表达式。


当需要创建多条边时，我们使用X -> {Y, Z}作为X -> Y, X -> Z的简写。

<table class=‘data’>
<caption>语句的一致性规则</caption>
<thead>
<tr><th>语句<th>新节点<th>递归分析<th>生成的控制流节点<th>新的边
</thead>
<tr><td class="nowrap">{s}
<td>
<td class="nowrap">(CF, s) => CF’
<td>CF’
<td>
<tr><td class="nowrap">s1 s2,<br>
若s1的行为中包含Next


    注意：*s1*通常以分号结束。

  <td>
  <td class="nowrap">(*CF*, *s1*) => *CF1*<br>
      (*CF1*, *s2*) => *CF2*
  <td>*CF2*
  <td>

<tr><td class="nowrap">s1 s2,<br>
若s1的行为中不包含Next


    注意：*s1*通常以分号结束。

  <td>
  <td>(*CF*, *s1*) => *CF1*<br>

  注意：*s2*静态上不可达，不进行递归分析。
  *s2*不参与一致性分析。
  <td>*CF1*
  <td>

<tr><td class="nowrap">if e s1 else s2<br> 且行为包含{Next}
<td>
<td rowspan=2 class="nowrap">(CF, e) => (CF’, V)<br>
(V, s1) => CF1<br>
(V, s2) => CF2
<td>CF
<td>
<tr><td class="nowrap">if e s1 else s2<br> 且行为为其他
<td>CFend
<td>CFend
<td class="nowrap">CFend -> {CF1, CF2}
<tr><td class="nowrap">loop {s1 continuing {s2}}<br> 且行为包含{Next}
<td rowspan=2>CF’
<td rowspan=2 class="nowrap">(CF’, s1) => CF1<br>
(CF1, s2) => CF2
<td>CF
<td rowspan=2 class="nowrap">CF’ -> {CF2, CF}
<tr><td class="nowrap">loop {s1 continuing {s2}}<br> 且行为为其他
<td>CF’
<tr><td class="nowrap">loop {s1}<br> 且行为包含{Next}
<td rowspan=2>CF’
<td rowspan=2 class="nowrap">(CF’, s1) => CF1
<td>CF
<td rowspan=2 class="nowrap">CF’ -> {CF1, CF}
<tr><td class="nowrap">loop {s1}<br> 且行为为其他
<td>CF’
<tr><td class="nowrap">switch e case _: s_1 … case _: s_n<br> 且行为包含{Next}
<td>
<td rowspan=2 class="nowrap">(CF, e) => (CF’, V)<br>
(V, s_1) => CF_1<br>
…<br>
(V, s_n) => CF_n
<td>CF
<td>
<tr><td class="nowrap">switch e case _: s_1 … case _: s_n<br> 且行为为其他
<td>CFend
<td>CFend
<td class="nowrap">CFend -> {CF_1, …, CF_n}
<tr><td class="nowrap">var x: T;
<td rowspan=3>
<td rowspan=3>
<td rowspan=3>CF
<td rowspan=3>
注意：如果x是一个[=address spaces/function=] 地址空间变量，CF用作[[#func-var-value-analysis|值分析]]中的零值初始化器。
<tr><td class="nowrap">break;
<tr><td class="nowrap">continue;
<tr><td class="nowrap">break if e;
<td>
<td class="nowrap">(CF, e) => (CF’, V)
<td>CF’
<td>
<tr><td class="nowrap">return;
<td>
<td>
<td>CF
<td>
对于每个[=address spaces/function=] 地址空间指针参数i，
[=Value_return_i_contents=] -> Vin(prev)（见[[#func-var-value-analysis]]）
<tr><td class="nowrap">return e;
<td>
<td class="nowrap">(CF, e) => (CF’, V)
<td>CF’
<td>[=Value_return=] -> V


  对于每个[=address spaces/function=] 地址空间指针参数*i*，
  [=Value_return_i_contents=] -> *Vin*(*prev*)（见[[#func-var-value-analysis]]）

<tr><td class="nowrap">e1 = e2;
<td>
<td class="nowrap">[=LHSValue=]: (CF, e1) => (CF1, LV)<br>
(CF1, e2) => (CF2, RV)
<td>CF2
<td>LV -> RV


  注意：*LV*是来自[[#func-var-value-analysis|值分析]]的结果值。

<tr><td class="nowrap">_ = e
<td>
<td class="nowrap">(CF, e) => (CF’, V)
<td>CF’
<td>
<tr><td class="nowrap">let x = e;
<td>
<td>(CF, e) => (CF’, V)
<td>CF’
<td>
<tr><td class="nowrap">var x = e;
<td>
<td>(CF, e) => (CF’, V)
<td>CF’
<td>注意：如果x是一个[=address spaces/function=] 地址空间变量，
V作为[[#func-var-value-analysis|值分析]]中的结果值。
</table>

分析[[#for-statement|for]]循环和[[#while-statement|while]]循环遵循它们各自的翻译，转换为[[#loop-statement|loop]]语句。


在[[#switch-statement|switch]]中，一个[=default-alone clause=]块就像一个[=case clause=]一样被处理，以保证一致性。


为了最大化性能，实现通常尝试最小化[=uniform control flow|非统一控制流=]的数量。
然而，能够称为统一的调用点随着许多因素的不同而变化。WGSL的静态分析保守地假设在[=statement/if=]、[=statement/switch=]和[=statement/loop=]语句的末尾，如果语句的[[#behaviors|行为]]是{Next}，就会恢复到统一控制流。
在前面的表格中，这被建模为结果控制流节点与输入控制流节点相同。

### 函数调用的一致性规则 ### {#uniformity-function-calls}

函数调用的最复杂规则是：
- 对于每个参数，应用相应的表达式规则，并且使用前一个参数退出时的控制流（对于第一个参数，使用函数调用开始时的控制流）。将相应的值节点命名为 <dfn noexport>arg_i</dfn>，控制流节点命名为 <dfn noexport>CF_i</dfn>。
- 创建两个新节点，命名为 <dfn noexport>Result</dfn> 和 <dfn noexport>CF_after</dfn>。
- 如果函数的[=call site tag=]是[=CallSiteRequiredToBeUniform.S=]，那么：
    - 从[=RequiredToBeUniform.S=]添加一条边到最后一个[=CF_i=]。
    - 将[=call site tag=]的[=potential-trigger-set=]的成员添加到与[=RequiredToBeUniform.S=]关联的潜在触发集合中。
- 从[=CF_after=]添加一条边到最后一个[=CF_i=]。
- 如果[=function tag=]是[=ReturnValueMayBeNonUniform=]，那么添加一条从[=Result=]到[=MayBeNonUniform=]的边。
- 从[=Result=]添加一条边到[=CF_after=]。
- 对于每个参数 i：
    - 如果相应的[=parameter tag=]是[=ParameterRequiredToBeUniform.S=]，那么：
        - 从[=RequiredToBeUniform.S=]添加一条边到[=arg_i=]。
        - 将[=parameter tag=]的[=potential-trigger-set=]的成员添加到与[=RequiredToBeUniform.S=]关联的潜在触发集合中。
    - 如果[=parameter return tag=]是[=ParameterReturnContentsRequiredToBeUniform=]，那么添加一条从[=Result=]到[=arg_i=]的边。
    - 如果相应参数具有[=pointer parameter tag=]为[=PointerParameterMayBeNonUniform=]，则添加一条从Vout(call)到[=MayBeNonUniform=]的边。
    - 如果参数是在[=address spaces/function=]地址空间的指针，那么添加一条从Vout(call)到之前记录的可达参数的相应[=arg_i=]的边。
        - 如果[=parameter tag=]是[=ParameterContentsRequiredToBeUniform.S=]，则从[=RequiredToBeUniform.S=]添加一条边到Vout(call)。

注：有关Vout(call)的定义，请参阅[[#func-var-value-analysis]]。

大多数内置函数具有以下标签：
* 一个[=调用位置标签=]为[=CallSiteNoRestriction=]。
* 一个[=函数标签=]为[=NoRestriction=]。
* 对于每个参数：
    * 一个[=参数标签=]为[=ParameterNoRestriction=]。
    * 一个[=参数返回标签=]为[=ParameterReturnContentsRequiredToBeUniform=]。

以下是例外情况的列表：
* 对[[#sync-builtin-functions]]中函数的调用：
    * 拥有一个[=函数标签=]为[=NoRestriction=]。
    * 拥有一个[=调用位置标签=]为[=CallSiteRequiredToBeUniform.S|CallSiteRequiredToBeUniform.error=]，其中[=potential-trigger-set=]包含一个未命名的[=diagnostic/triggering rule=]。
        * 注意：触发规则没有名称，因此不能被过滤。
    * 另外，对于[[#workgroupUniformLoad-builtin|workgroupUniformLoad]]的调用， 参数p有一个[=参数标签=]为[=ParameterRequiredToBeUniform.S|ParameterRequiredToBeUniform.error=]， 其中[=potential-trigger-set=]包含一个未命名的[=diagnostic/triggering rule=]。
* 对[[#derivative-builtin-functions]]，[[#texturesample]]，#texturesamplebias，和[[#texturesamplecompare]]中函数的调用：
    * 拥有一个[=函数标签=]为[=ReturnValueMayBeNonUniform=]。
    * 拥有一个[=调用位置标签=]如下所示：
        * 令 DF 为调用位置和触发规则[=trigger/derivative_uniformity=]的[=nearest enclosing diagnostic filter=]。
        * 如果 DF 存在，则让 S 为 DF 的新严重性参数。
            * 如果 S 是严重性[=severity/off=]，那么调用位置标签为[=CallSiteNoRestriction=]。
            * 否则调用位置标签为[=CallSiteRequiredToBeUniform.S=]，其中[=potential-trigger-set=]包含一个[=trigger/derivative_uniformity=]元素。
        * 如果没有这样的 DF， 那么调用位置标签为[=CallSiteRequiredToBeUniform.S|CallSiteRequiredToBeUniform.error=]，其中[=potential-trigger-set=]包含一个[=trigger/derivative_uniformity=]元素。
* 对[[#textureload]]的调用：
    * 有一个[=调用位置标签=]为[=CallSiteNoRestriction=]。
    * 有一个[=函数标签=]如下所示：
        * 如果对应于 t 参数的参数是一个[=type/read-write storage texture=]，则为[=ReturnValueMayBeNonUniform=]。
        * 否则为[=NoRestriction=]。

注意：一个WGSL实现会确保，如果在函数调用之前的控制流是[=uniform control flow|uniform=]，那么在函数调用之后也会是uniform。

### 表达式的一致性规则 ### {#uniformity-expressions}
分析表达式的规则接受两个参数：表达式本身和控制流在其开始时对应的节点（我们在下文中将其标记为"CF"），并返回以下内容：
* 对应于其退出点的控制流节点
* 对应于其值的节点
* 一组要添加到图中的新节点和边

<table class=‘data’>
<caption>[=RHSValue=] 表达式的一致性规则</caption>
<thead>
<tr><th>表达式<th>新节点<th>递归分析<th>产生的控制流节点，值节点<th>新边缘
</thead>
<tr><td class="nowrap">e1 || e2
<td rowspan=2>
<td rowspan=2 class="nowrap">(CF, e1) => (CF1, V1)<br>
(V1, e2) => (CF2, V2)
<td rowspan=2 class="nowrap">CF, V2
<td rowspan=2>
<tr><td class="nowrap">e1 && e2
<tr><td class="nowrap">字面值
<td>
<td>
<td class="nowrap">CF, CF
<td>
<tr><td>标识符 [=resolves|resolving=] 到函数作用域变量 "x"，
其中标识符作为 [=memory view=] 表达式的 [=root identifier=] 出现，
MVE，在 [=type checking=] 期间对 MVE 调用了 [=load rule=]
<td>Result
<td class>X 是对应于 "x" 在包含此表达式的语句输入时的值的节点
<td class="nowrap">CF, Result
<td class>Result -> {CF, X}


  注：*X* 等价于 "x" 的 *Vout*(*prev*)<br>
  (见 [[#func-var-value-analysis]])

<tr><td>标识符 [=resolves|resolving=] 到函数作用域变量 "x"，
其中 "x" 是解糖后的指针参数 i，并且
标识符作为 [=memory view=] 表达式的 [=root identifier=] 出现，
MVE，而且在 [=type checking=] 期间没有对 MVE 调用 [=load rule=]
<td>
<td class>
<td class="nowrap">CF, [=param_i=]
<td class>
<tr><td>标识符 [=resolves|resolving=] 到函数作用域变量 "x"，
其中标识符作为 [=memory view=] 表达式的 [=root identifier=] 出现，
MVE，而且在 [=type checking=] 期间没有对 MVE 调用 [=load rule=]
<td>
<td class>
<td class="nowrap">CF, CF
<td class>
<tr><td>标识符 [=resolves|resolving=] 到 [=const-declaration=]，[=override-declaration=]，
[=let-declaration=]，或非内置 [=formal parameter=] "x"
<td>Result
<td>X 是对应于 "x" 的节点
<td class="nowrap">CF, Result
<td class="nowrap">Result -> {CF, X}
<tr><td>标识符 [=resolves|resolving=] 到统一内置值 "x"
<td>
<td>
<td class="nowrap">CF, CF
<td>
<tr><td>标识符 [=resolves|resolving=] 到非统一内置值 "x"
<td>
<td>
<td class="nowrap">CF,<br>
[=MayBeNonUniform=]
<td>
<tr><td>标识符 [=resolves|resolving=] 到只读模块作用域变量 "x"
<td>
<td>
<td class="nowrap">CF, CF
<td>
<tr><td>标识符 [=resolves|resolving=] 到非只读模块作用域变量 "x"
其中标识符作为 [=memory view=] 表达式的 [=root identifier=] 出现，
MVE，在 [=type checking=] 期间对 MVE 调用了 [=load rule=]
<td>
<td>
<td class="nowrap">CF,<br>
[=MayBeNonUniform=]
<td>
<tr><td>标识符 [=resolves|resolving=] 到非只读模块作用域变量 "x"
其中标识符作为 [=memory view=] 表达式的 [=root identifier=] 出现，
MVE，而且在 [=type checking=] 期间没有对 MVE 调用 [=load rule=]
<td>
<td>
<td class="nowrap">CF,CF
<td>
<tr><td class="nowrap">op e，<br> 其中 op 是一元运算符
<td rowspan=2>
<td rowspan=2 class="nowrap">(CF, e) => (CF’, V)
<td rowspan=2 class="nowrap">CF’, V
<td rowspan=2>
<tr><td class="nowrap">e.field
<tr><td>e1 op e2，<br> 其中 op 是非短路二元运算符
<td rowspan=2> Result
<td rowspan=2 class="nowrap">(CF, e1) => (CF1, V1)<br>
(CF1, e2) => (CF2, V2)
<td rowspan=2 class="nowrap">CF2, Result
<td rowspan=2 class="nowrap">Result -> {V1, V2}
<tr><td class="nowrap">e1[e2]
</table>

以下内置输入变量被视为统一的：
- [=内置值/工作组ID=]
- [=内置值/工作组数目=]

所有其他的内置输入变量（参见 [=内置值=]）被视为非统一的。

注意：作者应避免将统一的内置值与其他非统一输入合并在一起，因为分析并不单独分析复合类型的组成部分。

<table class=‘data’>
<caption>[=LHSValue=]表达式的一致性规则</caption>
<thead>
<tr><th>表达式</th><th>新节点</th><th>递归分析</th><th>结果控制流节点、变量节点</th><th>新边
</thead>
<tr><td>标识符[=resolves|resolving=]到函数作用域变量"x"
<td>结果
<td>X是对应于在包含此表达式的语句的输出时"x"的值的节点。
<td class="nowrap">CF, 结果
<td class>结果 -> {CF, X}


  注意：*X*等价于*x*的*Vin*(*next*)<br>
  （参见[[#func-var-value-analysis]]）

<tr><td>标识符[=resolves|resolving=]到
[=const-declaration=]、[=override-declaration=]、[=let-declaration=]或[=formal parameter=] "x"
<td>
<td>X是对应于"x"的节点
<td class="nowrap">CF, X
<td>
<tr><td>标识符[=resolves|resolving=]到模块作用域变量"x"
<td>
<td>
<td class="nowrap">CF,<br>
[=MayBeNonUniform=]
<td>
<tr><td class="nowrap">e.字段
<td>
<td class="nowrap">[=LHSValue=]: (CF, e) => (CF1, L1)
<td class="nowrap">CF1, L1
<td>
<tr><td class="nowrap">e1[e2]
<td>
<td class="nowrap">[=LHSValue=]: (CF, e1) => (CF1, L1)<br>
(CF1, e2) => (CF2, V2)
<td class="nowrap">CF2, L1
<td class="nowrap">L1 -> V2
</table>

### 标注控制流中每个点的一致性 ### {#uniformity-optional-diagnosis-mode}

这整个小节是非规范性的。


如果实现者希望为开发者提供一个诊断模式，该模式可以显示整个着色器的控制流中的每个点是否是统一的（以及在那里调用要求统一性的函数是否有效），我们建议如下操作：
- 运行上一小节中描述的（强制的，规范性的）分析，并为每个函数保留图表。
- 反转所有这些图表中的所有边。
- 遍历每个函数，从入口点开始并且在访问所有调用方之前不访问任何函数：
    - 如果至少一个调用方中有非统一的参数，就从[=MayBeNonUniform=]添加一条边到每个参数。
    - 如果至少一个调用方中在非统一控制流中调用了该函数，则从[=MayBeNonUniform=]添加一条边到[=CF_start=]。
    - 查看从[=MayBeNonUniform=]可达的节点。每个被访问的节点都是表达式或控制流中的点，无法通过分析证明其统一性。

通过这些可达性分析未访问的任何节点，都可以通过分析证明是统一的（因此在那里调用导数或类似函数是安全的）。


注意：自底向上的分析仍然是必需的，因为它让我们知道在遇到调用时需要添加哪些边到图表中。

### 示例 ### {#uniformity-examples}

在后续示例中的图表使用以下规则表示节点：
* 矩形代表数值节点。
* 圆角矩形代表控制流节点。

#### 无效的 textureSample 函数调用 #### {#uniformity-example1}

这个例子展示了[[#texturesample|textureSample]]内置函数调用的一个非法使用。
函数调用发生在一个if语句内，该语句的条件依赖于一个非统一值（即内置值position）。
非法的依赖链以红色突出显示。

<div class='example wgsl' heading='WGSL invalid textureSample'>
  <xmp>
    @group(0) @binding(0) var t : texture_2d<f32>;
    @group(0) @binding(1) var s : sampler;

    @fragment
    fn main(@builtin(position) pos : vec4<f32>) {
      if (pos.x < 0.5) {
        // Invalid textureSample function call.
        _ = textureSample(t, s, pos.xy);
      }
    }
  </xmp>
</div>

<div class=example1>
  <figure>
    <figcaption>Uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_1.mmd.svg"></object>
  </figure>
</div>

示例同样表明，if语句后的控制流的一致性与if语句之前的一致性相同（CF_return连通到[=CF_start=]）。
也就是说，控制流在if语句之后再次变得一致（因为在入口点开头它被保证以一致的控制流开始）。
如果textureSample函数调用被移到if语句外面，那么程序将是有效的。
同样，如果if语句的条件是一个一致的值（例如，每次调用都从一个[=uniform buffer=]读取相同的值），程序也将是有效的。

#### 功能作用域变量一致性 #### {#uniformity-example2}

本例展示了依赖于函数作用域变量值的有效和无效[[#sync-builtin-functions|屏障]]函数调用。由于 x 的值来自可变模块作用域变量 a，因此 workgroupBarrier 是无效的。而 storageBarrier 是有效的，因为 x 的值来源于不可变的模块作用域变量 b。本例突出了[[#func-var-value-analysis|值分析]]能力，在函数作用域变量生命周期中区分不同统一性时段。此例也清楚地显示出，在第一个 [=statement/if=] 语句结束后，控制流再次变得一致。我们知道这一点，因为该部分图形与第二个 if 语句无关。

<div class='example wgsl' heading='WGSL using function variable'>
  <xmp>
    @group(0) @binding(0) var<storage, read_write> a : i32;
    @group(0) @binding(1) var<uniform> b : i32;

    @compute @workgroup_size(16,1,1)
    fn main() {
      var x : i32;
      x = a;
      if x > 0 {
        // Invalid barrier function call.
        workgroupBarrier();
      }
      x = b;
      if x < 0 {
        // Valid barrier function call.
        storageBarrier();
      }
    }
  </xmp>
</div>

<div class=example2>
  <figure>
    <figcaption>Uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_2.mmd.svg"></object>
  </figure>
</div>

注：子图仅为了便于理解而包含在示例中。


#### 综合价值分析的局限性 #### {#uniformity-example3}

均匀性分析的一个局限性是它无法独立跟踪复合值的组成部分。也就是说，任何非均匀的组件值的行为要求都会导致分析将整个复合值视为非均匀。这个例子说明了这个问题以及着色器作者可以使用的潜在解决方法，以避免这种局限。

<div class='example wgsl' heading='Invalid composite value WGSL'>
  <xmp>
    struct Inputs {
      // workgroup_id is a uniform built-in value.
      @builtin(workgroup_id) wgid : vec3<u32>,
      // local_invocation_index is a non-uniform built-in value.
      @builtin(local_invocation_index) lid : u32
    }

    @compute @workgroup_size(16,1,1)
    fn main(inputs : Inputs) {
      // This comparison is always uniform,
      // but the analysis cannot determine that.
      if inputs.wgid.x == 1 {
        workgroupBarrier();
      }
    }
  </xmp>
</div>

<div class=example2>
  <figure>
    <figcaption>Invalid uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_3.mmd.svg"></object>
  </figure>
</div>

分析这一限制的最简单方法是将复合体拆分，这样已知是均匀的值就与已知是非均匀的值分开了。在下面的替代WGSL中，将两个内置值分成单独的参数满足了均匀性分析。这可以通过图中从[=RequiredToBeUniform.S=]到[=MayBeNonUniform=]的路径缺失来看出来。

<div class='example wgsl' heading='Valid alternative WGSL'>
  <xmp>
    @compute @workgroup_size(16,1,1)
    fn main(@builtin(workgroup_id) wgid : vec3<u32>,
            @builtin(local_invocation_index) lid : u32) {
      // The uniformity analysis can now correctly determine this comparison is
      // always uniform.
      if wgid.x == 1 {
        // Valid barrier function call.
        workgroupBarrier();
      }
    }
  </xmp>
</div>

<div class=example3>
  <figure>
    <figcaption>Valid alternative uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_3b.mmd.svg"></object>
  </figure>
</div>

#### 循环中的一致性 #### {#uniformity-example4}

在这个例子中，一个循环中有一个无效的workgroupBarrier函数调用。尽管非一致内置值local_invocation_index出现在循环中的屏障之后，但它是最终原因。这是因为在后续的迭代中，工作组中的一些调用会提前退出循环，而其他调用尝试执行屏障。分析将迭代间的依赖关系建模为一条边，其中循环体开头的控制（CF_loop_body）依赖于循环体末尾的控制流（CF_after_if）。

<div class='example wgsl' heading='Loop uniformity WGSL'>
  <xmp>
    @compute @workgroup_size(16,1,1)
    fn main(@builtin(local_invocation_index) lid : u32) {
      for (var i = 0u; i < 10; i++) {
        workgroupBarrier();
        if (lid + i) > 7 {
          break;
        }
      }
    }
  </xmp>
</div>

<div class=example4>
  <figure>
    <figcaption>Uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_4.mmd.svg"></object>
  </figure>
</div>

#### 用户定义的函数调用 #### {#uniformity-example5}

该示例对[[#uniformity-example1|第一个示例]]进行了修改，但使用了用户自定义的函数调用。
分析过程将scale函数的两个参数的[=parameter return tag=]设置为[=ParameterReturnContentsRequiredToBeUniform=]。
这导致在main中，scale函数调用的返回值与内置值position之间形成一条路径。
该路径是从[=RequiredToBeUniform.S=]到[=MayBeNonUniform=]的整体非法路径的一个子路径。

<div class='example wgsl' heading='User-defined function call uniformity WGSL'>
  <xmp>
    fn scale(in1 : f32, in2 : f32) -> f32 {
      let v = in1 / in2;
      return v;
    }

    @group(0) @binding(0) var t : texture_2d<f32>;
    @group(0) @binding(1) var s : sampler;

    @fragment
    fn main(@builtin(position) pos : vec4<f32>) {
      let tmp = scale(pos.x, 0.5);
      if tmp > 1.0 {
        _ = textureSample(t, s, pos.xy);
      }
    }
  </xmp>
</div>

<div class=example5>
  <figure>
    <figcaption>Uniformity graph for scale</figcaption>
    <object type="image/svg+xml" data="img/uniformity_5scale.mmd.svg"></object>
  </figure>

  <figure>
    <figcaption>Uniformity graph for main</figcaption>
    <object type="image/svg+xml" data="img/uniformity_5main.mmd.svg"></object>
  </figure>
</div>

注：子图仅仅是为了便于理解而包含在示例中。

## 计算着色器和工作组 ## {#compute-shader-workgroups}

一组工作组（<dfn noexport for="compute shader stage">workgroup</dfn>）是一系列调用，它们并发执行一个[=compute shader stage=] [=entry point=]，并且共享对[=address spaces/workgroup=]地址空间中的着色器变量的访问。


对于计算着色器，工作组网格（<dfn noexport>workgroup grid</dfn>）是具有整数坐标*(i,j,k)*的点的集合，其中：
* 0 ≤ i < workgroup_size_x
* 0 ≤ j < workgroup_size_y
* 0 ≤ k < workgroup_size_z

其中*(workgroup_size_x, workgroup_size_y, workgroup_size_z)*是为入口点指定的[=attribute/workgroup_size=]属性的值。


每个工作组网格中的点都确切地有一个工作组中的调用。


一个调用的局部调用ID（<dfn noexport>local invocation ID</dfn>）是调用对应的工作组网格点的坐标三元组(i,j,k)。


当一个调用有[=local invocation ID=]时，它的局部调用索引（<dfn noexport>local invocation index</dfn>）是


i +
(j * workgroup_size_x) +
(k * workgroup_size_x * workgroup_size_y)


<p algorithm="local index range">请注意，如果一个工作组有|W|次调用，那么工作组中的每次调用|I|都有唯一的局部调用索引|L|(|I|)，使得0 ≤ |L|(|I|) < |W|，并且整个范围都被覆盖。</p>


当WebGPU实现从队列中移除一个调度命令并开始在GPU上指定的工作时，计算着色器开始执行。调度命令指定了一个调度大小（<dfn noexport>dispatch size</dfn>），这是一个整数三元组（<dfn>group_count_x</dfn>, <dfn>group_count_y</dfn>, <dfn>group_count_z</dfn>）表示要执行的工作组数，如下所述。


对于特定的调度，计算着色器网格（<dfn noexport>compute shader grid</dfn>）是具有整数坐标 (CSi,CSj,CSk) 的点的集合，其中：
* 0 ≤ CSi < workgroup_size_x × group_count_x
* 0 ≤ CSj < workgroup_size_y × group_count_y
* 0 ≤ CSk < workgroup_size_z × group_count_z

其中 workgroup_size_x，workgroup_size_y和workgroup_size_z与之前计算着色器入口点的相同。


计算着色器调度的执行工作是为计算着色器网格中的每个点精确地执行一次入口点的调用。


一个调用的全局调用ID（<dfn noexport>global invocation ID</dfn>）是调用对应的计算着色器网格点的坐标三元组。


调用被组织成工作组，以使每个调用的[=global invocation ID=] *(CSi, CSj, CSk)*映射到一个由<dfn noexport>workgroup ID</dfn>标识的单个工作组：
* ( ⌊ CSi ÷ workgroup_size_x ⌋,
* ⌊ CSj ÷ workgroup_size_y ⌋,
* ⌊ CSk ÷ workgroup_size_z ⌋)


和该工作组内的一个单独的调用，由[=local invocation ID=]标识：
* ( CSi mod workgroup_size_x ,
* CSj mod workgroup_size_y ,
* CSk mod workgroup_size_z )。


注意：工作组ID从(0,0,0)到([=group_count_x=] - 1, [=group_count_y=] - 1, [=group_count_z=] - 1)。


WebGPU不保证：
* 不同工作组的调用是否同时执行。也就是说，你无法假设多个工作组会同时执行。
* 一旦某个工作组的调用开始执行，其他工作组是否会被阻止执行。也就是说，你无法假设一次只有一个工作组执行。在工作组执行时，实现可能选择同时执行其他工作组，或其他排队但未被阻塞的工作。
* 某个特定工作组的调用是否会在另一个工作组的调用之前开始执行。也就是说，你无法假设工作组是按照特定顺序启动的。

## 片元着色器和助手调用 ## {#fragment-shaders-helper-invocations}

片元着色器阶段中的调用被划分为2x2的调用网格，网格内相邻调用在X和Y维度上具有邻接的[=内建值/位置|位置=]。每一个这样的网格被称为一个定义项（dfn标签且不导出）quad。quad在一些集体操作中可以协作（参见[[#derivatives]]）。


通常，[[WebGPU#fragment-processing|片元处理]]会为由[[WebGPU#rasterization|栅格化]]产生的每一个[=光栅化点=]创建一个片元着色器调用。有时，可能会因为不足的光栅化点而无法完全填充一个quad，例如在图形基元边缘的情况。当一个quad只有1、2或3个与光栅化点相对应的调用时，片段处理[=行为要求|将=]为quad中每个未填充位置创建一个定义项(helper invocation)。


helper invocation不会产生可观察的效果，除了帮助计算[[#derivatives|导数]]。因此，helper invocation受到以下限制：
* 禁止在[=地址空间/存储=]或[=地址空间/句柄=]地址空间中执行[=写访问|写访问=]（另见[[#memory-operation]]）。
* [[#atomic-builtin-functions|原子内建函数]][=行为要求|将=]返回[=不确定值|不确定的=]结果。
* [=入口点=]的[=返回值=]不会在[=GPURenderPipeline=]中继续被下游处理。

如果一个quad中的所有调用都成为helper invocation（例如，由于执行了一个[=statement/discard=]语句），那么该quad的执行可能会被终止；然而，这种终止不被视为产生[=均匀控制流|非均匀控制流=]。

## 集体操作 ## {#collective-operations}

### 障碍 ### {#barrier}

障碍是一种[[#sync-builtin-functions|内置同步函数]]，用于在程序中排序内存操作。
<dfn noexport>控制障碍</dfn>由相同[=计算着色器阶段/工作组=]中的所有调用执行，就好像它是并发执行的一样。
因此，控制障碍[=shader-creation error|必须=]只能在[=计算着色器阶段|计算=]着色器的[=统一控制流=]中执行。

### 衍生 ### {#derivatives}

一种<dfn noexport>偏导数</dfn>是沿着某个轴的值变化的速率。
在同一个[=quad=]内的片元着色器调用合作来计算近似偏导数。


用于计算导数的<dfn noexport>内置函数</dfn>有：
* [[#texturesample|textureSample]]、#texturesamplebias|textureSampleBias和[[#texturesamplecompare|textureSampleCompare]]
* [[#dpdx-builtin|dpdx]]、[[#dpdxCoarse-builtin|dpdxCoarse]]和[[#dpdxFine-builtin|dpdxFine]]
* [[#dpdy-builtin|dpdy]]、[[#dpdyCoarse-builtin|dpdyCoarse]]和[[#dpdyFine-builtin|dpdyFine]]
* [[#fwidth-builtin|fwidth]]、[[#fwidthCoarse-builtin|fwidthCoarse]]和[[#fwidthFine-builtin|fwidthFine]]

片段坐标的偏导数在以下内置函数的操作过程中隐式计算：


[[#texturesample|textureSample]]、
#texturesamplebias|textureSampleBias和
[[#texturesamplecompare|textureSampleCompare]]。

对于这些函数，偏导数帮助确定要采样的纹素的mip等级，或者在textureSampleCompare的情况下，采样并与参考值比较。


调用者指定值的偏导数由[[#derivative-builtin-functions]]中描述的内置函数计算：
* [[#dpdx-builtin|dpdx]]、[[#dpdxCoarse-builtin|dpdxCoarse]]和[[#dpdxFine-builtin|dpdxFine]]计算沿x轴的偏导数。
* [[#dpdy-builtin|dpdy]]、[[#dpdyCoarse-builtin|dpdyCoarse]]和[[#dpdyFine-builtin|dpdyFine]]计算沿y轴的偏导数。
* [[#fwidth-builtin|fwidth]]、[[#fwidthCoarse-builtin|fwidthCoarse]]和[[#fwidthFine-builtin|fwidthFine]] 计算与关联的x和y偏导数的曼哈顿距离。

因为相邻的调用合作计算导数，这些函数应该只在片元着色器中的[=uniform control flow=]中调用。
如果[[#uniformity|统一性分析]]无法证明这些函数的调用发生在统一控制流中，那么每次调用这些函数时，都会触发一个[=trigger/derivative_uniformity=] [=diagnostic=]。


如果在非统一控制流中调用了这些函数，则结果是一个[=indeterminate value=]。

## 浮点数计算 ## {#floating-point-evaluation}

WGSL遵循[[!IEEE-754|IEEE-754]]标准进行浮点运算，但有以下几点不同：
* 没有指定舍入模式。一个实现可能会向上或向下舍入数值。
* 不会生成浮点异常。
    * WGSL中的浮点运算将会产生一个中间结果，这个结果符合IEEE-754的规则，但IEEE-754要求的异常将会根据表达式是[=const-expression=]、[=override-expression=]还是[=runtime expression=]而映射到不同的行为。
    * IEEE-754定义了五种异常：
        * 非法操作。这些操作产生一个NaN值。非法操作的一个例子是0×∞。
        * 除以零。当在有限操作数上的操作被定义为有一个确切的无限结果时会发生这种情况。例如1÷0和log(0)。
        * 溢出。请参阅[[#floating-point-overflow]]。
        * 下溢。这发生在舍入或未舍入的结果是非常规的情况。
        * 不准确。当舍入结果与中间结果不同时，或者发生溢出时，就会发生这种情况。
    * 考虑对有限操作数的操作。 当且仅当IEEE-754要求操作发出非法操作、除以零或溢出异常时，操作产生溢出、无穷大或NaN。
* 可能不会生成信号NaN。 任何信号NaN都可以转换为安静的NaN。
* 在运行时之前生成的溢出、无穷大和NaN是错误。
    * [=Const-expressions=]和[=override-expressions=]在有限值上 [=behavioral requirement|will=]生成溢出、无穷大和NaN作为中间值，遵循IEEE-754的规则。
      * 注意：这条规则要求实现必须可靠地检测到溢出、无穷大和NaN，以便在这类表达式中达到精度限制，以便可以一致地生成错误。
    * 如果任何浮点类型的[=const-expression=]溢出或评估为NaN或无穷大，则会产生[=shader-creation error=]。
    * 如果任何浮点类型的[=override-expression=]溢出或评估为NaN或无穷大，则会产生[=pipeline-creation error=]。
* 实现可以假设运行时不存在溢出、无穷大和NaN。
    * 在这样的实现中，如果评估[=runtime expression=]的中间结果溢出，或生成无穷大或NaN，最终结果[=behavioral requirement|will=]是目标类型的一个[=indeterminate value=]。
    * 注意：这意味着某些函数（例如min和max）可能由于对NaN和无穷大的存在进行优化，而不会返回预期结果。
* 实现可能会忽略零的符号。 也就是说，正符号的零可能会像负符号的零一样行为，反之亦然。
* 将数值<dfn noexport title="flushed to zero">置零</dfn>是指将浮点类型的非规格化值替换为该类型的零值。
    * [[#floating-point-accuracy]]中列出的操作的任何输入或输出可能会被置零。
    * 此外，[[#pack-builtin-functions]]或[[#unpack-builtin-functions]]中列出的操作的中间值可能会被置零。
    * 其他操作需要保留非规格化数字。
* 操作的准确性在[[#floating-point-accuracy]]中给出。

### 浮点溢出 ### {#floating-point-overflow}

溢出的计算可能会舍入为无穷大或最近的有限值。
结果取决于溢出值的大小以及是否在着色器执行过程中进行计算。


对于浮点类型T，定义MAX(T)为T的最大正有限值，2<sup>EMAX(T)</sup>为T所能表示的最大2的幂次值。
特别地，EMAX([=f32=]) = 127，并且EMAX([=f16=]) = 15。


设X为一个浮点运算中的无限精度中间结果。
表达式的最终值通过中间值*X’和X’'*来确定，具体如下：


从X开始，通过舍入计算T中的X’：
* 如果X在T的有限范围内，则X’为X向上或向下舍入的结果。
* 如果X是NaN，则*X’*是NaN。
* 如果MAX(T) < X < 2<sup>EMAX(T)+1</sup>，则使用任何一种舍入方向：*X’为MAX(T)*或+∞。
* 如果2<sup>EMAX(T)+1</sup> ≤ X，则X’ = +∞。
    * 注意：这符合[[!IEEE-754|IEEE-754]]规则。
* 如果−MAX(T) > X > −2<sup>EMAX(T)+1</sup>，则使用任何一种舍入方向：*X’*为−*MAX(T)*或−∞。
* 如果−2<sup>EMAX(T)+1</sup> ≥ X，则X’ = −∞。
    * 注意：这符合IEEE-754规则。

从X’开始，计算表达式的最终值X’'，或检测程序错误：
* 如果*X’*是无穷大或NaN，则：
    * 如果表达式是一个[=const-expression=]，生成一个[=shader-creation error=]（着色器创建错误）。
    * 如果表达式是一个[=override-expression=]，生成一个[=pipeline-creation error=]（管线创建错误）。
    * 否则，表达式是一个[=runtime expression=]，*X’'*是一个[=indeterminate value=]（不确定值）。
* 否则X’’ = X’。


### 浮点数精确度 ### {#floating-point-accuracy}

<div algorithm="正确舍入">
设 |x| 是使用无限精度计算时某操作的精确实数值结果或无穷大的结果。
对于浮点类型 |T|，操作的<dfn>正确舍入</dfn>结果是：
* |x|，当 |x| 在 |T| 中时，
* 否则：
    * 大于 |x| 的 |T| 中最小的值，或
    * 小于 |x| 的 |T| 中最大的值。 </div>

即，结果可能会被向上或向下取整：
WGSL没有指定取整模式。


注意：浮点类型包括正无穷大和负无穷大，因此正确取整的结果可能是有限的或无限的。


对于浮点数x的最后一位单位，即<dfn noexport>ULP</dfn>，定义如下[[!Muller2005]]：
* 如果x在浮点类型的有限范围内，那么ULP(x)是 两个不相等的有限浮点数a和b之间的最小距离，使得a ≤ x ≤ b（即ulp(x) = min<sub>a,b</sub>|b - a|）。
* 否则，ULP(x)是|b - a|，其中b和a分别是最大和第二大的 可表示有限浮点值。

操作的准确性根据以下五种可能性提供：
* 正确结果（对于非浮点结果值）。
* [=正确取整=]。
* 一个绝对误差界限。
* 一个相对误差界限，表示为[=ULP=]。
* 一个表明准确性是<dfn noexport>继承自</dfn>的表达式。 也就是说，操作的准确性定义为评估给定WGSL表达式的准确性。 给定的表达式仅是函数的一种有效实现。 WebGPU的实现可能会以不同的方式实现操作，准确性更高 或对极端输入有更大的容忍。

当为操作指定了输入范围内的准确性时，
输入值超出该范围时，准确性是未定义的。


如果允许的结果超出了结果类型的有限范围，那么
将应用[[#floating-point-overflow]]中的规则。

#### 实浮点表达式的准确性 #### {#concrete-float-accuracy}

<table class=‘data’>
<caption>具体浮点操作的准确度</caption>
<thead>
<tr><th>表达式<th>f32的准确度<th>f16的准确度
</thead>


<tr><td>x + y<td colspan=2 style="text-align:left;">正确舍入
<tr><td>x - y<td colspan=2 style="text-align:left;">正确舍入
<tr><td>x * y<td colspan=2 style="text-align:left;">正确舍入
<tr><td>x / y<td>对于|y|范围在 [2<sup>-126</sup>, 2<sup>126</sup>]时,为2.5 ULP<td>对于|y|范围在 [2<sup>-14</sup>, 2<sup>14</sup>]时,为2.5 ULP
<tr><td>x % y<td colspan=2 style="text-align:left;">继承自 x - y * trunc(x/y)
<tr><td>-x<td colspan=2 style="text-align:left;">正确舍入


<tr><td>x == y<td colspan=2 style="text-align:left;">正确结果
<tr><td>x != y<td colspan=2 style="text-align:left;">正确结果
<tr><td>x < y<td colspan=2 style="text-align:left;">正确结果
<tr><td>x <= y<td colspan=2 style="text-align:left;">正确结果
<tr><td>x > y<td colspan=2 style="text-align:left;">正确结果
<tr><td>x >= y<td colspan=2 style="text-align:left;">正确结果
</table>


<table class=‘data’>
<caption>具体浮点内置函数的准确度</caption>
<thead>
<tr><th>内置函数<th>f32的准确度<th>f16的准确度
</thead>


<tr><td>abs(x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>acos(x)<td>
较差者为:
* 绝对误差 6.77×10<sup>-5</sup>
* 继承自 atan2(sqrt(1.0 - x * x), x)


  <td>较差者为:
   * 绝对误差 3.91&times;10<sup>-3</sup>
   * 继承自 `atan2(sqrt(1.0 - x * x), x)`
      <p>待办: 使用一致性测试检查此情况

<tr><td>acosh(x)<td colspan=2 style="text-align:left;">继承自 log(x + sqrt(x * x - 1.0))
<tr><td>asin(x)<td>
较差者为:
* 绝对误差 6.77×10<sup>-5</sup>
* 继承自 atan2(x, sqrt(1.0 - x * x))


  <td>较差者为:
   * 绝对误差 3.91&times;10<sup>-3</sup>
   * 继承自 `atan2(x, sqrt(1.0 - x * x))`
      <p>待办: 使用一致性测试检查此情况

<tr><td>asinh(x)<td colspan=2 style="text-align:left;">继承自 log(x + sqrt(x * x + 1.0))
<tr><td>atan(x)<td>4096 ULP<td>5 ULP
<tr><td>atan2(y, x)<td>对于|x|范围在 [2<sup>-126</sup>, 2<sup>126</sup>]且y有限和正常时,为4096 ULP<td>对于|x|范围在 [2<sup>-14</sup>, 2<sup>14</sup>]且y有限和正常时,为5 ULP
<tr><td>atanh(x)<td colspan=2 style="text-align:left;">继承自 log( (1.0 + x) / (1.0 - x) ) * 0.5
<tr><td>ceil(x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>clamp(x,low,high)<td colspan=2 style="text-align:left;">正确舍入。


无穷精确结果被计算为 `min(max(x,low),high)`，或者用3值的中位数公式计算。
当 `low > high`时，这两种方式可能有不同的结果。

如果 `x` 和 `low` 或 `high` 中的任何一个是非正规化的，结果可能是任意非正规化的值。
这是因为在非正规化输入上 `min` 和 `max` 函数可能的结果。

<tr><td>cos(x)
<td>当 x 在区间 [-π, π]内时，最大绝对误差为2<sup>-11</sup>
<td>当 x 在区间 [-π, π]内时，最大绝对误差为2<sup>-7</sup>
<tr><td>cosh(x)<td colspan=2 style="text-align:left;">继承自 (exp(x) + exp(-x)) * 0.5
<tr><td>cross(x, y)<td colspan=2 style="text-align:left;">继承自 (x[i] * y[j] - x[j] * y[i])
<tr><td>degrees(x)<td colspan=2 style="text-align:left;">继承自 x * 57.295779513082322865
<tr><td>determinant(m:mat2x2<T>)<br>
determinant(m:mat3x3<T>)<br>
determinant(m:mat4x4<T>)
<td colspan=2 style="text-align:left;">无限ULP。


 <div class=note>
 <span class=marker>笔记:</span>WebGPU实现应提供一个实际有用的行列式函数。

 在理想数学中，行列式是通过加法、减法和乘法运算计算得出。

 然而，GPU使用浮点数学，GPU实现的行列式函数更倾向于速度和简单性，而不是抵御溢出和误差的鲁棒性。

 例如，即使是2x2行列式的简单计算(`m[0][0] * m[1][1] - m[1][0] * m[0][1]`)
 也没有防止灾难性消除失误的保护措施。
 为2x2行列式提供更紧的误差界限是近期研究的主题[[Jeannerod2013]]。
 随着矩阵大小的增加，挑战迅速增加。

 WGSL中行列式没有有限误差范围反映了底层实现中同样的缺陷。
 </div>

<tr><td>distance(x, y)<td colspan=2 style="text-align:left;">继承自 length(x - y)
<tr><td>dot(x, y)<td colspan=2 style="text-align:left;">继承自 x[i] * y[i]之和
<tr><td>exp(x)<td>3 + 2 * |x| ULP<td>1 + 2 * |x| ULP
<tr><td>exp2(x)<td>3 + 2 * |x| ULP<td>1 + 2 * |x| ULP
<tr><td class="nowrap">faceForward(x, y, z)<td colspan=2 style="text-align:left;">继承自 select(-x, x, dot(z, y) < 0.0)
<tr><td>floor(x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>fma(x, y, z)<td colspan=2 style="text-align:left;">继承自 x * y + z
<tr><td>fract(x)<td colspan=2 style="text-align:left;">继承自 x - floor(x)
<tr><td>frexp(x)<td colspan=2 style="text-align:left;">当 x 为零或正常时，正确舍入。
<tr><td>inverseSqrt(x)<td colspan=2 style="text-align:left;">2 ULP
<tr><td>ldexp(x, y)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>length(x)<td colspan=2 style="text-align:left;">在向量情况下继承自 sqrt(dot(x, x))，在标量情况下继承自 sqrt(x*x)。
<tr><td>log(x)
<td>当 x 在区间 [0.5, 2.0]内时，最大绝对误差为2<sup>-21</sup>。<br>
当 x 在区间 [0.5, 2.0]外时，为3 ULP。<br>
<td>当 x 在区间 [0.5, 2.0]内时，最大绝对误差为2<sup>-7</sup>。<br>
当 x 在区间 [0.5, 2.0]外时，为3 ULP。<br>
<tr><td>log2(x)
<td>当 x 在区间 [0.5, 2.0]内时，最大绝对误差为2<sup>-21</sup>。<br>
当 x 在区间 [0.5, 2.0]外时，为3 ULP。<br>
<td>当 x 在区间 [0.5, 2.0]内时，最大绝对误差为2<sup>-7</sup>。<br>
当 x 在区间 [0.5, 2.0]外时，为3 ULP。<br>
<tr><td>max(x, y)<td colspan=2 style="text-align:left;">正确舍入
<p>如果 x 和 y 都是非正规化的，结果可能是任意输入。
<tr><td>min(x, y)<td colspan=2 style="text-align:left;">正确舍入。
<p>如果 x 和 y 都是非正规化的，结果可能是任意输入。
<tr><td>mix(x, y, z)<td colspan=2 style="text-align:left;">继承自 x * (1.0 - z) + y * z
<tr><td>modf(x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>normalize(x)<td colspan=2 style="text-align:left;">继承自 x / length(x)


<tr><td>pack4x8snorm(x)<td colspan=2 style="text-align:left;">正确舍入的中间值。正确结果。
<tr><td>pack4x8unorm(x)<td colspan=2 style="text-align:left;">正确舍入的中间值。正确结果。
<tr><td>pack2x16snorm(x)<td colspan=2 style="text-align:left;">正确舍入的中间值。正确结果。
<tr><td>pack2x16unorm(x)<td colspan=2 style="text-align:left;">正确舍入的中间值。正确结果。
<tr><td>pack2x16float(x)<td colspan=2 style="text-align:left;">正确舍入的中间值。正确结果。


<tr><td>pow(x, y)<td colspan=2 style="text-align:left;">继承自 exp2(y * log2(x))
<tr><td>quantizeToF16(x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>radians(x)<td colspan=2 style="text-align:left;">继承自 x * 0.017453292519943295474
<tr><td>reflect(x, y)<td colspan=2 style="text-align:left;">继承自 x - 2.0 * dot(x, y) * y
<tr><td>refract(x, y, z)<td colspan=2 style="text-align:left;">继承自 z * x - (z * dot(y, x) + sqrt(k)) * y,<br>其中 k = 1.0 - z * z * (1.0 - dot(y, x) * dot(y, x))<br>如果 k < 0.0 结果精确地为 0.0
<tr><td>round(x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>sign(x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>sin(x)
<td>当 x 在区间 [-π, π]内时，最大绝对误差为2<sup>-11</sup>
<td>当 x 在区间 [-π, π]内时，最大绝对误差为2<sup>-7</sup>
<tr><td>sinh(x)<td colspan=2 style="text-align:left;">继承自 (exp(x) - exp(-x)) * 0.5
<tr><td>saturate(x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>smoothstep(low, high, x)<td colspan=2 style="text-align:left;">继承自 t * t * (3.0 - 2.0 * t),<br>其中 t = clamp((x - low) / (high - low), 0.0, 1.0)
<tr><td>sqrt(x)<td colspan=2 style="text-align:left;">继承自 1.0 / inverseSqrt(x)
<tr><td>step(edge, x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>tan(x)<td colspan=2 style="text-align:left;">继承自 sin(x) / cos(x)
<tr><td>tanh(x)<td colspan=2 style="text-align:left;">继承自 sinh(x) / cosh(x)
<tr><td>transpose(x)<td colspan=2 style="text-align:left;">正确舍入
<tr><td>trunc(x)<td colspan=2 style="text-align:left;">正确舍入


<tr><td>unpack4x8snorm(x)<td>3 ULP<td>不适用
<tr><td>unpack4x8unorm(x)<td>3 ULP<td>不适用
<tr><td>unpack2x16snorm(x)<td>3 ULP<td>不适用
<tr><td>unpack2x16unorm(x)<td>3 ULP<td>不适用
<tr><td>unpack2x16float(x)<td>正确舍入<td>不适用


</table>

#### AbstractFloat 表达式的精确度 #### {#abstract-float-accuracy}

[=AbstractFloat=]操作的准确性如下：
* 当相应的[=f32=]操作要求正确结果时，需要正确的结果。
* 当相应的[=f32=]操作要求正确舍入的结果时，需要正确舍入的结果。
* 否则，相应[=f32=]操作的误差是绝对误差、相对误差、来自潜在实现的继承误差或这些因素的组合。 在这种情况下，[=AbstractFloat=]的误差是无限的。
    * 然而，[=AbstractFloat=]操作的误差应该最多只有相应[=f32=]操作的误差，以绝对值来说。
    * 这个建议意在避免意外：当类型从f32变为AbstractFloat时，表达式的准确性不应该降低。
    * 这个操作可能在WebAssembly [[WASM-CORE-2]]或ECMAScript [[ECMASCRIPT]]环境中评估， 而这些规范并未在许多相应的数值计算中指定误差界限。 例如，ECMAScript规定许多浮点操作为[[ECMASCRIPT#sec-terms-and-definitions-implementation-approximated|实现近似]]。 鼓励实现努力接近理想，但没有规定严格的要求。

<div class=note algorithm="ulp translation">
<span class=marker>注：</span>给定的绝对误差界限用ULP表示时，严重依赖于底层浮点类型。


假设[=AbstractFloat=]的[=ULP=]值与[[!IEEE-754|IEEE-754]]二进制64类型完全相同。


对于一个f32值的一[=ULP=]是IEEE 754二进制64值的1 ULP的2<sup>29</sup>倍，
因为二进制64格式的有效数字比f32类型的有效数字长29位。


例如，假设一个操作的真实结果值是|x|，但它被计算为<var>x’</var>。
如果其误差|x|-<var>x’</var>是f32中的3 ULP，则同样的绝对误差|x|-<var>x’</var>，
在AbstractFloat中是3·2<sup>29</sup> ULP。
</div>

### 重联和融合 ### {#reassociation-and-fusion}

<dfn noexport>重组</dfn>是指重新排序表达式中的运算，以便在精确计算时答案保持不变。例如：
* (a + b) + c 重组为 a + (b + c)
* (a - b) + c 重组为 (a + c) - b
* (a * b) / c 重组为 (a / c) * b

然而，当在浮点数中计算时，结果可能并不相同。
重组后的结果可能因为近似计算而不准确，或者在计算中间结果时可能引发溢出或NaN。


一个实现可以重组运算。


如果转换后的表达式至少与原始表达式一样准确，那么实现可以融合运算。
例如，一些融合乘加操作的实现可能比先乘后加更准确。

### 浮点数转换 ### {#floating-point-conversion}

在本节中，浮点类型可以是以下任一种：
* WGSL中的[=f32=]、[=f16=]和[=AbstractFloat=]类型。
* 对应于[[!IEEE-754|IEEE-754]]浮点标准定义的二进制格式的假设类型。

注意：回想一下，WGSL中的[=f32=]类型对应于IEEE-754二进制32格式，而[=f16=]类型对应于IEEE-754二进制16格式。


<dfn noexport>标量浮点到整数转换</dfn>算法如下：
<blockquote algorithm="convert a float value to an integral value">
将浮点标量值 |X| 转换为[=integer scalar=]类型 |T|：
* 如果 |X| 的原始值在目标类型 |T| 中可以精准表达，那么结果就是该值。
* 否则，结果是 |T| 中最接近=truncate=的值。

</blockquote>


注意：换句话说，浮点到整数转换是向零取整，然后在目标类型中进行饱和处理。


<div class=note><span class=marker>注意：</span>例如：
* 3.9f 转换为 [=u32=] 是 3u
* -1f 转换为 [=u32=] 是 0u
* 1e20f 转换为 [=u32=] 是 u32 的最大值，4294967295u
* -3.9f 转换为 [=i32=] 是 -3i
* 1e20f 转换为 [=i32=] 是 i32 的最大值，2147483647i
* -1e20f 转换为 [=i32=] 是 i32 的最小值，i32(-2147483648) </div>

注意：没有从 [=AbstractFloat=] 直接转换到整数标量类型的方法。
所有的转换首先都会转换到另一种浮点类型（通常是 [=f32=]）。


<dfn noexport>数值标量到浮点数的转换</dfn>算法是：
<blockquote>
当将一个 [=numeric scalar=] 值转换成浮点类型时：
    * 如果原始值在目标类型中能被精确表示，那么结果就是该值。
        * 另外，如果原始值为零且为 [=integer scalar=] 类型，则结果值的符号位为零。
    * 否则，原始值无法被精确表示。
        * 如果原始值不同于但位于目标类型中两个相邻的有限值之间， 那么结果是这两个值中的一个。 WGSL 没有规定选择较大还是较小的可表示值， 而且不同的此类转换实例可能会选择不同的值。
        * 否则，原始值超出了目标类型的有限范围：
            * 如果原始表达式是 [=const-expression=]，则会产生[=shader-creation error=]（着色器创建错误）。
            * 如果原始表达式是 [=override-expression=]，则会产生[=pipeline-creation error=]（渲染管线创建错误）。
            * 否则转换按以下步骤进行：
                1. 将 |X| 设置为原始值。
                2. 如果源类型的尾数位比目标类型多， 源值的额外尾数位可能会被丢弃（即视为0）。 相应地更新 |X|。
                3. 如果 |X| 是目标类型的最正或最负正常值，那么结果是 |X|。
                4. 否则，结果是目标类型的无穷大值，符号与 |X| 相同。
        * 否则，如果原始值是源类型的 NaN，则结果是目标类型中的 NaN。
</blockquote>

注意：整数值可能位于两个相邻可表示浮点值之间。特别是，[=f32=]类型使用23个显式小数位。此外，当浮点值位于正常范围内（指数不是极端值）时，尾数就是小数位集合加上最高有效位位置23的额外1位。例如，2<sup>28</sup>和1+2<sup>28</sup>这两个整数都映射到相同的浮点值：最低有效位1的差异无法通过浮点格式表示。这种碰撞发生在至少2<sup>25</sup>数量级的相邻整数对上。


注意：当原始类型是[=i32=]或[=u32=]之一，且目标类型是[=f32=]时，原始值始终在目标类型的范围内。


注意：当源类型是指数和尾数位数少于目标浮点类型的浮点类型时，原始值始终在目的类型的范围内。

# 关键词和标记总结 # {#grammar}

## 关键词总结 ## {#keyword-summary}

* <dfn for=syntax_kw noexport>`alias`</dfn>
* <dfn for=syntax_kw noexport>`break`</dfn>
* <dfn for=syntax_kw noexport>`case`</dfn>
* <dfn for=syntax_kw noexport>`const`</dfn>
* <dfn for=syntax_kw noexport>`const_assert`</dfn>
* <dfn for=syntax_kw noexport>`continue`</dfn>
* <dfn for=syntax_kw noexport>`continuing`</dfn>
* <dfn for=syntax_kw noexport>`default`</dfn>
* <dfn for=syntax_kw noexport>`diagnostic`</dfn>
* <dfn for=syntax_kw noexport>`discard`</dfn>
* <dfn for=syntax_kw noexport>`else`</dfn>
* <dfn for=syntax_kw noexport>`enable`</dfn>
* <dfn for=syntax_kw noexport>`false`</dfn>
* <dfn for=syntax_kw noexport>`fn`</dfn>
* <dfn for=syntax_kw noexport>`for`</dfn>
* <dfn for=syntax_kw noexport>`if`</dfn>
* <dfn for=syntax_kw noexport>`let`</dfn>
* <dfn for=syntax_kw noexport>`loop`</dfn>
* <dfn for=syntax_kw noexport>`override`</dfn>
* <dfn for=syntax_kw noexport>`requires`</dfn>
* <dfn for=syntax_kw noexport>`return`</dfn>
* <dfn for=syntax_kw noexport>`struct`</dfn>
* <dfn for=syntax_kw noexport>`switch`</dfn>
* <dfn for=syntax_kw noexport>`true`</dfn>
* <dfn for=syntax_kw noexport>`var`</dfn>
* <dfn for=syntax_kw noexport>`while`</dfn>

## 保留字 ## {#reserved-words}

保留字是为将来使用而保留的[=token=]。
WGSL 模块[=shader-creation error|不得=]包含保留字。


以下是保留字：

<pre class=include>
path: wgsl.reserved.bs.include
</pre>

## 句法标记 ## {#syntactic-tokens}

一个<dfn>语法记号</dfn>是一系列特殊代码点，用途包括：


拼写表达式操作符，或
作为标点符号：用来组合、排列或分隔其他语法元素。

语法记号包括：

* <dfn for=syntax_sym lt='and' noexport>`'&'` (Code point: `U+0026`)</dfn>
* <dfn for=syntax_sym lt='and_and' noexport>`'&&'` (Code points: `U+0026` `U+0026`)</dfn>
* <dfn for=syntax_sym lt='arrow' noexport>`'->'` (Code points: `U+002D` `U+003E`)</dfn>
* <dfn for=syntax_sym lt='attr' noexport>`'@'` (Code point: `U+0040`)</dfn>
* <dfn for=syntax_sym lt='forward_slash' noexport>`'/'` (Code point: `U+002F`)</dfn>
* <dfn for=syntax_sym lt='bang' noexport>`'!'` (Code point: `U+0021`)</dfn>
* <dfn for=syntax_sym lt='bracket_left' noexport>`'['` (Code point: `U+005B`)</dfn>
* <dfn for=syntax_sym lt='bracket_right' noexport>`']'` (Code point: `U+005D`)</dfn>
* <dfn for=syntax_sym lt='brace_left' noexport>`'{'` (Code point: `U+007B`)</dfn>
* <dfn for=syntax_sym lt='brace_right' noexport>`'}'` (Code point: `U+007D`)</dfn>
* <dfn for=syntax_sym lt='colon' noexport>`':'` (Code point: `U+003A`)</dfn>
* <dfn for=syntax_sym lt='comma' noexport>`','` (Code point: `U+002C`)</dfn>
* <dfn for=syntax_sym lt='equal' noexport>`'='` (Code point: `U+003D`)</dfn>
* <dfn for=syntax_sym lt='equal_equal' noexport>`'=='` (Code points: `U+003D` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='not_equal' noexport>`'!='` (Code points: `U+0021` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='greater_than' noexport>`'>'` (Code point: `U+003E`)</dfn> (also <dfn for=syntax_sym lt='_greater_than' noexport>`_greater_than`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='greater_than_equal' noexport>`'>='` (Code points: `U+003E` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_greater_than_equal' noexport>`_greater_than_equal`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='shift_right' noexport>`'>>'` (Code point: `U+003E` `U+003E`)</dfn> (also <dfn for=syntax_sym lt='_shift_right' noexport>`_shift_right`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='less_than' noexport>`'<'` (Code point: `U+003C`)</dfn> (also <dfn for=syntax_sym lt='_less_than' noexport>`_less_than`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='less_than_equal' noexport>`'<='` (Code points: `U+003C` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_less_than_equal' noexport>`_less_than_equal`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='shift_left' noexport>`'<<'` (Code points: `U+003C` `U+003C`)</dfn> (also <dfn for=syntax_sym lt='_shift_left' noexport>`_shift_left`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='modulo' noexport>`'%'` (Code point: `U+0025`)</dfn>
* <dfn for=syntax_sym lt='minus' noexport>`'-'` (Code point: `U+002D`)</dfn>
* <dfn for=syntax_sym lt='minus_minus' noexport>`'--'` (Code points: `U+002D` `U+002D`)</dfn>
* <dfn for=syntax_sym lt='period' noexport>`'.'` (Code point: `U+002E`)</dfn>
* <dfn for=syntax_sym lt='plus' noexport>`'+'` (Code point: `U+002B`)</dfn>
* <dfn for=syntax_sym lt='plus_plus' noexport>`'++'` (Code points: `U+002B` `U+002B`)</dfn>
* <dfn for=syntax_sym lt='or' noexport>`'|'` (Code point: `U+007C`)</dfn>
* <dfn for=syntax_sym lt='or_or' noexport>`'||'` (Code points: `U+007C` `U+007C`)</dfn>
* <dfn for=syntax_sym lt='paren_left' noexport>`'('` (Code point: `U+0028`)</dfn>
* <dfn for=syntax_sym lt='paren_right' noexport>`')'` (Code point: `U+0029`)</dfn>
* <dfn for=syntax_sym lt='semicolon' noexport>`';'` (Code point: `U+003B`)</dfn>
* <dfn for=syntax_sym lt='star' noexport>`'*'` (Code point: `U+002A`)</dfn>
* <dfn for=syntax_sym lt='tilde' noexport>`'~'` (Code point: `U+007E`)</dfn>
* <dfn for=syntax_sym lt='underscore' noexport>`'_'` (Code point: `U+005F`)</dfn>
* <dfn for=syntax_sym lt='xor' noexport>`'^'` (Code point: `U+005E`)</dfn>
* <dfn for=syntax_sym lt='plus_equal' noexport>`'+='` (Code points: `U+002B` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='minus_equal' noexport>`'-='` (Code points: `U+002D` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='times_equal' noexport>`'*='` (Code points: `U+002A` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='division_equal' noexport>`'/='` (Code points: `U+002F` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='modulo_equal' noexport>`'%='` (Code points: `U+0025` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='and_equal' noexport>`'&='` (Code points: `U+0026` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='or_equal' noexport>`'|='` (Code points: `U+007C` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='xor_equal' noexport>`'^='` (Code points: `U+005E` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='shift_right_assign' noexport>`'>>='` (Code point: `U+003E` `U+003E` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_shift_right_assign' noexport>`_shift_right_assign`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='shift_left_assign' noexport>`'<<='` (Code points: `U+003C` `U+003C` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_shift_left_assign' noexport>`_shift_left_assign`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='_template_args_end' noexport>`_template_args_end`</dfn>
    * 文本：'>'（代码点：U+003E）
    * 这个标记在文本上与[=syntax_sym/greater_than=]句法标记相同。
    * 它由模板列表消歧生成，并且作为模板列表中的最后一个标记使用。
* <dfn for=syntax_sym lt='_template_args_start' noexport>`_template_args_start`</dfn>
    * 文本：'<'（代码点：U+003C）
    * 从文本上看，这个记号与[=syntax_sym/less_than=]句法记号相同。
    * 它是由模板列表消除歧义生成的，并且用作模板列表中的第一个记号。
* <dfn for=syntax_sym lt='_disambiguate_template' noexport>`_disambiguate_template`</dfn>
    * 文本：无
    * 此标记指示解析器扫描模板列表。
    * 它触发模板列表消歧。

## 上下文依赖的名称标记 ## {#context-dependent-name-tokens}

这一节列出了作为[=上下文相关名称=]使用的标记。


[=语法/属性=]名称包括：

* `'align'`
* `'binding'`
* `'builtin'`
* `'compute'`
* `'const'`
* `'fragment'`
* `'group'`
* `'id'`
* `'interpolate'`
* `'invariant'`
* `'location'`
* `'size'`
* `'vertex'`
* `'workgroup_size'`

诊断过滤器的严重性控制名称包括：

<pre class=include>
path: syntax/severity_control_name.syntax.bs.include
</pre>

有效的[=enable-extension=]名称列在[[#enable-extensions-sec]]中，但一般与[=identifier=]的格式相同：

<pre class=include>
path: syntax/enable_extension_name.syntax.bs.include
</pre>

没有所谓的[=language extension=]名称，但它们的形式与[=identifier=]相同：
<pre class=include>
path: syntax/software_extension_name.syntax.bs.include
</pre>

[=swizzle=] 名称用于[[#vector-access-expr|向量访问表达式]]中：

<pre class=include>
path: syntax/swizzle_name.syntax.bs.include
</pre>

# 内置函数 # {#builtin-functions}

某些功能是[=预声明的=]，由实现提供，并因此总是可用于WGSL模块中。这些被称为<dfn noexport>内建函数</dfn>。


一个内建函数是一个函数的集合，它们都有相同的名字，但根据它们的[=形式参数=]的数量、顺序和类型来区分。这些不同的函数变体称为[=重载=]。


注意：每个[=用户定义的函数=]只有一个[=重载=]。


下面通过以下方式描述了每个[=重载=]：
* 如果有的话，类型参数化。
* 内建函数名称，带圆括号的[=形式参数=]列表，以及可选的[=返回类型=]。
* 这个函数重载的行为。

在调用内建函数时，所有传递给函数的参数都会在函数评估开始前被评估。
参见[[#function-calls]]。

## 内置构造函数 ## {#constructor-builtin-function}

一种<dfn noexport>值构造函数</dfn>内建函数会显式地创建一个给定类型的值。


WGSL为所有的[=predeclared=]类型和所有的[=constructible=] [=structure=]类型提供了值构造函数。
构造函数内建功能的拼写与类型相同。
在使用这种内建函数的任何地方，[=identifier=] [=shader-creation error|must=]需要在该类型的[=scope=]内，并且[=identifier=] [=shader-creation error|must not=] [=resolve=]为其他的声明。


注意：由[[#frexp-builtin|frexp]]、[[#modf-builtin|modf]]和[[#atomic-rmw|atomicCompareExchangeWeak]]返回的结构类型不能在WGSL模块中编写。


注意：在WGSL文本的那个声明中，类型的值声明需要是有效的。


WGSL提供了两种值构造函数：
* [[#zero-value-builtin-function|零值构造函数]]
* [[#value-constructor-builtin-function|值构造函数]]（同样提供了转换功能）

### 零值内置函数 ### {#zero-value-builtin-function}

每一种[=type/concrete=]、[=constructible=]的类型T都有一个独特的<dfn noexport>零值</dfn>，以及一个对应的内置函数，用WGSL表示就是类型名称后跟一个空的括号对：类型T ()。


零值定义如下：
* bool() 为 false
* i32() 为 0
* u32() 为 0
* f32() 为 0.0
* f16() 为 0.0
* 具有N个分量的向量类型T的零值是N个分量中每一个都是T的零值的向量。
* 一个C列R行的矩阵类型T的零值是一个这样维度的矩阵，且其填充的是T的零值。
* 一个可构造的N元素数组，其元素类型为E，它的零值是一个N个元素的数组，而每个元素都是E的零值。
* 一个可构造的结构体类型S的零值是一个结构体值S，其成员都是零值。

注意：WGSL中没有为[=atomic types=]（原子类型）、[=runtime-sized=]（运行时大小）数组或其他非[=constructible=]（可构造）类型提供零值内置函数。

<table class=‘data builtin’>
<tr><td style="width:10%">过载
<td>
<xmp>@const @must_use fn T() -> T</xmp>
<tr><td>参数化
<td>T 是一个[=type/concrete=] [=constructible=] 类型。<br>
<tr><td>描述
<td>构造类型 T 的[=zero value=]（零值）。
</table>


注意：AbstractInt 的填充零向量可以写作 vec2()、vec3() 和 vec4()。

<div class='example' heading="Zero-valued vectors">
  <xmp>
    vec2<f32>()                 // The zero-valued vector of two f32 components.
    vec2<f32>(0.0, 0.0)         // The same value, written explicitly.

    vec3<i32>()                 // The zero-valued vector of three i32 components.
    vec3<i32>(0, 0, 0)          // The same value, written explicitly.
  </xmp>
</div>

<div class='example' heading="Zero-valued arrays">
  <xmp>
    array<bool, 2>()               // The zero-valued array of two booleans.
    array<bool, 2>(false, false)   // The same value, written explicitly.
  </xmp>
</div>

<div class='example wgsl global-scope' heading="Zero-valued structures">
  <xmp>
    struct Student {
      grade: i32,
      GPA: f32,
      attendance: array<bool,4>
    }

    fn func() {
      var s: Student;

      // The zero value for Student
      s = Student();

      // The same value, written explicitly.
      s = Student(0, 0.0, array<bool,4>(false, false, false, false));

      // The same value, written with zero-valued members.
      s = Student(i32(), f32(), array<bool,4>());
    }
  </xmp>
</div>

### 值构造器内置函数 ### {#value-constructor-builtin-function}

以下小节中定义的内置函数通过以下方式创建一个[=可构建的=]值：
* 复制相同类型的现有值（即身份函数），或者
* 从明确的组件列表中创建一个复合值。
* 从另一种值类型转换。

矢量和矩阵形式从各种组件和子矢量组合中构建矢量和矩阵值，这些组件和子矢量具有匹配的组件类型。
在构造矢量和矩阵时有[=重载=]方法，这些方法指定了目标类型的维度，而无需指定组件类型；组件类型是根据构造函数参数推断出来的。

#### `array` #### {#array-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn array<T, N>(e1 : T, …, eN : T) -> array<T, N>
</xmp>
<tr><td>参数化
<td>T 是 [=type/concrete=]（具体类型）并且 [=constructible=]（可构造的）
<tr><td>描述
<td>从元素构造一个 [=array=]（数组）。


  注意：array&lt;|T|,|N|&gt; 是 [=constructible=]（可构造的），因为其 [=element count=]（元素数量）
  等于构造函数的参数数量，因此在 [=shader module creation|shader-creation=]（着色器模块创建）时完全确定。

</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn array(e1 : T, …, eN : T) -> array<T, N>
</xmp>
<tr><td>参数化
<td>T 是 [=constructible=]（可构造的）
<tr><td>描述
<td>从元素构造一个 [=array=]（数组）。


  组件类型根据元素的类型进行推断。
  数组的大小由元素的数量确定。

</table>

#### `bool` #### {#bool-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>@const @must_use fn bool(e : T) -> bool</xmp>
<tr><td>参数化
<td>T 是一个 [=type/concrete=] [=scalar=] 类型。
<tr><td>描述
<td>构造一个 [=bool=] 值。


  如果 `T` 是 [=bool=]，这是一个恒等操作。<br>
  否则，这是一个布尔类型的强制转换。
  如果 `e` 是一个 [=zero value=]（或者对于浮点类型是 -0.0），结果是 `false`，其它情况下结果是 `true`。

</table>

#### `f16` #### {#f16-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">负载过多
<td>
<xmp>@const @must_use fn f16(e : T) -> f16</xmp>
<tr><td>参数化
<td>T 是一种[=type/concrete=] [=scalar=]类型
<tr><td>描述
<td>构造一个[=f16=]值。


  如果 `T` 是[=f16=]，这是一个恒等操作。<br>
  如果 `T` 是[[#integer-types|整数类型]]或[=f32=]，`e` 被转换为[=f16=]（包括非法转换）。<br>
  如果 `T` 是[=bool=]，结果是如果 `e` 是 `true` 则为 `1.0h`，否则为 `0.0h`。

</table>

#### `f32` #### {#f32-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>@const @must_use fn f32(e : T) -> f32</xmp>
<tr><td>参数化
<td>T 是一个[=类型/具体的=] [=标量=] 类型
<tr><td>描述
<td>构造一个[=f32=]值。


  如果 `T` 是 [=f32=]，这是一个同一性操作。<br>
  如果 `T` 是一个[[#integer-types|整数类型]]或者 [=f16=]，`e` 被转换为 [=f32=]（包括无效的转换）。<br>
  如果 `T` 是 [=bool=]，结果是 `1.0f` 如果 `e` 是 `true`，否则是 `0.0f`。

</table>

#### `i32` #### {#i32-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>@const @must_use fn i32(e : T) -> i32</xmp>
<tr><td>参数化
<td>T 是一个[=type/concrete=] [=标量=]类型
<tr><td>描述
<td>构造一个[=i32=]值。


  如果 `T` 是[=i32=]，这是一个恒等操作。<br>
  如果 `T` 是[=u32=]，这是对位的重新解释（即，结果是在[=i32=]中具有与 `e` 相同位模式的唯一值）。<br>
  如果 `T` 是一个[[#floating-point-types|浮点类型]]，`e` 被[=标量浮点到整数转换|转换=]为[=i32=]，向零方向取整。<br>
  如果 `T` 是[=bool=]，当 `e` 为 `true` 时结果为 `1i`，否则为 `0i`。

</table>

#### `mat2x2` #### {#mat2x2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>
          @const @must_use fn mat2x2<T>(e : mat2x2<S>) -> mat2x2<T>
          @const @must_use fn mat2x2(e : mat2x2<S>) -> mat2x2<S>
        </xmp>
  <tr><td>参数化
      <td>`T` 是 [=f16=] 或 [=f32=]<br>
      `S` 是 [FLOATSCALAR]
  <tr><td>描述
      <td>为2x2列主序 [=matrix=] 构造器。

      如果 `T` 与 `S` 不匹配，将进行#浮点数转换|转换。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>
          @const @must_use fn mat2x2<T>(v1 : vec2<T>, v2 : vec2<T>) -> mat2x2<T>
          @const @must_use fn mat2x2(v1 : vec2<T>, v2 : vec2<T>) -> mat2x2<T>
        </xmp>
  <tr><td>参数化
      <td>`T` 是 [FLOATSCALAR]
  <tr><td>描述
      <td>从列向量构造2x2列主序 [=matrix=]。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>
          @const @must_use fn mat2x2<T>(e1 : T, e2 : T, e3 : T, e4 : T) -> mat2x2<T>
          @const @must_use fn mat2x2(e1 : T, e2 : T, e3 : T, e4 : T) -> mat2x2<T>
        </xmp>
  <tr><td>参数化
      <td>`T` 是 [FLOATSCALAR]
  <tr><td>描述
      <td>从元素构造2x2列主序 [=matrix=]。

          等同于 mat2x2(vec2(e1,e2), vec2(e3,e4))。
</table>

#### `mat2x3` #### {#mat2x3-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat2x3<T>(e : mat2x3<S>) -> mat2x3<T>
@const @must_use fn mat2x3(e : mat2x3<S>) -> mat2x3<S>
</xmp>
<tr><td>参数化
<td>T 是 [=f16=] 或 [=f32=]<br>
S 是 [FLOATSCALAR]
<tr><td>描述
<td>构造一个2x3列主序 [=matrix=] 的构造器。


  如果 `T` 与 `S` 不匹配，则会发生 [[#floating-point-conversion|转换]]。

</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat2x3<T>(v1 : vec3<T>, v2 : vec3<T>) -> mat2x3<T>
@const @must_use fn mat2x3(v1 : vec3<T>, v2 : vec3<T>) -> mat2x3<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从列向量构造一个2x3列主序 [=matrix=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat2x3<T>(e1 : T, …, e6 : T) -> mat2x3<T>
@const @must_use fn mat2x3(e1 : T, …, e6 : T) -> mat2x3<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从元素构造一个2x3列主序 [=matrix=]。


      与 mat2x3(vec3(e1,e2,e3), vec3(e4,e5,e6)) 相同。

</table>

#### `mat2x4` #### {#mat2x4-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>
          @const @must_use fn mat2x4<T>(e : mat2x4<S>) -> mat2x4<T>
          @const @must_use fn mat2x4(e : mat2x4<S>) -> mat2x4<S>
        </xmp>
  <tr><td>参数类别
      <td>`T` 为 [=f16=] 或 [=f32=]<br>
      `S` 为 [FLOATSCALAR]
  <tr><td>描述
      <td>构造一个2x4列主序的[=matrix=]。

      如果 `T` 与 `S` 不匹配，则会发生[[#floating-point-conversion|转换]]。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>
          @const @must_use fn mat2x4<T>(v1 : vec4<T>, v2 : vec4<T>) -> mat2x4<T>
          @const @must_use fn mat2x4(v1 : vec4<T>, v2 : vec4<T>) -> mat2x4<T>
        </xmp>
  <tr><td>参数类别
      <td>`T` 为 [FLOATSCALAR]
  <tr><td>描述
      <td>从列向量构造一个2x4列主序的[=matrix=]。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>
          @const @must_use fn mat2x4<T>(e1 : T, ..., e8 : T) -> mat2x4<T>
          @const @must_use fn mat2x4(e1 : T, ..., e8 : T) -> mat2x4<T>
        </xmp>
  <tr><td>参数类别
      <td>`T` 为 [FLOATSCALAR]
  <tr><td>描述
      <td>从元素构造一个2x4列主序的[=matrix=]。

          与 mat2x4(vec4(e1,e2,e3,e4), vec4(e5,e6,e7,e8)) 相同。
</table>

#### `mat3x2` #### {#mat3x2-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat3x2<T>(e : mat3x2<S>) -> mat3x2<T>
@const @must_use fn mat3x2(e : mat3x2<S>) -> mat3x2<S>
</xmp>
<tr><td>参数化
<td>T 是 [=f16=] 或者 [=f32=]<br>
S 是 [FLOATSCALAR]
<tr><td>描述
<td>构造一个3x2列优先的[=matrix=]。


  如果 `T` 和 `S` 不匹配，则进行[[#floating-point-conversion|转换]]。

</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat3x2<T>(v1 : vec2<T>,
v2 : vec2<T>,
v3 : vec2<T>) -> mat3x2<T>
@const @must_use fn mat3x2(v1 : vec2<T>,
v2 : vec2<T>,
v3 : vec2<T>) -> mat3x2<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从列向量构造一个3x2列优先的[=matrix=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat3x2<T>(e1 : T, …, e6 : T) -> mat3x2<T>
@const @must_use fn mat3x2(e1 : T, …, e6 : T) -> mat3x2<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从元素构造一个3x2列优先的[=matrix=]。


      与 mat3x2(vec2(e1,e2), vec2(e3,e4), vec2(e5,e6)) 相同。

</table>

#### `mat3x3` #### {#mat3x3-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat3x3<T>(e : mat3x3<S>) -> mat3x3<T>
@const @must_use fn mat3x3(e : mat3x3<S>) -> mat3x3<S>
</xmp>
<tr><td>参数化
<td>T 是 [=f16=] 或 [=f32=]<br>
S 是 [FLOATSCALAR]
<tr><td>描述
<td>构造一个3x3列优先的[=matrix=]。


  如果 `T` 与 `S` 不匹配，则会发生[[#floating-point-conversion|转换]]。

</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat3x3<T>(v1 : vec3<T>,
v2 : vec3<T>,
v3 : vec3<T>) -> mat3x3<T>
@const @must_use fn mat3x3(v1 : vec3<T>,
v2 : vec3<T>,
v3 : vec3<T>) -> mat3x3<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从列向量构造一个3x3列优先的[=matrix=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat3x3<T>(e1 : T, …, e9 : T) -> mat3x3<T>
@const @must_use fn mat3x3(e1 : T, …, e9 : T) -> mat3x3<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从元素构造一个3x3列优先的[=matrix=]。


      等同于 mat3x3(vec3(e1,e2,e3), vec3(e4,e4,e6), vec3(e7,e8,e9))。

</table>

#### `mat3x4` #### {#mat3x4-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat3x4<T>(e : mat3x4<S>) -> mat3x4<T>
@const @must_use fn mat3x4(e : mat3x4<S>) -> mat3x4<S>
</xmp>
<tr><td>参数化
<td>T 为 [=f16=] 或 [=f32=]<br>
S 为 [FLOATSCALAR]
<tr><td>描述
<td>3x4列主序[=matrix=]的构造函数。


  如果 `T` 与 `S` 不匹配，则发生[[#floating-point-conversion|转换]]。

</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat3x4<T>(v1 : vec4<T>,
v2 : vec4<T>,
v3 : vec4<T>) -> mat3x4<T>
@const @must_use fn mat3x4(v1 : vec4<T>,
v2 : vec4<T>,
v3 : vec4<T>) -> mat3x4<T>
</xmp>
<tr><td>参数化
<td>T 为 [FLOATSCALAR]
<tr><td>描述
<td>利用列向量构造一个3x4列主序[=matrix=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat3x4<T>(e1 : T, …, e12 : T) -> mat3x4<T>
@const @must_use fn mat3x4(e1 : T, …, e12 : T) -> mat3x4<T>
</xmp>
<tr><td>参数化
<td>T 为 [FLOATSCALAR]
<tr><td>描述
<td>利用元素构造一个3x4列主序[=matrix=]。


      相当于 mat3x4(vec4(e1,e2,e3,e4), vec4(e5,e6,e7,e8), vec4(e9,e10,e11,e12))。

</table>

#### `mat4x2` #### {#mat4x2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>
          @const @must_use fn mat4x2<T>(e : mat4x2<S>) -> mat4x2<T>
          @const @must_use fn mat4x2(e : mat4x2<S>) -> mat4x2<S>
        </xmp>
  <tr><td>参数化
      <td>`T` 是 [=f16=] 或 [=f32=]<br>
      `S` 是 [FLOATSCALAR]
  <tr><td>描述
      <td>构造一个 4x2 列优先 [=matrix=]。

      如果 `T` 与 `S` 不匹配，则发生[[#floating-point-conversion|转换]]。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>
          @const @must_use fn mat4x2<T>(v1 : vec2<T>,
                                        v2 : vec2<T>,
                                        v3 : vec2<T>,
                                        v4: vec2<T>) -> mat4x2<T>
          @const @must_use fn mat4x2(v1 : vec2<T>,
                                     v2 : vec2<T>,
                                     v3 : vec2<T>,
                                     v4: vec2<T>) -> mat4x2<T>
        </xmp>
  <tr><td>参数化
      <td>`T` 是 [FLOATSCALAR]
  <tr><td>描述
      <td>从列向量构造一个 4x2 列优先 [=matrix=]。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>
          @const @must_use fn mat4x2<T>(e1 : T, ..., e8 : T) -> mat4x2<T>
          @const @must_use fn mat4x2(e1 : T, ..., e8 : T) -> mat4x2<T>
        </xmp>
  <tr><td>参数化
      <td>`T` 是 [FLOATSCALAR]
  <tr><td>描述
      <td>从元素构造一个 4x2 列优先 [=matrix=]。

          与 mat4x2(vec2(e1,e2), vec2(e3,e4), vec2(e5,e6), vec2(e7,e8)) 相同。
</table>

#### `mat4x3` #### {#mat4x3-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat4x3<T>(e : mat4x3<S>) -> mat4x3<T>
@const @must_use fn mat4x3(e : mat4x3<S>) -> mat4x3<S>
</xmp>
<tr><td>参数化
<td>T 是 [=f16=] 或 [=f32=]<br>
S 是 [FLOATSCALAR]
<tr><td>描述
<td>构造一个4x3列优先 [=矩阵=]。


  如果 `T` 与 `S` 不匹配，将发生[[#floating-point-conversion|转换]]。

</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat4x3<T>(v1 : vec3<T>,
v2 : vec3<T>,
v3 : vec3<T>,
v4 : vec3<T>) -> mat4x3<T>
@const @must_use fn mat4x3(v1 : vec3<T>,
v2 : vec3<T>,
v3 : vec3<T>,
v4 : vec3<T>) -> mat4x3<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从列向量构造一个4x3列优先 [=矩阵=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat4x3<T>(e1 : T, …, e12 : T) -> mat4x3<T>
@const @must_use fn mat4x3(e1 : T, …, e12 : T) -> mat4x3<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从元素构造一个4x3列优先 [=矩阵=]。


      与mat4x3(vec3(e1,e2,e3), vec3(e4,e5,e6), vec3(e7,e8,e9), vec3(e10,e11,e12))相同。

</table>

#### `mat4x4` #### {#mat4x4-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat4x4<T>(e : mat4x4<S>) -> mat4x4<T>
@const @must_use fn mat4x4(e : mat4x4<S>) -> mat4x4<S>
</xmp>
<tr><td>参数化
<td>T 是 [=f16=] 或 [=f32=]<br>
S 是 [FLOATSCALAR]
<tr><td>描述
<td>用于构造一个4x4列优先[=matrix=]的构造函数。


  如果 `T` 与 `S` 不相符，则会发生[[#floating-point-conversion|转换]]。

</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat4x4<T>(v1 : vec4<T>,
v2 : vec4<T>,
v3 : vec4<T>,
v4 : vec4<T>) -> mat4x4<T>
@const @must_use fn mat4x4(v1 : vec4<T>,
v2 : vec4<T>,
v3 : vec4<T>,
v4 : vec4<T>) -> mat4x4<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从列向量构造一个4x4列优先[=matrix=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn mat4x4<T>(e1 : T, …, e16 : T) -> mat4x4<T>
@const @must_use fn mat4x4(e1 : T, …, e16 : T) -> mat4x4<T>
</xmp>
<tr><td>参数化
<td>T 是 [FLOATSCALAR]
<tr><td>描述
<td>从元素构造一个4x4列优先[=matrix=]。


      等同于 mat4x4(vec4(e1,e2,e3,e4), vec4(e5,e6,e7,e8), vec4(e9,e10,e11,e12), vec4(e13,e14,e15,e16))。

</table>

#### Structures #### {#structures-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>@const @must_use fn S(e1 : T1, …, eN : TN) -> S</xmp>
<tr><td>参数化
<td>S 是一个可构建的结构类型，其成员拥有 T1 … TN 类型。
<tr><td>描述
<td>从成员构造类型为 S 的结构体。
</table>

#### `u32` #### {#u32-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>@const @must_use fn u32(e : T) -> u32</xmp>
<tr><td>参数化
<td>T 是一个[=type/concrete=] [=scalar=] 类型或者 [=AbstractInt=]
<tr><td>描述
<td>构建一个[=u32=]值。


  如果 `T` 是 [=u32=]，这是一种恒等操作。<br>
  如果 `T` 是 [=i32=]，这是一种位的重新解释（即，结果是在 [=u32=] 中具有与 `e` 相同位模式的唯一值）。<br>
  如果 `T` 是 [[#floating-point-types|浮点类型]]，`e` 被[=scalar floating point to integral conversion|转换=]为 [=u32=]，向零方向舍入。<br>
  如果 `T` 是 [=bool=]，结果是如果 `e` 是 `true` 则为 `1u`，否则为 `0u`。<br>
  如果 `T` 是 [=AbstractInt=]，如果 `e` 可以在 [=u32=] 中表示，则这是一个恒等操作，否则它会产生一个 [=shader-creation error=]。

<tr><td>
<td>


  注意：从 [=AbstractInt=] 的重载存在是为了表达式如 `u32(4*1000*1000*1000)` 可以创建一个 u32 值，否则它将溢出 i32 类型。如果没有这个重载，[=overload resolution=] 会选择 `u32(i32)` 重载，AbstractInt 表达式会自动转换为 i32，这将因为溢出而导致创建着色器错误。

</table>

#### `vec2` #### {#vec2-builtin}

<table class="data builtin">
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec2<T>(e : T) -> vec2<T>
@const @must_use fn vec2(e : S) -> vec2<S>
</xmp>
<tr><td>参数化
<td>T 是一个 [=type/concrete=] [=scalar=]（具体类型的标量）<br>
S 是 [=scalar=]（标量）
<tr><td>描述
<td>构造一个两个组成部分都是 e 的 [=vector=]（向量）。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec2<T>(e : vec2<S>) -> vec2<T>
@const @must_use fn vec2(e : vec2<S>) -> vec2<S>
</xmp>
<tr><td>参数化
<td>T 是一个 [=type/concrete=] [=scalar=]（具体类型的标量）<br>
S 是 [=scalar=]（标量）
<tr><td>描述
<td>按[=Component-wise=]（逐元素）方式构造一个两个组成部分分别为 e.x 和 e.y 的 [=vector=]（向量）。


  如果 `T` 和 `S` 不匹配，则会使用转换，组成部分为 `T(e.x)` 和 `T(e.y)`。

</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec2<T>(e1 : T, e2 : T) -> vec2<T>
@const @must_use fn vec2(e1 : T, e2 : T) -> vec2<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]（标量）
<tr><td>描述
<td>按[=Component-wise=]（逐元素）方式构造一个两个组成部分分别为 e1 和 e2 的 [=vector=]（向量）。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec2() -> vec2<T>
</xmp>
<tr><td>参数化
<td>T 是 AbstractInt（抽象整型）
<tr><td>描述
<td>返回值 vec2(0,0)。
</table>

#### `vec3` #### {#vec3-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">过载
<td>
<xmp>
@const @must_use fn vec3<T>(e : T) -> vec3<T>
@const @must_use fn vec3(e : S) -> vec3<S>
</xmp>
<tr><td>参数化
<td>T 是一个 [=type/concrete=] [=scalar=]（具体类型标量）<br>
S 是 [=scalar=]（标量）
<tr><td>描述
<td>用 e 作为所有分量构造一个三分量 [=vector=]（向量）。
</table>


<table class=‘data builtin’>
<tr><td style="width:10%">过载
<td>
<xmp>
@const @must_use fn vec3<T>(e : vec3<S>) -> vec3<T>
@const @must_use fn vec3(e : vec3<S>) -> vec3<S>
</xmp>
<tr><td>参数化
<td>T 是一个 [=type/concrete=] [=scalar=]（具体类型标量）<br>
S 是 [=scalar=]（标量）
<tr><td>描述
<td>按 [=Component-wise=] 成分构造一个三分量 [=vector=]（向量），分量为 e.x, e.y 和 e.z。


  如果 `T` 与 `S` 不匹配，则使用转换，分量为 `T(e.x)`, `T(e.y)` 和 `T(e.z)`。

</table>

<table class=‘data builtin’>
<tr><td style="width:10%">过载
<td>
<xmp>
@const @must_use fn vec3<T>(e1 : T, e2 : T, e3 : T) -> vec3<T>
@const @must_use fn vec3(e1 : T, e2 : T, e3 : T) -> vec3<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]（标量）
<tr><td>描述
<td>按 [=Component-wise=] 成分构造一个三分量 [=vector=]（向量），分量为 e1, e2 和 e3。
</table>


<table class=‘data builtin’>
<tr><td style="width:10%">过载
<td>
<xmp>
@const @must_use fn vec3<T>(v1 : vec2<T>, e1 : T) -> vec3<T>
@const @must_use fn vec3(v1 : vec2<T>, e1 : T) -> vec3<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]（标量）
<tr><td>描述
<td>按 [=Component-wise=] 成分构造一个三分量 [=vector=]（向量），分量为 v1.x, v1.y 和 e1。
</table>

<table class=‘data builtin’>
<tr><td style="width:10%">过载
<td>
<xmp>
@const @must_use fn vec3<T>(e1 : T, v1 : vec2<T>) -> vec3<T>
@const @must_use fn vec3(e1 : T, v1 : vec2<T>) -> vec3<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]（标量）
<tr><td>描述
<td>按 [=Component-wise=] 成分构造一个三分量 [=vector=]（向量），分量为 e1, v1.x, 和 v1.y。
</table>

<table class=‘data builtin’>
<tr><td style="width:10%">过载
<td>
<xmp>
@const @must_use fn vec3() -> vec3<T>
</xmp>
<tr><td>参数化
<td>T 是 AbstractInt
<tr><td>描述
<td>返回值 vec3(0,0,0)。
</table>

#### `vec4` #### {#vec4-builtin}

<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4<T>(e : T) -> vec4<T>
@const @must_use fn vec4(e : S) -> vec4<S>
</xmp>
<tr><td>参数化
<td>T 是一个 [=type/concrete=] [=scalar=]<br>
S 是 [=scalar=]
<tr><td>描述
<td>使用 e 作为所有分量来构造一个四元素的 [=vector=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4<T>(e : vec4<S>) -> vec4<T>
@const @must_use fn vec4(e : vec4<S>) -> vec4<S>
</xmp>
<tr><td>参数化
<td>T 是一个 [=type/concrete=] [=scalar=]<br>
S 是 [=scalar=]
<tr><td>描述
<td>使用 e.x、e.y、e.z 和 e.w 作为分量，按元素 [=Component-wise=] 构造一个四元素 [=vector=]。


  如果 `T` 与 `S` 不匹配，则会使用转换，分量将变为 `T(e.x)`、`T(e.y)`、`T(e.z)` 和 `T(e.w)`。

</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4<T>(e1 : T, e2 : T, e3 : T, e4 : T) -> vec4<T>
@const @must_use fn vec4(e1 : T, e2 : T, e3 : T, e4 : T) -> vec4<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]
<tr><td>描述
<td>使用 e1、e2、e3 和 e4 作为分量，按元素 [=Component-wise=] 构造一个四元素 [=vector=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4<T>(e1 : T, v1 : vec2<T>, e2 : T) -> vec4<T>
@const @must_use fn vec4(e1 : T, v1 : vec2<T>, e2 : T) -> vec4<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]
<tr><td>描述
<td>使用 e1、v1.x、v1.y 和 e2 作为分量，按元素 [=Component-wise=] 构造一个四元素 [=vector=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4<T>(e1 : T, e2 : T, v1 : vec2<T>) -> vec4<T>
@const @must_use fn vec4(e1 : T, e2 : T, v1 : vec2<T>) -> vec4<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]
<tr><td>描述
<td>使用 e1、e2、v1.x 和 v1.y 作为分量，按元素 [=Component-wise=] 构造一个四元素 [=vector=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4<T>(v1 : vec2<T>, v2 : vec2<T>) -> vec4<T>
@const @must_use fn vec4(v1 : vec2<T>, v2 : vec2<T>) -> vec4<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]
<tr><td>描述
<td>使用 v1.x、v1.y、v2.x 和 v2.y 作为分量，按元素 [=Component-wise=] 构造一个四元素 [=vector=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4<T>(v1 : vec2<T>, e1 : T, e2 : T) -> vec4<T>
@const @must_use fn vec4(v1 : vec2<T>, e1 : T, e2 : T) -> vec4<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]
<tr><td>描述
<td>使用 v1.x、v1.y、e1 和 e2 作为分量，按元素 [=Component-wise=] 构造一个四元素 [=vector=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4<T>(v1 : vec3<T>, e1 : T) -> vec4<T>
@const @must_use fn vec4(v1 : vec3<T>, e1 : T) -> vec4<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]
<tr><td>描述
<td>使用 v1.x、v1.y、v1.z 和 e1 作为分量，按元素 [=Component-wise=] 构造一个四元素 [=vector=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4<T>(e1 : T, v1 : vec3<T>) -> vec4<T>
@const @must_use fn vec4(e1 : T, v1 : vec3<T>) -> vec4<T>
</xmp>
<tr><td>参数化
<td>T 是 [=scalar=]
<tr><td>描述
<td>使用 e1、v1.x、v1.y 和 v1.z 作为分量，按元素 [=Component-wise=] 构造一个四元素 [=vector=]。
</table>
<table class=‘data builtin’>
<tr><td style="width:10%">重载
<td>
<xmp>
@const @must_use fn vec4() -> vec4<T>
</xmp>
<tr><td>参数化
<td>T 是 AbstractInt
<tr><td>描述
<td>返回值 vec4(0,0,0,0)。
</table>

## 位重新解释内置函数 ## {#bit-reinterp-builtin-functions}

### `bitcast` ### {#bitcast-builtin}

bitcast 内置函数用于将一个类型中值的位表示重新解释为另一个类型中的值。


内部布局规则在[[#internal-value-layout]]中有描述。

<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>@const @must_use fn bitcast<T>(e : T) -> T</xmp>
  <tr><td>参数化
      <td>`T` 是一个 [=type/concrete=] [=numeric scalar=] 或者 [=type/concrete=] [=numeric vector=]
  <tr><td>描述
      <td>身份变换。<br>
      当 `T` 是一个 [=vector=] 时，[=Component-wise=]。<br>
      结果是 `e`。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>@const @must_use fn bitcast<T>(e : S) -> T</xmp>
  <tr><td>参数化
      <td>`S` 是 i32，u32 或者 f32<br>
      `T` 不是 `S` 并且是 i32，u32 或者 f32
  <tr><td>描述
      <td>以 `T` 的形式重新解释位。<br>
      结果是 `e` 的位以 `T` 的值重新解释。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>@const @must_use fn bitcast<vecN<T>>(e : vecN<S>) -> T</xmp>
  <tr><td>参数化
      <td>`S` 是 i32，u32，或者 f32<br>
      `T` 不是 `S` 并且是 i32，u32，或者 f32
  <tr><td>描述
      <td>[=Component-wise=] 以 `T` 的形式重新解释位。<br>
      结果是 `e` 的位以 `vecN<T>` 的值重新解释。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>@const @must_use fn bitcast<u32>(e : AbstractInt) -> T

                            @const @must_use fn bitcast<vecN<u32>>(e : vecN<AbstractInt>) -> T</xmp>
  <tr><td>参数化
      <td>
  <tr><td>描述
      <td>如果 `e` 可以表示为 [=u32=]，则为身份操作，
      否则它产生一个 [=shader-creation error=]。
      也就是说，产生与 `u32(e)` 相同的结果。

      当 `e` 是向量时，[=Component-wise=]。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>@const @must_use fn bitcast<T>(e : vec2<f16>) -> T</xmp>
  <tr><td>参数化
      <td>`T` 是 i32，u32 或者 f32
  <tr><td>描述
      <td>[=Component-wise=] 以 `T` 的形式重新解释位。<br>
      结果是 `e` 中的 32 位以 `T` 的值重新解释，遵循内部布局规则。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>@const @must_use fn bitcast<vec2<T>>(e : vec4<f16>) -> vec2<T></xmp>
  <tr><td>参数化
      <td>`T` 是 i32，u32 或者 f32<br>
  <tr><td>描述
      <td>[=Component-wise=] 以 `T` 的形式重新解释位。<br>
      结果是 `e` 中的 64 位以 `T` 的值重新解释，遵循内部布局规则。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>@const @must_use fn bitcast<vec2<f16>>(e : T) -> vec2<f16></xmp>
  <tr><td>参数化
      <td>`T` 是 i32，u32 或者 f32
  <tr><td>描述
      <td>[=Component-wise=] 以 f16 的形式重新解释位。<br>
      结果是 `e` 中的 32 位以一个 f16 值重新解释，遵循内部布局规则。
</table>
<table class='data builtin'>
  <tr><td style="width:10%">重载
      <td>
        <xmp>@const @must_use fn bitcast<vec4<f16>>(e : vec2<T>) -> vec4<f16></xmp>
  <tr><td>参数化
      <td>`T` 是 i32，u32 或者 f32
  <tr><td>描述
      <td>[=Component-wise=] 以 `vec2<f16>` 的形式重新解释位。<br>
      结果是 `e` 中的 64 位以一个 f16 值重新解释，遵循内部布局规则。
</table>

## 逻辑内置函数 ## {#logical-builtin-functions}

### `all` ### {#all-builtin}
<table class=‘data builtin’>
<tr algorithm="vector all">
<td style="width:10%">重载
<td>
<xmp>@const @must_use fn all(e: vecN<bool>) -> bool</xmp>
<tr>
<td>描述
<td>如果 e 的每个分量都为真，则返回真。
</table>


<table class=‘data builtin’>
<tr algorithm="scalar all">
<td style="width:10%">重载
<td class="nowrap">
<xmp>@const @must_use fn all(e: bool) -> bool</xmp>
<tr>
<td>描述
<td>返回 e。
</table>

### `any` ### {#any-builtin}
<table class=‘data builtin’>
<tr algorithm="vector any">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn any(e: vecN<bool>) -> bool
</xmp>
<tr>
<td style="width:10%">描述
<td>如果 e 的任何分量为 true，则返回 true。
</table>


<table class=‘data builtin’>
<tr algorithm="scalar any">
<td style="width:10%">重载
<td class="nowrap">
<xmp>@const @must_use fn any(e: bool) -> bool</xmp>
<tr>
<td>描述
<td>返回 e。
</table>

### `select` ### {#select-builtin}
<table class=‘data builtin’>
<tr algorithm="scalar select">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn select(f: T,
t: T,
cond: bool) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [=标量=] 或者 [=向量=]
<tr>
<td>描述
<td>当 cond 为真时返回 t，否则返回 f。
</table>


<table class=‘data builtin’>
<tr algorithm="vector select">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn select(f: vecN<T>,
t: vecN<T>,
cond: vecN<bool>) -> vecN<T>
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [=标量=]
<tr>
<td>描述
<td>[=逐元素=] 选择。结果组件 i 是通过 select(f[i], t[i], cond[i]) 计算得出的。
</table>

## 数组内置函数 ## {#array-builtin-functions}

### `arrayLength` ### {#arrayLength-builtin}
<table class=‘data builtin’>
<tr algorithm="runtime-sized array length">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@must_use fn arrayLength(p: ptr<storage, array<E>, AM>) -> u32
</xmp>
<tr>
<td style="width:10%">参数化
<td>E 是一个运行时大小数组的元素类型,<br>
[=访问模式=] AM 是 [=访问/读取=] 或 [=访问/读写=]
<tr>
<td>描述
<td>返回 [=NRuntime=]，即运行时大小数组中的元素数量。


    见 [[#buffer-binding-determines-runtime-sized-array-element-count]]

</table>


<div class=‘example wgsl global-scope’ heading=‘获取运行时大小数组中的元素数量’>
<xmp>
struct PointLight {
position : vec3f,
color : vec3f,
}


struct LightStorage {
pointCount : u32,
point : array<PointLight>,
}


@group(0) @binding(1) var<storage> lights : LightStorage;


fn num_point_lights() -> u32 {
return arrayLength( &lights.point );
}
</xmp>
</div>

## 数值内置函数 ## {#numeric-builtin-functions}

### `abs` ### {#abs-float-builtin}
<table class=‘data builtin’>
<tr algorithm="float abs">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn abs(e: T ) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLNUMERICDECL]
<tr>
<td>描述
<td>e的绝对值。当T是一个向量时，按组件逐个计算。


如果 `e` 是一个浮点类型，那么结果是带有正号的 `e`。
如果 `e` 是一个无符号[=整数标量=]类型，则结果为 `e`。
如果 `e` 是一个有符号[=整数标量=]类型并且计算结果为最大的负值，那么结果为 `e`。

</table>

### `acos` ### {#acos-builtin}
<table class=‘data builtin’>
<tr algorithm="acos">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn acos(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回逆余弦（cos<sup>-1</sup>）e的主值（以弧度为单位）。<br>
即，近似x，满足 0 ≤ x ≤ π，使得cos(x) = e。


当 `T` 是向量时，[=按组件操作=]。

<tr>
<td>
<td>


注意：当abs(e) > 1时，结果在数学上是无意义的。
</table>

### `acosh` ### {#acosh-builtin}
<table class=‘data builtin’>
<tr algorithm="acosh">
<td style="width:10%">函数重载
<td class="nowrap">
<xmp>
@const @must_use fn acosh(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回以弧度表示的 e 的反双曲余弦（cosh<sup>-1</sup>）值。<br>
也就是近似 x，其满足 0 ≤ x ≤ ∞，以使得 cosh(x) = e。


当 `T` 是一个向量时，会分别对向量中的每个元素进行计算。

<tr>
<td>
<td>


注意：当 e < 1 时，结果在数学上是没有意义的。


</table>

### `asin` ### {#asin-builtin}
<table class=‘data builtin’>
<tr algorithm="asin">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn asin(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回给定输入 e 的反正弦（sin<sup>-1</sup>）的主值（以弧度表示）。<br>
即，近似 x，满足 -π/2 ≤ x ≤ π/2，并且 sin(x) = e。


当 `T` 是向量时，会逐个分量地计算。

<tr>
<td>
<td>


注意：当 abs(e) > 1 时，结果在数学上没有意义。
</table>

### `asinh` ### {#asinh-builtin}
<table class=‘data builtin’>
<tr algorithm="asinh">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn asinh(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e 的反双曲正弦（sinh<sup>-1</sup>），即以弧度为单位的双曲角。<br>
也就是说，近似求解 x 使得 sinh(x) = e。


当 `T` 是向量时，按[=分量逐个=]操作。

</table>

### `atan` ### {#atan-builtin}
<table class=‘data builtin’>
<tr algorithm="atan">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn atan(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回逆正切（tan<sup>-1</sup>）的主要值，单位是弧度，即e。<br>
即，近似 x 且 π/2 ≤ x ≤ π/2，使得 tan(x) = e。


当 `T` 是向量时，按组件（Component-wise）进行计算。

</table>

### `atanh` ### {#atanh-builtin}
<table class='data builtin'>
  <tr algorithm="atanh">
    <td style="width:10%">重载
    <td class="nowrap">
      <xmp>
        @const @must_use fn atanh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">参数化
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>描述
    <td>返回 `e` 的反双曲正切（tanh<sup>-1</sup>），作为以弧度表示的双曲[=角度=]。<br>
    亦即，近似 `x` 使得 `tanh`(`x`) = `e`。

    当 `T` 是向量时，采用[=逐分量=]方式。
  <tr>
    <td>
    <td>

注：当 `abs(e)` &ge; 1 时，结果在数学上没有意义。

</table>

### `atan2` ### {#atan2-builtin}
<table class=‘data builtin’>
<tr algorithm="atan2">
<td style="width:10%">方法重载
<td class="nowrap">
<xmp>
@const @must_use fn atan2(y: T,
x: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回一个弧度制的[=角度=]，范围在 [-π, π] 之间，其正切值为 y÷x。


结果所选择的象限取决于 `y` 和 `x` 的符号。
例如，函数可实现为：

* `atan(y/x)` 当 `x` &gt; 0 时
* `atan(y/x)` + &pi; 当 (`x` &lt; 0) 且 (`y` &gt; 0) 时
* `atan(y/x)` - &pi; 当 (`x` &lt; 0) 且 (`y` &lt; 0) 时

<div class=note>
<span class=marker>注意：</span> 结果的误差无界限：
* 当 `abs(x)` 非常小，例如对应类型的非规格数，
* 在原点处 (`x`,`y`) = (0,0)，或者
* 当 `y` 是非规格数或无穷大。

</div>

当 `T` 是向量时[=按分量操作=]。

</table>

### `ceil` ### {#ceil-builtin}
<table class=‘data builtin’>
<tr algorithm="ceil">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn ceil(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回e的[=ceiling expression|向上取整=]。
当T是向量时[=Component-wise=]逐元素进行。
</table>

### `clamp` ### {#clamp}
<table class=‘data builtin’>
<tr algorithm="clamp">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use 函数 clamp(e: T,
low: T,
high: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLNUMERICDECL]
<tr>
<td>描述
<td>限定 e 的值在一个范围之内。


如果 `T` 是整数类型，则结果为 `min(max(e, low), high)`。

如果 `T` 是浮点类型，则结果为 `min(max(e, low), high)`，或者是 `e`、`low`、`high` 三个值的中值。

当 `T` 是矢量时，按[=分量-wise=]方式处理。

如果 `low` 大于 `high`，则：
* 如果 `low` 和 `high` 是[=const-expressions=]，那么将是一个 [=shader-creation error=]（着色器创建错误）。
* 如果 `low` 和 `high` 是[=override-expressions=]，那么将是一个 [=pipeline-creation error=]（管线创建错误）。

</table>

### `cos` ### {#cos-builtin}
<table class=‘data builtin’>
<tr algorithm="cos">
<td style="width:10%">重载
<td class="nowrap">
<xmp>@const @must_use fn cos(e: T) -> T</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回参数e的余弦值，其中e是以弧度为单位。
当T是向量时[=Component-wise=]（按组件方式）计算。
</table>

### `cosh` ### {#cosh-builtin}
<table class=‘data builtin’>
<tr algorithm="cosh">
<td style="width:10%">函数重载
<td class="nowrap">
<xmp>
@const @must_use fn cosh(arg: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回参数 arg 的双曲余弦值，其中 arg 是以弧度为单位的双曲角。
接近纯数学函数 (e<sup>arg</sup> + e<sup>-arg</sup>)÷2 的结果，
但不一定以该方式计算。


当 `T` 是向量时[=Component-wise=]逐元素操作

</table>

### `countLeadingZeros` ### {#countLeadingZeros-builtin}
<table class=‘data builtin’>
<tr algorithm="计算前导零的数量">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn countLeadingZeros(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [整型]
<tr>
<td>描述
<td>从 e 的最高有效位开始连续0位的数量，当 T 是一个标量类型时。<br>
当 T 是一个向量时，按[=分量逐个=]处理。<br>
在某些语言中也被称为 "clz"。
</table>

### `countOneBits` ### {#countOneBits-builtin}
<table class=‘data builtin’>
<tr algorithm="计算1的个数">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn countOneBits(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [整型]
<tr>
<td>描述
<td>表示数值e中1比特的个数。<br>
也称为"位的数量"或"汉明重量"。<br>
当T是向量时，是[=按成分操作=]。
</table>

### `countTrailingZeros` ### {#countTrailingZeros-builtin}
<table class=‘data builtin’>
<tr algorithm="计算末尾零的个数">
<td style="width:10%">函数重载
<td class="nowrap">
<xmp>
@const @must_use fn countTrailingZeros(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [整型]
<tr>
<td>描述
<td>从 e 的最低位起连续的 0 比特数，当 T 为标量类型时。<br>
当 T 为矢量时按[=分量逐个=]计算。<br>
在某些语言中也被称为 "ctz"。
</table>

### `cross` ### {#cross-builtin}
<table class=‘data builtin’>
<tr algorithm="向量情形，叉乘">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn cross(e1: vec3<T>,
e2: vec3<T>) -> vec3<T>
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是抽象浮点数，f32 或 f16
<tr>
<td>描述
<td>返回 e1 与 e2 的叉积。
</table>

### `degrees` ### {#degrees-builtin}
<table class=‘data builtin’>
<tr algorithm="degrees">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn degrees(e1: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>将弧度转换为度数，大约为 e1 × 180 ÷ π。
当 T 为向量时逐元素操作
</table>

### `determinant` ### {#determinant-builtin}
<table class=‘data builtin’>
<tr algorithm="行列式">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn determinant(e: matCxC<T>) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 为 AbstractFloat、f32 或 f16
<tr>
<td>描述
<td>返回 e 的行列式。
</table>

### `distance` ### {#distance-builtin}
<table class=‘data builtin’>
<tr algorithm="distance">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn distance(e1: T,
e2: T) -> S
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e1 与 e2 之间的距离（例如，length(e1 - e2)）。
</table>

### `dot` ### {#dot-builtin}
<table class=‘data builtin’>
<tr algorithm="dot">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn dot(e1: vecN<T>,
e2: vecN<T>) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 AbstractInt、AbstractFloat、i32、u32、f32 或 f16
<tr>
<td>描述
<td>返回 e1 和 e2 的点积。
</table>

### `exp` ### {#exp-builtin}
<table class=‘data builtin’>
<tr algorithm="exp">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn exp(e1: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e1 的自然指数（例如，e<sup>e1</sup>）。
当 T 是向量时，按组件逐个计算。
</table>

### `exp2` ### {#exp2-builtin}
<table class=‘data builtin’>
<tr algorithm="exp2">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn exp2(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 2 的 e 次幂（例如 2<sup>e</sup>）。当 T 是向量时，进行[=按元素=]运算。
</table>

### `extractBits` (signed) ### {#extractBits-signed-builtin}
<table class='data builtin'>
  <tr algorithm="signed extract bits">
    <td style="width:10%">重载
    <td class="nowrap">
      <xmp>
        @const @must_use fn extractBits(e: T,
                                        offset: u32,
                                        count: u32) -> T
      </xmp>
  <tr>
     <td style="width:10%">参数化
     <td>`T` 是 [SIGNEDINTEGRAL]
  <tr>
     <td>描述
     <td>从整数中读取位，并进行符号扩展。

     当 `T` 是一个标量类型时：
     <ul>
     <li>`w` 是 `T` 的位宽
     <li>`o = min(offset, w)`
     <li>`c = min(count, w - o)`
     <li>如果 `c` 为 0，则结果为 0。
     <li>否则，结果的 `0..c - 1` 位从 `e` 的 `o..o + c - 1` 位复制。
        结果的其它位与结果的第 `c - 1` 位相同。
     </ul>
     当 `T` 是矢量时按 [=逐元素=] 方式处理。

     如果 `count` + `offset` 大于 `w`，那么：
     * 如果 `count` 和 `offset` 是 [=const-expressions=]，则这是一个 [=着色器创建错误=]。
     * 如果 `count` 和 `offset` 是 [=override-expressions=]，则这是一个 [=管线创建错误=]。
</table>

### `extractBits` (unsigned) ### {#extractBits-unsigned-builtin}
<table class=‘data builtin’>
<tr algorithm="unsigned extract bits">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn extractBits(e: T,
offset: u32,
count: u32) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [UNSIGNEDINTEGRAL]
<tr>
<td>描述
<td>从整数中读取位，不进行符号扩展。


当 `T` 是标量类型时：
<ul>
<li>`w` 是 `T` 的位宽度
<li>`o = min(offset, w)`
<li>`c = min(count, w - o)`
<li>如果 `c` 是 0，则结果为 0。
<li>否则，结果的 `0..c - 1` 位从 `e` 的 `o..o + c - 1` 位复制。
   结果的其他位为 0。
</ul>
当 `T` 是向量时，按[=Component-wise=]操作。

如果 `count` + `offset` 大于 `w`，那么：
* 如果 `count` 和 `offset` 是 [=const-expressions=]，那么这是一个 [=shader-creation error=]。
* 如果 `count` 和 `offset` 是 [=override-expressions=]，那么这是一个 [=pipeline-creation error=]。

</table>

### `faceForward` ### {#faceForward-builtin}
<table class=‘data builtin’>
<tr algorithm="faceForward">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn faceForward(e1: T,
e2: T,
e3: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 vecN<AbstractFloat>, vecN<f32>, 或 vecN<f16>
<tr>
<td>描述
<td>如果 dot(e2, e3) 是负数，则返回 e1，否则返回 -e1。
</table>

### `firstLeadingBit` (signed) ### {#firstLeadingBit-signed-builtin}
<table class=‘data builtin’>
<tr algorithm="signed find most significant one bit">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn firstLeadingBit(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [SIGNEDINTEGRAL]
<tr>
<td>描述
<td>对于标量 T，结果为：
<ul>
<li>-1 如果 e 是 0 或者 -1。
<li>否则为 e 中最高有效位与 e 的符号位不同的位的位置。
</ul>


    当 `T` 是向量时[=按分量操作=]。

<tr>
<td>
<td>


注意：因为有符号整数使用二进制补码表示法，
所以符号位出现在最高位位置。


</table>

### `firstLeadingBit` (unsigned) ### {#firstLeadingBit-unsigned-builtin}
<table class=‘data builtin’>
<tr algorithm="unsigned find most significant one bit">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn firstLeadingBit(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [无符号整型]
<tr>
<td>描述
<td>对于标量 T，结果为：
<ul>
<li>如果 e 为零，则结果为 T(-1)。
<li>否则为 e 中最高位 1 的位置。
</ul>
当 T 是向量时，按[=逐个元素的方式=]运算。
</table>

### `firstTrailingBit` ### {#firstTrailingBit-builtin}
<table class=‘data builtin’>
<tr algorithm="查找最不重要的一位">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn firstTrailingBit(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [整型]
<tr>
<td>描述
<td>对于标量 T，结果是：
<ul>
<li>如果 e 为零，则为 T(-1)。
<li>否则为 e 中最不重要的一位的位置。
</ul>
当 T 是矢量时为[=分量逐个=]。
</table>

### `floor` ### {#floor-builtin}
<table class=‘data builtin’>
<tr algorithm="向下取整">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn floor(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[所有浮点数声明]
<tr>
<td>描述
<td>返回e的[=floor expression|向下取整=]值。
当T是向量时，以[=Component-wise|分量方式=]执行。
</table>

### `fma` ### {#fma-builtin}
<table class=‘data builtin’>
<tr algorithm="fma">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn fma(e1: T,
e2: T,
e3: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e1 * e2 + e3。当 T 是向量时，[=按组件=]进行计算。


注：名称 `fma` 是 "fused multiply add"（融合乘加）的简写。

注意：
[[!IEEE-754|IEEE-754]] 中的 `fusedMultiplyAdd` 操作计算中间结果时
仿佛有无限范围和精度，最终结果才四舍五入到目标类型。
然而，对 `fma` 的 [[#floating-point-accuracy]] 规则允许实现
先进行普通类型的乘法，然后是普通加法。
在这种情况下，中间值可能会溢出或失去精度，并且整个操作根本不是"融合"的。

</table>

### `fract` ### {#fract-builtin}
<table class=‘data builtin’>
<tr algorithm="fract">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn fract(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回e的小数部分，计算方法为e - floor(e)。<br>
当T为向量类型时，[=Component-wise=]（逐元素）计算。
<tr>
<td>
<td>


注意：有效结果在闭区间[0, 1.0]内。
例如，如果e是一个非常小的负数，那么fract(e)可能为1.0。


</table>

### `frexp` ### {#frexp-builtin}
<table class=‘data builtin’>
<tr algorithm="scalar case, binary32, frexp">
<td style="width:10%">函数重载
<td class="nowrap">
<xmp>
@const @must_use fn frexp(e: T) -> __frexp_result_f32
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f32
<tr>
<td>描述
<td>将 e 分解成一个小数部分和一个指数部分。


* 当 `e` 为零时，小数部分为零。
* 当 `e` 是非零且标准值时，`e` 等于 `fraction * 2`<sup>`exponent`</sup>，此时小数部分的范围是 [0.5, 1.0) 或 (-1.0, -0.5]。
* 否则，`e` 是非规格化数、NaN 或无穷大。结果的小数部分和指数部分都是[=不确定的值=]。

返回内建结构 `__frexp_result_f32`，定义如下：
```

struct __frexp_result_f32 {
fract : f32, // 小数部分
exp : i32    // 指数部分
}
```


注意：`frexp` 这个名字的助记符是 "**fr**action 和 **exp**onent"（小数和指数）。

<tr>
<td>
<td>
<div class=‘example wgsl function-scope’ heading=‘frexp 使用例子’>
<xmp>
// 推断结果类型
let fraction_and_exponent = frexp(1.5);
// 设置 fraction_only 为 0.75
let fraction_only = frexp(1.5).fract;
</xmp>
</div>
<tr>
<td>
<td>


注意：不能显式声明一个类型为 __frexp_result_f32 的值，但是值可以推断出这个类型。


</table>

<table class=‘data builtin’>
<tr algorithm="scalar case, binary16, frexp">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn frexp(e: T) -> __frexp_result_f16
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f16
<tr>
<td>描述
<td>将 e 分解为小数部分和指数部分。


* 当 `e` 为零时，小数部分为零。
* 当 `e` 非零且为规范值时，`e` &equals; `fraction * 2`<sup>`exponent`</sup>，其中
    小数部分范围为 [0.5, 1.0) 或 (-1.0, -0.5]。
* 否则，`e` 是非规范值，NaN 或无穷大。结果的小数部分和指数部分为[=不定值=]。

返回内置结构体 `__frexp_result_f16`，定义如下所示：
```

struct __frexp_result_f16 {
fract : f16, // 小数部分
exp : i32    // 指数部分
}
```


注：`frexp` 这个名称的记忆法是 "**fr**action（小数） 和 **exp**onent（指数）"。

<tr>
<td>
<td>


注：不能显式声明类型为 __frexp_result_f16 的值，
但可以推断出该类型的值。


</table>


<table class=‘data builtin’>
<tr algorithm="scalar case, abstract, frexp">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn frexp(e: T) -> __frexp_result_abstract
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 AbstractFloat
<tr>
<td>描述
<td>将 e 分解为小数部分和指数部分。


* 当 `e` 为零时，小数部分为零。
* 当 `e` 非零且为规范值时，`e` &equals; `fraction * 2`<sup>`exponent`</sup>，其中
    小数部分范围为 [0.5, 1.0) 或 (-1.0, -0.5]。
* 当 `e` 是非规范值时，小数部分和指数部分的误差是无界的。
    小数部分可以是任何 AbstractFloat 值，指数可以是任何 AbstractInt 值。

注：导致无穷大或 NaN 的 AbstractFloat 表达式会导致 [=着色器创建错误=]。

返回内置结构体 `__frexp_result_abstract`，定义如下：
```

struct __frexp_result_abstract {
fract : AbstractFloat, // 小数部分
exp : AbstractInt      // 指数部分
}
```


注：`frexp` 这个名称的记忆法是 "**fr**action（小数） 和 **exp**onent（指数）"。

<tr>
<td>
<td>
<div class=‘example wgsl function-scope’ heading=‘abstract frexp usage’>
<xmp>
// 推断结果类型
const fraction_and_exponent = frexp(1.5);
// 设置 fraction_only 为 0.75
const fraction_only = frexp(1.5).fract;
</xmp>
</div>
<tr>
<td>
<td>


注：不能显式声明类型为 __frexp_result_abstract 的值，
但可以推断出该类型的值。


</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary32, frexp">
    <td style="width:10%">重载
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_vecN_f32
      </xmp>
  <tr>
    <td style="width:10%">参数化
    <td>`T` 是 vecN&lt;f32&gt;
  <tr>
    <td>描述
    <td>将 `e` 的分量 `ei` 拆分成一个小数部分和一个指数部分。

    * 当 `ei` 是零时，小数部分为零。
    * 当 `ei` 非零且正常时，`ei` &equals; `fraction * 2`<sup>`exponent`</sup>，其中
        小数部分的范围是 [0.5, 1.0) 或 (-1.0, -0.5]。
    * 否则，`ei`是NaN或无穷大。结果的小数部分和指数部分是[=不确定值=]。

    返回 `__frexp_result_vecN_f32` 内置结构体，其定义如下：
    ```
struct __frexp_result_vecN_f32 {
  fract : vecN<f32>, // 小数部分
  exp : vecN<i32>    // 指数部分
}
    ```

    注意："frexp"名字的助记符是"**fr**action 和 **exp**onent"的缩写。
  <tr>
    <td>
    <td>

注意：不能显式声明类型为 `__frexp_result_vecN_f32` 的值，
但值可以推断出这个类型。

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary16, frexp">
    <td style="width:10%">重载
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_vecN_f16
      </xmp>
  <tr>
    <td style="width:10%">参数化
    <td>`T` 是 vecN&lt;f16&gt;
  <tr>
    <td>描述
    <td>将 `e` 的分量 `ei` 拆分成一个小数部分和一个指数部分。

    * 当 `ei` 是零时，小数部分为零。
    * 当 `ei` 非零且正常时，`ei` &equals; `fraction * 2`<sup>`exponent`</sup>，其中
        小数部分的范围是 [0.5, 1.0) 或 (-1.0, -0.5]。
    * 否则，`ei` 是NaN或无穷大。结果的小数部分和指数部分是[=不确定值=]。

    返回 `__frexp_result_vecN_f16` 内置结构体，其定义如同下面这样：
    ```
struct __frexp_result_vecN_f16 {
  fract : vecN<f16>, // 小数部分
  exp : vecN<i32>    // 指数部分
}
    ```

    注意："frexp"名字的助记符是"**fr**action 和 **exp**onent"的缩写。
  <tr>
    <td>
    <td>

注意：不能显式声明类型为 `__frexp_result_vecN_f16` 的值，
但值可以推断出这个类型。

</table>

<table class=‘data builtin’>
<tr algorithm="矢量情形、抽象类型、frexp">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn frexp(e: T) -> __frexp_result_vecN_abstract
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 为 vecN<AbstractFloat>
<tr>
<td>描述
<td>将 e 的组成部分 ei 拆分为一个小数和一个指数。


* 当 `ei` 为零时，小数部分为零。
* 当 `ei` 为非零且正常时，`ei` &equals; `fraction * 2`<sup>`exponent`</sup>，其中
    小数在 [0.5, 1.0) 或 (-1.0, -0.5] 范围内。
* 当 `ei` 为非规格化时，小数和指数的误差是无界的。
    小数可为任何 AbstractFloat 值，指数可为任何 AbstractInt 值。

注意：生成无穷大或 NaN 的 AbstractFloat 表达式会导致 [=着色器创建错误=]。

返回 `__frexp_result_vecN_abstract` 内置结构体，定义如下：
```

struct __frexp_result_vecN_abstract {
fract : vecN<AbstractFloat>, // 小数部分
exp : vecN<AbstractInt>      // 指数部分
}
```


注意：`frexp` 名称的记忆方法为 "**fr**action and **exp**onent"（小数和指数）。

<tr>
<td>
<td>


注意：不能使用类型 __frexp_result_vecN_abstract 显式声明一个值，
但一个值可能会推断出这个类型。


</table>

### `insertBits` ### {#insertBits-builtin}
<table class=‘data builtin’>
<tr algorithm="insert bits">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn insertBits(e: T,
newbits: T,
offset: u32,
count: u32) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 [整型]
<tr>
<td>描述
<td>在一个整数中设置位。


当 `T` 是一个标量类型时：
<ul>
<li>`w` 是 `T` 的位宽
<li>`o = min(offset, w)`
<li>`c = min(count, w - o)`
<li>如果 `c` 是 0，则结果为 `e`。
<li>否则，
   结果中的位 `o..o + c - 1` 将从 `newbits` 的位 `0..c - 1` 复制得来。
   结果中的其它位从 `e` 复制得来。
</ul>
当 `T` 是向量时，按[=component-wise=]操作。

如果 `count` + `offset` 大于 `w`，则：
* 如果 `count` 和 `offset` 是 [=const-expressions=]，那么它是一个 [=shader-creation error=]。
* 如果 `count` 和 `offset` 是 [=override-expressions=]，那么它是一个 [=pipeline-creation error=]。

</table>

### `inverseSqrt` ### {#inverseSqrt-builtin}
<table class=‘data builtin’>
<tr algorithm="inverseSqrt">
<td style="width:10%">函数重载
<td class="nowrap">
<xmp>
@const @must_use fn inverseSqrt(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 sqrt(e) 的倒数。
当 T 为向量时，对每个分量逐一进行计算。
<tr>
<td>
<td>


注意：如果 e ≤ 0，则结果在数学上没有意义。
</table>

### `ldexp` ### {#ldexp-builtin}
<table class=‘data builtin’>
<tr algorithm="ldexp">
<td style="width:10%">函数重载
<td class="nowrap">
<xmp>
@const @must_use fn ldexp(e1: T,
e2: I) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]<br>
I 是 [ALLSIGNEDINTEGRAL]<br>
当 T 是向量时 I 也为向量<br>
当 T 是一个确定的[=type/concrete=]类型时，I 也是
<tr>
<td>描述
<td>返回 e1 * 2<sup>e2</sup>，除了：
* 如果 e2 + 偏移量 ≤ 0，结果可能为零。
* 如果 e2 > 偏移量 + 1
* 如果 e2 是一个[=const-expression=]，它会成为一个[=shader-creation error=]（着色器创建错误）。
* 如果 e2 是一个[=override-expression=]，它会成为一个[=pipeline-creation error=]（流水线创建错误）。
* 否则结果是 T 的一个[=indeterminate value=]（不确定值）。


这里，*偏移量* 是浮点格式的指数偏移量：
* 对于 `f16` 是 15
* 对于 `f32` 是 127
* 对于 AbstractFloat 是 1023，当 AbstractFloat 为 [[!IEEE-754|IEEE-754]] binary64 时

如果 `x` 是零或其类型的一个有限正常值，则：

<blockquote>
x = ldexp(frexp(x).fract, frexp(x).exp)
</blockquote>

当 `T` 是向量时，[=Component-wise=]（按组件）处理。

注意：`ldexp` 名称的记忆方法是 "load exponent"（加载指数）。
这个名称可能来源于 PDP-11 浮点单元中的对应指令。

</table>

### `length` ### {#length-builtin}
<table class=‘data builtin’>
<tr algorithm="length">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn length(e: T) -> S
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e 的长度。<br>
如果 T 是[=标量=]，则计算 e 的绝对值。<br>
如果 T 是向量类型，则计算 sqrt(e[0]<sup>2</sup> + e[1]<sup>2</sup> + ...)。


    注意：标量情况可能会通过 `sqrt(e * e)` 来计算，
    这可能会不必要地溢出或失去精度。

</table>

### `log` ### {#log-builtin}
<table class=‘data builtin’>
<tr algorithm="log">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn log(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回e的自然对数。
当T是向量时，[=逐元素操作=]。
<tr>
<td>
<td>


注意：如果e < 0，结果在数学上没有意义。
</table>

### `log2` ### {#log2-builtin}
<table class=‘data builtin’>
<tr algorithm="log2">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn log2(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e 的以 2 为底的对数。
当 T 是向量时，按组件计算。
<tr>
<td>
<td>


注意：如果 e < 0，则结果在数学上没有意义。
</table>

### `max` ### {#max-float-builtin}
<table class=‘data builtin’>
<tr algorithm="max">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn max(e1: T,
e2: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLNUMERICDECL]
<tr>
<td>描述
<td>如果 e1 小于 e2，则返回 e2，否则返回 e1。
当 T 是向量时[=按元素操作=]。


如果 `e1` 和 `e2` 是浮点数值，则：
* 如果 `e1` 和 `e2` 均为非正规化数，结果可能是*任何一个*值。
* 如果一个操作数是 NaN，则返回另一个操作数。
* 如果两个操作数均为 NaN，则返回一个 NaN。

</table>

### `min` ### {#min-float-builtin}
<table class=‘data builtin’>
<tr algorithm="min">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn min(e1: T,
e2: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLNUMERICDECL]
<tr>
<td>描述
<td>如果 e2 小于 e1，则返回 e2，否则返回 e1。
当 T 是向量时[=按分量操作=]。


如果 `e1` 和 `e2` 是浮点数值，那么：
* 如果 `e1` 和 `e2` 都是非正规化数，那么结果可能是*任一*值。
* 如果一个操作数是 NaN，那么返回另一个。
* 如果两个操作数都是 NaN，那么返回一个 NaN。

</table>

### `mix` ### {#mix-builtin}
<table class=‘data builtin’>
<tr algorithm="混合所有相同类型的操作数">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn mix(e1: T,
e2: T,
e3: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e1 和 e2 的线性混合（例如 e1 * (1 - e3) + e2 * e3）。
当 T 是向量时，[=按组件操作=]。
</table>


<table class=‘data builtin’>
<tr algorithm="向量与标量混合因子混合">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn mix(e1: T2,
e2: T2,
e3: T) -> T2
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 为 AbstractFloat、f32 或 f16<br>
T2 为 vecN<T>
<tr>
<td>描述
<td>返回 e1 和 e2 的逐组件线性混合，
对每个组件都使用标量混合因子 e3。<br>
等同于 mix(e1, e2, T2(e3))。
</table>

### `modf` ### {#modf-builtin}
<table class=‘data builtin’>
<tr algorithm="scalar case, binary32, modf">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn modf(e: T) -> __modf_result_f32
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 为 f32
<tr>
<td>描述
<td>将 e 分解为小数部分和整数部分。


整数部分是 [[#trunc-builtin|trunc]](`e`)，小数部分是 `e` - [[#trunc-builtin|trunc]](`e`)。

返回 `__modf_result_f32` 内置结构体，定义如下：
```

struct __modf_result_f32 {
fract : f32, // 小数部分
whole : f32  // 整数部分
}
```
<tr>
<td>
<td>
<div class=‘example wgsl function-scope’ heading=‘modf 使用例’>
<xmp>
// 推断结果类型
let fract_and_whole = modf(1.5);
// 将 fract_only 设置为 0.5
let fract_only = modf(1.5).fract;
// 将 whole_only 设置为 1.0
let whole_only = modf(1.5).whole;
</xmp>
</div>
<tr>
<td>
<td>


注意：不能使用类型 __modf_result_f32 显式声明一个值，
但可以推断值的类型。


</table>


<table class=‘data builtin’>
<tr algorithm="scalar case, binary16, modf">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn modf(e: T) -> __modf_result_f16
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 为 f16
<tr>
<td>描述
<td>将 e 分解为小数部分和整数部分。


整数部分是 [[#trunc-builtin|trunc]](`e`)，小数部分是 `e` - [[#trunc-builtin|trunc]](`e`)。

返回 `__modf_result_f16` 内置结构体，定义若为：
```

struct __modf_result_f16 {
fract : f16, // 小数部分
whole : f16  // 整数部分
}
```
<tr>
<td>
<td>


注意：不能使用类型 __modf_result_f16 显式声明一个值，
但可以推断值的类型。


</table>

<table class='data builtin'>
  <tr algorithm="scalar case, abstract, modf">
    <td style="width:10%">重载
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_abstract
      </xmp>
  <tr>
    <td style="width:10%">参数化
    <td>`T` 是 AbstractFloat
  <tr>
    <td>描述
    <td>将 `e` 分割为小数部分和整数部分。

    整数部分是 [[#trunc-builtin|trunc]](`e`)，小数部分是 `e` - [[#trunc-builtin|trunc]](`e`)。

    返回 `__modf_result_abstract` 内置结构，如下所定义：
    ```
struct __modf_result_abstract {
  fract : AbstractFloat, // 小数部分
  whole : AbstractFloat  // 整数部分
}
    ```
  <tr>
    <td>
    <td>
    <div class='example wgsl function-scope' heading='modf 抽象使用'>
    <xmp>
     // 推断结果类型
     const fract_and_whole = modf(1.5);
     // 将 fract_only 设置为 0.5
     const fract_only = modf(1.5).fract;
     // 将 whole_only 设置为 1.0
     const whole_only = modf(1.5).whole;
    </xmp>
    </div>
  <tr>
    <td>
    <td>

注：不能使用类型 `__modf_result_abstract` 显式声明一个值，
但可以推断出该类型的值。

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary32, modf">
    <td style="width:10%">重载
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_vecN_f32
      </xmp>
  <tr>
    <td style="width:10%">参数化
    <td>`T` 是 vecN&lt;f32&gt;
  <tr>
    <td>描述
    <td>将 `e` 的组成部分分割为小数部分和整数部分。

    整数和小数部分的第 `i` 个组件等于 `modf(e[i])` 的整数和小数部分。

    返回 `__modf_result_vecN_f32` 内置结构，如下所定义：
    ```
struct __modf_result_vecN_f32 {
  fract : vecN<f32>, // 小数部分
  whole : vecN<f32>  // 整数部分
}
    ```
  <tr>
    <td>
    <td>

注：不能使用类型 `__modf_result_vecN_f32` 显式声明一个值，
但可以推断出该类型的值。

</table>

<table class=‘data builtin’>
<tr algorithm="vector case, binary16, modf">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn modf(e: T) -> __modf_result_vecN_f16
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 vecN<f16>
<tr>
<td>描述
<td>将 e 的各组成部分拆分为小数部分和整数部分。


整数和小数部分的第 `i` 个分量等于 `modf(e[i])` 的整数和小数部分。

返回内置结构 `__modf_result_vecN_f16`，定义如下：
```

struct __modf_result_vecN_f16 {
fract : vecN<f16>, // 小数部分
whole : vecN<f16>  // 整数部分
}
```
<tr>
<td>
<td>


注意：无法显式声明类型为 __modf_result_vecN_f16 的值，
但值可以推断出类型。


</table>


<table class=‘data builtin’>
<tr algorithm="vector case, abstract, modf">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn modf(e: T) -> __modf_result_vecN_abstract
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 vecN<AbstractFloat>
<tr>
<td>描述
<td>将 e 的各组成部分拆分为小数部分和整数部分。


整数和小数部分的第 `i` 个分量等于 `modf(e[i])` 的整数和小数部分。

返回内置结构 `__modf_result_vecN_abstract`，定义如下：
```

struct __modf_result_vecN_abstract {
fract : vecN<AbstractFloat>, // 小数部分
whole : vecN<AbstractFloat>  // 整数部分
}
```
<tr>
<td>
<td>


注意：无法显式声明类型为 __modf_result_vecN_abstract 的值，
但值可以推断出类型。


</table>

### `normalize` ### {#normalize-builtin}
<table class=‘data builtin’>
<tr algorithm="矢量情况，归一化">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn normalize(e: vecN<T> ) -> vecN<T>
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 AbstractFloat, f32 或 f16
<tr>
<td>描述
<td>返回与 e 相同方向的单位向量。
</table>

### `pow` ### {#pow-builtin}
<table class=‘data builtin’>
<tr algorithm="pow">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn pow(e1: T,
e2: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e1 的 e2 次幂。
当 T 是向量时，[=按元素操作=]。
</table>

### `quantizeToF16` ### {#quantizeToF16-builtin}
<table class=‘data builtin’>
<tr algorithm="量化至 f16">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn quantizeToF16(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f32 或 vecN<f32>
<tr>
<td>描述
<td>将32位浮点数值 e 量化，就像将 e 转换为
[[!IEEE-754|IEEE 754]] 二进制16位值，然后再转换回
IEEE 754 二进制32位值。


    如果 `e` 超出了二进制16的有限范围，则：
    * 如果 `e` 是 [=const-expression=]，那么它是一个 [=shader-creation error=]。
    * 如果 `e` 是 [=override-expression=]，那么它是一个 [=pipeline-creation error=]。
    * 否则结果对于 `T` 是一个 [=indeterminate value=]。

    中间的二进制16位值可以被 [=flushed to zero=]，即如果中间的二进制16位值是非规范值，
    那么最终结果可能是零。

    参见 [[#floating-point-conversion]]。

    当 `T` 是向量时，操作是[=Component-wise=]的。

<tr>
<td>
<td>


注：vec2<f32> 的情况与 unpack2x16float(pack2x16float(e)) 相同。


</table>

### `radians` ### {#radians-builtin}
<table class=‘data builtin’>
<tr algorithm="radians">
<td style="width:10%">超载
<td class="nowrap">
<xmp>
@const @must_use fn radians(e1: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[所有浮点类型声明]
<tr>
<td>描述
<td>将角度转换为弧度，近似计算 e1 × π; ÷ 180。
当 T 是向量时[=按组件操作=]
</table>

### `reflect` ### {#reflect-builtin}
<table class=‘data builtin’>
<tr algorithm="reflect">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn reflect(e1: T,
e2: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 vecN<AbstractFloat>, vecN<f32>, 或 vecN<f16>
<tr>
<td>描述
<td>对于入射向量 e1 和表面方向 e2，返回反射方向
e1 - 2 * dot(e2, e1) * e2。
</table>

### `refract` ### {#refract-builtin}
<table class=‘data builtin’>
<tr algorithm="refract">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn refract(e1: T,
e2: T,
e3: I) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 vecN<I><br>
I 是抽象浮点数(AbstractFloat)，f32 或者 f16
<tr>
<td>描述
<td>对于入射向量 e1、表面法线 e2 以及折射率之比 e3，
设 k = 1.0 - e3 * e3 * (1.0 - dot(e2, e1) * dot(e2, e1))。
如果 k < 0.0，则返回折射向量0.0，否则返回折射向量
e3 * e1 - (e3 * dot(e2, e1) + sqrt(k)) * e2。
</table>

### `reverseBits` ### {#reverseBits-builtin}
<table class='data builtin'>
  <tr algorithm="bit reversal">
    <td style="width:10%">重载
    <td class="nowrap">
      <xmp>
        @const @must_use fn reverseBits(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">参数化
    <td>`T` 是 [整数类型]
  <tr>
    <td>描述
    <td>反转 `e` 中的位：结果中位置 `k` 的位等于 `e` 中位置 `31 - k` 的位。<br>
        当 `T` 是向量时，[=按组件操作=]。
</table>

### `round` ### {#round-builtin}
<table class=‘data builtin’>
<tr algorithm="round">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn round(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>结果是最接近e的整数k，以浮点数形式表示。<br>
当e位于两个整数k和k + 1的中间时，
若k为偶数，则结果为k；若k为奇数，则结果为k + 1。<br>
当T是向量时，按[=逐元素=]处理。
</table>

### `saturate` ### {#saturate-float-builtin}
<table class=‘data builtin’>
<tr algorithm="saturate">
<td style="width:10%">过载
<td class="nowrap">
<xmp>@const @must_use fn saturate(e: T) -> T</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 clamp(e, 0.0, 1.0)。
当 T 是向量时，[=按分量操作=]。
</table>

### `sign` ### {#sign-builtin}
<table class=‘data builtin’>
<tr algorithm="numeric sign">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn sign(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[所有有符号的数值声明]
<tr>
<td>描述
<td>结果是：
<ul>
<li> 1 当 e > 0
<li> 0 当 e = 0
<li> -1 当 e < 0
</ul>


当 `T` 是向量时[=按分量运算=]。

</table>

### `sin` ### {#sin-builtin}
<table class=‘data builtin’>
<tr algorithm="sin">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn sin(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e 的正弦值，其中 e 是以弧度为单位。
当 T 是向量时[=按组件=]计算。
</table>

### `sinh` ### {#sinh-builtin}
<table class=‘data builtin’>
<tr algorithm="sinh">
<td style="width:10%">函数重载
<td class="nowrap">
<xmp>
@const @must_use fn sinh(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回e的双曲正弦值，其中e是以弧度表示的双曲[=角度=]。
接近纯数学函数
(e<sup>arg</sup> − e<sup>−arg</sup>)÷2,
但并不一定以这种方式计算。


当 `T` 是向量时，[=按组件计算=]。

</table>

### `smoothstep` ### {#smoothstep-builtin}
<table class=‘data builtin’>
<tr algorithm="smoothstep">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn smoothstep(low: T,
high: T,
x: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回从0到1的平滑Hermite插值。
当T是向量时[=分量逐个处理=]。


对于标量 `T`，结果是
`t * t * (3.0 - 2.0 * t)`，
其中 `t = clamp((x - low) / (high - low), 0.0, 1.0)`。

</table>

### `sqrt` ### {#sqrt-builtin}
<table class=‘data builtin’>
<tr algorithm="sqrt">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn sqrt(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回 e 的平方根。
当 T 是向量时，[=Component-wise=] (按元素计算)。
</table>

### `step` ### {#step-builtin}
<table class=‘data builtin’>
<tr algorithm="step">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn step(edge: T,
x: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>当 edge ≤ x 时返回1.0，否则返回0.0。
当 T 是向量时，以[=按分量操作=]的方式。
</table>

### `tan` ### {#tan-builtin}
<table class=‘data builtin’>
<tr algorithm="tan">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn tan(e: T) -> T
</xmp>
</tr>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
</tr>
<tr>
<td>描述
<td>返回e的正切值，其中e是以弧度为单位的角度。
当T是向量时，按[=逐元素=]操作。
</table>

### `tanh` ### {#tanh-builtin}
<table class=‘data builtin’>
<tr algorithm="tanh">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@const @must_use fn tanh(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回e的双曲正切值，其中e是以弧度表示的一个双曲[=角度=]。
近似纯数学函数
(e<sup>arg</sup> − e<sup>−arg</sup>) ÷ (e<sup>arg</sup> + e<sup>−arg</sup>)
但不一定以这种方式计算。


当 `T` 是向量时，[=逐元素=]计算。

</table>

### `transpose` ### {#transpose-builtin}
<table class=‘data builtin’>
<tr algorithm="transpose">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@const @must_use fn transpose(e: matRxC<T>) -> matCxR<T>
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 AbstractFloat、f32 或 f16
<tr>
<td>描述
<td>返回 e 的转置。
</table>

### `trunc` ### {#trunc-builtin}
<table class=‘data builtin’>
<tr algorithm="trunc">
<td style="width:10%">函数重载
<td class="nowrap">
<xmp>
@const @must_use fn trunc(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>[ALLFLOATINGDECL]
<tr>
<td>描述
<td>返回=truncate=，即最接近的整数，其绝对值小于或等于e的绝对值。
当T是向量时，按[=Component-wise=]（逐分量）执行此操作。
</table>

## 内置导数函数 ## {#derivative-builtin-functions}

参见[[#derivatives]]章节。


对这些函数的调用：
* [=shader-creation error|必须=]只能在 [=fragment=] 着色器阶段中使用。
* 如果 [=uniformity analysis=] 无法证明调用处于 [=uniform control flow=] 中，将触发一个 [=trigger/derivative_uniformity=] [=diagnostic=] 。

### `dpdx` ### {#dpdx-builtin}
<table class=‘data builtin’>
<tr algorithm="dpdx">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@must_use fn dpdx(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f32 或 vecN<f32>
<tr>
<td>描述
<td>对于窗口 x 坐标的 e 的偏导数。
结果与 dpdxFine(e) 或 dpdxCoarse(e) 相同。


如果在[=非均匀控制流=]中调用，则返回一个[=不确定的值=]。

</table>

### `dpdxCoarse` ### {#dpdxCoarse-builtin}
<table class=‘data builtin’>
<tr algorithm="dpdxCoarse">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@must_use fn dpdxCoarse(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f32 或 vecN<f32>
<tr>
<td>描述
<td>返回关于窗口x坐标的e的局部差分形式的偏导数。
这可能导致比dpdxFine(e)有更少的独特位置。


如果在[=非统一控制流|非均匀控制流=]中调用，则返回[=不确定值=]。

</table>

### `dpdxFine` ### {#dpdxFine-builtin}
<table class=‘data builtin’>
<tr algorithm="dpdxFine">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@must_use fn dpdxFine(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f32 或 vecN<f32>
<tr>
<td>描述
<td>返回对于窗口x坐标e的偏导数。


如果在[=uniform control flow|不均匀控制流=]中调用，则返回[=不确定值=]。

</table>

### `dpdy` ### {#dpdy-builtin}
<table class=‘data builtin’>
<tr algorithm="dpdy">
<td style="width:10%">过载
<td class="nowrap">
<xmp>@must_use fn dpdy(e: T) -> T</xmp>
</tr>
<tr>
<td style="width:10%">参数化
<td>T 是 f32 或 vecN<f32>
</tr>
<tr>
<td>描述
<td>相对于窗口 y 坐标的 e 的偏导数。
结果与 dpdyFine(e) 或 dpdyCoarse(e) 相同。


如果在 [=非均匀控制流程|均匀控制流程=] 中调用，则返回一个 [=不确定的值=]。

</tr>
</table>

### `dpdyCoarse` ### {#dpdyCoarse-builtin}
<table class=‘data builtin’>
<tr algorithm="dpdyCoarse">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@must_use 函数 dpdyCoarse(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f32 或 vecN<f32>
<tr>
<td>描述
<td>利用局部差异返回关于窗口y坐标的e的偏导数。
这可能会导致比 dpdyFine(e) 更少的唯一位置。


如果在[=非一致控制流=]中调用，则返回[=不确定值=]。

</table>

### `dpdyFine` ### {#dpdyFine-builtin}
<table class=‘data builtin’>
<tr algorithm="dpdyFine">
<td style="width:10%">过载
<td class="nowrap">
<xmp>
@must_use fn dpdyFine(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f32 或 vecN<f32>
<tr>
<td>描述
<td>返回 e 相对于窗口 y 坐标的偏导数。


如果在[=非均匀控制流=]中调用，则返回[=不确定的值=]。

</table>

### `fwidth` ### {#fwidth-builtin}
<table class=‘data builtin’>
<tr algorithm="fwidth">
<td style="width:10%">重载
<td class="nowrap">
<xmp>
@must_use fn fwidth(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f32 或 vecN<f32>
<tr>
<td>描述
<td>返回 abs(dpdx(e)) + abs(dpdy(e))。


如果在[=非一致控制流|不一致的控制流=]中调用，则返回[=不确定的值=]。

</table>

### `fwidthCoarse` ### {#fwidthCoarse-builtin}
<table class=‘data builtin’>
<tr algorithm="fwidthCoarse">
<td style="width:10%">函数重载
<td class="nowrap">
<xmp>
@must_use fn fwidthCoarse(e: T) -> T
</xmp>
<tr>
<td style="width:10%">参数化
<td>T 是 f32 或 vecN<f32>
<tr>
<td>描述
<td>返回 abs(dpdxCoarse(e)) + abs(dpdyCoarse(e))。


如果在[=均匀控制流|非均匀控制流=]中调用，则返回[=不确定值=]。

</table>

### `fwidthFine` ### {#fwidthFine-builtin}
<table class='data builtin'>
  <tr algorithm="fwidthFine">
    <td style="width:10%">过载
    <td class="nowrap">
      <xmp>
        @must_use fn fwidthFine(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">参数化
    <td>`T` 是 f32 或 vecN<f32>
  <tr>
    <td>描述
    <td>返回 `abs(dpdxFine(e)) + abs(dpdyFine(e))`。

    如果在[=非一致控制流程=]中调用，则返回[=不确定值=]。
</table>

## 纹理内置函数 ## {#texture-builtin-functions}

参数值必须对应各自的纹理类型而有效。

### `textureDimensions` ### {#texturedimensions}

返回一个纹理或纹理的mip等级的尺寸，以纹素为单位。

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureDimensions 1d">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_1d<ST>` or `texture_storage_1d<F,A>`
    <td>
      <xmp>@must_use fn textureDimensions(t: T) -> u32</xmp>

  <tr algorithm="textureDimensions 1d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        |T| is `texture_1d<ST>`

        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureDimensions(t: T,
                                       level: L) -> u32
      </xmp>

  <tr algorithm="textureDimensions 2d">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_2d<ST>`, `texture_2d_array<ST>`, `texture_cube<ST>`,
               `texture_cube_array<ST>`, `texture_multisampled_2d<ST>`,
               `texture_depth_2d`, `texture_depth_2d_array`, `texture_depth_cube`,
               `texture_depth_cube_array`, `texture_depth_multisampled_2d`,
               `texture_storage_2d<F,A>`, `texture_storage_2d_array<F,A>`,
               or `texture_external`
    <td>
      <xmp>@must_use fn textureDimensions(t: T) -> vec2<u32></xmp>

  <tr algorithm="textureDimensions 2d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        |T| is `texture_2d<ST>`, `texture_2d_array<ST>`, `texture_cube<ST>`,
               `texture_cube_array<ST>`, `texture_depth_2d`, `texture_depth_2d_array`,
               `texture_depth_cube`, or `texture_depth_cube_array`

        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureDimensions(t: T,
                                       level: L) -> vec2<u32>
      </xmp>

  <tr algorithm="textureDimensions 3d">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_3d<ST>` or `texture_storage_3d<F,A>`
    <td>
      <xmp>@must_use fn textureDimensions(t: T) -> vec3<u32></xmp>

  <tr algorithm="textureDimensions 3d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        |T| is `texture_3d<ST>`

        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureDimensions(t: T,
                                       level: L) -> vec3<u32>
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  采样（sampled）、多采样（multisampled）、深度（depth）、存储（storage）或外部（external）纹理。
  <tr><td>level<td>
  [=mip 层级=]，层级0包含了纹理的完整尺寸版本。<br>
  如果省略，则返回层级0的尺寸。
</table>

**Returns:**

纹理的坐标维度。


也就是说，结果提供了[=逻辑纹素地址=]坐标的整数边界，
但不包括[=纹理/多级渐进纹理数量=]、[=纹理/阵列大小=]以及[=纹理/采样数量=]。


对于基于立方体的纹理，结果是立方体每个面的维度。
立方体面是正方形的，所以结果的x和y分量相等。


如果level在范围[0, textureNumLevels(t))之外，则可能会返回一个[=不确定值=]
作为返回类型。

### `textureGather` ### {#texturegather}

一种<dfn noexport>纹理采集</dfn>操作读取一个2D、2D数组、立方体或立方体数组纹理，按如下方式计算一个四分量向量：


从[=mip等级=] 0处找到在使用线性过滤的采样操作中将会使用的四个纹理元素：
使用指定的坐标，数组索引（如果存在）和偏移（如果存在）。
纹理元素相邻，形成一个正方形，当考虑它们的纹理空间坐标(u，v)时。
在纹理边缘、立方体面边缘或立方体角处选定的纹理素被处理 如同普通纹理采样一样。
对于每个纹理元素，读取一个通道并将其转换为标量值。
对于非深度纹理，基于零的component参数指定要使用的通道。
如果纹理格式支持指定的通道，即拥有超过component通道数量：
当纹理元素的值是v时，生成标量值v[component]。
否则：
当component是1或2时，生成0.0。
当component是3（即alpha通道）时，生成1.0。
对于[=type/depth textures=]，产生纹理元素的值。（深度纹理只有一个通道。）
根据纹理元素的相对坐标，生成四分量向量，把前一步生成的标量值组织进组件中，如下所示：
<table> <thead class=‘data’><td>结果分量<td>相对纹理元素坐标</thead> <tr><td>x<td>(u<sub>min</sub>,v<sub>max</sub>) <tr><td>y<td>(u<sub>max</sub>,v<sub>max</sub>) <tr><td>z<td>(u<sub>max</sub>,v<sub>min</sub>) <tr><td>w<td>(u<sub>min</sub>,v<sub>min</sub>) </table>

待办事项：四个纹理素是应该由WebGPU规范描述的"样本范围"。
https://github.com/gpuweb/gpuweb/issues/2343


<table class=‘data’>
<thead>
<tr><td style="width:25%">参数化<th>重载
</thead>
<tr algorithm="textureGather 2d">
<td><var ignore>C</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=]，[=u32=] 或 [=f32=]
<td>
<xmp>
@must_use fn textureGather(component: C,
t: texture_2d<ST>,
s: sampler,
coords: vec2<f32>) -> vec4<ST>
</xmp>


<tr algorithm="textureGather 2d offset">
<td><var ignore>C</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=]，[=u32=] 或 [=f32=]
<td>
<xmp>
@must_use fn textureGather(component: C,
t: texture_2d<ST>,
s: sampler,
coords: vec2<f32>,
offset: vec2<i32>) -> vec4<ST>
</xmp>


<tr algorithm="textureGather 2d array">
<td><var ignore>C</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>A</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=]，[=u32=] 或 [=f32=]
<td>
<xmp>
@must_use fn textureGather(component: C,
t: texture_2d_array<ST>,
s: sampler,
coords: vec2<f32>,
array_index: A) -> vec4<ST>
</xmp>


<tr algorithm="textureGather 2d array offset">
<td><var ignore>C</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>A</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=]，[=u32=] 或 [=f32=]
<td>
<xmp>
@must_use fn textureGather(component: C,
t: texture_2d_array<ST>,
s: sampler,
coords: vec2<f32>,
array_index: A,
offset: vec2<i32>) -> vec4<ST>
</xmp>


<tr algorithm="textureGather cube">
<td><var ignore>C</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=]，[=u32=] 或 [=f32=]
<td>
<xmp>
@must_use fn textureGather(component: C,
t: texture_cube<ST>,
s: sampler,
coords: vec3<f32>) -> vec4<ST>
</xmp>


<tr algorithm="textureGather cube array">
<td><var ignore>C</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>A</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=]，[=u32=] 或 [=f32=]
<td>
<xmp>
@must_use fn textureGather(component: C,
t: texture_cube_array<ST>,
s: sampler,
coords: vec3<f32>,
array_index: A) -> vec4<ST>
</xmp>


<tr algorithm="textureGather 2d depth">
<td>
<td>
<xmp>
@must_use fn textureGather(t: texture_depth_2d,
s: sampler,
coords: vec2<f32>) -> vec4<f32>
</xmp>


<tr algorithm="textureGather 2d depth offset">
<td>
<td>
<xmp>
@must_use fn textureGather(t: texture_depth_2d,
s: sampler,
coords: vec2<f32>,
offset: vec2<i32>) -> vec4<f32>
</xmp>


<tr algorithm="textureGather cube depth">
<td>
<td>
<xmp>
@must_use fn textureGather(t: texture_depth_cube,
s: sampler,
coords: vec3<f32>) -> vec4<f32>
</xmp>


<tr algorithm="textureGather 2d depth array">
<td><var ignore>A</var> 是 [=i32=] 或 [=u32=]
<td>
<xmp>
@must_use fn textureGather(t: texture_depth_2d_array,
s: sampler,
coords: vec2<f32>,
array_index: A) -> vec4<f32>
</xmp>


<tr algorithm="textureGather 2d depth array offset">
<td><var ignore>A</var> 是 [=i32=] 或 [=u32=]
<td>
<xmp>
@must_use fn textureGather(t: texture_depth_2d_array,
s: sampler,
coords: vec2<f32>,
array_index: A,
offset: vec2<i32>) -> vec4<f32>
</xmp>


<tr algorithm="textureGather cube depth array">
<td><var ignore>A</var> 是 [=i32=] 或 [=u32=]
<td>
<xmp>
@must_use fn textureGather(t: texture_depth_cube_array,
s: sampler,
coords: vec3<f32>,
array_index: A) -> vec4<f32>
</xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`component`</td>
  <td>仅适用于非深度纹理。<br>
  从选定纹素中读取的通道索引。<br>
  当提供时，`component`表达式[=shader-creation error|必须=]是一个[=const-expression=]（例如 `1`）。<br>
  其值必须至少为0且最多为3。
  超出此范围的值将导致[=shader-creation error=]（着色器创建错误）。</td></tr>
  <tr><td>`t`</td>
  <td>从中读取的[采样](#sampled-texture-type)或[深度](#texture-depth)纹理。</td></tr>
  <tr><td>`s`</td>
  <td>[采样器类型](#sampler-type)。</td></tr>
  <tr><td>`coords`</td>
  <td>纹理坐标。</td></tr>
  <tr><td>`array_index`</td>
  <td>基于0的纹理数组索引。</td></tr>
  <tr><td>`offset`</td>
  <td>在采样纹理之前应用于非标准化纹理坐标的可选纹素偏移。在应用任何纹理包装模式之前应用此偏移。<br>
  `offset`表达式[=shader-creation error|必须=]是一个[=const-expression=]（例如 `vec2<i32>(1, 2)`）。<br>
  每个 `offset` 分量[=shader-creation error|必须=]至少为 `-8` 且最多为 `7` 。超出此范围的值将导致[=shader-creation error=]（着色器创建错误）。</td></tr>
</table>

**Returns:**

一个由上文描述的从选定纹理像素的指定通道中提取的组件构成的四分量向量。


<div class=‘example wgsl global-scope’ heading="从2D纹理中的纹理像素聚集组件">
<xmp>
@group(0) @binding(0) var t: texture_2d<f32>;
@group(0) @binding(1) var dt: texture_depth_2d;
@group(0) @binding(2) var s: sampler;


fn gather_x_components(c: vec2<f32>) -> vec4<f32> {
  return textureGather(0,t,s,c);
}
fn gather_y_components(c: vec2<f32>) -> vec4<f32> {
  return textureGather(1,t,s,c);
}
fn gather_z_components(c: vec2<f32>) -> vec4<f32> {
  return textureGather(2,t,s,c);
}
fn gather_depth_components(c: vec2<f32>) -> vec4<f32> {
  return textureGather(dt,s,c);
}

</xmp>
</div>

### `textureGatherCompare` ### {#texturegathercompare}

纹理采集对比操作在一个深度纹理的四个纹素上执行深度比较，并将结果收集到单个向量中，过程如下：
* 在从 [纹理级别=] 0开始的深度采样操作中找到四个会被用到的线性过滤纹素：
    * 使用指定的坐标、数组索引（如存在）和偏移量（如存在）。
    * 这些纹素相邻，形成一个正方形，考虑它们在纹理空间中的坐标（u，v）。
    * 在纹理边缘、立方体面边缘或立方体角落的选定纹素，处理方式与普通纹理采样相同。
* 对每个纹素执行与深度参考值的比较，根据比较采样器参数的控制产生 0.0 或 1.0 的值。
    * 输出四分量向量，其组分是与相对纹素坐标如下的纹素的比较结果：
  

<table> <thead class=‘data’><td>结果组分<td>相对纹素坐标</thead> <tr><td>x<td>(u<sub>min</sub>,v<sub>max</sub>) <tr><td>y<td>(u<sub>max</sub>,v<sub>max</sub>) <tr><td>z<td>(u<sub>max</sub>,v<sub>min</sub>) <tr><td>w<td>(u<sub>min</sub>,v<sub>min</sub>) </table>

<table class=‘data’>
<thead>
<tr><td style="width:25%">参数化<th>函数重载
</thead>
<tr algorithm="textureGatherCompare 2d depth">
<td>
<td>
<xmp>
@must_use fn textureGatherCompare(t: texture_depth_2d,
s: sampler_comparison,
coords: vec2<f32>,
depth_ref: f32) -> vec4<f32>
</xmp>


<tr algorithm="textureGatherCompare 2d depth offset">
<td>
<td>
<xmp>
@must_use fn textureGatherCompare(t: texture_depth_2d,
s: sampler_comparison,
coords: vec2<f32>,
depth_ref: f32,
offset: vec2<i32>) -> vec4<f32>
</xmp>


<tr algorithm="textureGatherCompare 2d depth array">
<td><var ignore>A</var> 是 [=i32=], 或者 [=u32=]
<td>
<xmp>
@must_use fn textureGatherCompare(t: texture_depth_2d_array,
s: sampler_comparison,
coords: vec2<f32>,
array_index: A,
depth_ref: f32) -> vec4<f32>
</xmp>


<tr algorithm="textureGatherCompare 2d depth array offset">
<td><var ignore>A</var> 是 [=i32=], 或者 [=u32=]
<td>
<xmp>
@must_use fn textureGatherCompare(t: texture_depth_2d_array,
s: sampler_comparison,
coords: vec2<f32>,
array_index: A,
depth_ref: f32,
offset: vec2<i32>) -> vec4<f32>
</xmp>


<tr algorithm="textureGatherCompare 2d depth cube">
<td>
<td>
<xmp>
@must_use fn textureGatherCompare(t: texture_depth_cube,
s: sampler_comparison,
coords: vec3<f32>,
depth_ref: f32) -> vec4<f32>
</xmp>


<tr algorithm="textureGatherCompare 2d depth cube array">
<td><var ignore>A</var> 是 [=i32=], 或者 [=u32=]
<td>
<xmp>
@must_use fn textureGatherCompare(t: texture_depth_cube_array,
s: sampler_comparison,
coords: vec3<f32>,
array_index: A,
depth_ref: f32) -> vec4<f32>
</xmp>


</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  用于读取的[深度](#texture-depth)纹理。
  <tr><td>`s`<td>
  [采样器比较](#sampler-type)。
  <tr><td>`coords`<td>
  纹理坐标。
  <tr><td>`array_index`<td>
  基于0的纹理数组索引。
  <tr><td>`depth_ref`<td>
  用于与采样的深度值比较的参考值。
  <tr><td>`offset`<td>
  在采样纹理之前应用于未标准化纹理坐标的可选纹素偏移。在应用任何纹理包装模式之前应用此偏移。<br>
  `offset` 表达式[=shader-creation error|必须=]是一个[=const-expression=]（例如 `vec2<i32>(1, 2)`）。<br>
  每个 `offset` 组件[=shader-creation error|必须=]至少为 `-8` 并且最多为 `7`。超出此范围的值将导致一个[=shader-creation error=]。
</table>

**Returns:**

一个包含所选纹素比较结果的四分量向量，如上述所述。


<div class=‘example wgsl global-scope’ heading="深度比较汇集">
<xmp>
@group(0) @binding(0) var dt: texture_depth_2d;
@group(0) @binding(1) var s: sampler;


fn gather_depth_compare(c: vec2<f32>, depth_ref: f32) -> vec4<f32> {
  return textureGatherCompare(dt,s,c,depth_ref);
}

</xmp>
</div>

### `textureLoad` ### {#textureload}

从纹理中读取单个纹素，不进行采样或过滤。


<table class=‘data’>
<thead>
<tr><td style="width:25%">参数化<th>重载
</thead>
<tr algorithm="textureLoad 1d">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>L</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=], [=u32=], 或 [=f32=]
<td>
<xmp>
@必须使用函数 textureLoad(t: texture_1d<ST>,
坐标: C,
级别: L) -> vec4<ST>
</xmp>


<tr algorithm="textureLoad 2d">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>L</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=], [=u32=], 或 [=f32=]
<td>
<xmp>
@必须使用函数 textureLoad(t: texture_2d<ST>,
坐标: vec2<C>,
级别: L) -> vec4<ST>
</xmp>


<tr algorithm="textureLoad 2d array">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>A</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>L</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=], [=u32=], 或 [=f32=]
<td>
<xmp>
@必须使用函数 textureLoad(t: texture_2d_array<ST>,
坐标: vec2<C>,
数组索引: A,
级别: L) -> vec4<ST>
</xmp>


<tr algorithm="textureLoad 3d">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>L</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=], [=u32=], 或 [=f32=]
<td>
<xmp>
@必须使用函数 textureLoad(t: texture_3d<ST>,
坐标: vec3<C>,
级别: L) -> vec4<ST>
</xmp>


<tr algorithm="textureLoad 2d multisampled">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>S</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>ST</var> 是 [=i32=], [=u32=], 或 [=f32=]
<td>
<xmp>
@必须使用函数 textureLoad(t: texture_multisampled_2d<ST>,
坐标: vec2<C>,
样本索引: S)-> vec4<ST>
</xmp>


<tr algorithm="textureLoad 2d depth">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>L</var> 是 [=i32=], 或 [=u32=]
<td>
<xmp>
@必须使用函数 textureLoad(t: texture_depth_2d,
坐标: vec2<C>,
级别: L) -> f32
</xmp>


<tr algorithm="textureLoad 2d depth array">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>A</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>L</var> 是 [=i32=], 或 [=u32=]
<td>
<xmp>
@必须使用函数 textureLoad(t: texture_depth_2d_array,
坐标: vec2<C>,
数组索引: A,
级别: L) -> f32
</xmp>


<tr algorithm="textureLoad 2d depth multisampled">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>S</var> 是 [=i32=], 或 [=u32=]
<td>
<xmp>
@必须使用函数 textureLoad(t: texture_depth_multisampled_2d,
坐标: vec2<C>,
样本索引: S)-> f32
</xmp>


<tr algorithm="textureLoad external">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]
<td>
<xmp>
@必须使用函数 textureLoad(t: texture_external,
坐标: vec2<C>) -> vec4<f32>
</xmp>


<tr algorithm="textureLoad 1d storage">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>AM</var> 是 [=access/read=] 或 [=access/read_write=]<br>
<var ignore>CF</var> 取决于存储纹素格式 <var ignore>F</var>。
参见纹素格式表了解纹素格式映射到通道格式的信息。
<td>
<xmp>
@必须使用函数 textureLoad(t : texture_storage_1d<F, AM>,
坐标 : C) -> vec4<CF>
</xmp>


<tr algorithm="textureLoad 2d storage">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>AM</var> 是 [=access/read=] 或 [=access/read_write=]<br>
<var ignore>CF</var> 取决于存储纹素格式 <var ignore>F</var>。
参见纹素格式表了解纹素格式映射到通道格式的信息。
<td>
<xmp>
@必须使用函数 textureLoad(t : texture_storage_2d<F, AM>,
坐标 : vec2<C>) -> vec4<CF>
</xmp>


<tr algorithm="textureLoad 2d array storage">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>AM</var> 是 [=access/read=] 或 [=access/read_write=]<br>
<var ignore>A</var> 是 [=i32=] 或 [=u32=]<br>
<var ignore>CF</var> 取决于存储纹素格式 <var ignore>F</var>。
参见纹素格式表了解纹素格式映射到通道格式的信息。
<td>
<xmp>
@必须使用函数 textureLoad(t : texture_storage_2d_array<F, AM>,
坐标 : vec2<C>,
数组索引 : A) -> vec4<CF>
</xmp>


<tr algorithm="textureLoad 3d storage">
<td><var ignore>C</var> 是 [=i32=], 或 [=u32=]<br>
<var ignore>AM</var> 是 [=access/read=] 或 [=access/read_write=]<br>
<var ignore>CF</var> 取决于存储纹素格式 <var ignore>F</var>。
参见纹素格式表了解纹素格式映射到通道格式的信息。
<td>
<xmp>
@必须使用函数 textureLoad(t : texture_storage_3d<F, AM>,
坐标 : vec3<C>) -> vec4<CF>
</xmp>
</table>

**Parameters:**

<table class=‘data’>
<tr><td>t<td>
被采样的[=type/sampled texture|采样=]、
[=type/multisampled texture|多重采样=]、
[=type/depth texture|深度=]、
[=type/storage texture|存储=] 或者
[=type/external texture|外部=]
纹理
<tr><td>coords<td>
基于0的纹素坐标。
<tr><td>array_index<td>
基于0的纹理数组索引。
<tr><td>level<td>
[=mip level=]，其中级别0包含纹理的完整尺寸版本。
<tr><td>sample_index<td>
[=type/multisampled texture=]的基于0的样本索引。
</table>

**Returns:**

原始纹素数据。


如果出现以下情况，[=逻辑纹素地址=] 是无效的：
* coords 的任何元素都超出了相对应元素的范围 [0, textureDimensions(t, level))，或者
* array_index 超出了范围 [0, textureNumLayers(t))，或者
* level 超出了范围 [0, textureNumLevels(t))，或者
* sample_index 超出了范围 [0, textureNumSamples(s))

如果逻辑纹素地址是无效的，内置函数将返回以下内容之一：
* 纹理范围内某个纹素的数据
* 对于非深度纹理，适当类型的向量 (0,0,0,0) 或 (0,0,0,1)
* 对于深度纹理，返回 0.0

### `textureNumLayers` ### {#texturenumlayers}

返回一个[=texture/arrayed=]纹理的层数（元素数量）。


<table class=‘data’>
<thead>
<tr><td style="width:25%">参数化<th>重载
</thead>
<tr algorithm="texturenumlayers">
<td><var ignore>F</var> 是一个 [=纹素格式=]<br>
<var ignore>A</var> 是一个 [=访问模式=]<br>
<var ignore>ST</var> 是 [=i32=]、[=u32=] 或 [=f32=]<br><br>
<var ignore>T</var> 是 texture_2d_array<ST>、texture_cube_array<ST>、
texture_depth_2d_array、texture_depth_cube_array，
或者 texture_storage_2d_array<F,A>
<td>
<xmp>@must_use fn textureNumLayers(t: T) -> u32</xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=],
  [=type/depth texture|depth=], or
  [=type/storage texture=] array texture.
</table>

**Returns:**

如果纹理是基于立方体的，返回立方体阵列纹理中立方体的数量。


否则返回阵列纹理中层的数量（纹素的均匀网格）。

### `textureNumLevels` ### {#texturenumlevels}

返回纹理的mip级别数量。


<table class=‘data’>
<thead>
<tr><td style="width:25%">参数化<th>重载
</thead>
<tr algorithm="texturenumlevels">
<td><var ignore>ST</var> 是 [=i32=]、[=u32=] 或 [=f32=]<br><br>
<var ignore>T</var> 是 texture_1d<ST>、texture_2d<ST>、
texture_2d_array<ST>、texture_3d<ST>、
texture_cube<ST>、texture_cube_array<ST>、
texture_depth_2d、texture_depth_2d_array、
texture_depth_cube 或 texture_depth_cube_array
<td>
<xmp>@must_use fn textureNumLevels(t: T) -> u32</xmp>
</table>

**Parameters:**

<table class=‘data’>
<tr><td>t<td>
采样的纹理或深度纹理的类型。
</table>

**Returns:**

这个纹理的[=贴图/纹理级别数量=]。


### `textureNumSamples` ### {#texturenumsamples}

返回每个纹素在多重采样纹理中的样本数量。


<table class=‘data’>
<thead>
<tr><td style="width:45%">参数化<th>重载
</thead>
<tr algorithm="texturenumsamples">
<td><var ignore>ST</var> 是 [=i32=]、[=u32=] 或 [=f32=]<br><br>
<var ignore>T</var> 是 texture_multisampled_2d<ST>
或 texture_depth_multisampled_2d
<td>
<xmp>@must_use fn textureNumSamples(t: T) -> u32</xmp>
</table>

参数：

<table class=‘data’>
<tr><td>t<td>
多重采样纹理的类型。
</table>

**Returns:**

[=texture/sample count=]为[=type/multisampled texture=]的纹理/采样数。


### `textureSample` ### {#texturesample}

采样一个纹理。


[=shader-creation error|必须=]只能在一个[=fragment=]片段着色器阶段中使用。


如果[=uniformity analysis=]不能证明对这个函数的调用位于[=uniform control flow=]中，那么一个[=trigger/derivative_uniformity=] [=diagnostic=]将会被[=triggered=]。

<table class=‘data’>
<thead>
<tr><td style="width:25%">参数化<th>重载
</thead>
<tr algorithm="textureSample 1d">
<td>
<td>
<xmp>
@must_use fn textureSample(t: texture_1d<f32>,
s: sampler,
coords: f32) -> vec4<f32>
</xmp>


<tr algorithm="textureSample 2d">
<td>
<td>
<xmp>
@must_use fn textureSample(t: texture_2d<f32>,
s: sampler,
coords: vec2<f32>) -> vec4<f32>
</xmp>


<tr algorithm="textureSample 2d offset">
<td>
<td>
<xmp>
@must_use fn textureSample(t: texture_2d<f32>,
s: sampler,
coords: vec2<f32>,
offset: vec2<i32>) -> vec4<f32>
</xmp>


<tr algorithm="textureSample 2d array">
<td><var ignore>A</var>是 [=i32=] 或者 [=u32=]
<td>
<xmp>
@must_use fn textureSample(t: texture_2d_array<f32>,
s: sampler,
coords: vec2<f32>,
array_index: A) -> vec4<f32>
</xmp>


<tr algorithm="textureSample 2d array offset">
<td><var ignore>A</var>是 [=i32=] 或者 [=u32=]
<td>
<xmp>
@must_use fn textureSample(t: texture_2d_array<f32>,
s: sampler,
coords: vec2<f32>,
array_index: A,
offset: vec2<i32>) -> vec4<f32>
</xmp>


<tr algorithm="textureSample 3d">
<td><var ignore>T</var>是 texture_3d<f32> 或者 texture_cube<f32>
<td>
<xmp>
@must_use fn textureSample(t: T,
s: sampler,
coords: vec3<f32>) -> vec4<f32>
</xmp>


<tr algorithm="textureSample 3d offset">
<td>
<td>
<xmp>
@must_use fn textureSample(t: texture_3d<f32>,
s: sampler,
coords: vec3<f32>,
offset: vec3<i32>) -> vec4<f32>
</xmp>


<tr algorithm="textureSample cube array">
<td><var ignore>A</var>是 [=i32=] 或者 [=u32=]
<td>
<xmp>
@must_use fn textureSample(t: texture_cube_array<f32>,
s: sampler,
coords: vec3<f32>,
array_index: A) -> vec4<f32>
</xmp>


<tr algorithm="textureSample 2d depth">
<td>
<td>
<xmp>
@must_use fn textureSample(t: texture_depth_2d,
s: sampler,
coords: vec2<f32>) -> f32
</xmp>


<tr algorithm="textureSample 2d depth offset">
<td>
<td>
<xmp>
@must_use fn textureSample(t: texture_depth_2d,
s: sampler,
coords: vec2<f32>,
offset: vec2<i32>) -> f32
</xmp>


<tr algorithm="textureSample 2d depth array">
<td><var ignore>A</var>是 [=i32=] 或者 [=u32=]
<td>
<xmp>
@must_use fn textureSample(t: texture_depth_2d_array,
s: sampler,
coords: vec2<f32>,
array_index: A) -> f32
</xmp>


<tr algorithm="textureSample 2d depth array offset">
<td><var ignore>A</var>是 [=i32=] 或者 [=u32=]
<td>
<xmp>
@must_use fn textureSample(t: texture_depth_2d_array,
s: sampler,
coords: vec2<f32>,
array_index: A,
offset: vec2<i32>) -> f32
</xmp>


<tr algorithm="textureSample cube depth">
<td>
<td>
<xmp>
@must_use fn textureSample(t: texture_depth_cube,
s: sampler,
coords: vec3<f32>) -> f32
</xmp>


<tr algorithm="textureSample cube depth array">
<td><var ignore>A</var>是 [=i32=] 或者 [=u32=]
<td>
<xmp>
@must_use fn textureSample(t: texture_depth_cube_array,
s: sampler,
coords: vec3<f32>,
array_index: A) -> f32
</xmp>


</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  待采样的[=type/sampled texture|采样=]纹理或[=type/depth texture|深度=]纹理。
  <tr><td>`s`<td>
  [=sampler=]采样器类型。
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  待采样的基于0的纹理数组索引。
  <tr><td>`offset`<td>
  在采样纹理之前，施加到未归一化纹理坐标上的可选纹素偏移。此偏移在应用任何纹理包装模式之前就被应用。<br>
  `offset` 表达式[=shader-creation error|必须=]是一个[=const-expression=]（例如 `vec2<i32>(1, 2)`）。<br>
  每个 `offset` 分量[=shader-creation error|必须=]至少是 `-8` 并且最多是 `7` 。超出这个范围的值将导致[=shader-creation error=]。
</table>

**Returns:**

采样值。


如果在[=不均匀控制流程|非均匀控制流=]中调用，则结果是一个[=不确定值=]。


### textureSampleBias ### {#texturesamplebias}

采样具有mip级别偏差的纹理。


[=着色器创建错误|必须=]仅在[=片段=]着色器阶段中使用。


如果[=均匀性分析=]无法证明对这个函数的调用处于[=均匀控制流=]中，
那么将触发一个[=触发/导数均匀性=] [=诊断=]。

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleBias 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       bias: f32) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       bias: f32,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       bias: f32) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       bias: f32,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: T,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       bias: f32) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_3d<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       bias: f32,
                                       offset: vec3<i32>) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_cube_array<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       array_index: A,
                                       bias: f32) -> vec4<f32>
      </xmp>

</table>

**Parameters:**

<table class='data'>
<tr><td>t<td>
需要采样的[=type/sampled texture=]（已采样纹理）。
<tr><td>s<td>
[=type/sampler=]（采样器）类型。
<tr><td>coords<td>
用于采样的纹理坐标。
<tr><td>array_index<td>
要采样的基于0的纹理数组索引。
<tr><td>bias<td>
在采样前应用于mip等级的偏移。
bias [=shader-creation error|must=] 范围必须在-16.0到15.99之间。
<tr><td>offset<td>
在采样纹理之前应用于未标准化的纹理坐标的可选纹素偏移量。在应用任何纹理包装模式之前应用此偏移量。<br>
offset 表达式[=shader-creation error|must=] 必须是一个[=const-expression=]（常量表达式），例如vec2<i32>(1, 2)。<br>
每个offset 分量[=shader-creation error|must=] 至少为-8并且最多为7。超出此范围的值将导致一个[=shader-creation error=]（着色器创建错误）。
</table>

**Returns:**

采样的值。


如果在[=非一致控制流=]中调用，则产生[=不确定值=]。

### `textureSampleCompare` ### {#texturesamplecompare}

对一个[=类型/深度纹理=]进行采样，并将采样得到的深度值与一个参考值进行比较。


[=着色器创建错误|必须=]只能在[=片段=]着色器阶段使用。


如果[=一致性分析=]无法证明对这个函数的调用位于[=统一控制流=]中，则会[=触发/导数一致性=]一个[=诊断=]。

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleCompare 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_cube,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_cube_array,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> f32
      </xmp>

</table>

**Parameters:**

<table class='data'>
<tr><td>t<td>
用于采样的[=type/depth texture=]深度纹理。
<tr><td>s<td>
[=type/sampler_comparison=]比较采样器类型。
<tr><td>coords<td>
用于采样的纹理坐标。
<tr><td>array_index<td>
用于采样的基于0的纹理数组索引。
<tr><td>depth_ref<td>
用于与采样深度值比较的参考值。
<tr><td>offset<td>
可选的纹素偏移，应用于采样纹理之前的未标准化纹理坐标。在应用任何纹理包裹模式之前，将应用此偏移。<br>
offset表达式[=shader-creation error|must=]是一个[=const-expression=]（例如 vec2<i32>(1, 2)）。<br>
每个offset分量[=shader-creation error|must=]至少是-8并且最多是7。超出此范围的值将导致[=shader-creation error=]着色器创建错误。
</table>

**Returns:**

范围为'[0.0..1.0]'的值。

每个采样的texel与参考值进行比较
由' sampler_comparison '定义的运算符，结果为' 0 '或' 1 '
值。

如果采样器使用双线性滤波，则返回值为
这些值的过滤平均值，否则为a的比较结果
返回单个texel。

如果在[=均匀控制流|非均匀控制流=]中调用，结果为[=不确定值=]。

### `textureSampleCompareLevel` ### {#texturesamplecomparelevel}

采样 [=type/depth纹理=]，并将采样的深度值与参考值进行比较。

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleCompareLevel 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_2d,
                                               s: sampler_comparison,
                                               coords: vec2<f32>,
                                               depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_2d,
                                               s: sampler_comparison,
                                               coords: vec2<f32>,
                                               depth_ref: f32,
                                               offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_2d_array,
                                               s: sampler_comparison,
                                               coords: vec2<f32>,
                                               array_index: A,
                                               depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
    <xmp>
      @must_use fn textureSampleCompareLevel(t: texture_depth_2d_array,
                                             s: sampler_comparison,
                                             coords: vec2<f32>,
                                             array_index: A,
                                             depth_ref: f32,
                                             offset: vec2<i32>) -> f32
    </xmp>

  <tr algorithm="textureSampleCompareLevel cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_cube,
                                               s: sampler_comparison,
                                               coords: vec3<f32>,
                                               depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_cube_array,
                                               s: sampler_comparison,
                                               coords: vec3<f32>,
                                               array_index: A,
                                               depth_ref: f32) -> f32
      </xmp>

</table>

**Parameters:**

<table class='data'>
< tr > < td > ' t ' < td >
要采样的[=type/depth纹理=]。
< tr > < td > s < td >
[=type/sampler_comparison=]类型。
< tr > < td >"坐标"< td >
用于采样的纹理坐标。
< tr > < td >"array_index"< td >
基于0的纹理数组索引到sample。
< tr > < td >"depth_ref"< td >
用来比较采样深度值的参考值。
< tr > < td >"抵消"< td >
应用于非规范化纹理坐标的可选纹理偏移量
在取样纹理之前。此偏移量在应用任何
纹理包裹模式。<br>
' offset '表达式[=shader-creation error|必须=]是一个[=const-expression=](例如:vec2&lt; i32&gt;(1、2)")。< br >
每个'偏移'组件[=shader-creation error|必须=]至少为' -8 '，最多为' 7 '。值外
这个范围将导致一个[=shader-creation error=]。
</table>

**Returns:**

范围为'[0.0..1.0]'的值。

' textureSampleCompareLevel '函数与' textureSampleCompare '相同，不同之处在于:

* ' textureSampleCompareLevel '总是从mip级别0采样纹理。
* 该函数不计算导数。
* 不需要在[=统一控制流=]中调用' textureSampleCompareLevel '。
* ' textureSampleCompareLevel '可以在任何着色器阶段调用。

### `textureSampleGrad` ### {#texturesamplegrad}

Samples a texture using explicit gradients.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleGrad 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: T,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       ddx: vec3<f32>,
                                       ddy: vec3<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_3d<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       ddx: vec3<f32>,
                                       ddy: vec3<f32>,
                                       offset: vec3<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_cube_array<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       array_index: A,
                                       ddx: vec3<f32>,
                                       ddy: vec3<f32>) -> vec4<f32>
      </xmp>

</table>

**Parameters:**

<table class='data'>
< tr > < td > ' t ' < td >
要采样的[=type/采样纹理=]。
< tr > < td > s < td >
(=类型/取样器=)。
< tr > < td >"坐标"< td >
用于采样的纹理坐标。
< tr > < td >"array_index"< td >
基于0的纹理数组索引到sample。
< tr > < td >的ddx < td >
用于计算采样位置的x方向导数向量。
< tr > < td >"ddy"< td >
y方向导数矢量用于计算采样位置。
< tr > < td >"抵消"< td >
应用于非规范化纹理坐标的可选纹理偏移量
在取样纹理之前。此偏移量在应用任何
纹理包裹模式。<br>
' offset '表达式[=shader-creation error|必须=]是一个[=const-expression=](例如:vec2&lt; i32&gt;(1、2)")。< br >
每个'偏移'组件[=shader-creation error|必须=]至少为' -8 '，最多为' 7 '。值外
这个范围将导致一个[=shader-creation error=]。
</table>

**Returns:**

采样值


### `textureSampleLevel` ### {#texturesamplelevel}

使用显式mip级别对纹理进行采样。

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleLevel 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: f32,
                                        offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d_array<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d_array<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: f32,
                                        offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: T,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_3d<f32>,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        level: f32,
                                        offset: vec3<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_cube_array<f32>,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        array_index: A,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth">
    <td><var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: L) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth offset">
    <td><var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: L,
                                        offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d_array,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: L) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d_array,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: L,
                                        offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel cube depth">
    <td><var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_cube,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        level: L) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_cube_array,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        array_index: A,
                                        level: L) -> f32
      </xmp>
</table>

**Parameters:**

<table class='data'>
< tr > < td > ' t ' < td >
将[=type/ sampling纹理| sampling =]或[=type/depth纹理|depth=]纹理转换为
样本。
< tr > < td > s < td >
[=sampler=]类型。
< tr > < td >"坐标"< td >
用于采样的纹理坐标。
< tr > < td >"array_index"< td >
基于0的纹理数组索引到sample。
< tr > < td >"水平"< td >
mip关卡，关卡0包含纹理的完整尺寸版本。
对于' level '为' f32 '的函数，可能会插入分数值
在两个级别之间，如果格式可根据
[纹理格式功能](https://gpuweb.github.io/gpuweb/#texture-format-caps)。
< tr > < td >"抵消"< td >
应用于非规范化纹理坐标的可选纹理偏移量
在取样纹理之前。此偏移量在应用任何
纹理包裹模式。<br>
' offset '表达式[=shader-creation error|必须=]是一个[=const-expression=](例如:vec2&lt; i32&gt;(1、2)")。< br >
每个'偏移'组件[=shader-creation error|必须=]至少为' -8 '，最多为' 7 '。值外
这个范围将导致一个[=shader-creation error=]。
</table>

**Returns:**

The sampled value.

### `textureSampleBaseClampToEdge` ### {#textureSampleBaseClampToEdge}

在它的基础级别采样纹理视图，
与纹理坐标夹紧到边缘如下所述。

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>

  <tr algorithm="textureSampleBaseClampToEdge">
    <td><var ignore>T</var> is `texture_2d<f32>` or `texture_external`
    <td>
      <xmp>
        @must_use fn textureSampleBaseClampToEdge(t: T,
                                                  s: sampler,
                                                  coords: vec2<f32>) -> vec4<f32>
      </xmp>
</table>

**Parameters:**

<table class='data'>
< tr > < td > ' t ' < td >
将[=type/采样纹理|采样=]或[=type/外部纹理|外部=]纹理进行采样。
< tr > < td > s < td >
[=type/sampler=]类型。
< tr > < td >"坐标"< td >
用于采样的纹理坐标。

在采样之前，给定的坐标[=行为要求| =]将被固定到矩形上

比;[*half_texel*， 1 - *half_texel*]

在哪里

比;*half_texel* = vec2(0.5) / vec2&lt;f32&gt;(textureDimensions(t))

注:半像素调整确保，
独立于采样器的{{GPUAddressMode|寻址}}
和{{GPUFilterMode|filter}}模式，
不会发生包装。
也就是说，当在边缘附近采样时，采样的元素
将位于或邻近该边，而不是从对边中选择。
</table>

**Returns:**

The sampled value.

### `textureStore` ### {#texturestore}

将单个纹素写入纹理。

<table class='data'>
  <thead>
    <tr><td style="width:25%">参数化<th>过载
  </thead>
  <tr algorithm="textureStore 1d">
    <td>|F|是一个[=texel format=]<br>
& lt; var ignore&gt C&lt; / var&gt;[=i32=]， or [=u32=]<br>
& lt; var ignore&gt AM&lt; / var&gt;Is [=access/write=] or [=access/read_write=]<br>
& lt; var ignore&gt CF&lt; / var&gt;取决于存储文本格式|F|。
[参见文本格式表](#storage-texel-formats)获取文本的映射
格式为通道格式。
    <td>
      <xmp>
        fn textureStore(t: texture_storage_1d<F,AM>,
                        coords: C,
                        value: vec4<CF>)
      </xmp>

  <tr algorithm="textureStore 2d">
    <td>|F|是一个[=texel format=]<br>
& lt; var ignore&gt C&lt; / var&gt;[=i32=]， or [=u32=]<br>
& lt; var ignore&gt AM&lt; / var&gt;Is [=access/write=] or [=access/read_write=]<br>
& lt; var ignore&gt CF&lt; / var&gt;取决于存储文本格式|F|。
[参见文本格式表](#storage-texel-formats)获取文本的映射
格式为通道格式。
    <td>
      <xmp>
        fn textureStore(t: texture_storage_2d<F,AM>,
                        coords: vec2<C>,
                        value: vec4<CF>)
      </xmp>

  <tr algorithm="textureStore 2d array">
    <td>|F|是一个[=texel format=]<br>
& lt; var ignore&gt C&lt; / var&gt;[=i32=]， or [=u32=]<br>
& lt; var ignore&gt AM&lt; / var&gt;Is [=access/write=] or [=access/read_write=]<br>
& lt; var ignore&gt A&lt; / var&gt;[=i32=]， or [=u32=]<br>
& lt; var ignore&gt CF&lt; / var&gt;取决于存储文本格式|F|。
[参见文本格式表](#storage-texel-formats)获取文本的映射
格式为通道格式。
    <td>
      <xmp>
        fn textureStore(t: texture_storage_2d_array<F,AM>,
                        coords: vec2<C>,
                        array_index: A,
                        value: vec4<CF>)
      </xmp>

  <tr algorithm="textureStore 3d">
    <td>|F|是一个[=texel format=]<br>
& lt; var ignore&gt C&lt; / var&gt;[=i32=]， or [=u32=]<br>
& lt; var ignore&gt AM&lt; / var&gt;Is [=access/write=] or [=access/read_write=]<br>
& lt; var ignore&gt CF&lt; / var&gt;取决于存储文本格式|F|。
[参见文本格式表](#storage-texel-formats)获取文本的映射
格式为通道格式。
    <td>
      <xmp>
        fn textureStore(t: texture_storage_3d<F,AM>,
                        coords: vec3<C>,
                        value: vec4<CF>)
      </xmp>

</table>

**Parameters:**

<table class='data'>
< tr > < td > ' t ' < td >
[=type/write-only storage纹理=]或
[=type/读写存储纹理=]
< tr > < td >"坐标"< td >
基于0的文本坐标。<br>
< tr > < td >"array_index"< td >
基于0的纹理数组索引。
< tr > < td >"价值"< td >
新的文本值。<br>
</table>

**Note:**

在下列情况下，[=logical texel address=]无效:
* ' coordds '的任何元素都在' [0,textureDimensions(t)) '的范围之外'
* 对应的元素，或
* ' array_index '超出' [0,textureNumLayers(t)) '的范围

如果逻辑文本地址无效，则内置函数可能会执行以下任何操作:
*不被执行
*存储' value '到一些边界texel

## 原子内置函数 ## {#atomic-builtin-functions}

原子内置函数可用于读/写/读-修改-写原子
对象。它们是[[#atomic-types]]上唯一允许的操作。

所有原子内置函数都使用"放松的"[[#memory-semantics|]内存
订购]]。这意味着同步和排序保证只适用于
原子操作作用于相同的[=内存位置=]。没有同步
或者在原子和非原子内存访问之间应用排序保证，或者
在作用于不同内存位置的原子访问之间。

原子内置函数[=shader-creation error|绝对不能=]在[=vertex=]着色器阶段使用。

地址空间' AS '的' atomic_ptr '参数在所有原子内置
函数[=shader-creation error|必须=]是[=address spaces/storage=]或[=address spaces/workgroup=]。

|T| [=shader-creation error] |必须=][=u32=]或[=i32=]

### 原子负载 ### {#atomic-load}

```
fn atomicLoad(atomic_ptr: ptr<AS, atomic<T>, read_write>) -> T
```

返回原子加载的' atomic_ptr '所指向的值。
它不是[=atomic modification|modify=]对象。

### Atomic Store ### {#atomic-store}

```
fn atomicStore(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T)
```

自动地将值' v '存储在' atomic_ptr '指向的原子对象中。

### Atomic Read-modify-write ### {#atomic-rmw}

```
fn atomicAdd(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicSub(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicMax(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicMin(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicAnd(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicOr(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicXor(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
```
每个函数自动执行以下步骤:

1. 加载' atomic_ptr '指向的原始值。
2. 通过从函数中执行操作(例如max)获得一个新值，名称，取值为|v|。
3. 使用' atomic_ptr '存储新值。

每个函数返回存储在原子对象中的原始值。

```
fn atomicExchange(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
```

Atomically stores the value `v` in the atomic object pointed to
`atomic_ptr` and returns the original value stored in the atomic object.

```
fn atomicCompareExchangeWeak(
      atomic_ptr: ptr<AS, atomic<T>, read_write>,
      cmp: T,
      v: T) -> __atomic_compare_exchange_result<T>

struct __atomic_compare_exchange_result<T> {
  old_value : T; // old value stored in the atomic
  exchanged : bool; // true if the exchange was done
}
```

注意:不能用类型显式声明值
' __atomic_compare_exchange_result '，但值可以推断类型。

自动执行以下步骤:

1. 加载' atomic_ptr '指向的原始值。
2. 使用相等操作将原始值与值' cmp '进行比较。
3. 只有当相等比较的结果为true时，才存储值v。

返回一个双成员结构，其中第一个成员' old_value '是
原子对象和第二个成员'已交换'的原始值为
比较是否成功。

注意:在某些实现中，相等比较可能会错误地失败。那
是，结果向量的第二个组成部分可能是"假"，即使第一个
结果向量的分量等于' cmp '。

## 数据打包内置功能 ## {#pack-builtin-functions}

数据打包内置函数可用于使用以下数据格式对值进行编码
不直接对应于WGSL中的类型。
这使得程序可以将许多密集的值写入内存
减少着色器的内存带宽需求。

每个内置程序将[=通道传递函数=]的*逆*应用于几个输入值，然后进行组合
它们的结果变成一个单一的输出值。

注:对于打包非均匀值，归一化浮点值在[0.0,1.0]区间内。

注意:对于打包snonorm值，归一化的浮点值在[-1.0,1.0]区间内。

### `pack4x8snorm` ### {#pack4x8snorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 4x8snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack4x8snorm(e: vec4<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>将四个标准化浮点值转换为8位有符号整数，然后将它们组合
一个' u32 '值。<br>
输入的分量' e[i] '被转换为8位双补位整数值
&lfloor;0.5 + 127 &times;Min (1, max(-1, e[i])) &rfloor;然后把它放在位上
8报;"我"通过
8报;结果的' i ' + 7。
</table>

### `pack4x8unorm` ### {#pack4x8unorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 4x8unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack4x8unorm(e: vec4<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>将四个标准化浮点值转换为8位无符号整数，然后将它们组合
一个' u32 '值。<br>
输入的分量' e[i] '被转换成一个8位无符号整数值
&lfloor;0.5 + 255 &times;Min (1, max(0, e[i])) &rfloor;然后把它放在位上
8报;"我"通过
8报;结果的' i ' + 7。
</table>

### `pack2x16snorm` ### {#pack2x16snorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 2x16snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack2x16snorm(e: vec2<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>将两个标准化浮点值转换为16位有符号整数，然后将它们组合
一个' u32 '值。<br>
输入的分量' e[i] '被转换成一个16位的双补位整数值
&lfloor;0.5 + 32767 &times;Min (1, max(-1, e[i])) &rfloor;然后把它放在位上
16报;"我"通过
16报;' i ' + 15的结果。
</table>

### `pack2x16unorm` ### {#pack2x16unorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 2x16unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack2x16unorm(e: vec2<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>将两个标准化浮点值转换为16位无符号整数，然后将它们组合
一个' u32 '值。<br>
输入的分量' e[i] '被转换为16位无符号整数值
&lfloor;0.5 + 65535 &times;Min (1, max(0, e[i])) &rfloor;然后把它放在位上
16报;"我"通过
16报;' i ' + 15的结果。
</table>

### `pack2x16float` ### {#pack2x16float-builtin}
<table class='data builtin'>
  <tr algorithm="packing 2x16float">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack2x16float(e: vec2<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>将两个浮点值转换为半精度浮点数，然后进行组合
它们组成一个' u32 '值
输入的组件' e[i] '被转换为[[!]IEEE-754|IEEE-754]] binary16值，即then
按位放置
16报;"我"通过
16报;' i ' + 15的结果。
[[# floating-point-conversion]]。

如果' e[0] '或' e[1] '超出binary16的有限范围，则:
*如果' e '是[=const-expression=]，这是一个[=shader-creation error=]。
*如果' e '是[=override-expression=]，则为[=pipeline-creation error=]。
*否则，u32的结果为[=不确定值=]。
</table>

## 数据拆封内置函数 ## {#unpack-builtin-functions}

数据解压缩内置函数可用于解码中的值
与WGSL中的类型不直接对应的数据格式。
这使得程序可以从内存中读取许多密集的值，这可以
减少着色器的内存带宽需求。

每个内置程序将输入值分解为通道，然后对每个通道应用[=通道传递函数=]。

注意:对于解包非均匀值，归一化浮点结果在[0.0,1.0]区间内。

注意:对于解压缩snorm值，归一化的浮点结果在[-1.0,1.0]区间内。

### `unpack4x8snorm` ### {#unpack4x8snorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 4x8snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack4x8snorm(e: u32) -> vec4<f32>
      </xmp>
  <tr>
    <td>Description
    <td>将32位值分解为4个8位块，然后重新解释
每个块作为一个有符号的规范化浮点值
结果的分量' i '是max(v &div;127， -1)，其中' v '是对
将' e '的8&times; ' i '到8&times; ' i + 7 '作为双补码的有符号整数。
</table>

### `unpack4x8unorm` ### {#unpack4x8unorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 4x8unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack4x8unorm(e: u32) -> vec4<f32>
      </xmp>
  <tr>
    <td>Description
    <td>将32位值分解为4个8位块，然后重新解释
每个数据块作为一个无符号规范化浮点值。<br>
结果的分量' i '是' v ' &div;255，其中' v '是对
将' e '的8&times; ' i '到8&times; ' i + 7 '作为无符号整数。
</table>

### `unpack2x16snorm` ### {#unpack2x16snorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 2x16snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack2x16snorm(e: u32) -> vec2<f32>
      </xmp>
  <tr>
    <td>Description
    <td>将32位值分解为两个16位块，然后重新解释
每个块作为一个有符号的规范化浮点值
结果的分量' i '是max(v &div;32767， -1)，其中' v '是对
将' e '的16&times; ' i '到16&times; ' i + 15 '作为双补码的有符号整数。
</table>

### `unpack2x16unorm` ### {#unpack2x16unorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 2x16unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack2x16unorm(e: u32) -> vec2<f32>
      </xmp>
  <tr>
    <td>Description
    <td>将32位值分解为两个16位块，然后重新解释
每个数据块作为一个无符号规范化浮点值。<br>
结果的分量' i '是' v ' &div;65535，其中' v '是对
将' e '的16&times; ' i '到16&times; ' i + 15 '作为无符号整数。
</table>

### `unpack2x16float` ### {#unpack2x16float-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 2x16float">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack2x16float(e: u32) -> vec2<f32>
      </xmp>
  <tr>
    <td>Description
    <td>将32位值分解为两个16位块，并重新解释每个块
作为浮点值。<br>
结果的分量' i '是' v '的f32表示形式，
其中' v '是对' e '的16倍' i '到16倍' i + 15 '的解释
作为一个[[!]IEEE-754|IEEE-754]] binary16 value。
[[# floating-point-conversion]]。
</table>

## 同步内置功能 ## {#sync-builtin-functions}

所有同步函数都执行一个[=control barrier=]
获取/释放[[#memory-semantics|内存排序]]。
即所有同步函数，以及受影响的内存和原子
操作顺序为[[#program-order|program order]]
同步功能。
此外，受影响的内存和原子操作在程序之前是有序的
对象中的所有其他线程必须对同步函数可见
在任何受影响的内存或原子操作程序之前的工作组之后排序
同步功能由工作组的成员执行。

所有同步函数都使用' Workgroup ' [=memory scope=]
所有同步函数都有一个"Workgroup"[=execution scope=]
所有同步函数[=shader-creation error|must=]只能在
[=compute=]着色器阶段。
所有同步函数[=shader-creation error|必须=]只能在
[=均匀控制流=]。

### `storageBarrier` ### {#storageBarrier-builtin}

<table class='data builtin'>
  <tr algorithm="storageBarrier">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        fn storageBarrier()
      </xmp>
  <tr>
    <td>Description
    <td>执行[=control barrier=]同步函数
[=地址空间/存储=]地址中的内存和原子操作
空间。
</table>

### `textureBarrier` ### {#textureBarrier-builtin}

<table class='data builtin'>
  <tr algorithm="textureBarrier">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        fn textureBarrier()
      </xmp>
  <tr>
    <td>Description
    <td>执行[=control barrier=]同步函数
[=address spaces/handle=]地址空间中的内存操作。
</table>

### `workgroupBarrier` ### {#workgroupBarrier-builtin}

<table class='data builtin'>
  <tr algorithm="workgroupBarrier">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        fn workgroupBarrier()
      </xmp>
  <tr>
    <td>Description
    <td>执行[=control barrier=]同步函数
[=地址空间/工作组=]地址中的内存和原子操作
空间。
</table>

### `workgroupUniformLoad` ### {#workgroupUniformLoad-builtin}

<table class='data builtin'>
  <tr algorithm="workgroupUniformLoad">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn workgroupUniformLoad(p : ptr<workgroup, T>) -> T
      </xmp>
  <tr>
    <td>Parameterization
    <td>`T` is a [=type/concrete=] [=plain type=] with a [=fixed footprint=]
    that does not contain any [=atomic types=]
  <tr>
    <td>Description
    <td>将' p '指向的值返回给工作组中的所有调用。
返回值为[=uniform value|uniform=]。
' p ' [=shader-creation error|必须=]是一个[=uniform value=]。

执行[=control barrier=]同步函数
[=地址空间/工作组=]地址中的内存和原子操作
空间。
</table>

# 递归下降解析的语法 # {#grammar-recursive-descent}

本节是非规范性的。

WGSL语法以适合LALR(1)解析器的形式指定。
实现可能希望使用递归下降解析器。

规范语法不能直接在递归下降解析器中使用，因为
它的一些规则是左递归的。
当定义的非终结符首先出现时，语法规则直接左递归
在它的一个作品中。

以下是WGSL语法，但机械地转换为:
*消除直接和间接左递归。
*避免空产品。(也就是说，避免使用ε规则。)
*在兄弟作品中汇集共同的前缀。

然而，它不是LL(1)。
对于一些非终结符，几个结果有共同的前瞻集。
例如，' attribute '非终结符的所有结果都以' attr '令牌开始。
一个更微妙的例子是' global_decl '，其中三个结果以' attribute * '开头。
短语，但随后由标记' fn '， ' override '和' var '来区分。


为简洁起见，许多标记定义不重复。
使用规范主体部分的令牌定义。


<pre class=include>
path: wgsl.recursive.bs.include
</pre>

# 附录 A: The `text/wgsl` Media Type # {#text-wgsl-media-type}

互联网号码分配机构(IANA)在[[IANA- media - types]]保存媒体类型的注册表。

以下是wgsl模块的' text/wgsl '媒体类型的定义。
它已在IANA注册，
网址:[https://www.iana.org/assignments/media-types/text/wgsl](https://www.iana.org/assignments/media-types/text/wgsl)。

: 类型名称
:: 文本
: 子类型名称
:: wgsl
: 所需参数
:: N / A
: 可选参数
:: 没有
: 编码注意事项
:: 二进制
    WGSL是使用UTF-8编码的Unicode文本，没有字节顺序标记(BOM)。
    见WGSL第3节。文本结构。
: 安全考虑:
:: WebGPU Shading Language (WGSL)是一种面向GPU的编程语言
    在WebGPU API上下文中执行的代码。为了安全
    注意事项，参见第2.1节安全注意事项。
    有关隐私方面的考虑，请参见第2.2节隐私
    考虑。
    互操作性考虑:
    WebGPU的实现可能有不同的功能，并且
    这些差异可能会影响哪些功能可以被执行
    WGSL项目。见第3.6节可选功能，
    和WGSL第11节。语言扩展。

    我们期望实现的行为是这样的
    注册适用于后续版本的WGSL及其发布
    规格参考可能会不时相应地更新
    时间。虽然这种期望在媒体类型中并不常见
    注册，它符合广泛的行业惯例。
: 已发布的规范:
:: [[!WGSL]]
: 使用此媒体类型的应用程序:
    WebGPU的实现。预计这将包括web浏览器。
    片段标识符注意事项
:: 没有
: 其他资料:
:: 魔术数:无
    文件扩展名:' .wgsl '
:: Macintosh文件类型代码:' TEXT '
: 联系人及电子邮件地址:
:: David Neto, dneto@google.com，或WGSL中列出的编辑。
: 预期用途
:: 常见
    作者:
:: W3C。参见WGSL中列出的编辑器。
: 变更控制器
    W3C::
: 标准参考文献
:: [[!WebGPU]] W3C，"WebGPU"W3C工作草案，2023年1月。https://w3.org/TR/webgpu
:: [[!WGSL]] W3C，"WebGPU着色语言"W3C工作草案，2023年1月。https://w3.org/TR/WGSL
