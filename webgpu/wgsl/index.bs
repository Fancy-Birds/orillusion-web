<pre class='metadata'>
Title: WebGPU Shading Language
Shortname: WGSL
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/wgsl/
TR: https://www.w3.org/TR/WGSL/
Repository: gpuweb/gpuweb
Text Macro: INT i32 or u32
Text Macro: UNSIGNEDINTEGRAL u32 or vecN&lt;u32&gt;
Text Macro: SIGNEDINTEGRAL i32 or vecN&lt;i32&gt;
Text Macro: ALLSIGNEDINTEGRAL AbstractInt, i32, vecN&lt;AbstractInt&gt;, or vecN&lt;i32&gt;
Text Macro: INTEGRAL i32, u32, vecN&lt;i32&gt;, or vecN&lt;u32&gt;
Text Macro: FLOATING f32, f16, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
Text Macro: NUMERIC i32, u32, f32, f16, vecN&lt;i32&gt;, vecN&lt;u32&gt;, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
Text Macro: FLOATSCALAR [=AbstractFloat=], [=f16=], or [=f32=]
Text Macro: ALLINTEGRALDECL S is AbstractInt, i32, or u32<br>T is S or vecN&lt;S&gt;
Text Macro: ALLFLOATINGDECL S is AbstractFloat, f32, or f16<br>T is S or vecN&lt;S&gt;
Text Macro: ALLNUMERICDECL S is AbstractInt, AbstractFloat, i32, u32, f32, or f16<br>T is S, or vecN&lt;S&gt;
Text Macro: ALLSIGNEDNUMERICDECL S is AbstractInt, AbstractFloat, i32, f32, or f16<br>T is S, or vecN&lt;S&gt;
Ignored Vars: i, c0, e, e1, e2, e3, edge, eN, p, s1, s2, sn, AS, AM, N, newbits, M, C, R, v, Stride, Offset, Align, Extent, T, T1

!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new?labels=wgsl">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues?q=is%3Aissue+is%3Aopen+label%3Awgsl">open issues</a>)
!Tests: <a href=https://github.com/gpuweb/cts/tree/main/src/webgpu/shader/>WebGPU CTS shader/</a>

Editor: Alan Baker, Google https://www.google.com, alanbaker@google.com, w3cid 129277
Editor: Mehmet Oguz Derin, mehmetoguzderin@mehmetoguzderin.com, w3cid 101130
Editor: David Neto, Google https://www.google.com, dneto@google.com, w3cid 99785
Former Editor: Myles C. Maxfield, Apple Inc., mmaxfield@apple.com, w3cid 77180
Former Editor: dan sinclair, Google https://www.google.com, dsinclair@google.com, w3cid 107549
Abstract: Shading language for WebGPU.
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
</pre>

<style>
tr:nth-child(2n) {
  background-color: #b0b0b050;
}
thead {
  background-color: #b0b0b050;
  font-weight: bold;
}
.nowrap {
  white-space:nowrap;
}
.small {
  font-size: smaller;
}
div.syntax {
  display: block;
  page-break-before: avoid;
  padding: .5em 1em;
  background: var(--def-bg);
  border-left: 0.5em solid var(--def-border);
  color: var(--def-text);
  margin-block-start: 1em;
  margin-block-end: 1em;
}
div.syntax > p {
  color: var(--text);
  font-weight: 100;
  margin: 0;
}
div.syntax > p > .choice {
  display: inline-block;
  width: 1em;
  text-align: center;
}
div.syntax > p > a {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  font-style: italic;
  font-weight: normal;
  color: var(--text);
}
div.syntax > p > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
div.syntax > p > a > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
[data-dfn-for="syntax"] {
  font-style: italic;
  font-weight: normal;
  color: var(--text);
}
[data-dfn-for="syntax_kw"] {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
[data-dfn-for="syntax_sym"] {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
.hidden {
  display: none
}
table.data.builtin tbody{
  border-bottom: 0;
}
table.builtin {
  border-bottom: 2px solid grey;
}
table.builtin tr:nth-child(2n) {
    background-color: #00000000;
}
table.builtin td {
    vertical-align: top;
}
/* Our SVGs aren't responsive to light/dark mode, so they're opaque with a
 * white or black background. Rounded corners make them a bit less jarring. */
object[type="image/svg+xml"] {
    border-radius: .5em;
}
</style>

<pre class=biblio>
{
  "WebGPU": {
    "authors": [
      "Kai Ninomiya",
      "Brandon Jones",
      "Myles C. Maxfield"
    ],
    "href": "https://w3.org/TR/webgpu",
    "title": "WebGPU",
    "status": "Working Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "WGSL": {
    "authors": [
      "Alan Baker",
      "Mehmet Oguz Derin",
      "David Neto"
    ],
    "href": "https://www.w3.org/TR/WGSL/",
    "title": "WebGPU Shading Language",
    "status": "Working Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "IEEE-754":{
    "href":"http://ieeexplore.ieee.org/servlet/opac?punumber=4610933",
    "title":"IEEE Standard for Floating-Point Arithmetic",
    "publisher":"Institute of Electrical and Electronics Engineers",
    "isbn":"978-0-7381-5752-8",
    "versions":["IEEE-754-2008","IEEE-754-1985"],
    "id":"IEEE-754",
    "date":"29 August 2008"
  },
  "VulkanMemoryModel": {
    "authors": [
      "Jeff Bolz",
      "Alan Baker",
      "Tobias Hector",
      "David Neto",
      "Robert Simpson",
      "Brian Sumner"
    ],
    "href": "https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model",
    "title": "Vulkan Memory Model",
    "publisher": "Khronos Group"
  },
  "UnicodeVersion14": {
    "href":"http://www.unicode.org/versions/Unicode14.0.0/",
    "author":"The Unicode Consortium",
    "title":"The Unicode Standard, Version 14.0.0",
    "isbn":"978-1-936213-29-0",
    "id":"UnicodeVersion14"
  },
  "DeRemer1969": {
    "href":"http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-065.pdf",
    "author":"F. L. DeRemer",
    "publisher":"Massachusetts Institute of Technology",
    "date":"24 October 1969",
    "title":"Practical Translators for LR(k) Languages"
  },
  "Muller2005": {
    "title":"On the definition of ulp(x)",
    "href":"https://inria.hal.science/inria-00070503",
    "source":"[Research Report] RR-5504, LIP RR-2005-09, INRIA, LIP",
    "author":"Jean-Michel Muller",
    "publisher":"INRIA",
    "date":"February 2005",
    "rawDate": "2005-02"
  },
  "Jeannerod2013": {
    "href":"https://www.ams.org/journals/mcom/2013-82-284/S0025-5718-2013-02679-8/S0025-5718-2013-02679-8.pdf",
    "title":"Further Analysis of Kahan's Algorithm for the Accurate Computation of 2x2 Determinants",
    "authors": [
      "Claude-Pierre Jeannerod",
      "Nicolas Louvet",
      "Jean-Michel Muller"
    ],
    "publisher": "American Mathematical Society",
    "rawDate":"2013-10",
    "pages": "2245-2264"
  },
  "VanWyk2007": {
    "href":"https://dl.acm.org/doi/10.1145/1289971.1289983",
    "title":"Context-Aware Scanning for Parsing Extensible Languages",
    "authors": [
      "Eric R. Van Wyk",
      "August C. Schwerdfeger"
    ],
    "publisher":"Association for Computing Machinery",
    "series":"GCPE'07",
    "date":"2007"
  }
}
</pre>

<pre class='anchors'>
spec: Vulkan ; urlPrefix: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#
    type: dfn
        text: memory model memory operation; url: memory-model-memory-operation
        text: memory model reference; url: memory-model-references
        text: memory model atomic operation; url: memory-model-atomic-operation
        text: memory model scope; url:memory-model-scope
        text: memory model memory semantics; url:memory-model-memory-semantics
        text: memory model non-private; url: memory-model-non-private
spec: UAX14; urlPrefix: https://www.unicode.org/reports/tr14
    type: dfn
        text: UAX14 Section 6.1 Non-tailorable Line Breaking Rules; url: BreakingRules
        text: UAX14 LB4; url: LB4
        text: UAX14 LB5; url: LB5
spec: UAX31; urlPrefix: https://www.unicode.org/reports/tr31/tr31-35.html
    type: dfn
        text: Unicode Standard Annex #31 for Unicode Version 14.0.0
        text: UAX31 Lexical Classes; url: Table_Lexical_Classes_for_Identifiers
        text: UAX31 Grammar; url: D1
spec: Unicode Character Database for Unicode Version 14.0.0; urlPrefix: https://www.unicode.org/Public/14.0.0/ucd/DerivedCoreProperties.txt
    type: dfn
        text: Unicode Character Database for Unicode Version 14.0.0
spec: UnicodeVersion14; urlPrefix: https://www.unicode.org/versions/Unicode14.0.0/UnicodeStandard-14.0.pdf
    type: dfn
        text: code point; url:
spec: WebGPU; urlPrefix: https://gpuweb.github.io/gpuweb/#
    type: dfn
        text: GPU command; url: gpu-command
        text: RasterizationPoint; url: rasterizationpoint
        text: effective buffer binding size; url: abstract-opdef-effective-buffer-binding-size
        text: binding member; url: binding-member
        text: binding resource type; url: binding-resource-type
        text: binding type; url: binding-type
        text: GPU error scope; url: gpu-error-scope
        text: front-facing; url: front-facing
        text: shader-output mask; url: shader-output-mask
        text: framebuffer; url: framebuffer
        text: normalized device coordinates; url: ndc
        text: clip space coordinates; url: clip-space-coordinates
        text: clip position; url: clip-position
        text: viewport; url: dom-renderstate-viewport-slot
        text: rasterizationpoint-destination; url: rasterizationpoint-destination
        text: rasterizationpoint-depth; url: rasterizationpoint-depth
        text: rasterizationpoint-perspectivedivisor; url: rasterizationpoint-perspectivedivisor
        text: fragmentdestination-position; url: fragmentdestination-position
        for: supported limits
            text: maxComputeWorkgroupStorageSize; url: dom-supported-limits-maxcomputeworkgroupstoragesize
    type: attribute
        for: GPU
            text: wgslLanguageFeatures; url: gpuwgsllanguagefeatures
    type: abstract-op
        text: validating GPUProgrammableStage; url: abstract-opdef-validating-gpuprogrammablestage
    type: enum-value
        for: GPUStorageTextureAccess
            text: read-only; url: dom-gpustoragetextureaccess-read-only
            text: read-write; url: dom-gpustoragetextureaccess-read-write
</pre>

# 介绍 # {#intro}

WebGPU着色语言（WGSL）是[[!WebGPU]]的着色语言。换句话说，使用WebGPU API的应用程序使用WGSL来表达在GPU上运行的程序，也称为着色器。

<div class='example wgsl global-scope'>
  <xmp>
    // A fragment shader which lights textured geometry with point lights.

    // Lights from a storage buffer binding.
    struct PointLight {
      position : vec3f,
      color : vec3f,
    }

    struct LightStorage {
      pointCount : u32,
      point : array<PointLight>,
    }
    @group(0) @binding(0) var<storage> lights : LightStorage;

    // Texture and sampler.
    @group(1) @binding(0) var baseColorSampler : sampler;
    @group(1) @binding(1) var baseColorTexture : texture_2d<f32>;

    // Function arguments are values from the vertex shader.
    @fragment
    fn fragmentMain(@location(0) worldPos : vec3f,
                    @location(1) normal : vec3f,
                    @location(2) uv : vec2f) -> @location(0) vec4f {
      // Sample the base color of the surface from a texture.
      let baseColor = textureSample(baseColorTexture, baseColorSampler, uv);

      let N = normalize(normal);
      var surfaceColor = vec3f(0);

      // Loop over the scene point lights.
      for (var i = 0u; i < lights.pointCount; i++) {
        let worldToLight = lights.point[i].position - worldPos;
        let dist = length(worldToLight);
        let dir = normalize(worldToLight);

        // Determine the contribution of this light to the surface color.
        let radiance = lights.point[i].color * (1 / pow(dist, 2));
        let nDotL = max(dot(N, dir), 0);

        // Accumulate light contribution to the surface color.
        surfaceColor += baseColor.rgb * radiance * nDotL;
      }

      // Return the accumulated surface color.
      return vec4(surfaceColor, baseColor.a);
    }
  </xmp>
</div>

## 总览 ## {#overview}

WebGPU通过GPU命令将工作单元发送到GPU中。WGSL关注两种类型的GPU命令：

  * 一个draw command在着色器阶段输入、着色器阶段输出和附加资源的上下文中执行render pipeline。
  * 一个dispatch command在着色器阶段输入和附加资源的上下文中执行compute pipeline。

这两种类型的管线都使用WGSL编写的着色器。


一个shader是WGSL程序中执行管线中的着色器阶段的部分。
一个着色器由以下部分组成：

  * 一个入口函数。
  * 从入口函数开始的所有被调用函数的传递闭包。 这个集合包括用户定义函数和内置函数。(更严格的定义请参见“着色器阶段中的函数”。)
  * 所有这些函数静态访问的变量和常量集合。
  * 用于定义或分析所有这些函数、变量和常量的类型集合。

注意：一个WGSL程序不需要入口函数；然而，API无法执行这样的程序，因为创建GPUProgrammableStage需要入口函数。

执行着色器阶段时，实现的操作：
* 计算在模块范围声明的常量的值。
* 将资源绑定到着色器的资源接口中的变量，使得这些资源的内容在执行期间对着色器可用。
* 为其他模块范围变量分配内存，并使用指定的初始值填充该内存。
* 如果存在，将入口点的形式参数与着色器阶段的输入连接。
* 将入口点的返回值（如果存在）连接到着色器阶段的输出。
* 然后调用入口点。

一个WGSL程序的组织结构包括：

* 指令，用于指定模块级别的行为控制。
* 函数，用于指定执行行为。
* 语句，即声明或可执行行为的单元。
* 文字字面量，用于表示纯数学值的文本表示。
* 常量，为每个特定时间计算的值提供一个名称。
* 变量，为存储值的内存提供一个名称。
* 表达式，每个表达式组合一组值以产生一个结果值。
* 类型，每个类型描述：
    * 一组值。
    * 支持的表达式的约束。
    * 这些表达式的语义。
* 属性，用于修改对象以指定额外信息，例如：
    * 指定接口与入口点。
    * 指定诊断过滤器。

注意：目前，WGSL程序由单个WGSL模块组成。

WGSL是一种命令式语言：行为被指定为要执行的一系列语句。
语句可以：

* 声明[[#value-decls|常量]]或[[#var-decls|变量]]。
* 修改变量的内容。
* 使用结构化编程结构修改执行顺序：
    * 有选择性的执行：[[#if-statement|if]]（可选的else if和else子句），[[#switch-statement|switch]]。
    * 循环执行：[[#loop-statement|loop]]，[[#while-statement|while]]，[[#for-statement|for]]。
    * 退出嵌套的执行结构：[[#continue-statement|continue]]，[[#break-statement|break]]，[[#break-if-statement|break if]]。
    * 重构：[[#function-calls|函数调用]]和[[#return-statement|return]]。
* 评估表达式以计算上述行为的值。
* 在[=shader模块创建|shader creation=]时间使用[=const-expression|常量表达式=]检查[[#const-assert-statement|假设]]。

WGSL是静态类型的：特定表达式计算的每个值都有一个特定类型，只能通过检查程序源代码来确定。

WGSL具有描述布尔值和数字（整数和浮点数）的类型。
这些类型可以组合成复合类型（向量、矩阵、数组和结构体）。
WGSL具有特殊类型（例如原子类型），提供独特的操作。
WGSL描述了可以存储在内存中的类型，称为内存视图。
WGSL以纹理和采样器的形式提供常用的渲染类型。
这些类型有相关的内置函数，用于暴露常见的用于图形渲染的GPU硬件。


WGSL不支持从具体类型自动进行隐式转换或提升，但可以从抽象类型进行隐式转换和提升。
将一个值从一个具体的数值或布尔类型转换为另一个类型需要显式的转换、值构造函数或位的重新解释。
然而，WGSL确实提供了一些有限的方法来将标量类型提升为向量类型。
这同样适用于复合类型。

着色器阶段的工作被划分为一个或多个<dfn noexport>调用</dfn>，每个调用在稍微不同的条件下执行入口点。
着色器阶段中的调用共享某些变量的访问权限：

* 阶段中的所有调用共享着色器接口中的资源。
* 在计算着色器阶段中，同一个计算着色器阶段/工作组中的调用共享地址空间/工作组（address spaces/workgroup）中的变量。不同工作组中的调用不共享这些变量。

然而，调用作用于不同的着色器阶段输入集，包括提供标识值以区分调用与其同行的内建输入。
每个调用都有自己独立的内存空间，即在地址空间/私有（address spaces/private）和地址空间/函数（address spaces/function）中的变量。


在着色器阶段内部，调用并发执行，并且通常可以并行执行。
着色器作者负责确保着色器阶段中调用的动态行为：


满足某些原始操作（包括纹理采样和控制栅栏）的[[#uniformity|一致性]]要求。
协调对共享变量的潜在冲突访问，以避免数据竞争。

在某些情况下，WGSL允许多种可能的行为。
这是一个可移植性风险，因为不同的实现可能表现出不同的行为。
WGSL的设计旨在尽量减少这种情况，但受到可行性和在广泛设备范围内实现高性能的目标的限制。


<dfn noexport>行为要求</dfn>是实现处理或执行WGSL程序时执行的操作。它们描述了实现与程序员的合同中的义务。当这些义务可能不明显时，规范会明确说明这些义务。

## 语法符号表示法 ## {#syntax-notation}

以下语法符号表示WGSL的语法规则约定：

* 在规则两侧的斜体文本表示语法规则。
* 在规则右侧以单引号（'）开始和结束的粗体等宽文本表示关键字和令牌。
* 正常文本中的冒号（:）注册一个语法规则。
* 正常文本中的竖线（|）表示多个可选项。
* 正常文本中的问号（?）表示前一个关键字、令牌、规则或组出现零次或一次（可选）。
* 正常文本中的星号（*）表示前一个关键字、令牌、规则或组出现零次或多次。
* 正常文本中的加号（+）表示前一个关键字、令牌、规则或组出现一次或多次。
* 正常文本中的配对的括号（( 和 )）表示一组元素。

## 数学术语和符号 ## {#terms-and-notation}

<dfn noexport>Angles</dfn>:
* 按照惯例，角度用弧度来表示。
* 测量角度的参考射线是从原点(0,0)指向(+∞,0)的射线。
* 设θ为比较射线和参考射线所对应的角度。那么当比较射线逆时针移动时，θ增加。
* 一个完整的圆周有2π弧度。
* 例子：
    * 角度0从原点指向右边，即指向(1,0)
    * 角度2π从原点指向右边，即指向(1,0)
    * 角度π/4从原点指向(1,1)点
    * 角度π/2从原点指向(0,1)点
    * 角度π从原点指向(-1,0)点
    * 角度(3/2)π从原点指向(0,-1)点

一个间隔是一个有下界和上界的连续数集。
根据上下文，它们可以是整数、浮点数或实数集合。

* 闭区间[a, b]是一组数字x，使得a ≤ x ≤ b。
* 半开区间[a, b)是一组数字x，使得a ≤ x < b。
* 半开区间(a, b]是一组数字x，使得a < x ≤ b。

地板函数是定义在实数 |x| 扩展为正无穷和负无穷的范围内的：

* ⌊ + ∞ ⌋ = +∞
* ⌊ − ∞ ⌋ = −∞
* 对于实数 |x|，⌊|x|⌋ = |k|，其中 |k| 是满足 |k| ≤ |x| < |k|+1 的唯一整数

天花板函数是定义在实数 |x| 扩展为正无穷和负无穷的范围内的：

* ⌈ +∞ ⌉ = +∞
* ⌈ −∞ ⌉ = −∞
* 对于实数 |x|，⌈|x|⌉ = |k|，其中 |k| 是满足 |k|-1 < |x| ≤ |k| 的唯一整数

截断函数是定义在实数 |x| 扩展为正无穷和负无穷的范围内的：

* truncate(+∞) = +∞
* truncate(−∞) = −∞
* 对于实数 |x|，计算绝对值小于或等于 |x| 的最近整数：
    * 如果 |x| ≥ 0，则 truncate(|x|) = ⌊|x|⌋，否则为 ⌈|x|⌉

向上取整函数对于正整数 |k| 和 |n| 定义如下：

* roundUp(|k|, |n|) = ⌈|n| ÷ |k|⌉ × |k|

一个 |c| 列 |r| 行矩阵 |A| 的转置是通过将 |A| 的行复制为 |A|<sup>T</sup> 的列来形成的 |r| 列 |c| 行矩阵：

* transpose(|A|) = |A|<sup>T</sup>
* transpose(|A|)<sub>|i|,|j|</sub> = |A|<sub>|j|,|i|</sub>

列向量的转置是通过将列向量解释为一个 1 行矩阵来定义的。类似地，行向量的转置是通过将行向量解释为一个 1 列矩阵来定义的。

# WGSL 模块 # {#wgsl-module}

一个WGSL程序由一个单独的WGSL模块组成。

一个模块是一个可选指令序列，后面跟着模块作用域声明和const_assert语句。
一个模块按以下方式组织：

* 指令，用于指定模块级别的行为控制。
* 函数，用于指定执行行为。
* 表达式，包括声明或可执行行为的单元。
* 文字量，是纯数学值的文本表示。
* 变量，每个变量提供一个存储值的名称。
* 常量，每个常量提供一个在特定时间计算的值的名称。
* 表达式，每个表达式将一组值组合在一起产生一个结果值。
* 类型，每个类型描述：
    * 一组值。
    * 支持表达式的限制。
    * 表达式的语义。
* 属性，用于修改对象以指定额外的信息，例如：
    * 指定接口到入口点的接口。
    * 指定诊断过滤器。

<pre class=include>
path: syntax/translation_unit.syntax.bs.include
</pre>

<pre class=include>
path: syntax/global_decl.syntax.bs.include
</pre>

## 着色器生命周期 ## {#shader-lifecycle}

一个WGSL程序和它可能包含的着色器的生命周期中有四个关键事件。
前两个对应于用于准备执行WGSL程序的WebGPU API方法。
最后两个是着色器执行的开始和结束。


这些事件包括：

1. <dfn noexport>着色器模块创建</dfn>
    * 当调用WebGPU的{{GPUDevice/createShaderModule()}}方法时发生。 此时提供了WGSL程序的源文本。
2. <dfn noexport>管线创建</dfn>
    * 当调用WebGPU的{{GPUDevice/createComputePipeline()}}方法或{{GPUDevice/createRenderPipeline()}}方法时发生。 这些方法使用一个或多个先前创建的着色器模块，以及其他配置信息。
3. <dfn noexport>着色器执行开始</dfn>
    * 当向GPU发出绘制命令或调度命令时发生， 着色器开始执行指定的管线， 并调用着色器阶段的入口点函数。
4. <dfn noexport>着色器执行结束</dfn>
    * 当着色器中的所有工作完成时发生：
        * 所有执行终止，
        * 所有对资源的访问完成，
        * 如果有输出，将传递给下游管线阶段。

事件的排序是基于以下原因：

* 数据依赖性：着色器执行需要流水线，而流水线需要着色器模块。
* 因果关系：着色器必须在完成执行前开始执行。

## 错误 ## {#errors}

WebGPU 实现可能由于两个原因无法处理着色器：

* 如果着色器不满足 WGSL 或 WebGPU 规范的要求，则会出现 <dfn export>程序错误</dfn>。
* 即使满足了所有 WGSL 和 WebGPU 的要求，也可能出现 <dfn noexport>未分类错误</dfn>。 可能的原因包括：
    * 着色器过于复杂，超出了实现的能力，但无法轻松捕捉到预定的[[#limits |limits]]。简化着色器可能可以解决此问题。
    * WebGPU 实现中的缺陷。

着色器的生命周期中可能会发生处理错误的三个阶段：

* <dfn export>着色器创建错误</dfn> 是在[=着色器模块创建=]过程中可能检测到的错误。 检测仅依赖于 WGSL 模块源文本和可用于 createShaderModule API 方法的其他信息。 如果程序违反了规范中描述的必须进行的某些操作，则通常会产生着色器创建错误。

* <dfn export>管线创建错误</dfn> 是在[=管线创建=]过程中可能检测到的错误。 检测依赖于 WGSL 模块源文本和可用于特定管线创建 API 方法的其他信息。

* <dfn export>动态错误</dfn>是在着色器执行过程中发生的错误。 这些错误可能可检测，也可能不可检测。


注意：例如，数据竞争可能无法检测到。


每个要求的[=行为要求|行为=]将在最早的机会进行检查。
也就是说：

* 如果在着色器创建时未满足可在着色器创建时检测到的要求，则会导致着色器创建错误。
* 如果在管线创建时未满足可在管线创建时检测到的要求，则会导致管线创建错误，但不会在此之前检测到。

在上下文不清楚的情况下，该规范会指出
未满足特定要求的结果是着色器创建错误、管线创建错误还是动态错误。

错误的后果如下：

* 具有[=着色器创建错误=]或[=管线创建错误=]错误的 WGSL 模块将不会合并到[=管线=]中，因此不会被执行。
* 可检测到的错误[=行为要求|将=]会触发[=诊断=]。
* 如果发生[=动态错误=]：
    * [=内存访问=]只能限制为：
        * [=着色器阶段输入=]，
        * [=着色器阶段输出=]，
        * 绑定到 WGSL 模块变量的[=资源=]的任何部分以及
        * 在 WGSL 模块中声明的其他变量。
    * 否则，程序可能不会按照本规范的其余部分描述的那样运行。 注意：这些效果可能是非局部的。

## 诊断 ## {#diagnostics}


在“着色器模块创建”或“管线创建”过程中，实现可能会产生诊断信息。
诊断信息是为了应用程序作者的利益而由实现生成的消息。


当满足特定条件时，会创建或触发诊断，这被称为“触发规则”。
在源文本中满足条件的位置，表示为源文本中的点或范围，被称为“触发位置”。


诊断具有以下属性：

* 诊断严重性。
* 触发规则。
* 触发位置。

诊断的严重性可以是以下类型，按照从高到低排序：
: <dfn dfn-for="severity" noexport>错误</a>
:: 该诊断是一个错误。
    这对应于“着色器创建错误”或“管线创建错误”。
: <dfn dfn-for="severity" noexport>警告</a>
:: 该诊断描述了值得应用程序开发人员注意的异常，但不是错误。
: <dfn dfn-for="severity" noexport>信息</a>
:: 该诊断描述了值得应用程序开发人员注意的显著条件，但不是错误或警告。
: <dfn dfn-for="severity" noexport>关闭</a>
:: 该诊断已被禁用。不会传达给应用程序。

“触发规则”的名称可以是：

* 一个“诊断名称标记”，或
* 两个“诊断名称标记”，由句点“.”（U+002E）分隔。

<pre class=include>
path:syntax/diagnostic_rule_name.syntax.bs.include
</pre>

### 诊断处理 ### {#diagnostic-processing}

触发的诊断行为将按以下方式进行处理：

1. 对于每个诊断D，找到包含D的触发位置的最小受影响范围的诊断过滤器，并且该过滤器具有相同的触发规则。
    * 如果存在这样的过滤器，将其应用于D，更新D的严重程度。
    * 否则，D保持不变。
2. 丢弃严重程度为关闭的诊断。
3. 如果至少有一个剩余的诊断DI的严重程度为信息：
    * 可能会丢弃其他具有相同触发规则的信息诊断，只保留原始诊断DI。
4. 如果至少有一个剩余的诊断DW的严重程度为警告：
    * 可能会丢弃其他严重程度为信息或警告的具有相同触发规则的诊断，只保留原始诊断DW。
5. 如果至少有一个剩余的诊断的严重程度为错误：
    * 可能会丢弃其他诊断，包括其他严重程度为错误的诊断。
    * 生成一个程序错误。
        * 如果诊断在着色器模块创建时触发，错误是一个着色器创建错误。
        * 如果诊断在管线创建时触发，错误是一个管线创建错误。
6. 如果在着色器模块创建期间进行处理，剩余的诊断将填充WebGPU GPUCompilationInfo对象的GPUCompilationInfo/messages成员。
7. 如果在管线创建期间进行处理，严重程度为错误的诊断将导致WebGPU验证失败，验证GPUProgrammableStage。

注意：规则允许实现在检测到错误后停止处理WGSL模块。
此外，针对特定警告的分析可以在第一个警告上停止，
针对特定信息诊断的分析可以在第一次出现时停止。
WGSL不指定执行不同种类分析的顺序，或在单个分析中的顺序。
因此，对于相同的WGSL模块，不同的实现可能报告相同严重程度的不同诊断实例。

### 可过滤的触发规则 ### {#filterable-triggering-rules}

大多数诊断信息都会直接报告给WebGPU应用程序。
某些类型的诊断信息可以通过命名其诊断/触发规则来进行[[#diagnostic-filtering|过滤]]。
以下表格列出了可以进行过滤的标准触发规则集。

<table class='data'>
  <caption>可筛选的诊断触发规则</caption>
  <thead>
    <tr><th>可筛选的触发规则<th>默认的严重性<th>触发位置<th>描述
  </thead>

  <tr>
    <td><dfn noexport dfn-for="trigger">derivative_uniformity</dfn>
    <td>[=severity/error=]
    <td>The location of the [=call site=] for any
        [=builtin functions that compute a derivative|builtin function that computes a derivative=].
        That is, the location of a call to any of:
        * the [[#derivative-builtin-functions|derivative builtin functions]]
        * [[#texturesample|textureSample]]
        * [[#texturesamplebias|textureSampleBias]]
        * [[#texturesamplecompare|textureSampleCompare]]

    <td>一个对内置函数的调用会计算出导数，但是[=uniformity analysis=]无法证明该调用发生在[=uniform control flow=]中。

    见 [[#uniformity]].
</table>

使用一个单一的[=diagnostic name-token=]组成的未识别的触发规则应该触发用户代理的警告。


实现可以支持此处未指定的触发规则，只要它们使用[=syntax/diagnostic_rule_name=]的多令牌形式拼写。
使用多令牌形式拼写的未识别的触发规则本身可能触发诊断。


未来版本的规范可能会删除特定的规则或降低其默认严重程度
（即用较轻的默认值替换其当前默认值），但仍被视为满足向后兼容性要求。
例如，未来版本的WGSL可能会将[=trigger/derivative_uniformity=]的默认严重程度从“错误”更改为“警告”或“信息”。
在规范更改后，先前有效的程序仍将保持有效。

### 诊断过滤 ### {#diagnostic-filtering}


一旦具有可过滤的诊断和触发规则的诊断被触发，WGSL提供机制来丢弃诊断或修改其严重性。

一个诊断过滤器DF有三个参数：

* AR：称为受影响范围的源文本范围
* NS：新的诊断严重性
* TR：触发规则

将诊断过滤器DF（AR，NS，TR）应用于诊断D具有以下效果：

* 如果D的触发位置在AR内，且D的触发规则为TR，则将D的严重性属性设置为NS。
* 否则，D保持不变。

范围诊断过滤器是一个受影响范围为指定源文本范围的诊断过滤器。
范围诊断过滤器指定为开始处的@diagnostic属性，如下表所示。
@diagnostic属性不能出现在其他位置。

范围诊断过滤器的放置位置和受影响范围如下表所示。

注意：以下也是复合语句：函数体、case子句、default-alone子句、while和for循环的循环体，if子句、else_if子句和else子句的主体。

例如，在纹理采样上使用范围诊断过滤器的示例：

var<private> d: f32;
fn helper() -> vec4<f32> {
  // 在"if"的主体中禁用derivative_uniformity诊断。
  if (d < 0.5) @diagnostic(off,derivative_uniformity) {
    return textureSample(t,s,vec2(0,0));
  }
  return vec4(0.0);
}

全局诊断过滤器可以用于将诊断过滤器应用于整个WGSL模块。


例如，具有导数一致性的全局诊断过滤器的示例：

diagnostic(off,derivative_uniformity);
var<private> d: f32;
fn helper() -> vec4<f32> {
  if (d < 0.5) {
    // 通过全局诊断过滤器在此处禁用导数一致性诊断。
    return textureSample(t,s,vec2(0,0));
  } else {
    // 导数一致性诊断设置为警告级别。
    @diagnostic(warning,derivative_uniformity) {
      return textureSample(t,s,vec2(0,0));
    }
  }
  return vec4(0.0);
}

两个诊断过滤器DF1（AR1，NS1，TR1）和DF2（AR2，NS2，TR2）冲突，当：

* （AR1 = AR2），且
* （TR1 = TR2），且
* （NS1 ≠ NS2）。

诊断过滤器不能冲突。

WGSL的诊断过滤器设计为受影响范围完美嵌套。
如果DF1的受影响范围与DF2的受影响范围重叠，那么DF1的受影响范围要么完全包含在DF2的受影响范围内，要么反之亦然。

对于源位置L和触发规则TR，如果存在最近的封闭诊断过滤器，则是诊断过滤器DF（AR，NS，TR），其中：

L位于受影响范围AR内，且
如果有另一个过滤器DF’（AR’，NS’，TR），其中L位于AR’内，则AR包含在AR’内。

因为受影响范围可以嵌套，最近的封闭诊断是唯一的或不存在。

## 限制 ## {#limits}

一个WGSL实现将支持满足以下限制的着色器。
一个WGSL实现可以支持超出指定限制的着色器。

注意：如果一个WGSL实现不支持超出指定限制的着色器，应该发出错误。

<table class=‘data’>
  <caption>可量化的着色器复杂度限制</caption>
  <thead>
    <tr><th>限制<th>最小支持值
  </thead>
  <tr><td>结构类型中的成员最大数量<td>16383
  <tr><td>复合类型的最大嵌套深度<td>255
  <tr><td>函数中花括号包围语句的最大嵌套深度<td>127
  <tr><td>函数的最大形式参数数量<td>255
  <tr><td>switch语句中的case选择器的最大数量<td>16383
  <tr><td>在地址空间/函数或地址空间/私有地址空间中实例化的数组类型的最大字节大小
          对于这个限制，bool类型的大小为1字节。
      <td>65535
  <tr><td>在地址空间/工作组地址空间中实例化的数组类型的最大字节大小。
          对于这个限制，bool类型的大小为1字节，并且当替代覆盖值时，固定尺寸的数组被视为创建固定尺寸的数组。
          这将WebGPU的支持限制maxComputeWorkgroupStorageSize映射到一个独立的WGSL限制。
          注意：虽然满足这个限制的多个工作组变量仍然可以组合超过API限制。
      <td>[=supported limits/maxComputeWorkgroupStorageSize|16384=]
  <tr><td>数组类型的常量表达式中的最大元素数量<td>65535
</table>

# 文本结构 # {#textual-structure}

text/wgsl 媒体类型用于将内容标识为 WGSL 模块。
参见[[#text-wgsl-media-type]]。

WGSL 模块是使用 UTF-8 编码的 Unicode 文本，没有字节顺序标记（BOM）。

WGSL 模块文本由一系列 Unicode [=码点=] 组成，这些码点分组为连续非空的集合，形成：

* [=注释=]
* [=标记=]
* [=空白字符=]

程序文本 [=着色器创建错误|不得=] 包含空代码点（U+0000）。

## 解析 ## {#parsing}

解析WGSL模块的步骤如下:
  <blockquote>
    1. 移除[=comments=]：
        * 用空格代码点(U+0020)替换第一个注释。
        * 重复此过程直到没有注释为止。
    2. 使用[[#template-lists-sec]]中的[=template list discovery=]算法，寻找[=template lists=]。
    3. 解析整个文本，尝试匹配[=syntax/translation_unit=]语法规则。 解析使用了一个LALR(1)解析器(一次向前看一个标记) [[!DeRemer1969]]，以下是定制内容:
        * Tokenization与解析交错进行，并且具有上下文感知功能。 当解析器请求下一个标记时:
            * 消耗并忽略一系列以[=blankspace=]代码点开头的字符。
            * 如果下一个代码点是[=template list=]的开始，消耗它并返回[=syntax_sym/_template_args_start=]。
            * 如果下一个代码点是[=template list=]的结束，消耗它并返回[=syntax_sym/_template_args_end=]。
            * 否则:
                * 一个<dfn>token candidate</dfn>是由剩下未消耗代码点的非空前缀构成的WGSL[=token=]。
                * 返回的标记是最长的、同时也是当前解析器状态的有效向前看标记的[=token candidate=]。[[!VanWyk2007]]
  </blockquote>


如果发生[=shader-creation error=]，则可能是因为:
* 整个源代码无法转换为有效标记的有限序列，或者
* [=syntax/translation_unit=]语法规则与整个标记序列不匹配。

## 空白处和换行 ## {#blankspace-and-line-breaks}

<dfn>空格</dfn>是来自Unicode的一个或多个代码点的组合。
下面是Unicode版本14.0.0的[=Unicode标准附录＃31：Pattern_White_Space=]属性中的代码点集合：

* 空格（U+0020）
* 水平制表符（U+0009）
* 换行符（U+000A）
* 垂直制表符（U+000B）
* 换页符（U+000C）
* 回车符（U+000D）
* 下一行（U+0085）
* 从左到右的标记（U+200E）
* 从右到左的标记（U+200F）
* 行分隔符（U+2028）
* 段落分隔符（U+2029）

<dfn>换行符</dfn>是一系列[=空格=]代码点的连续序列，表示行的结束。
它被定义为[=UAX14第6.1节不可调整的换行规则=]中定义的一个“强制换行”信号，即[=UAX14 LB4|LB4=]和[=UAX14 LB5|LB5=]。
换行符可以是以下之一：

* 换行符（U+000A）
* 垂直制表符（U+000B）
* 换页符（U+000C）
* 回车符（U+000D），但未跟随换行符（U+000A）
* 回车符（U+000D）后跟换行符（U+000A）
* 下一行（U+0085）
* 行分隔符（U+2028）
* 段落分隔符（U+2029）

注意：以行号报告源文本位置的诊断应使用[=换行符=]来计算行数。

## 注释 ## {#comments}

一个<dfn>注释(comment)</dfn>是一段文本，它不会影响WGSL程序的有效性或含义，除非它能够分隔[=标记(tokens)=]。着色器作者可以使用注释来对他们的程序进行文档记录。

一个<dfn noexport>行尾注释(line-ending comment)</dfn>是一种注释，由两个代码点// (U+002F后跟U+002F)和随后的代码点组成，直到但不包括:

* 下一个[=换行符(line break)=]，或
* 程序结束。

一个<dfn noexport>块注释(block comment)</dfn>是一种注释，由以下组成:

* 两个代码点/* (U+002F后跟U+002A)
* 任意序列:
    * 一个[=块注释(block comment)=]，或
    * 不包含*/ (U+002A后跟U+002F)或/* (U+002F后跟U+002A)的文本
* 两个代码点*/ (U+002A后跟U+002F)

注意：块注释可以嵌套。由于块注释需要匹配的开始和结束文本序列，并且允许任意嵌套，因此无法使用正则表达式识别块注释。这是正则语言泵引理的一个结果。

<div class='example wgsl' heading='Comments'>
  <xmp>
  const f = 1.5; // This is line-ending comment.
  const g = 2.5; /* This is a block comment
                  that spans lines.
                  /* Block comments can nest.
                   */
                  But all block comments must terminate.
                 */
  </xmp>
</div>

## 令牌 ## {#tokens}
一个<dfn>标记</dfn>是由连续的代码点形成的一种：

* 一个[=文字=]。
* 一个[=关键词=]。
* 一个[=保留字=]。
* 一个[=语法标记=]。
* 一个[=标识符=]。
* 一个[=上下文相关名称=]。

## 字面量 ## {#literals}

一个<dfn>字面量</dfn>是以下之一：

* 一个<dfn noexport>布尔字面量</dfn>：要么是true，要么是false。
* 一个<dfn>数值字面量</dfn>：要么是一个整数字面量，要么是一个浮点数字面量， 用来表示一个数字。

<pre class=include>
path: syntax/literal.syntax.bs.include
</pre>

### 布尔字面量 ### {#boolean-literals}

<div class='example wgsl bool-literals' heading='boolean literals'>
  <xmp>
    const a = true;
    const b = false;
  </xmp>
</div>

<pre class=include>
path: syntax/bool_literal.syntax.bs.include
</pre>

### 数值字面量 ### {#numeric-literals}

数字字面值的形式是通过模式匹配来定义的。

一个整数字面值是：

* 一个表示整数的方式，可以是以下任意一种：
    * 0
    * 一串十进制数字，其中第一个数字不是0。
    * 0x或0X后跟一个十六进制数字序列。
* 然后是可选的i或u后缀。

<pre class=include>
path: syntax/int_literal.syntax.bs.include
</pre>

<pre class=include>
path: syntax/decimal_int_literal.syntax.bs.include
</pre>

<div class='example wgsl decimal-int-literals' heading='decimal integer literals'>
  <xmp>
    const a = 1u;
    const b = 123;
    const c = 0;
    const d = 0i;
  </xmp>
</div>

<pre class=include>
path: syntax/hex_int_literal.syntax.bs.include
</pre>

<div class='example wgsl hexadecimal-int-literals' heading='hexadecimal integer literals'>
  <xmp>
    const a = 0x123;
    const b = 0X123u;
    const c = 0x3f;
  </xmp>
</div>

<dfn>浮点数字面值</dfn>是指十进制浮点数字面值或十六进制浮点数字面值。

<pre class=include>
path: syntax/float_literal.syntax.bs.include
</pre>

一个浮点数字面量有两个逻辑部分：表示分数的尾数和一个可选的指数。
大致上，字面量的值等于尾数乘以一个基础值的给定指数次方。
如果一个尾数数字非零，或者它的左边和右边都有非零的尾数数字，那么这个数字就是【尾数】中的【有效数字】。
有效数字从左到右进行计数：第n个有效数字左边有n-1个有效数字。

一个<dfn noexport>十进制浮点数字面量</dfn>是：

* 一个尾数，由一系列数字指定，其中可以选用一个小数点（.）放置在其中某个位置。 尾数表示一个十进制数分数。
* 然后是一个可选的指数后缀，包括：
    * e 或 E。
    * 然后是一个十进制数指定的指数，可以带有可选的符号（+ 或 -）。
    * 然后是一个可选的 f 或 h 后缀。
* 小数点、指数或 f 或 h 后缀中至少要有一个。 如果没有其中任何一个，则该标记实际上是一个整数字面值。

<pre class=include>
path: syntax/decimal_float_literal.syntax.bs.include
</pre>

<div class='example wgsl decimal-float-literals' heading='decimal floating point literals'>
  <xmp>
    const a = 0.e+4f;
    const b = 01.;
    const c = .01;
    const d = 12.34;
    const f = .0f;
    const g = 0h;
    const h = 1e-3;
  </xmp>
</div>

<div algorithm="mathematical value of decimal floating point literal">

一个十进制浮点字面量的数学值计算如下：
* 根据 |mantissa| 计算出 |effective_mantissa|：
    * 如果 |mantissa| 有20个或更少的有效数字，那么 |effective_mantissa| 就是 |mantissa|。
    * 否则：
        * 令 |truncated_mantissa| 与 |mantissa| 相同，除了第20个有效数字右边的每个数字被替换为0。
        * 令 |truncated_mantissa_next| 与 |mantissa| 相同，除了：
            * 第20个有效数字增加1，并将进位传递到左侧，以确保每个数字仍在0到9的范围内，
            * 第20个有效数字右边的每个数字被替换为0。
        * 将 |effective_mantissa| 设置为 |truncated_mantissa| 或 |truncated_mantissa_next|。这是一个实现选择。
* 字面量的数学值是以十进制小数形式表示的 |effective_mantissa| 的数学值，乘以10的指数次方。 当未指定指数时，假定指数为0。

</div>

注意：小数尾数在20位小数后被截断，保留了大约log(10)/log(2)×20约等于66.4个有效位数的小数部分。

一个<dfn noexport>十六进制浮点字面量</dfn>包括：

* 一个以0x或0X开头的前缀
* 之后是一个尾数，表示为一串十六进制数字，其中可以选择包含一个十六进制小数点（.）。 尾数表示一个十六进制的分数。
* 之后是一个可选的指数后缀，包括：
    * p或P
    * 之后是一个指数，表示为一个十进制数字，可以选择带有一个可选的符号（+或-）。
    * 之后是一个可选的f或h后缀。
* 十六进制小数点或指数中至少有一个必须存在。 如果两者都不存在，则该标记实际上是一个整数字面量。

<pre class=include>
path: syntax/hex_float_literal.syntax.bs.include
</pre>

<div class='example wgsl hexadecimal-float-literals' heading='hexadecimal floating point literals'>
  <xmp>
    const a = 0xa.fp+2;
    const b = 0x1P+4f;
    const c = 0X.3;
    const d = 0x3p+2h;
    const e = 0X1.fp-4;
    const f = 0x3.2p+2h;
  </xmp>
</div>

<div algorithm="mathematical value of hexadecimal floating point literal">
十六进制浮点数文字的数学值计算如下：

* 根据尾数计算有效尾数：
    * 如果尾数有16位或更少的有效数字，则有效尾数等于尾数。
    * 否则：
        * 将截断后的尾数设为与尾数相同，除了第16位有效数字右边的每一位都被替换为0。
        * 将截断后的下一个尾数设为与尾数相同，除了：
            * 第16位有效数字增加1，并根据需要向左传播进位，以确保每一位数字保持在0到f的范围内，以及
            * 第16位有效数字右边的每一位都被替换为0。
        * 将有效尾数设为截断尾数或截断后的下一个尾数之一。这是一个实现选择。
* 文字的数学值是以十六进制分数的形式表示的有效尾数的数学值，乘以2的指数次方。 如果没有指定指数，则假定指数为0。

</div>

注意：十六进制尾数在16个十六进制数字后被截断，保留大约64个有效比特的小数部分。

当一个数值字面量有后缀时，这个字面量表示特定标量类型的值。
否则，字面量表示下面定义的一个抽象数值类型的值。
无论哪种情况，字面量表示的值是将其转换为目标类型后的数学值，
遵循[[#floating-point-conversion]]中的规则。

<table class=data>
  <caption>Mapping numeric literals to types</caption>
  <thead>
    <tr><th>Numeric Literal<th>Suffix<th>Type<th>Examples
  </thead>

  <tr><td>[=integer literal=]<td>`i`<td>[=i32=]<td>42i
  <tr><td>[=integer literal=]<td>`u`<td>[=u32=]<td>42u
  <tr><td>[=integer literal=]<td><td>[=AbstractInt=]<td>124
  <tr><td>[=floating point literal=]<td>`f`<td>[=f32=]<td>42f 1e5f 1.2f 0x1.0p10f
  <tr><td>[=floating point literal=]<td>`h`<td>[=f16=]<td>42h 1e5h 1.2h 0x1.0p10h
  <tr><td>[=floating point literal=]<td><td>[=AbstractFloat=]<td>1e5 1.2 0x1.0p10
</table>

如果发生以下情况之一，将导致“shader-creation error”：

* 带有“i”或“u”后缀的整数字面量无法由目标类型表示。
* 带有“f”或“h”后缀的十六进制浮点数字面量溢出或无法被目标类型准确表示。
* 带有“f”或“h”后缀的十进制浮点数字面量溢出目标类型。
* 在未启用“extension/f16|f16 extension”时使用带有“h”后缀的浮点数字面量。

注意：十六进制浮点值“0x1.00000001p0”需要33个尾数位才能准确表示，而“f32”只有23个显式尾数位。


注意：如果您想使用“f”后缀强制将十六进制浮点数字面量标记为某种类型，字面量还必须使用二进制指数。例如，写作“0x1p0f”。相比之下，“0x1f”是一个十六进制整数字面量。

## Keywords ## {#keywords}

一个<dfn>关键字</dfn>是指一个预定义的语言概念的[=标记=]。
请参阅[[#keyword-summary]]以获取WGSL关键字列表。

## 标识符 ## {#identifiers}

标识符是一种被用作名称的令牌。参见[[#declaration-and-scope]]。

WGSL使用两种语法非终结符来区分用例：

* 语法非终结符"ident"用于命名一个声明的对象。
* 语法非终结符"member_ident"用于命名一个结构类型的成员。

<pre class=include>
path: syntax/ident.syntax.bs.include
</pre>
<pre class=include>
path: syntax/member_ident.syntax.bs.include
</pre>

标识符的形式基于《Unicode标准附录 #31 - Unicode版本14.0.0》中描述的规范，并有以下详细说明。

标识符使用根据《UAX31语法》描述的以下配置文件。

```
<Identifier> := <Start> <Continue>* (<Medial> <Continue>+)*

<Start> := XID_Start + U+005F
<Continue> := <Start> + XID_Continue
<Medial> :=
```

这意味着像Δέλτα，réflexion，Кызыл，𐰓𐰏𐰇，朝焼け，سلام，검정，שָׁלוֹם，गुलाबी，փիրուզ这样具有非ASCII代码点的标识符是有效的。

With the following exceptions:
* An identifier [=shader-creation error|must not=] have the same spelling as a [=keyword=] or as a [=reserved word=].
* An identifier [=shader-creation error|must not=] be `_` (a single underscore, `U+005F`).
* An identifier [=shader-creation error|must not=] start with `__` (two underscores, `U+005F` followed by `U+005F`).

<pre class=include>
path: syntax/ident_pattern_token.syntax.bs.include
</pre>

[=Unicode Character Database for Unicode Version 14.0.0=] 包含了非规范性的列表，其中包含了所有有效的编码点，包括 [=UAX31 Lexical Classes|XID_Start=] 和 [=UAX31 Lexical Classes|XID_Continue=]。

注意：一些内建函数的返回类型是结构类型，这些结构类型的名称在WGSL源代码中不能使用。这些结构类型被描述得好像它们是以两个下划线开头的预声明类型。结果值可以使用类型推断保存到新声明的let或var中，或者可以立即通过名称提取其中的一个成员。请参阅frexp和modf的描述中的示例用法。

### 标识符比较 ### {#identifier-comparison}

如果且仅当两个WGSL标识符由相同的代码点序列组成时，它们才是相同的。


注意：本规范不允许对值进行Unicode归一化以进行比较。
视觉上和语义上相同但使用不同Unicode字符序列的值将不匹配。
建议内容作者在选择值时要么始终使用相同的编码序列，要么避免使用可能会引起问题的字符。
有关更多信息，请参阅[[CHARMOD-NORM]]。


注意：当一个WGSL模块的含义会随着将所有标识符的实例替换为该标识符的形状相同的标识符之一而发生改变时，用户代理应发出开发者可见的警告。
（同形异意是一串代码点的序列，可能对读者来说与另一串代码点的序列看起来相同。
检测同形异意的映射示例包括前一段中提到的转换、映射和匹配算法。如果标识符可以通过重复替换子序列来将一个序列转换为另一个序列，则这两个序列是同形异意的。）

## 依赖上下文的名称 ## {#context-dependent-names}

一个<dfn>上下文相关名称（context-dependent name）</dfn>是一个用于命名概念的<b><dfn>标记（token）</dfn></b>，但仅在特定的语法上下文中使用。
这个标记的拼写可能与<b><dfn>标识符（identifier）</dfn></b>相同，但该标记并不会<b><dfn>解析（resolve）</dfn></b>为一个已声明的对象。

章节[[#context-dependent-name-tokens]]列出了所有这样的标记。

## 诊断规则名称 ## {#diagnostic-rule-names}
<dfn noexport>诊断性名词令牌</dfn>是诊断触发规则名称中使用的令牌。令牌的拼写可能与标识符相同，但不会解析为已声明的对象。该令牌不能是关键字或保留字。

参见[[#diagnostics]]。

<pre class=include>
path: syntax/diagnostic_name_token.syntax.bs.include
</pre>

## 模板列表 ## {#template-lists-sec}

<dfn noexport>模板参数化</dfn>是一种指定修改常规概念的参数的方式。
要编写一个模板参数化，先写出常规概念，然后是一个[=模板列表=]。

忽略[=注释=]和[=空格=]，一个<dfn noexport>模板列表</dfn>由以下部分组成：

* 一个初始的'<'（U+003C）代码点，然后
* 一个[=syntax_sym/comma=]分隔的一个或多个<dfn noexport>模板参数</dfn>的列表，然后
* 一个可选的尾部[=syntax_sym/comma=]，然后
* 一个终止的'>'（U+003E）代码点。

一个[=模板参数=]的形式是通过下面的[=模板列表发现=]算法隐式定义的。
通常，它们是名称、表达式或类型。

注意：例如，短语vec3<f32>是一个模板参数化，其中vec3是被修改的常规概念，
而<f32>是包含一个参数的模板列表，该参数是类型[=f32=]。
一起来看，vec3<f32>表示一个特定的[=向量=]类型。

注意：例如，短语var<storage,read_write>用模板参数storage和read_write修改了通用的var概念。

<div class=note>
  <span class=marker>注意：</span>例如，短语array<vec4<f32>>有两个模板参数化：

  * vec4<f32>用模板参数f32修改了通用的vec4概念。
  * array<vec4<f32>>用模板参数vec4<f32>修改了通用的array概念。

</div>

将界定模板列表的'<'（U+003C）和'>'（U+003E）代码点，也用于拼写：

* 在[=syntax/relational_expression=]中的比较操作符。
* 在[=syntax/shift_expression=]中的移位操作符。
* 在执行移位操作后进行赋值的[=syntax/compound_assignment_operator=]。

在语法上，会优先解决模板列表的歧义：

* 在解析的早期阶段，模板列表会在[=declarations=]、[=expressions=]、[=statements=]解析之前被发现。
* 在后续的词法标记化过程中， 模板列表的初始'<'（U+003C）被映射为[=syntax_sym/_template_args_start=]标记，而 模板列表的结束'>'（U+003E）被映射为[=syntax_sym/_template_args_end=]标记。

以下是[=template list discovery=]算法。
算法使用以下假设和属性：

1. 模板参数是一个表达式，因此不以'<'（U+003C）或'='（U+003D）代码点开头。
2. 表达式不包含代码点';'（U+003B）、'{'（U+007B）或':'（U+003A）。
3. 表达式不包含[=statement/assignment=]。
4. '='（U+003D）代码点仅用于比较操作，即出现在下列其中之一中：
    <a for=syntax_sym lt=less_than_equal>'<='</a>，
    <a for=syntax_sym lt=greater_than_equal>'>='</a>，
    <a for=syntax_sym lt=equal_equal>'=='</a>或 <a for=syntax_sym lt=not_equal>'!='</a>。
    否则，'='（U+003D）代码点将用于赋值。
5. 模板列表的分隔符会考虑由括号’(…)‘和数组索引’[…]'形成的嵌套表达式。 模板列表的起始和结束必须出现在相同的嵌套级别。

<blockquote algorithm="template list discovery">
**Algorithm:** <dfn noexport>Template list discovery</dfn>

**Input:** 程序源文本.

**Record types:**

定义一个记录类型|UnclosedCandidate|包含：
* |position|，源文本中的位置
* |depth|，一个整数，表示在|position|处的表达式嵌套深度


定义一个记录类型|TemplateList|包含：
* |start_position|，表示此模板列表开始的’<’ (U+003C)字符的源位置
* |end_position|，表示此模板列表结束的’>’ (U+003E)字符的源位置


输出： |DiscoveredTemplateLists|，一个包含|TemplateList|记录的列表。

**Algorithm:**
* 将|DiscoveredTemplateLists|初始化为空列表。
* 将|Pending|变量初始化为空的|UnclosedCandidate|记录的堆栈。
* 将|CurrentPosition|整数变量初始化为0。 它编码了正在检查的代码点的位置，以源文本开始后的代码点数为计数。
    * 在执行算法时，该变量会向前移动文本。 当到达文本末尾时，立即终止算法，并使其返回|DiscoveredTemplateLists|。
* 将|NestingDepth|整数变量初始化为0。
* 重复以下步骤：
    * 将 |CurrentPosition| 推进过 [=blankspace=]、[=comments=] 和 [=literals=]。
    * 如果 [=syntax/ident_pattern_token=] 与 |CurrentPosition| 处的文本匹配，则：
        * 将 |CurrentPosition| 推进过 [=syntax/ident_pattern_token=]。
        * 如果有空格和注释，将 |CurrentPosition| 推进过它们。
        * 如果 |CurrentPosition| 处出现 '<' (U+003C)，则：
            * 注意：这个代码点有可能是模板列表的开始。 保存足够的状态以便在输入中稍后出现的 '>' (U+003E) 进行匹配。
            * 将 |UnclosedCandidate|(|position|=|CurrentPosition|,|depth|=|NestingDepth|) 推入 |Pending| 栈。
            * 将 |CurrentPosition| 推进到下一个代码点。
            * 如果 |CurrentPosition| 处出现 '<' (U+003C)，则：
                * 注意：根据假设1，没有模板参数以 '<' (U+003C) 开始，因此前一个代码点不能是模板列表的开始。 因此当前和前一个代码点必须是 <a for=syntax_sym lt=shift_left>'<<'</a> 运算符。
                * 弹出 |Pending| 栈中的顶部条目。
                * 将 |CurrentPosition| 推进过这个代码点，并开始下一次循环迭代。
            * 如果 |CurrentPosition| 处出现 '=' (U+003D)，则：
                * 注意：根据假设1，没有模板参数以 '=' (U+003C) 开始，因此前一个代码点不能是模板列表的开始。 假设当前和前一个代码点组成一个 <a for=syntax_sym lt=less_than_equal>'<='</a> 比较运算符。 跳过 '=' (U+003D) 代码点，以防后续步骤错误地将其视为赋值运算符。
                * 弹出 |Pending| 栈中的顶部条目。
                * 将 |CurrentPosition| 推进过这个代码点，并开始下一次循环迭代。
    * 如果‘>’（U+003E）出现在|CurrentPosition|处，则：
        * 注意：该代码点有可能是模板列表的结尾候选项。
        * 如果|Pending|不为空，则令|T|为其顶部项，如果|T|的|depth|等于|NestingDepth|，则：
            * 注意：该代码点结束了以|T|记录的当前模板列表的开头。
            * 将|TemplateList|（|start_position|=|T|.|position|，|end_position|=|CurrentPosition|）添加到|DiscoveredTemplateLists|中。
            * 从|Pending|栈中弹出|T|。
            * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
        * 否则，该代码点不结束模板列表：
            * 将|CurrentPosition|向前移动至此代码点的下一个位置。
            * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
                * 注意：假设当前代码点和前一个代码点形成一个<a for=syntax_sym lt=greater_than_equal>'>='</a>比较运算符。 跳过‘=’（U+003D）代码点，以免在后面的步骤中将其误认为是一个赋值。
                * 将|CurrentPosition|向前移动至此代码点的下一个位置。
                * 开始循环的下一次迭代。
    * 如果‘(’（U+0028）或‘[’（U+005B）出现在|CurrentPosition|处，则：
        * 注意：进入一个嵌套表达式。
        * 在|NestingDepth|上加1。
        * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果‘)’（U+0029）或‘]’（U+005D）出现在|CurrentPosition|处，则：
        * 注意：退出一个嵌套表达式。
        * 从|Pending|栈中弹出条目，直到它为空，或者直到其顶部条目的|depth| < |NestingDepth|为止。
        * 将|NestingDepth|设置为0或|NestingDepth| − 1中的较大值。
          * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果‘!’（U+0021）出现在|CurrentPosition|处，则：
        * 将|CurrentPosition|向前移动至此代码点的下一个位置。
        * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
            * 注意：假设当前代码点和前一个代码点形成一个<a for=syntax_sym lt=not_equal>'!='</a>比较运算符。 跳过‘=’（U+003D）代码点，以免在后面的步骤中将其误认为是一个赋值。
            * 将|CurrentPosition|向前移动至此代码点的下一个位置。
        * 开始循环的下一次迭代。
    * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
        * 将|CurrentPosition|向前移动至此代码点的下一个位置。
        * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
            * 注意：假设当前代码点和前一个代码点形成一个<a for=syntax_sym lt=equal_equal>'=='</a>比较运算符。 跳过‘=’（U+003D）代码点，以免在后面的步骤中将其误认为是一个赋值。
            * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
        * 注意：假设此代码点是赋值的一部分，它不能作为表达式的一部分出现，因此不能出现在模板列表中。 清除未完成的候选项。
        * 将|NestingDepth|设置为0。
        * 从|Pending|栈中删除所有条目。
        * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果‘;’（U+003B）或‘{’（U+007B）或‘:’（U+003A）出现在|CurrentPosition|处，则：
        * 注意：这些不能出现在表达式的中间，因此不能出现在模板列表中。 清除未完成的候选项。
        * 将|NestingDepth|设置为0。
        * 从|Pending|栈中删除所有条目。
        * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果<a for=syntax_sym lt=and_and>'&&'</a>或<a for=syntax_sym lt=or_or>'||'</a>与|CurrentPosition|处的文本匹配，则：
        * 注意：这些是低于比较运算符优先级的运算符。拒绝当前表达式级别中未完成的候选项。
        * 注意：按此规则，在程序片段 `a<b || c>d` 中，将找不到模板列表。 而它将被识别为两个比较运算的短路或运算。
        * 从|Pending|栈中弹出条目，直到它为空，或者直到其顶部条目的|depth| < |NestingDepth|为止。
        * 将|CurrentPosition|向前移动两个代码点，并开始循环的下一次迭代。
    * 将|CurrentPosition|向前移动至当前代码点的下一个位置。

</blockquote>

<div class=note algorithm="find template paramters">
<span class=marker>Note:</span>算法可以修改为找到[=模板参数=]的源范围，如下所示：

* 修改|UnclosedCandidate|，添加以下字段：
    * |parameters|，模板参数的源范围列表。
    * |parameter_start_position|，源位置。
* 修改|TemplateList|，添加一个字段：
    * |parameters|，模板参数的源范围列表。
* 当将新的|UnclosedCandidate|推入|待处理|栈时：
    * 将其|parameters|字段设置为空列表。
    * 将|parameter_start_position|设置为|CurrentPosition|的下一个代码点。
* 当将|TemplateList|，|TL|，添加到<var ignore>DiscoveredTemplateLists</var>中时：
    * 让|T|成为栈|Pending|的顶部，就像原算法中一样。
    * 将从|T|.|parameter_start_position|开始到|CurrentPosition|−1结束的源范围推入|T|.|parameters|中。
    * 按照原算法准备|TL|。
    * 将|TL|.|parameters|设置为|T|.|parameters|。
* 在循环结束之前，在推进到当前代码点之前插入一个检查：
    * 如果在|CurrentPosition|处出现了’,'（U+002C），并且|Pending|不为空，则：
      * 让|T|成为栈|Pending|的顶部。
      * 将从|T|.|parameter_start_position|开始到|CurrentPosition|−1结束的源范围推入|T|.|parameters|中。
      * 将|T|.|parameter_start_position|设置为|CurrentPosition|+1。

</div>
注意：该算法显式跳过字面值，因为有些数值字面值以字母结尾，例如1.0f。终止的f不应该被误认为是一个[=syntax/ident_pattern_token=]的开始。


注意：在短语A ( B < C, D > ( E ) )中，段落< C, D >是一个[=template list=]。


注意：该算法遵循表达式嵌套：特定模板列表的起始和结束不可以出现在不同的表达式嵌套层级上。
例如，在array<i32,select(2,3,a>b)>中，模板列表有三个参数，其中最后一个是select(2,3,a>b)。
a>b中的'>'并不终止模板列表，因为它被括在调用select函数的表达式的括号部分中。


注意：模板列表的两端必须出现在同一个[=indexing expression=]中。例如，a[b<d]>()不包含合法的模板列表。


注意：在短语A<B<<C>中，短语B<<C被解析为B后面跟着左移运算符 <a for=syntax_sym lt=shift_left>'<<'</a> 然后是C。
模板发现算法开始检查B，然后是'<' (U+003C)，但是发现紧接着的'<' (U+003C)不可能是模板参数的开始，因此
紧接在B后面的'<'并不是模板列表的开始。
初始的'<'和最后的'>'是唯一的模板列表分界符，它有模板参数B<<C。


注意：短语A<B<=C>的解析和前面的说明类似，因此短语B<=C被解析为B后面跟着小于或等于的运算符 <a for=syntax_sym lt=less_than_equal>'<='</a> 然后是C。
模板发现算法开始检查B，然后是'<' (U+003C)，但是发现紧接着的'=' (U+003D) 不可能是模板参数的开始，因此
紧接在B后面的'<'并不是模板列表的开始。
初始的'<'和最后的'>'是唯一的模板列表分界符，它有模板参数B<=C。


注意：在检查短语A<(B>=C)>时，有一个模板列表，起始于第一个'<' (U+003C) 代码点，并以最后一个'>' (U+003E) 代码点结束，参数为B>=C。
在检查到第一个'>' (U+003E) 代码点（在B之后）后，需要特殊识别'=' (U+003D) 代码点，以免被认为是赋值的一部分。


注意：在检查短语A<(B!=C)>时，有一个模板列表，起始于第一个'<’ (U+003C) 代码点，并以最后一个'>' (U+003E) 代码点结束，参数为B!=C。
在检查到'!' (U+0021) 代码点（在'B'之后）后，需要特殊识别'=' (U+003D) 代码点，以免被认为是赋值的一部分。


注意：在检查短语A<(B==C)>时，有一个模板列表，起始于第一个'<' (U+003C) 代码点，并以最后一个'>' (U+003E) 代码点结束，参数为B==C。
在检查到第一个'=' (U+003D) 代码点（在'B'之后）后，需要特殊识别第二个'=' (U+003D) 代码点，以免被认为是赋值的一部分。


在[=template list discovery=]完成后，
[[#parsing|parsing]] [=behavioral requirement|将会=] 尝试将每个模板列表与[=syntax/template_list=]语法规则匹配。

<pre class=include>
path: syntax/template_list.syntax.bs.include
</pre>

<pre class=include>
path: syntax/template_arg_comma_list.syntax.bs.include
</pre>

<pre class=include>
path: syntax/template_arg_expression.syntax.bs.include
</pre>

# 指令 # {#directives}

<dfn noexport>指令</dfn>是一系列的令牌，用于修改WGSL程序在WebGPU实现中的处理方式。


指令是可选的。
如果存在，则必须在任何声明或常量断言之前出现所有指令。

<pre class=include>
path: syntax/global_directive.syntax.bs.include
</pre>

## 扩展 ## {#extensions}

预计WGSL会随着时间的推移进行演变。

[=扩展=]是对WGSL规范进行一致性修改的命名分组，可以包含以下任意组合：

* 通过新的语法添加新的概念和行为，包括：
    * 声明、语句、属性和内置函数。
* 删除当前规范或先前发布的扩展中的限制。
* 用于减少可行行为集的语法。
* 对程序的某个部分可用功能进行限制的语法。
* 描述扩展与现有规范以及可能与其他扩展交互的方式。

假设，扩展可以：

* 添加数值标量类型，如不同位宽的整数。
* 添加语法以限制浮点数的舍入模式。
* 添加语法以表示着色器不使用原子类型。
* 添加新的语句类型。
* 添加新的内置函数。
* 添加语法以限制着色器执行方式。
* 添加新的着色器阶段。

有两种类型的扩展：[=启用扩展=]和[=语言扩展=]。

### 启用扩展 ### {#enable-extensions-sec}

一个<dfn noexport>enable-extension</dfn>是一种[=扩展=]，其功能仅在满足以下条件时才可用：


* 实现支持它，且
* 着色器通过一个[=enable指令=]明确请求它，且
* 在创建{{GPUDevice}}时，相应的WebGPU {{GPUFeatureName}}是所请求的必需功能之一。

[=Enable-extensions=]旨在公开不是普遍可用的硬件功能。


一个<dfn noexport>enable指令</dfn>是一个[=指令=]，它开启对一个或多个enable-extensions的支持。
如果实现不支持列出的所有enable-extensions，则会产生一个[=着色器创建错误=]。

<pre class=include>
path: syntax/enable_directive.syntax.bs.include
</pre>
<pre class=include>
path: syntax/enable_extension_list.syntax.bs.include
</pre>

与其他指示符一样，如果存在 [=enable directive=]，则它必须出现在所有 [=declarations=] 和 [[#const-assert-statement|const assertions]] 之前。
扩展名不是 [=identifiers=]：它们不会 [=resolve=] 为 [=declarations=]。

The valid [=enable-extensions=] are listed in the following table.
<table class='data'>
  <caption>Enable-extensions</caption>
  <thead>
    <tr><th>WGSL enable-extension
        <th>WebGPU {{GPUFeatureName}}
        <th>Description
  </thead>
  <tr><td><dfn noexport dfn-for="extension">`f16`</dfn>
      <td>`"shader-f16"`
      <td>在WGSL模块中使用“f16”类型是有效的。否则，直接或间接使用“f16”将会导致着色器创建错误.
</table>

<div class='example wgsl using extensions expect-error' heading="Using hypothetical enable-extensions">
  <xmp>
    // Enable a hypothetical extension for arbitrary precision floating point types.
    enable arbitrary_precision_float;
    enable arbitrary_precision_float; // A redundant enable directive is ok.

    // Enable a hypothetical extension to control the rounding mode.
    enable rounding_mode;

    // Assuming arbitrary_precision_float enables use of:
    //    - a type f<E,M>
    //    - as a type in function return, formal parameters and let-declarations
    //    - as a value constructor from AbstractFloat
    //    - operands to division operator: /
    // Assuming @rounding_mode attribute is enabled by the rounding_mode enable directive.
    @rounding_mode(round_to_even)
    fn halve_it(x : f<8, 7>) -> f<8, 7> {
      let two = f<8, 7>(2);
      return x / 2; // uses round to even rounding mode.
    }
  </xmp>
</div>

### 语言扩展 ### {#language-extensions-sec}

如果实现支持，<dfn noexport>语言扩展</dfn>是自动可用的 [=extension=]。程序不必显式请求它。

[=语言扩展=] 包含了在任何WebGPU实现中都可以合理支持的功能。
如果该功能不是普遍可用，那是因为某些WebGPU实现尚未实现它。


注意：例如，do-while循环可以是一种语言扩展。

WebGPU对象的{{GPU/wgslLanguageFeatures}}成员列出了实现支持的一组[=语言扩展=]。


<dfn noexport>requires-directive</dfn>是一条[=指令=]，记录了程序对一个或多个[=语言扩展=]的使用。它不会改变实现所暴露的功能。如果实现不支持某个所需的扩展，那么会导致[=着色器创建错误=]。


WGSL模块可以使用[=requires-directive=]来表示可能的不可移植性，并且表示意图的最低可移植性要求。


注意：WebGPU实现之外的工具可以检查一个程序中使用的所有[=语言扩展=]是否都被程序中的[=requires-directive=]覆盖。

<pre class=include>
path: syntax/requires_directive.syntax.bs.include
</pre>
<pre class=include>
path: syntax/software_extension_list.syntax.bs.include
</pre>

与其他指示符一样，如果存在[=requires-directive=]，它必须出现在所有[=declarations=]和[[#const-assert-statement|const assertions]]之前。
扩展名不是[=identifiers=]：它们不能[=resolves|resolve=]为[=declarations=]。

<table class='data'>
  <caption>Language extensions</caption>
  <thead>
    <tr><th style="width:30%">WGSL language extension
        <th>Description
  </thead>
  <tr><td>readonly_and_readwrite_storage_textures
      <td>允许在类型/存储纹理中使用“访问/读取”和“访问/读写”访问模式。
          此外，还添加了“textureBarrier”内建函数。
</table>

注意：WGSL 的目的是随着时间的推移，定义包含当时常见的语言扩展的所有功能的语言扩展。
在一个 “requires-directive” 中，这些扩展作为一种简化方式，用于列出所有这些常见功能。
它们代表着逐步增加的功能集合，可以将其视为一种语言版本。

## 全局诊断过滤器 ## {#global-diagnostic-directive}

全局诊断筛选器是一个其受影响范围为整个WGSL模块的诊断筛选器。
它是一个指令，因此出现在任何模块范围声明之前。
它的拼写类似于属性形式，但没有前导的@（U+0040）代码点，并以分号结尾。

<pre class=include>
path: syntax/diagnostic_directive.syntax.bs.include
</pre>

# 声明和范围 # {#declaration-and-scope}

<dfn noexport>声明</dfn>将一个标识符与以下类型的对象之一关联起来：

* 一个类型
* 一个类型生成器
* 一个值声明
* 一个变量
* 一个函数
* 一个形式参数
* 一个枚举值

换句话说，声明为对象引入了一个名称。

如果声明出现在程序源代码中，但在任何其他声明的文本之外，则该声明处于模块范围内。


函数声明出现在模块范围内。
函数声明包含形式参数的声明（如果有的话），并且它可以在函数体内包含变量和值的声明。
因此，这些包含的声明不在模块范围内。


注意：唯一包含另一个声明的声明是函数声明。

WebGPU实现提供了某些对象，并将其视为在WGSL模块源代码开始之前声明过。我们称这样的对象为<dfn noexport>预声明</dfn>。例如，WGSL预声明了：

* 内置函数，
* 内置类型如i32和f32，
* 内置类型生成器如“array”、“ptr”和“texture_2d”，以及
* 枚举值如“access/read_write”、“interpolation type/perspective”和“texel format/rgba8unorm”。

声明的范围是指声明标识符可能指代其关联对象的程序源位置的集合。我们说标识符在这些源位置上是<dfn noexport>有效范围内</dfn>的（对于该声明）。

声明出现的位置决定了其范围：

* 预声明的对象和在模块范围内声明的对象在整个程序源代码中都是有效范围内的。
* 用户声明的函数的每个形式参数在相应的函数体中都是有效范围内的。详见[[#function-declaration-sec]]。
* 否则，范围是从声明的结束位置之后开始的一段文本。详见[[#var-and-value]]。

同一个WGSL源程序中的两个声明不能同时：

* 引入相同的标识符名称，并且
* 拥有相同的作用域结束位置。

注意：预声明的对象在WGSL源代码中没有声明。
因此，模块范围内或函数内的用户指定声明可以和预声明对象具有相同的名称。

标识符的使用方式如下，根据语法上下文进行区分：

* 与[=syntax/ident=]语法元素匹配的标记：
    * 用于声明中，作为正在声明的对象的名称，或
    * 作为名称使用，表示在其他地方声明的对象。这是常见情况。
* 与[=syntax/member_ident=]语法元素匹配的标记：
    * 用于结构类型声明中，作为成员的名称，或
    * 作为名称使用，表示结构值的成员，或表示对结构成员的引用。参见[[#struct-access-expr]]。

当一个[=syntax/ident=]标记作为表示在其他地方声明的对象的名称时，
它在某个声明中必须处于范围之内。
标识符标记所表示的对象由以下方式确定：

* 如果该标记在至少一个非模块范围声明的范围之内， 则该标记表示与最近的那个声明相关联的对象。

    注意：最近的这样的声明会出现在标识符标记之前。

* 否则，如果存在具有该名称的模块范围声明，则该标记 表示已声明的对象。

    注意：模块范围的声明可以出现在标识符标记之前或之后。

* 否则，如果存在具有该名称的预声明对象，则该标记表示该对象。

当上述算法用于将标识符映射到声明时，我们说该标识符解析到该声明。类似地，我们也说标识符解析到所声明的对象。

如果任何模块范围的声明是递归的，那么这是一个着色器创建错误。也就是说，声明之间不能存在循环：

> 考虑以下有向图：
> * 每个节点对应一个声明 D。
> * 当 D 的定义提到一个解析为 T 的标识符时，存在从声明 D 到声明 T 的边。
>
>       这个图不能有循环。

注意：函数体是函数声明的一部分，因此函数不能是递归的，无论是直接还是间接递归。

注意：非模块范围的标识符声明必须在文本中使用之前。

<div class='example wgsl' heading='Valid and invalid declarations'>
  <xmp>
    // Valid, user-defined variables can have the same name as a built-in function.
    var<private> modf: f32 = 0.0;

    // Valid, foo_1 is in scope for the entire program.
    var<private> foo: f32 = 0.0; // foo_1

    // Valid, bar_1 is in scope for the entire program.
    var<private> bar: u32 = 0u; // bar_1

    // Valid, my_func_1 is in scope for the entire program.
    // Valid, foo_2 is in scope until the end of the function.
    fn my_func(foo: f32) { // my_func_1, foo_2
      // Any reference to 'foo' resolves to the function parameter.

      // Invalid, modf resolves to the module-scope variable.
      let res = modf(foo);

      // Invalid, the scope of foo_2 ends at the of the function.
      var foo: f32; // foo_3

      // Valid, bar_2 is in scope until the end of the function.
      var bar: u32; // bar_2
      // References to 'bar' resolve to bar_2
      {
        // Valid, foo_4 is in scope until the end of the compound statement.
        var foo : f32; // foo_4

        // Valid, bar_3 is in scope until the end of the compound statement.
        var bar: u32; // bar_3
        // References to 'bar' resolve to bar_3

        // Invalid, bar_4 has the same end scope as bar_3.
        var bar: i32; // bar_4

        // Valid, i_1 is in scope until the end of the for loop
        for ( var i: i32 = 0; i < 10; i++ ) { // i_1
          // Invalid, i_2 has the same end scope as i_1.
          var i: i32 = 1; // i_2.
        }
      }

      // Invalid, bar_5 has the same end scope as bar_2.
      var bar: u32; // bar_5

      // Valid, later_def, a module scope declaration, is in scope for the entire program.
      var early_use : i32 = later_def;
    }

    // Invalid, bar_6 has the same scope as bar_1.
    var<private> bar: u32 = 1u; // bar_6

    // Invalid, my_func_2 has the same end scope as my_func_1.
    fn my_func() { } // my_func_2

    // Valid, my_foo_1 is in scope for the entire program.
    fn my_foo( //my_foo_1
      // Valid, my_foo_2 is in scope until the end of the function.
      my_foo: i32 // my_foo_2
    ) { }

    var<private> later_def : i32 = 1;
  </xmp>
</div>

<div class='example wgsl' heading='Shadowing predeclared objects'>
  <xmp>
     // This declaration hides the predeclared 'min' built-in function.
     // Since this declaration is at module-scope, it is in scope over the entire
     // source.  The built-in function is no longer accessible.
     fn min() -> u32 { return 0; }

     const rgba8unorm = 12; // This shadows the predeclared 'rgba8unorm' enumerant.
  </xmp>
</div>

# 类型 # {#types}

程序计算值。

在WGSL中，<dfn noexport>类型</dfn>是一组值，每个值都属于且只属于一个类型。
值的类型确定了可以对该值执行的操作的语法和语义。

例如，数学中的1在WGSL中对应于以下不同的值：

* 32位有符号整数值1i,
* 32位无符号整数值1u,
* 32位浮点值1.0f,
* 如果启用了[f16扩展|f16 extension]，则为16位浮点值1.0h,
* [=AbstractInt=]值1，以及
* [=AbstractFloat=]值1.0

WGSL将它们视为不同，因为它们的机器表示和操作不同。

类型要么是[=预定义=]的，要么是通过WGSL源代码中的[=声明=]创建的。

一些类型被表示为[=模板参数化=]。
<dfn noexport>类型生成器</dfn>是一个[=预定义=]对象，当用[=模板列表=]参数化时，表示一个类型。
例如，类型atomic<u32>将类型生成器atomic与模板列表<u32>组合起来。


我们区分类型的概念和WGSL中表示该类型的语法。
在许多情况下，此规范中类型的拼写与其在WGSL中的语法相同。
例如：

32位无符号整数值集合在此规范中拼写为u32，在WGSL模块中也是如此。
结构类型或包含结构的类型的拼写不同。

一些WGSL类型仅用于分析源程序和确定程序的运行时行为。
本规范将描述这些类型，但它们不会出现在WGSL源代码中。


注意：[=引用类型=]不会在WGSL模块中编写。参见[[#ref-ptr-types]]。

## 类型检查 ## {#type-checking-section}

计算WGSL值是通过评估表达式来实现的。
表达式是源文本的一部分，被解析为以“expression”结尾的WGSL语法规则之一。
表达式E可以包含子表达式，这些子表达式是外部表达式E中正确包含的表达式。
顶层表达式是一个不是自己的子表达式的表达式。
参见[[#expression-grammar]]。


表达式评估产生的特定值取决于：

* 静态上下文：表达式周围的源文本，以及
* 动态上下文：评估表达式的调用状态，以及调用所在的执行上下文。

通过评估特定表达式可能得到的值将始终属于特定的WGSL类型，即表达式的静态类型。
WGSL的规则设计使得表达式的静态类型仅取决于表达式的静态上下文。

类型断言是将某个WGSL源表达式映射到一个WGSL类型的操作。
表示为

> *e* : *T*

这个类型断言表示WGSL表达式e的静态类型为T。

注意：类型断言是关于程序文本的一个事实陈述，它不是运行时的检查。

语句通常使用表达式，并可能对这些表达式的静态类型有要求。
例如：
* if语句的条件表达式必须是bool类型。
* 在具有指定显示类型的let声明中，初始化表达式必须求值为该类型。

对成功解析的WGSL模块进行类型检查是将每个表达式映射到它的静态类型，并验证每个语句的类型要求是否满足的过程。
如果类型检查失败，将出现一种特殊情况下的着色器创建错误，称为类型错误。

类型检查可以通过递归地应用类型规则到句法短语来进行，其中句法短语可以是表达式或语句。
类型规则描述了句法短语的静态上下文如何确定该短语中包含的表达式的静态类型。

一个[= 类型规则 =] 有两个部分：
* 一个[= 类型规则结论 =]。
    * 如果短语是一个表达式，结论是该表达式的[= 类型断言 =]。
    * 如果短语是一个语句，结论是一组[= 类型断言 =]，每个断言对应语句的[= 顶层表达式 =]。
    * 在这两种情况下，使用斜体的名称来指定[= 句法短语 =]， 来表示子表达式或其他语法确定的参数。
* [= 类型规则前提条件 =]，包括：
    * 对于表达式：
        * 当它具有子表达式时，对子表达式的类型断言。 每个断言可以通过直接满足或通过[= 可行的自动转换 =]（在[[ #conversion-rank ]]中定义）满足。
        * 表达式在语句中的使用方式。
    * 对于语句：
        * 语句的句法形式以及
        * 语句中的[= 顶层表达式 =]的类型断言。
    * 其他示意参数的条件（如果有）。
    * 可选的其他静态上下文。

类型规则在其前提条件和结论中可以包含[= 类型参数 =]。
当类型规则的结论或前提条件包含类型参数时，
我们说它是[= 参数化的 =]。
当它们不包含类型参数时，我们说该规则是[= 完全展开的 =]。
我们可以通过为规则的每个类型参数替换类型，
并在规则中的所有相同参数出现处使用相同的类型，
从参数化的规则生成一个完全展开的类型规则。
给规则的类型参数分配类型被称为[= 替换 =]。

例如，这是逻辑取反的类型规则（形式为!|e|）：

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论
  </thead>
  <tr algorithm="example boolean negation"><td>|e|: |T|<br>
  |T| 为 bool 或 vec|N|&lt;bool&gt;
  <td>`!`|e|`:` |T|
</table>

这是一个带参数的规则，因为它包含类型参数|T|，可以代表四种类型之一[=bool=]、vec2<bool>、vec3<bool>或vec4<bool>。
应用将|T|映射到vec3<bool>的替换，得到完全详细的类型规则：

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论
  </thead>
  <tr algorithm="example2 boolean negation"><td>|e|`: vec3<bool>`<br>
  <td>`!`|e|`: vec3<bool>`
</table>

我们通过应用满足规则其他条件的一些替换来从参数化规则中产生的每个完全阐述的规则被称为参数化规则的<dfn noexport>重载</dfn>。例如，布尔取反规则有四个重载，因为有四种可能的方式来为其类型参数|T|分配类型。

注意：
换句话说，参数化类型规则为一组完全阐述的类型规则提供了模式，每个模式通过对参数化规则应用不同的替换而产生。

当一个规则的结论与一个[=语法短句=]的有效解析相匹配，并且规则的前提条件得到满足时，一个类型规则将适用于该语法短句。

如果存在一个[=替换=]产生一个[=完全阐述=]的适用于该表达式的类型规则，那么一个[=参数化=]类型规则将适用于该表达式。

考虑表达式 1u+2u。
它有两个面值表达式：1u 和 2u，都是类型 u32。
[=顶层表达式=] 是一个加法。
参考算术表达式中的规则，加法的类型规则适用于该表达式，因为：

* 1u+2u 与 |e1|+|e2| 格式的解析相匹配，其中 |e1| 表示 1u，|e2| 表示 2u，并且
* |e1| 是类型 u32，而且
* |e2| 是类型 u32，而且
* 我们可以将 u32 替换类型参数 |T| 在类型规则中， 从而得到一个[=完全阐述=]的规则，适用于整个表达式。

在分析语法短语时，可能会出现三种情况：

* 表达式没有适用的类型规则。这会导致类型错误。
* 表达式只适用一个完全扩展的类型规则。 在这种情况下，规则的类型规则结论被断定，确定表达式的静态类型。
* 适用多个类型规则。也就是说，满足了多个重载的前提条件。 在这种情况下，使用[[#overload-resolution-section]]中描述的解决冲突的过程。
    * 如果重载解析成功，则确定一个适用于表达式的重载。 在该重载的类型规则结论中断言类型规则，并因此确定表达式或语法短语中的表达式的类型。
    * 如果重载解析失败，则会导致类型错误。

继续上面的例子，表达式1u+2u只适用一条类型规则，因此类型检查接受该类型规则的结论，即1u+2u的类型为u32。


当满足以下条件时，WGSL源程序被称为是“类型良好”的：

* 通过应用类型规则可以确定程序中每个表达式的静态类型。
* 满足每个语句的类型要求。

否则，存在类型错误，源程序不是有效的WGSL模块。

WGSL是一种“静态类型语言”，因为对WGSL模块进行类型检查要么成功，要么发现类型错误，而只需要检查程序源文本。

### 类型规则表 ### {#typing-tables-section}

表达式的WGSL[=类型规则=]按照<dfn noexport>类型规则表</dfn>进行组织，每个类型规则占据一行。


<dfn noexport>表达式的语义</dfn>是对该表达式进行评估的效果，主要是产生一个结果值。
适用于表达式的类型规则的描述列将指定表达式的语义。
语义通常取决于类型规则参数的值，包括任何子表达式的假定值。
有时，表达式的语义包括除产生结果值之外的其他影响，例如其子表达式的非结果值影响。

<div class='example' heading="Side-effect of an expression">
  <xmp>
    fn foo(p : ptr<function, i32>) -> i32 {
      let x = *p;
      *p += 1;
      return x;
    }

    fn bar() {
      var a: i32;
      let x = foo(&a); // the call to foo returns a value
                       // and updates the value of a
    }
  </xmp>
</div>

### 转化排名 ### {#conversion-rank}

当一个类型断言|e|:|T|被用作[=类型规则前提条件=]时，有以下情况时它被满足：

* |e|已经是类型|T|，或者
* |e|是类型|S|，并且类型|S|可以自动转换成类型|T|，如下所定义。

该规则由下表中定义的对类型对的<dfn>ConversionRank</dfn>函数所编码。
[=ConversionRank=]函数表达了自动转换一个类型(Src)到另一个类型(Dest)的偏好和可行性。
较低的rank更优先。

一个<dfn>可行的自动转换</dfn>将一个值从类型Src转换为类型Dest，并且当[=ConversionRank=]是有限的时允许进行。
这样的转换会保持值不变，但受到[[#floating-point-evaluation]]中描述的限制。

注意：自动转换只发生在两种情况下。
首先，当将一个[=const-expression=]转换为可以在GPU上使用的对应的类型化数值时。
其次，当从引用内存加载时，产生的值是存储在该内存中的值。

注意：无限rank的转换是不可行的，即不允许的。

注意：当没有进行转换时，转换rank为零。

<table class='data'>
  <caption>
    ConversionRank from one type to another
  </caption>
  <thead>
    <tr><th>Src
        <th>Dest
        <th>ConversionRank(Src,Dest)
        <th>Description
  </thead>
  <tr algorithm="conversion rank identity">
      <td>|T|
      <td>|T|
      <td>0
      <td>Identity. No conversion performed.
  <tr algorithm="conversion rank from reference via load rule">
      <td>ref&lt;|AS|,|T|,|AM|&gt;<br>for [=address space=] |AS|,
          and where [=access mode=] |AM| is [=access/read=] or [=access/read_write=].
      <td>|T|
      <td>0
      <td>Apply the [=Load Rule=] to load a value from a memory reference.
  <tr algorithm="conversion rank abstract float to f32">
      <td>[=AbstractFloat=]
      <td>f32
      <td>1
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract float to f16">
      <td>[=AbstractFloat=]
      <td>f16
      <td>2
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract int to i32">
      <td>[=AbstractInt=]
      <td>i32
      <td>3
      <td>Identity if the value is in [=i32=].
          Produces a [=shader-creation error=] otherwise.
  <tr algorithm="conversion rank abstract int to u32">
      <td>[=AbstractInt=]
      <td>u32
      <td>4
      <td>Identity if the value is in [=u32=].
          Produces a [=shader-creation error=] otherwise.
  <tr algorithm="conversion rank abstract int to abstract float">
      <td>[=AbstractInt=]
      <td>[=AbstractFloat=]
      <td>5
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract int to f32">
      <td>[=AbstractInt=]
      <td>f32
      <td>6
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f32
  <tr algorithm="conversion rank abstract int to f16">
      <td>[=AbstractInt=]
      <td>f16
      <td>7
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f16
  <tr algorithm="conversion rank abstract vector">
      <td>vec|N|&lt;|S|&gt;
      <td>vec|N|&lt;|T|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component type.
  <tr algorithm="conversion rank abstract matrix">
      <td>mat|C|x|R|&lt;|S|&gt;
      <td>mat|C|x|R|&lt;|T|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component type.
  <tr algorithm="conversion rank abstract array">
      <td>array&lt;|S|,|N|&gt;
      <td>array&lt;|T|,|N|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component type.
      Note: Only [=fixed-size arrays=] may have an [=type/abstract=] component type.
  <tr algorithm="conversion rank for frexp result">
      <td>__frexp_result_abstract
      <td>__frexp_result_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for frexp result f16">
      <td>__frexp_result_abstract
      <td>__frexp_result_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for frexp result vector">
      <td>__frexp_result_vecN_abstract
      <td>__frexp_result_vecN_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for frexp result vector f16">
      <td>__frexp_result_vecN_abstract
      <td>__frexp_result_vecN_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for modf result">
      <td>__modf_result_abstract
      <td>__modf_result_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for modf result f16">
      <td>__modf_result_abstract
      <td>__modf_result_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for modf result vector">
      <td>__modf_result_vecN_abstract
      <td>__modf_result_vecN_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for modf result vector f16">
      <td>__modf_result_vecN_abstract
      <td>__modf_result_vecN_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for non-convertible cases">
      <td><var ignore>S</var>
      <td><var ignore>T</var><br>where above cases don't apply
      <td>infinity
      <td>There are no automatic conversions between other types.
</table>

如果类型T是类型S的具体化，则满足以下条件：

* T是具体类型，且
* T不是引用类型，且
* ConversionRank(S, T)是有限的，且
* 对于任何其他非引用类型T2，有 ConversionRank(S, T2) > ConversionRank(S, T)

一个类型为T的值e的具体化是通过对e应用将T映射到具体化的可行转换得到的值。


备注：将类型转换为f32始终优先于f16，因此仅当模块中启用了f16扩展时，自动转换才会产生f16。

### 过载解析 ### {#overload-resolution-section}

当一个句法短语拥有多个类型规则适用时，需要使用一种决策过程来确定哪个规则生效。这个过程被称为重载解析（overload resolution），并假设类型检查已成功找到了句法短语的静态类型。

考虑一个句法短语P，以及适用于P的所有类型规则。重载解析算法将这些类型规则称为重载候选。对于每个候选：

* 它的前提条件已经直接或通过可行的自动转换得到满足。
* 它的结论具有：与P的有效解析匹配的句法形式，以及与P中每个顶级表达式相对应的类型断言。

对于P的重载解析的步骤如下，目标是找到一个最适合的重载候选：

1. 对于每个候选C，在句法短语中枚举子表达式的转换等级。候选的前提条件已经满足，因此对于P中的第i个子表达式：

    * 其静态类型已计算。
    * 存在一种从表达式的静态类型到前提条件中所需类型的可行自动转换。
        让C.R(i)是该转换的转换等级。

1. 消除任何其中一个子表达式在可行自动转换后解析为抽象类型，但候选的另一个子表达式不是常量表达式的情况。

    注：作为后果，如果短语中的任何子表达式不是常量表达式，则短语中的所有子表达式都必须具有具体类型。


1. 对候选进行排名：给定两个重载候选C1和C2，如果C1在C2之前执行，则C1优先于C2的定义如下：

    * 对于P中的每个表达式位置i，C1.R(i)≤C2.R(i)。
        * 即，将C1应用于P所需的每个表达式转换至少与将C2应用于P所需的相应表达式转换一样优先。
    * 至少存在一个表达式位置i，其中C1.R(i)<C2.R(i)。
        * 即，至少存在一个将C1应用所需的表达式转换比将C2应用所需的相应转换更优先的情况。

1. 如果存在一个候选C，它在所有其他候选之上都是最优的，则重载解析成功，得到候选类型规则C。否则，重载解析失败。

## 简单类型 ## {#plain-types-section}

[=Plain types=] 是用于机器表示的布尔值、数字、向量、矩阵或这些值的聚合的类型。

一个 <dfn>plain type</dfn> 可以是一个 [=scalar=] 类型，一个 [=atomic type|atomic=] 类型，或者一个 [=composite=] 类型。

注意：WGSL 中的 Plain types 类似于 C++ 中的 Plain-Old-Data types，但也包括原子类型和抽象数值类型。

### 抽象数字类型 ### {#abstract-types}

这些类型在WGSL源代码中不能被拼写出来，它们只用于类型检查。


某些表达式在着色器模块创建时进行求值，其数值范围和精度可能大于GPU直接实现的范围。


WGSL为这些求值定义了两个<dfn>抽象数值类型</dfn>：
* <dfn noexport>AbstractInt</dfn>类型是整数|i|的集合，满足-2<sup>63</sup> ≤ |i| < 2<sup>63</sup>。
* <dfn noexport>AbstractFloat</dfn>类型是可以表示在[[!IEEE-754|IEEE-754]] binary64（双精度）格式中的有限浮点数集。


在这些类型之一的表达式求值中，不能溢出或产生无限或NaN值。


如果一个类型是抽象数值类型或包含抽象数值类型，则该类型是<dfn dfn-for=“type” noexport>抽象的</dfn>。
如果一个类型不是抽象类型，则该类型是<dfn dfn-for=“type” noexport>具体的</dfn>。


没有后缀的[=numeric literal=]表示一个[=abstract numeric type=]中的值：
* 没有i或u后缀的[=integer literal=]表示[=AbstractInt=]值。
* 没有f或h后缀的[=floating point literal=]表示[=AbstractFloat=]值。


例子：表达式log2(32)的分析如下：


* log2(32)被解析为对具有操作数[=AbstractInt=]值32的内建函数log2的函数调用。
* log2没有带有[=integer scalar=]形式参数的重载。
* 取而代之的是，进行[=overload resolution=]，考虑三个可能的重载和[=feasible automatic conversions=]：
  * [=AbstractInt=]转换为[=AbstractFloat=]。（转换秩为4）
  * [=AbstractInt=]转换为[=f32=]。（转换秩为5）
  * [=AbstractInt=]转换为[=f16=]。（转换秩为6）
  * 结果计算为[=AbstractFloat=]（例如log2(32.0)）。

例子：表达式1 + 2.5的分析如下：

* 1 + 2.5被解析为加法运算，其子表达式为[=AbstractInt=]值1和[=AbstractFloat=]值2.5。
* 没有整数类型和浮点类型的|===|运算重载。
* 但是，使用可行的自动转换，有三个潜在的重载：
    * 1被转换为[=AbstractFloat=]值1.0（秩为4）且2.5保持不变为[=AbstractFloat=]（秩为0）。
    * 1被转换为[=f32=]值1.0f（秩为5）且2.5被转换为[=f32=]值2.5f（秩为1）。
    * 1被转换为[=f16=]值1.0f（秩为6）且2.5被转换为[=f16=]值2.5h（秩为2）。
    * 第一个重载是[=preferable candidate=]，类型检查成功。
    * 结果计算为[=AbstractFloat=] 1.0 + 2.5。

例子：let x = 1 + 2.5;


这个例子与上面的例子类似，只是x不能解析为[=abstract numeric type=]。
因此，存在两个可行的重载候选：使用[=f32=]或[=f16=]进行加法运算。
[=preferable candidate=]使用[=f32=]。
声明的效果就像写作let x：f32 = 1.0 + 2.5f;一样。

例子：1u + 2.5会导致[=shader-creation error=]：
* 1u项是一个类型为[=u32=]的表达式。
* 2.5项是一个类型为[=AbstractFloat=]的表达式。
* 没有有效的重载候选：
    * 没有可行的自动将GPU实例化的[=integer scalar=]类型转换为浮点类型。
    * 没有类型规则能够匹配将e+f，其中e为[=integer scalar=]类型，f为浮点类型。

<div class='example literals' heading="Type inference for literals">
  <xmp>
    // Explicitly-typed unsigned integer literal.
    var u32_1 = 1u; // variable holds a u32

    // Explicitly-typed signed integer literal.
    var i32_1 = 1i; // variable holds a i32

    // Explicitly-typed floating point literal.
    var f32_1 = 1f; // variable holds a f32

    // Explicitly-typed unsigned integer literal cannot be negated.
    var u32_neg = -1u; // invalid: unary minus does not support u32

    // When a concrete type is required, but no part of the statement or
    // expression forces a particular concrete type, an integer literal is
    // interpreted as an i32 value:
    //   Initializer for a let-declaration must be constructible (or pointer).
    //   The most preferred automatic conversion from AbstractInt to a constructible type
    //   is AbstractInt to i32, with conversion rank 2.  So '1' is inferred as i32.
    let some_i32 = 1; // like let some_i32: i32 = 1i;

    // Inferred from declaration type.
    var i32_from_type : i32 = 1; // variable holds i32.  AbstractInt to i32, conversion rank 2
    var u32_from_type : u32 = 1; // variable holds u32.  AbstractInt to u32, conversion rank 3

    // Unsuffixed integer literal can convert to floating point when needed:
    //   Automatically convert AbstractInt to f32, with conversion rank 5.
    var f32_promotion : f32 = 1; // variable holds f32

    // Invalid: no feasible conversion from floating point to integer
    var i32_demotion : i32 = 1.0; // Invalid

    // Inferred from expression.
    var u32_from_expr = 1 + u32_1; // variable holds u32
    var i32_from_expr = 1 + i32_1; // variable holds i32

    // Values must be representable.
    let u32_too_large   : u32 = 1234567890123456890; // invalid, overflow
    let i32_too_large   : i32 = 1234567890123456890; // invalid, overflow
    let u32_large : u32 = 2147483649; // valid
    let i32_large : i32 = 2147483649; // invalid, overflow
    let f32_out_of_range1 = 0x1p500; // invalid, out of range
    let f32_hex_lost_bits = 0x1.0000000001p0; // invalid, not exactly representable in f32

    // Minimum integer: unary negation over AbstractInt, then infer i32.
    // Most preferred conversion from AbstractInt to a constructible type (with lowest
    // conversion rank) is AbstractInt to i32.
    let i32_min = -2147483648;  // has type i32

    // Invalid.  Select AbstractInt to i32 as above, but the value is out of
    // range, producing shader-creation error.
    let i32_too_large_2 = 2147483648; // Invalid.

    // Subexpressions can resolve to AbstractInt and AbstractFloat.
    // The following examples are all valid and the value of the variable is 6u.
    var u32_expr1 = (1 + (1 + (1 + (1 + 1)))) + 1u;
    var u32_expr2 = 1u + (1 + (1 + (1 + (1 + 1))));
    var u32_expr3 = (1 + (1 + (1 + (1u + 1)))) + 1;
    var u32_expr4 = 1 + (1 + (1 + (1 + (1u + 1))));

    // Inference based on built-in function parameters.

    // Most-preferred candidate is clamp(i32,i32,i32)->i32
    let i32_clamp = clamp(1, -5, 5);
    // Most preferred candidate is clamp(u32,u32,u32).
    // Literals use automatic conversion AbstractInt to u32.
    let u32_clamp = clamp(5, 0, u32_from_expr);
    // Most preferred candidate is clamp(f32,f32,f32)->f32
    // literals use automatic conversion AbstractInt to f32.
    let f32_clamp = clamp(0, f32_1, 1);

    // The following examples all promote to f32 with an initial value of 10f.
    let f32_promotion1 = 1.0 + 2 + 3 + 4;
    let f32_promotion2 = 2 + 1.0 + 3 + 4;
    let f32_promotion3 = 1f + ((2 + 3) + 4);
    let f32_promotion4 = ((2 + (3 + 1f)) + 4);

    // Type rule violations.

    // Invalid, the initializer can only resolve to f32:
    // No feasible automatic conversion from AbstractFloat to u32.
    let mismatch : u32 = 1.0;

    // Invalid. There is no overload of clamp that allows mixed sign parameters.
    let ambiguous_clamp = clamp(1u, 0, 1i);

    // Inference completes at the statement level.

    // Initializer for a let-declaration must be constructible (or pointer).
    // The most preferred automatic conversion from AbstractInt to a constructible type
    // is AbstractInt to i32, with conversion rank 2.  So '1' is inferred as i32.
    let some_i32 = 1; // like let some_i32: i32 = 1i;

    let some_f32 : f32 = some_i32; // Type error: i32 cannot be assigned to f32

    // Another overflow case
    let overflow_u32 = (1 -2) + 1u; // invalid, -1 is out of range of u32

    // Ideal value out of range of 32-bits, but brought back into range
    let out_and_in_again = (0x1ffffffff / 8);

    // Similar, but invalid
    let out_of_range = (0x1ffffffff / 8u); // requires computation is done in 32-bits,
                                           // making 0x1ffffffff out of range.

  </xmp>
</div>

### 布尔类型 ### {#bool-type}

<dfn noexport>bool</dfn> 类型包括值 `true` 和 `false`.

<table class='data'>
  <caption>Boolean literal type rules</caption>
  <thead>
    <tr><th>前提条件<th>结论<th>描述
  </thead>
  <tr><td><td>`true`: bool<td>The true value.
  <tr><td><td>`false`: bool<td>The false value.
</table>

### 整数类型 ### {#integer-types}

<dfn noexport>u32</dfn>类型是由32位无符号整数组成的集合。

<dfn noexport>i32</dfn>类型是由32位有符号整数组成的集合。它使用二进制补码表示，其中符号位位于最高有效位的位置。

<table class='data'>
  <caption>整数类型的极值</caption>
  <thead>
    <tr><th>Type<th>最小值<th>最大值
  </thead>
    <tr><td rowspan=2>i32<td>i32(-2147483648)<td>2147483647i
    <tr><td>i32(-0x80000000)<td>0x7fffffffi
    <tr><td rowspan=2>u32<td>0u<td>4294967295u
    <tr><td>0x0u<td>0xffffffffu
</table>

注意：[=AbstractInt=]也是一种整数类型。

### 浮点数类型 ### {#floating-point-types}

<f32>类型是[[!IEEE-754|IEEE-754]]二进制32位浮点格式（单精度）的32位浮点值集合。有关详细信息，请参见[[#floating-point-evaluation]]。


<f16>类型是[[!IEEE-754|IEEE-754]]二进制16位浮点格式（半精度）的16位浮点值集合。如果在程序中未包含enable f16;指令以启用[=extension/f16|f16扩展=]，则使用<f16>类型会引发[=shader-creation error=]。有关详细信息，请参见[[#floating-point-evaluation]]。


下表列出了浮点类型的某些极限值。每个值都有对应的负值。
<table class='data'>
  <caption>Extreme values for floating point types</caption>
  <thead>
    <tr><th>Type<th>Smallest positive denormal<th>Smallest positive normal<th>Largest positive finite<th>Largest finite power of 2
  </thead>
    <tr><td rowspan=2>f32<td>1.40129846432481707092e-45f<td>1.17549435082228750797e-38f<td>3.40282346638528859812e+38f<td rowspan=2>0x1p+127f
    <tr><td>0x1p-149f<td>0x1p-126f<td>0x1.fffffep+127f
    <tr><td rowspan=2>f16<td>5.9604644775390625e-8h<td>0.00006103515625h<td>65504.0h<td rowspan=2>0x1p+15h
    <tr><td>0x1p-24h<td>0x1p-14h<td>0x1.ffcp+15h
</table>

注意：[=AbstractFloat=]也是一种浮点类型。

### 标量类型 ### {#scalar-types}

<dfn noexport>标量</dfn>类型有bool、AbstractInt、AbstractFloat、i32、u32、f32和f16。


数值标量类型有AbstractInt、AbstractFloat、i32、u32、f32和f16。


整数标量类型有AbstractInt、i32和u32。

### 向量类型 ### {#vector-types}

<dfn noexport>向量</dfn>是由2、3或4个[=标量=]组成的序列。
components.

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr><td>vec*N*<*T*><td>类型为T的N个组件的向量。N必须取{2, 3, 4}之一，而T必须是标量类型之一。我们将T称为向量的<dfn noexport>组件类型</dfn>。
</table>

如果一个向量的组件类型是标量数值类型，那么它就是一个数值向量。


向量的主要用途包括：

* 表示方向和大小。
* 表示空间中的位置。
* 在某种颜色空间中表示颜色。 例如，各个分量可以表示红、绿、蓝的强度，而第四个分量可以表示 alpha（透明度）值。

向量上的许多操作都是组件逐个进行的，即通过独立地对每个分量进行操作来形成结果向量。

<div class='example wgsl type-scope' heading='Vector'>
  <xmp>
    vec2<f32>  // is a vector of two f32s.
  </xmp>
</div>

<div class='example wgsl function-scope component-wise addition' heading='Component-wise addition'>
  <xmp>
    let x : vec3<f32> = a + b; // a and b are vec3<f32>
    // x[0] = a[0] + b[0]
    // x[1] = a[1] + b[1]
    // x[2] = a[2] + b[2]
  </xmp>
</div>

WGSL还预声明了以下类型别名：

<table class='data'>
  <thead>
    <tr>
        <th>Predeclared alias
        <th>Original type
        <th>Restrictions
  </thead>
  <tr>
      <td><dfn noexport>vec2i</dfn>
      <td>vec2&lt;i32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec3i</dfn>
      <td>vec3&lt;i32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec4i</dfn>
      <td>vec4&lt;i32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec2u</dfn>
      <td>vec2&lt;u32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec3u</dfn>
      <td>vec3&lt;u32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec4u</dfn>
      <td>vec4&lt;u32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec2f</dfn>
      <td>vec2&lt;f32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec3f</dfn>
      <td>vec3&lt;f32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec4f</dfn>
      <td>vec4&lt;f32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec2h</dfn>
      <td>vec2&lt;f16&gt;
      <td rowspan=3>Requires the [=extension/f16|f16 extension=].
  <tr>
      <td><dfn noexport>vec3h</dfn>
      <td>vec3&lt;f16&gt;
  <tr>
      <td><dfn noexport>vec4h</dfn>
      <td>vec4&lt;f16&gt;
</table>

### 矩阵类型 ### {#matrix-types}

一个矩阵是由2、3或4个浮点向量组成的分组序列。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="matrix type">
    <td>mat|C|x|R|&lt;|T|&gt;
    <td>类型为 |T| 的 |C| 列和 |R| 行的矩阵，其中 |C| 和 |R| 都在 {2, 3, 4} 中，而 |T| 必须为 [=f32=]、[=f16=] 或 [=AbstractFloat=]。
等价地，它可以被视为类型为 vec|R|<T> 的 |C| 列向量。
</table>

矩阵的关键用途是体现线性变换。
在这个解释中，矩阵的向量被视为列向量。

乘法运算符（*）被用于以下操作之一：

* 通过标量大小缩放变换。
* 对向量应用变换。
* 将变换与另一个矩阵结合。

参见[[#arithmetic-expr]]。

<div class='example wgsl type-scope' heading='Matrix'>
  <xmp>
    mat2x3<f32>  // This is a 2 column, 3 row matrix of 32-bit floats.
                 // Equivalently, it is 2 column vectors of type vec3<f32>.
  </xmp>
</div>

WGSL也[=指定预定义预定义=]以下[=类型别名=]：

<table class='data'>
  <thead>
    <tr>
        <th>Predeclared alias
        <th>Original type
        <th>Restrictions
  </thead>
  <tr> <td><dfn noexport>mat2x2f</dfn> <td>mat2x2&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat2x3f</dfn> <td>mat2x3&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat2x4f</dfn> <td>mat2x4&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat3x2f</dfn> <td>mat3x2&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat3x3f</dfn> <td>mat3x3&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat3x4f</dfn> <td>mat3x4&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat4x2f</dfn> <td>mat4x2&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat4x3f</dfn> <td>mat4x3&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat4x4f</dfn> <td>mat4x4&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat2x2h</dfn> <td>mat2x2&lt;f16&gt; <td rowspan=9>Requires the [=extension/f16|f16 extension=].
  <tr> <td><dfn noexport>mat2x3h</dfn> <td>mat2x3&lt;f16&gt;
  <tr> <td><dfn noexport>mat2x4h</dfn> <td>mat2x4&lt;f16&gt;
  <tr> <td><dfn noexport>mat3x2h</dfn> <td>mat3x2&lt;f16&gt;
  <tr> <td><dfn noexport>mat3x3h</dfn> <td>mat3x3&lt;f16&gt;
  <tr> <td><dfn noexport>mat3x4h</dfn> <td>mat3x4&lt;f16&gt;
  <tr> <td><dfn noexport>mat4x2h</dfn> <td>mat4x2&lt;f16&gt;
  <tr> <td><dfn noexport>mat4x3h</dfn> <td>mat4x3&lt;f16&gt;
  <tr> <td><dfn noexport>mat4x4h</dfn> <td>mat4x4&lt;f16&gt;
</table>

### 原子类型 ### {#atomic-types}

一个原子类型(encapsulates)封装了一个具体的整数标量类型，具体而言：

* 原子对象提供给并发观察者[[#memory-model|某些保证]]，
* 原子对象上唯一有效的操作是[[#atomic-builtin-functions|原子内置函数]]。

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr algorithm="atomic type"><td>atomic&lt;|T|&gt;
    <td>Atomic of type |T|. |T| [=shader-creation error|must=] be either [=u32=] or [=i32=].
</table>

表达式不得评估为原子类型。


原子类型只能由地址空间中的变量或具有读写访问模式的存储缓冲变量实例化。
对该类型的操作的内存范围由它实例化的地址空间确定。
地址空间中的原子类型具有“工作组”内存范围，而地址空间/存储中的原子类型具有“队列族”内存范围。


原子修改是对原子对象进行的任何操作，该操作设置对象的内容。
即使新值与对象的现有值相同，该操作也被视为修改。


在WGSL中，针对每个对象，原子修改是相互有序的。
也就是说，在着色器阶段执行期间，对于每个原子对象A，所有代理观察到对A应用的修改操作的相同顺序。
不同原子对象的排序可能没有任何关联；不暗示任何因果关系。
请注意，地址空间/工作组空间中的变量在计算着色器阶段/工作组内共享，但在不同工作组之间不共享。


### 数组类型 ### {#array-types}

一个<dfn noexport>数组</dfn>是一个可索引的元素值序列。

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr><td algorithm="fixed-size array type">array&lt;|E|,|N|&gt;
      <td>A <dfn>具有 |N| 个元素，类型为 |E| 的定长数组。<br> |N| 被称为数组的元素计数。
  <tr><td algorithm="runtime-sized array type">array&lt;|E|&gt;
      <td>A <dfn noexport>runtime-sized</dfn> 元素类型为|E|的数组。这些数组只能出现在特定的上下文中。
</table>

数组中的第一个元素位于索引0，每个后续元素位于下一个整数索引位置。
参见[[#array-access-expr]]。

一个表达式[=shader-creation error|不能=]求值为运行时大小的数组类型。

固定大小数组的元素计数表达式|N|受到以下约束：

* 它[=shader-creation error|必须=]是一个[=override-expression=]。
* 它[=shader-creation error|必须=]求值为[=type/concrete=]的[=integer scalar=]。
* 如果|N|不大于零，这是一个[=pipeline-creation error=]。

注意：元素计数的值在[=pipeline creation=]时完全确定。


注意：为了符合类型等效性，任何非const表达式的override表达式必须是一个identifier。
参见<a href=“#example-workgroup-variables-sized-by-override”>通过可重写常量确定尺寸的工作组变量</a>


运行时大小数组的元素数量由与相应的[=storage buffer=]变量相关联的缓冲绑定的大小确定。
参见[[#buffer-binding-determines-runtime-sized-array-element-count]]。

数组元素类型[=shader-creation error|必须=]是以下之一：

* [=scalar=]类型
* [=vector=]类型
* [=matrix=]类型
* [=atomic type|atomic=]类型
* 具有[=creation-fixed footprint=]的[=array=]类型
* 具有[=creation-fixed footprint=]的[=structure=]类型。

注意：元素类型必须是[=plain type=]。


当且仅当以下所有条件为真时，两个数组类型才相同：

* 它们具有相同的元素类型。
* 它们的元素计数规格匹配，即以下之一为真：
    * 它们都是运行时大小的。
    * 它们都是具有[=creation-fixed footprint=]的固定大小，且元素计数相等，即使其中一个是有符号的，另一个是无符号的。 (在这种情况下，有符号和无符号值是可比较的，因为元素计数始终为正数。)
    * 它们都是具有以标识符[=resolves|resolving=]到相同的[=pipeline-overridable=]常量声明的元素计数的固定大小。

<div class='example wgsl fixed-size array types' heading='Example fixed-size array types, non-overridable element count'>
  <xmp>
    // array<f32,8> and array<i32,8> are different types:
    // different element types
    var<private> a: array<f32,8>;
    var<private> b: array<i32,8>;
    var<private> c: array<i32,8u>;  // array<i32,8> and array<i32,8u> are the same type

    const width = 8;
    const height = 8;

    // array<i32,8>, array<i32,8u>, and array<i32,width> are the same type.
    // Their element counts evaluate to 8.
    var<private> d: array<i32,width>;

    // array<i32,height> and array<i32,width> are the same type.
    var<private> e: array<i32,width>;
    var<private> f: array<i32,height>;
  </xmp>
</div>

注意: 唯一有效的使用可受覆盖常量调整大小的数组类型是作为地址空间/工作组地址空间中的[内存视图]。
这包括工作组变量的存储类型。
请参见[[#var-and-value]]。

<div class='example wgsl global-scope'
   heading="Workgroup variables sized by overridable constants"
   id="example-workgroup-variables-sized-by-override">
  <xmp>
    override blockSize = 16;

    var<workgroup> odds: array<i32,blockSize>;
    var<workgroup> evens: array<i32,blockSize>; // Same type

    // None of the following have the same type as 'odds' and 'evens'.

    // Different type: Not the identifier 'blockSize'
    var<workgroup> evens_0: array<i32,16>;
    // Different type: Uses arithmetic to express the element count.
    var<workgroup> evens_1: array<i32,(blockSize * 2 / 2)>;
    // Different type: Uses parentheses, not just an identifier.
    var<workgroup> evens_2: array<i32,(blockSize)>;

    // An invalid example, because the overridable element count may only occur
    // at the outer level.
    // var<workgroup> both: array<array<i32,blockSize>,2>;

    // An invalid example, because the overridable element count is only
    // valid for workgroup variables.
    // var<private> bad_address_space: array<i32,blockSize>;
  </xmp>
</div>

### 结构类型 ### {#struct-types}

一个<dfn noexport>结构</dfn>是具有命名的<dfn noexport>成员</dfn>值的命名分组。

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr algorithm="structure type">
      <td>`struct`&nbsp;|AStructName|&nbsp;{<br>
           &nbsp;&nbsp;<var ignore>M<sub>1</sub></var> : <var ignore>T<sub>1</sub></var>,<br>
           &nbsp;&nbsp;...<br>
           &nbsp;&nbsp;<var ignore>M<sub>N</sub></var> : <var ignore>T<sub>N</sub></var>,<br>
           }
      <td> 一个名为[=identifier=] |AStructName| 的结构类型的声明，
          该结构类型具有|N|个成员，
          其中成员<var ignore>i</var>的名称由标识符<var ignore>M<sub>|i|</sub></var>确定，
          并且是类型<var ignore>T<sub>|i|</sub></var>。


          |N| [=shader-creation error|必须=]至少为1。

          同一类型的两个成员[=shader-creation error|不能=]具有相同的名称。
</table>

结构类型在模块作用域下声明。
程序源代码中，结构类型由其标识符名称表示。
请参见[[#declaration-and-scope]]。

两个结构类型仅在它们具有相同的名称时才相同。

结构成员类型必须是以下之一：

* 标量类型
* 向量类型
* 矩阵类型
* 原子类型
* 具有固定大小的数组类型和固定的创建大小
* 但仅当它是结构的最后一个成员时，它可以是运行时大小数组类型
* 具有固定创建大小的结构类型

注意：所有用户声明的结构类型都是具体类型。


注意：每个成员类型必须是纯类型。


一些限制结构成员和数组元素类型的后果包括：

* 指针、纹理或采样器不能在数组或结构的嵌套级别中出现。
* 当运行时大小数组是较大类型的一部分时，它只能出现在结构的最后一个元素中，而结构本身不能是外部数组或结构的一部分。

<div class='example wgsl global-scope' heading="Structure">
  <xmp>
    // A structure with three members.
    struct Data {
      a: i32,
      b: vec2<f32>,
      c: array<i32,10>, // last comma is optional
    }

    // Declare a variable storing a value of type Data.
    var<private> some_data: Data;
  </xmp>
</div>

<pre class=include>
path: syntax/struct_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/struct_body_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/struct_member.syntax.bs.include
</pre>

可以应用以下属性到结构成员：

* [=attribute/align=]（对齐）
* [=attribute/builtin=]（内建）
* [=attribute/location=]（位置）
* [=attribute/interpolate=]（插值）
* [=attribute/invariant=]（不变性）
* [=attribute/size=]（大小）

属性[=attribute/builtin=]，[=attribute/location=]，[=attribute/interpolate=]和[=attribute/invariant=]是IO属性。
在结构体S的成员上使用IO属性仅在S用作形式参数或入口点的返回类型时生效。
参见[[#stage-inputs-outputs]]。


属性[=attribute/align=]和[=attribute/size=]是布局属性，
如果结构类型用来定义统一缓冲区或存储缓冲区，则可能需要这些属性。
参见[[#memory-layouts]]。

<div class='example wgsl global-scope' heading='Structure declaration'>
  <xmp>
    struct my_struct {
      a: f32,
      b: vec4<f32>
    }
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Structure used to declare a buffer'>
  <xmp>
    // Runtime Array
    alias RTArr = array<vec4<f32>>;
    struct S {
      a: f32,
      b: f32,
      data: RTArr
    }
    @group(0) @binding(0) var<storage> buffer: S;
  </xmp>
</div>

### 组合类型 ### {#composite-types}

如果一个类型有作为其他类型组合的内部结构，则它是复合类型。内部部分不重叠，并且被称为组件。复合值可以被分解为其组件。参见[[#composite-value-decomposition-expr]]。


复合类型包括：

* 向量类型
* 矩阵类型
* 数组类型
* 结构类型

对于一个复合类型|T|，其嵌套深度|T|的定义为：

* 向量类型的嵌套深度为1
* 矩阵类型的嵌套深度为2
* 数组类型（元素类型为|E|）的嵌套深度为1 + NestDepth(|E|)
* 结构类型（成员类型为M<sub>1</sub>，…，M<sub>N</sub>）的嵌套深度为1 + max(NestDepth(M<sub>1</sub>)，…，NestDepth(M<sub>N</sub>))


### 可构建类型 ### {#constructible-types}

许多种类的值可以被创建、加载、存储、传递到函数中，并从函数中返回。
我们将这些称为"可构造的"。


如果类型属于以下之一，则称其为"可构造的"：

* 标量类型
* 向量类型
* 矩阵类型
* 如果固定大小数组类型具有"已创建的固定占用空间"属性，并且其元素类型是可构造的，则此类型也属于可构造的。
* 如果结构类型的所有成员都是可构造的，则此类型也属于可构造的。

注：所有可构造类型都具有"已创建的固定占用空间"属性。


注：原子类型和运行时大小的数组类型不可构造。
不可构造包含原子和运行时大小数组的复合类型。

### 固定足迹类型 ### {#fixed-footprint-types}

变量的<dfn noexport>内存占用</dfn>是用于存储变量内容的内存空间的数量。
变量的内存占用取决于其存储类型，并在着色器生命周期的某个时刻确定。
大多数变量在着色器模块创建时就确定大小。
有些变量可能在管线创建时确定大小，而其他变量可能在着色器执行开始时确定大小。

如果某个类型的具体化大小在着色器模块创建时完全确定，那么它具有"creation-fixed footprint"。
如果某个类型的大小在管线创建时完全确定，那么它具有"fixed footprint"。

注意：所有具有"creation-fixed footprint"和"fixed footprint"的类型都是可存储的。

注意：管线的创建依赖于着色器的创建，因此具有"creation-fixed footprint"的类型也具有"fixed footprint"。


具有"creation-fixed footprint"的类型有：

* 标量类型
* 矢量类型
* 矩阵类型
* 原子类型
* 固定大小数组类型，满足以下条件：
* 其元素数量是一个常量表达式。
* 结构类型，如果其所有成员都具有"creation-fixed footprint"。

注意：可构造的类型具有"creation-fixed footprint"。

具有"fixed footprint"的纯类型包括：

* 具有"creation-fixed footprint"的类型
* 固定大小数组类型（不进一步约束其元素数量）

注意：固定大小数组的唯一有效用途是作为地址空间/工作组地址空间中的内存视图。
这包括工作组变量的存储类型。

注意：固定占用的类型可以直接或间接地包含原子类型，而可构造类型则不能。

注意：固定占用的类型不包括运行时大小的数组，以及包含运行时大小数组的任何结构。

## Enumeration Types ## {#enumeration-types}

<dfn noexport>枚举</dfn>类型是一组有限的命名值。
枚举用于区分特定概念的可能性集合，例如有效的[=纹理格式=]集合。


枚举值是枚举中的一个命名值。
每个枚举值与所有其他枚举值以及所有其他类型的值都是不同的。


在WGSL源代码中没有声明新的枚举值或新的枚举类型的机制。


注意：枚举值用作[=模板参数=]。


<div class=note>
  <span class=marker>注意：</span>无法复制枚举值或为其创建替代名称的方法：


  * [[#var-and-value|变量或值]]声明不能将枚举作为其[=存储类型=]或[=有效值类型=]。
  * 函数形式参数不能是枚举类型，部分原因是枚举不可构造。

</div>

### 预先声明的枚举值 ### {#predeclared-enumerants}

以下表格列出了WGSL中的枚举类型及其预定义的枚举元素。
这些枚举类型是存在的，但是在WGSL源码中无法表示。

<table class=data>
<caption>
  预先声明的枚举值
</caption>
<thead>
  <tr><th>枚举<br>(Cannot be spelled in WGSL)<th>预先声明的枚举值
</thead>
  <tr><td rowspan=3>[=access mode=]<td>[=access/read=]
  <tr><td>[=access/write=]
  <tr><td>[=access/read_write=]
  <tr><td rowspan=5>[=address space=]

      Note: The `handle` address space is never written in a WGSL source.
      <td>[=address spaces/function=]
  <tr><td>[=address spaces/private=]
  <tr><td>[=address spaces/workgroup=]
  <tr><td>[=address spaces/uniform=]
  <tr><td>[=address spaces/storage=]
  <tr><td rowspan=3>[=interpolation type=]
      <td>[=interpolation type/perspective=]
  <tr><td>[=interpolation type/linear=]
  <tr><td>[=interpolation type/flat=]
  <tr><td rowspan=3>[=interpolation sampling=]
      <td>[=interpolation sampling/center=]
  <tr><td>[=interpolation sampling/centroid=]
  <tr><td>[=interpolation sampling/sample=]
  <tr><td rowspan=12>[=built-in value=]
      <td>[=built-in values/vertex_index=]
  <tr><td>[=built-in values/instance_index=]
  <tr><td>[=built-in values/position=]
  <tr><td>[=built-in values/front_facing=]
  <tr><td>[=built-in values/frag_depth=]
  <tr><td>[=built-in values/local_invocation_id=]
  <tr><td>[=built-in values/local_invocation_index=]
  <tr><td>[=built-in values/global_invocation_id=]
  <tr><td>[=built-in values/workgroup_id=]
  <tr><td>[=built-in values/num_workgroups=]
  <tr><td>[=built-in values/sample_index=]
  <tr><td>[=built-in values/sample_mask=]
  <tr><td rowspan=17>[=texel format=]
      <td>[=texel format/rgba8unorm=]
  <tr><td>[=texel format/rgba8snorm=]
  <tr><td>[=texel format/rgba8uint=]
  <tr><td>[=texel format/rgba8sint=]
  <tr><td>[=texel format/rgba16uint=]
  <tr><td>[=texel format/rgba16sint=]
  <tr><td>[=texel format/rgba16float=]
  <tr><td>[=texel format/r32uint=]
  <tr><td>[=texel format/r32sint=]
  <tr><td>[=texel format/r32float=]
  <tr><td>[=texel format/rg32uint=]
  <tr><td>[=texel format/rg32sint=]
  <tr><td>[=texel format/rg32float=]
  <tr><td>[=texel format/rgba32uint=]
  <tr><td>[=texel format/rgba32sint=]
  <tr><td>[=texel format/rgba32float=]
  <tr><td>[=texel format/bgra8unorm=]
</table>

## 记忆视图 ## {#memory-views}

除了使用普通类型值进行计算外，WGSL程序还经常从[[#memory|memory]]中读取值或将值写入memory，通过内存访问操作进行。每个内存访问都是通过内存视图进行的。


一个内存视图包括：

* 特定地址空间中的一组内存位置，
* 一个[[#memory-model-reference|内存模型引用]]，
* 将这些位置的内容解释为WGSL类型的存储类型，称为<dfn noexport>store type</dfn>，
* 一个访问模式。

内存视图的访问模式[=shader-creation error|必须=]由地址空间支持。参见[[#var-and-value]]。

### 可存储类型 ### {#storable-types}

存储在变量中的值必须是可存储类型的值。
可存储类型可以通过WGSL来定义明确的表示，参见[[#internal-value-layout]]，
或者可以是不透明的，例如纹理资源和采样器资源。

如果一个类型同时满足以下条件，则被称为<dfn noexport>可存储</dfn>类型：

* 标量类型
* 向量类型
* 矩阵类型
* 原子类型
* 数组类型
* 结构体类型
* 纹理类型
* 采样器类型

注意：可存储类型包括标量类型、纹理类型和采样器类型。

### 可共享的主机类型 ### {#host-shareable-types}

可与主机共享的类型用于描述主机与GPU之间共享的缓冲区的内容，或在主机和GPU之间进行复制时不进行格式转换。在此目的下使用时，该类型还可以应用[=layout attributes=]，如[[#memory-layouts]]所述。如[[#var-decls]]所述，[=uniform buffer=]和[=storage buffer=]变量的[=store type=]必须可与主机共享。


如果类型既是[=type/concrete=]，又符合以下条件之一，该类型就是<dfn noexport>可与主机共享</dfn>的：

* [=numeric scalar=]类型
* [=numeric vector=]类型
* [=matrix=]类型
* [=atomic type|atomic=]类型
* [=fixed-size array=]类型，如果它具有[=creation-fixed footprint=]并且其元素类型可与主机共享
* [=runtime-sized=]数组类型，如果它的元素类型可与主机共享
* [=structure=]类型，如果其所有成员均可与主机共享

注：关于中间阶段输入和输出类型的限制，可以参考[[#stage-inputs-outputs]]和后续部分。这些类型也具有大小，但计数方式可能不同。


注：[[#texture-sampler-types|纹理和采样器]]也可以在主机和GPU之间共享，但它们的内容是不透明的。本节中的可与主机共享类型专门用于[=storage buffer|storage=]和[=uniform buffer|uniform=]缓冲区中的使用。

### 引用和指针类型 ### {#ref-ptr-types}

WGSL有两种类型来表示[内存视图]：[引用类型]和[指针类型]。

<table class='data'>
  <thead>
    <tr><th>限制<th>Type<th>描述
  </thead>
  <tr algorithm="memory reference type">
    <td style="width:25%">|AS| 是一个地址空间，
                          |T| 是一个可存储的类型，
                          |AM| 是一种访问模式。
    <td>ref&lt;|AS|,|T|,|AM|&gt;
    <td><dfn noexport>引用类型</dfn>被定义为一组在|AS|中存储着类型为|T|的值的内存视图，支持由模式|AM|描述的内存访问。
        在这里，|T|是[=存储类型=]。
        引用类型不会在WGSL源代码中直接出现；它们被用于分析WGSL模块。
  <tr algorithm="pointer type">
    <td>|AS| 是一个地址空间，
        |T| 是一个可存储类型，
        |AM| 是一个访问模式。
    <td>ptr&lt;|AS|,|T|,|AM|&gt;
    <td>指针类型指的是在AS中保存类型为T的值的内存位置的一组内存视图，支持由AM模式描述的内存访问。
        这里，T是存储类型。
        指针类型可以出现在WGSL源代码中。
</table>

只有当两个指针类型具有相同的地址空间、存储类型和访问模式时，它们才是相同的。


在分析 WGSL 模块时，引用和指针类型是由地址空间、可存储类型和访问模式完全参数化的。
在本规范中的代码示例中，注释显示了这种完全参数化的形式。


然而，在 WGSL 源文本中：

* 引用类型 [=shader-creation error|不能出现=]。
* 指针类型可以出现。
    * 指针类型的拼写方式为参数化：
        * [=地址空间=]，
        * [=存储类型=]，
        * 有时也由 [=访问模式=] 参数化，如 [[#address-space]] 中所指定的。
* 如果程序源代码中出现指针类型，则该类型的变量声明也要在程序的某个地方有效，包括 [=地址空间=]、[=存储类型=] 和 [=访问模式=]。

注意：此限制禁止了某些永远不会在运行时使用的 [=type aliases=] 和函数 [=formal parameters=] 的声明。 如果没有这个限制，声明指针类型的别名将是有效的，但永远不能创建该类型的指针值。 同样，声明一个带有指针形式参数的函数将是有效的，但永远不能调用该函数。

<div class='example wgsl' heading='Pointer type'>
  <xmp>
    fn my_function(
      /* 'ptr<function,i32,read_write>' is the type of a pointer value that references
         memory for keeping an 'i32' value, using memory locations in the 'function'
         address space.  Here 'i32' is the store type.
         The implied access mode is 'read_write'.
         See "Address Space" section for defaults. */
      ptr_int: ptr<function,i32>,

      // 'ptr<private,array<f32,50>,read_write>' is the type of a pointer value that
      // refers to memory for keeping an array of 50 elements of type 'f32', using
      // memory locations in the 'private' address space.
      // Here the store type is 'array<f32,50>'.
      // The implied access mode is 'read_write'.
      // See the "Address space section for defaults.
      ptr_array: ptr<private, array<f32, 50>>
    ) { }
  </xmp>
</div>

引用类型和指针类型都是一组内存视图：
特定的内存视图与唯一的引用值和唯一的指针值相关联：

<blockquote algorithm=“pointer reference correspondence”>
每个类型为ptr<|AS|,|T|,|AM|>的指针值|p|对应于类型为ref<|AS|,|T|,|AM|>的唯一引用值|r|，
反之亦然，
其中|p|和|r|描述相同的内存视图。
</blockquote>

### 有效和无效的内存引用 ### {#valid-invalid-memory-references}

一个引用类型的值可以是有效引用或无效内存引用。

引用的形成如详细描述在[[#forming-references-and-pointers]]中。
通常，一个有效引用可以通过以下方式形成：

* 命名一个变量，或
* 对一个有效指针应用间接（一元*）操作，或
* 一个以有效引用为基础的命名分量表达式，或
* 一个以有效引用为基础的索引表达式，并使用合法索引。

通常，一个无效内存引用可以通过以下方式形成：

* 对一个无效指针应用间接运算符，或
* 一个以无效内存引用为基础的命名分量表达式，或
* 一个以引用为基础的索引表达式，并且要么：
    * 基础为无效内存引用，或
    * 索引为越界索引。

一个合法指针是指对应于有效引用的指针。
一个无效指针是指对应于无效内存引用的指针。

### 起始变量 ### {#originating-variable-section}

<div algorithm="defining orginating variable">
对于参考值|R|，<dfn noexport>起源变量</dfn>的定义如下：

* 当|R|是一个变量时，它就是这个变量。
* 当|R|是指针值|P|的间接操作符（一元*）的应用时，它就是|P|的起源变量。
* 当|R|是一个[=named component expression=]或一个[=indexing expression=]时，它就是[=decomposition/base=]的起源变量。

</div>

一个指针值的初始变量被定义为对应引用值的初始变量。

注意：初始变量是一个动态概念。
函数的形式参数的初始变量取决于函数的调用点。
不同的调用点可能提供指向不同初始变量的指针。

一个有效的引用始终对应于某个变量的一个或多个内存位置的非空内存视图。

<div class=note>
<span class=marker>Note:</span> 一个引用可以对应于变量内部的内存位置，但仍然可能是无效的。
当索引超过被索引的类型的范围时，就会发生这种情况，但是被引用的位置却在后续的兄弟数据成员内。


在下面的例子中，引用 the_particle.position[i] 当且仅当 i 为0或1时是有效的。
当 i 是2时，引用将是一个无效的内存引用，但在其他情况下，它会对应于 the_particle.color_index 的内存位置。
<div class='example wgsl' heading='Invalid memory reference still inside a variable'>
<span id="example-invalid-ref"></span>
  <xmp>
    struct Particle {
       position: vec2f,
       velocity: vec2f,
       color_index: i32,
    }

    @group(0) @binding(0)
    var<storage,read_write> the_particle: Particle;

    fn particle_velocity_component(p: Particle, i: i32) -> f32 {
      return the_particle.velocity[i]; // A valid reference when i is 0 or 1.
    }
  </xmp>
</div>
</div>

### 越界访问 ### {#out-of-bounds-access-sec}

一个访问无效内存引用的操作被称为“越界访问”。


越界访问是程序中的一个缺陷，因为如果按照写下的方式执行，通常会出现以下情况：

* 读取或写入变量之外的内存位置
* 将这些位置的内容解释为错误的存储类型
* 导致意外的数据竞争

因此，实现不会按照写下的方式执行此访问。执行越界访问会生成动态错误。


注意：在前一节的示例中，出现了解释错误存储类型的示例。当i为2时，表达式the_particle.velocity[i]的类型为ref<storage,f32,read_write>，意味着它是一个以f32为存储类型的内存视图。然而，内存位置被分配给color_index成员，因此实际存储的值是i32类型。

<div class=note>
  <span class=marker>注意：</span>越界访问会导致动态错误，可能会出现多种可能的结果。


  这些结果包括但不限于以下情况：


  <dfn noexport>陷阱</dfn>：
  着色器调用立即终止，[=着色器阶段输出=]被设置为零值。


  <dfn noexport>无效的加载</dfn>：
  从无效引用中加载可能返回以下之一：
  * 当原始变量是一个统一缓冲区或存储缓冲区时，
  * 来自原始变量绑定的WebGPU {{GPUBuffer}}的任何[=内存位置|内存位置=]的值
  * 当原始变量不是统一缓冲区或存储缓冲区时，
  * 来自原始变量中的任何[=内存位置|内存位置=]的值
  * 引用的存储类型的[=零值=]
  * 如果加载的值是一个向量，则为值(0, 0, 0, x)，其中x是：
  * 对于整数分量，为0、1或最大正值
  * 对于浮点分量，为0.0或1.0


  <dfn noexport>无效的存储</dfn>：
  对无效引用的[=语句/赋值|存储=]行为可能是以下之一：
  * 当原始变量是一个存储缓冲区时，
  * 将值存储到绑定到原始变量的WebGPU {{GPUBuffer}}的任何[=内存位置|内存位置=]
  * 当原始变量不是存储缓冲区时，
  * 将值存储到原始变量中的任何[=内存位置|内存位置=]
  * 不执行


  如果将无效的加载或存储重定向到共享地址空间变量内部的不同位置，
  则可能发生数据竞争。
  例如，几个并发执行的调用的访问可能会被重定向到数组的第一个元素。
  如果至少有一个访问是写入的，并且它们没有被同步，
  则结果是数据竞争，因此也是动态错误。


  越界访问使得[[#uniformity|一致性分析]]的假设失效。
  例如，如果一个调用由于越界访问而提前终止，那么它将无法参与集合操作。
  特别是，对[[#sync-builtin-functions|workgroupBarrier]]的调用可能会导致着色器挂起，而导数可能会产生无效的结果。
</div>

### 参考和指针的用途 ### {#ref-ptr-use-cases}

参考和指针的区别在于它们的用法：
* 变量的类型是引用类型。
* 取地址操作（一元运算符&）将引用值转换为其相应的指针值。
* 解引用操作（一元运算符*）将指针值转换为其相应的引用值。
* let声明可以是指针类型，但不能是引用类型。
* 形式参数可以是指针类型，但不能是引用类型。
* 简单赋值语句通过引用执行写访问操作来更新内存的内容，其中：
* 赋值语句的左侧必须是引用类型，并具有访问模式为access/write或access/read_write。
* 赋值语句的右侧必须求值为左侧的存储类型。
* 载入规则：在函数内部，引用会自动解引用（读取）以满足类型规则：
* 在函数中，当使用具有存储类型为T的引用表达式|r|的语句或表达式时，其中
* |r|的访问模式为access/read或access/read_write，并且
* 唯一可能匹配的类型规则要求|r|具有类型为T的值，则
* 认为已满足该类型规则要求，并且
* 在该上下文中评估|r|的结果是存储在|r|引用的内存位置上的值（类型为T）。 即，执行读访问以产生结果值。

以这种方式定义引用使得变量的使用变得简单而惯用。

<div class='example wgsl' heading='Reference types enable simple use of variables'>
  <xmp>
    @compute @workgroup_size(1)
    fn main() {
      // 'i' has reference type ref<function,i32,read_write>
      // The memory locations for 'i' store the i32 value 0.
      var i: i32 = 0;

      // 'i + 1' can only match a type rule where the 'i' subexpression is of type i32.
      // So the expression 'i + 1' has type i32, and at evaluation, the 'i' subexpression
      // evaluates to the i32 value stored in the memory locations for 'i' at the time
      // of evaluation.
      let one: i32 = i + 1;

      // Update the value in the locations referenced by 'i' so they hold the value 2.
      i = one + 1;

      // Update the value in the locations referenced by 'i' so they hold the value 5.
      // The evaluation of the right-hand-side occurs before the assignment takes effect.
      i = i + 3;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Returning a reference returns the value loaded via the reference'>
  <xmp>
    var<private> age: i32;
    fn get_age() -> i32 {
      // The type of the expression in the return statement must be 'i32' since it
      // must match the declared return type of the function.
      // The 'age' expression is of type ref<private,i32,read_write>.
      // Apply the Load Rule, since the store type of the reference matches the
      // required type of the expression, and no other type rule applies.
      // The evaluation of 'age' in this context is the i32 value loaded from the
      // memory locations referenced by 'age' at the time the return statement is
      // executed.
      return age;
    }

    fn caller() {
      age = 21;
      // The copy_age constant will get the i32 value 21.
      let copy_age: i32 = get_age();
    }
  </xmp>
</div>

以这种方式定义指针可以实现两个关键应用场景：
* 使用具有指针类型的let声明，以形成变量内容的一部分的简短名称。
* 使用函数的形式参数来引用对调用函数可访问的变量的内存。
      * 对于这样的函数调用，必须为该操作数提供指针值。 这通常需要使用地址运算符（一元&）来获取变量内容的指针。

<div class='example wgsl' heading='Using a pointer as a short name for part of a variable'>
  <xmp>
    struct Particle {
      position: vec3<f32>,
      velocity: vec3<f32>
    }
    struct System {
      active_index: i32,
      timestep: f32,
      particles: array<Particle,100>
    }
    @group(0) @binding(0) var<storage,read_write> system: System;

    @compute @workgroup_size(1)
    fn main() {
      // Form a pointer to a specific Particle in storage memory.
      let active_particle: ptr<storage,Particle> =
          &system.particles[system.active_index];

      let delta_position: vec3<f32> = (*active_particle).velocity * system.timestep;
      let current_position: vec3<f32>  = (*active_particle).position;
      (*active_particle).position = delta_position + current_position;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Using a pointer as a formal parameter'>
  <xmp>
    fn add_one(x: ptr<function,i32>) {
      /* Update the locations for 'x' to contain the next higher integer value,
         (or to wrap around to the largest negative i32 value).
         On the left-hand side, unary '*' converts the pointer to a reference that
         can then be assigned to. It has a read_write access mode, by default.
         /* On the right-hand side:
            - Unary '*' converts the pointer to a reference, with a read_write
              access mode.
            - The only matching type rule is for addition (+) and requires '*x' to
              have type i32, which is the store type for '*x'.  So the Load Rule
              applies and '*x' evaluates to the value stored in the memory for '*x'
              at the time of evaluation, which is the i32 value for 0.
            - Add 1 to 0, to produce a final value of 1 for the right-hand side. */
         Store 1 into the memory for '*x'. */
      *x = *x + 1;
    }

    @compute @workgroup_size(1)
    fn main() {
      var i: i32 = 0;

      // Modify the contents of 'i' so it will contain 1.
      // Use unary '&' to get a pointer value for 'i'.
      // This is a clear signal that the called function has access to the memory
      // for 'i', and may modify it.
      add_one(&i);
      let one: i32 = i;  // 'one' has value 1.
    }
  </xmp>
</div>

### 形成引用和指针值 ### {#forming-references-and-pointers}

引用值可以通过以下方式之一形成：

* [=标识符=] 通过解析为在作用域内的变量 v 的引用值来指示 v 的内存。
* 在指针上使用间接操作（一元 *）。
* 在对复合引用上使用命名成分表达式：
    * 给定一个带有向量存储类型的引用，添加一个单字母向量访问短语将导致指向向量的命名成分的引用。
    * 给定一个带有结构存储类型的引用，添加一个成员访问短语将导致指向结构的命名成员的引用。
* 在对复合引用上使用索引表达式：
    * 给定一个带有向量存储类型的引用，添加一个数组索引访问短语将导致指向向量的索引成分的引用。
    * 给定一个带有矩阵存储类型的引用，添加一个数组索引访问短语将导致指向矩阵的索引列向量的引用。
    * 给定一个带有数组存储类型的引用，添加一个数组索引访问短语将导致指向数组的索引元素的引用。

在所有情况下，结果的访问模式与原始引用的访问模式相同。

<div class='example wgsl' heading='Component reference from a composite reference'>
  <xmp>
    struct S {
        age: i32,
        weight: f32
    }
    var<private> person: S;
    // Elsewhere, 'person' denotes the reference to the memory underlying the variable,
    // and will have type ref<private,S,read_write>.

    fn f() {
        var uv: vec2<f32>;
        // For the remainder of this function body, 'uv' denotes the reference
        // to the memory underlying the variable, and will have type
        // ref<function,vec2<f32>,read_write>.

        // Evaluate the left-hand side of the assignment:
        //   Evaluate 'uv.x' to yield a reference:
        //   1. First evaluate 'uv', yielding a reference to the memory for
        //      the 'uv' variable. The result has type ref<function,vec2<f32>,read_write>.
        //   2. Then apply the '.x' vector access phrase, yielding a reference to
        //      the memory for the first component of the vector pointed at by the
        //      reference value from the previous step.
        //      The result has type ref<function,f32,read_write>.
        // Evaluating the right-hand side of the assignment yields the f32 value 1.0.
        // Store the f32 value 1.0 into the storage memory locations referenced by uv.x.
        uv.x = 1.0;

        // Evaluate the left-hand side of the assignment:
        //   Evaluate 'uv[1]' to yield a reference:
        //   1. First evaluate 'uv', yielding a reference to the memory for
        //      the 'uv' variable. The result has type ref<function,vec2<f32>,read_write>.
        //   2. Then apply the '[1]' array index phrase, yielding a reference to
        //      the memory for second component of the vector referenced from
        //      the previous step.  The result has type ref<function,f32,read_write>.
        // Evaluating the right-hand side of the assignment yields the f32 value 2.0.
        // Store the f32 value 2.0 into the storage memory locations referenced by uv[1].
        uv[1] = 2.0;

        var m: mat3x2<f32>;
        // When evaluating 'm[2]':
        // 1. First evaluate 'm', yielding a reference to the memory for
        //    the 'm' variable. The result has type ref<function,mat3x2<f32>,read_write>.
        // 2. Then apply the '[2]' array index phrase, yielding a reference to
        //    the memory for the third column vector pointed at by the reference
        //    value from the previous step.
        //    Therefore the 'm[2]' expression has type ref<function,vec2<f32>,read_write>.
        // The 'let' declaration is for type vec2<f32>, so the declaration
        // statement requires the initializer to be of type vec2<f32>.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the vec2<f32> value loaded
        // from the memory locations referenced by 'm[2]' at the time the declaration
        // is executed.
        let p_m_col2: vec2<f32> = m[2];

        var A: array<i32,5>;
        // When evaluating 'A[4]'
        // 1. First evaluate 'A', yielding a reference to the memory for
        //    the 'A' variable. The result has type ref<function,array<i32,5>,read_write>.
        // 2. Then apply the '[4]' array index phrase, yielding a reference to
        //    the memory for the fifth element of the array referenced by
        //    the reference value from the previous step.
        //    The result value has type ref<function,i32,read_write>.
        // The let-declaration requires the right-hand-side to be of type i32.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the i32 value loaded from
        // the memory locations referenced by 'A[4]' at the time the declaration
        // is executed.
        let A_4_value: i32 = A[4];

        // When evaluating 'person.weight'
        // 1. First evaluate 'person', yielding a reference to the memory for
        //    the 'person' variable declared at module scope.
        //    The result has type ref<private,S,read_write>.
        // 2. Then apply the '.weight' member access phrase, yielding a reference to
        //    the memory for the second member of the memory referenced by
        //    the reference value from the previous step.
        //    The result has type ref<private,f32,read_write>.
        // The let-declaration requires the right-hand-side to be of type f32.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the f32 value loaded from
        // the memory locations referenced by 'person.weight' at the time the
        // declaration is executed.
        let person_weight: f32 = person.weight;
    }
  </xmp>
</div>

指针值可以通过以下方式之一形成：

* 在引用上使用[=取地址=]（一元&）操作符。
    * 只有当原始引用是[=有效引用=]时，结果才是[=有效指针=]。
    * 有效结果的[=原始变量=]被定义为引用的原始变量。
* 如果一个函数[=形式参数=]具有指针类型，则在运行时调用函数时，形式参数的使用表示传递给调用函数中相应操作数的指针值。
    * 形式参数在运行时表示的值只有在调用点的指针值是[=有效指针=]时才是[=有效指针=]。
    * 有效指针形式参数在运行时的[=原始变量=]被定义为调用点处指针操作数的原始变量。

在所有情况下，结果的[=访问模式=]与原始指针的访问模式相同。

<div class='example wgsl' heading='Pointer from a variable'>
  <xmp>
    // Declare a variable in the private address space, for storing an f32 value.
    var<private> x: f32;

    fn f() {
        // Declare a variable in the function address space, for storing an i32 value.
        var y: i32;

        // The name 'x' resolves to the module-scope variable 'x',
        // and has reference type ref<private,f32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode is the same as the access mode of the original variable, so
        // the fully specified type is ptr<private,f32,read_write>.  But read_write
        // is the default access mode for function address space, so read_write does not
        // have to be spelled in this case
        let x_ptr: ptr<private,f32> = &x;

        // The name 'y' resolves to the function-scope variable 'y',
        // and has reference type ref<private,i32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode defaults to 'read_write'.
        let y_ptr: ptr<function,i32> = &y;

        // A new variable, distinct from the variable declared at module scope.
        var x: u32;

        // Here, the name 'x' resolves to the function-scope variable 'x' declared in
        // the previous statement, and has type ref<function,u32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode defaults to 'read_write'.
        let inner_x_ptr: ptr<function,u32> = &x;
    }
  </xmp>
</div>

### 与其他语言中的引用和指针的比较 ### {#pointers-other-languages}

本节是信息性的，而不是规范性的。


在WGSL中，引用和指针的限制比其他语言更严格。具体而言：
* 在WGSL中，引用不能直接声明为对另一个引用或变量的别名，无论是作为变量还是作为形式参数。
* 在WGSL中，指针和引用不能存储。也就是说，WGSL的变量声明的内容不能包含指针或引用。
* 在WGSL中，函数着色器不能返回指针或引用。
* 在WGSL中，没有办法在整数值和指针值之间进行转换。
* 在WGSL中，没有办法强制将指针值的类型更改为另一种指针类型。
    * 复合组件引用表达式是不同的： 它获取对复合值的引用，并产生对复合值内部的一个组件或元素的引用。 在WGSL中，尽管它们在更低级别的实现抽象中可能具有相同的机器地址，但它们被认为是不同的引用。
* 在WGSL中，没有办法强制将引用值的类型更改为另一种引用类型。
* 在WGSL中，没有办法更改指针或引用的访问模式。
    * 相比之下，C++会自动将非const指针转换为const指针，并使用const_cast将const值转换为非const值。
* 在WGSL中，没有办法从"堆"中分配新的内存。
* 在WGSL中，没有办法显式销毁变量。只有当变量超出作用域时，WGSL变量的内存才变得不可访问。

注意：根据上述规则，无法形成"悬空"指针，即不引用"活动"源变量的指针。[=memory view=]可能是一个[=invalid memory reference=]，但它[=behavioral requirement|绝不会=]访问与[=originating variable=]或缓冲区无关的[=memory locations=]。

## 纹理类型和采样器类型 ## {#texture-sampler-types}

<dfn noexport>纹素</dfn>是指作为纹理中最小独立可访问元素的标量或矢量。纹素是纹素元素的缩写。

<dfn noexport>纹理</dfn>是一组支持用于渲染的特殊操作的纹素集合。在WGSL中，这些操作通过纹理内置函数调用。请参阅[[#texture-builtin-functions]]获取完整列表。

WGSL纹理对应WebGPU的{{GPUTexture}}。

纹理具有以下特征：

: [=纹理格式=]
:: 每个纹素的数据表示。参见纹素格式。
: <dfn dfn-for=texture noexport>维度性</dfn>：网格坐标的维度数量以及坐标的解释方式。
:: 维度数量可以是1、2或3。
: 大多数纹理使用笛卡尔坐标。
:: 立方体纹理具有六个正方形面，并且通过从原点指向以原点为中心的立方体的三维坐标进行采样解释为方向向量。 详见{{GPUTextureViewDimension}}。
: 尺寸：沿每个维度的网格坐标的范围。这是一个与mip等级有关的函数。
:: <dfn dfn-for=texture noexport>mip等级数量</dfn>
    对于采样纹理和深度纹理，mip等级数量至少为1，对于存储纹理等级数量等于1。
    mip等级0包含纹理的全尺寸版本。
    每个后续的mip等级包含前一个mip等级的一半大小（舍入）的滤波版本。 在对纹理进行采样时，使用显式或隐式计算的细节级别来选择从中读取纹素数据的mip等级，然后通过滤波组合生成采样值。
: <dfn dfn-for=texture noexport>是否是数组纹理</dfn>
:: 非数组纹理是纹素的网格。
    * 数组纹理是纹素网格的一致数组。
: <dfn dfn-for=texture noexport>数组大小/dfn>
:: 如果纹理是数组纹理，则是一致网格的数量。
: <dfn dfn-for=texture noexport>采样次数</dfn>
:: 如果纹理是多重采样的，是采样数量。

纹理中的每个像素与一个唯一的“逻辑纹素地址”相关联，这是一个整数元组，具有以下特征：
* 一个[=mip level=]在[0, [=texture/mip level count=]]的范围内。
* 一定数量的分量，由[=texture/dimensionality=]控制，每个分量的值在[0, S<sub>i</sub>)的范围内，其中S<sub>i</sub>是第i个分量的[=texture/size=]。
* 如果纹理是[=texture/arrayed=]，则有一个在[0, [=texture/array size=]]的范围内的数组索引。请注意，[=texture/size=]是[=mip level=]的一个函数。
* 如果纹理是[[#multisampled-texture-type|multisampled]]，则有一个在[0, [=texture/sample count=]]的范围内的样本索引。

纹理的物理组织通常针对渲染操作进行了优化。为了实现这一点，很多细节对程序员来说是隐藏的，包括数据布局、数据类型以及不能直接在着色器语言中表达的内部操作。

因此，着色器不能直接访问[=texture resource|texture variable=]中的纹素内存。相反，访问是通过一个不透明的句柄进行的。

* 在着色器内部：
    * 声明一个模块作用域变量，其中[=存储类型=]是后面章节中描述的纹理类型之一。该变量存储底层纹理内存的不透明句柄，并自动放置在[=地址空间/句柄=]地址空间中。
    * 在函数内部，调用其中一个纹理内建函数，并将纹理变量或函数参数作为纹理内建函数的第一个参数提供。

* 构建WebGPU管道时，纹理变量的存储类型和绑定须与相应的绑定组布局条目兼容。


通过这种方式，纹理类型的支持操作集由具有该纹理类型[=形式参数=]的纹理内建函数的可用性决定。


注意：纹理变量存储的句柄不能由着色器改变。也就是说，该变量是只读的，即使它提供访问的底层纹理可能是可变的（例如，写入仅[=类型/存储纹理=]）。


<dfn>纹理类型</dfn>是在以下定义的一组类型：
* 采样纹理类型
* 多重采样纹理类型
* 外部纹理类型
* 纹理存储
* 纹理深度

采样器是一个不透明的句柄，用于控制从采样纹理或深度纹理中访问像素。

WGSL采样器映射到WebGPU的{{GPUSampler}}。

通过采样器的几个属性来控制像素的访问方式：

: 寻址模式
:: 控制如何解决纹理边界和越界坐标的问题。
: 每个纹理维度的寻址模式可以独立设置。
:: 详见WebGPU的{{GPUAddressMode}}。
: 过滤模式
:: 控制访问哪些像素以生成最终结果。
    过滤可以使用最近的像素或在多个像素之间进行插值。
    可以独立设置多个过滤模式。
    详见WebGPU的{{GPUFilterMode}}。
: LOD（Level of Detail）夹持
:: 控制访问的最小和最大细节级别。
: 比较
:: 控制用于比较采样器的类型。
    详见WebGPU的{{GPUCompareFunction}}。
: 最大各向异性
:: 控制采样器使用的最大各向异性值。

在WGSL模块中无法创建采样器，并且它们的状态（例如上述列出的属性）在着色器内部是不可变的，只能通过WebGPU API进行设置。

如果使用具有非可过滤格式的纹理与使用插值过滤的采样器（即任何采样器）一起使用，则会出现[=pipeline-creation error=]。

注意：着色器无法更改采样器变量存储的句柄。

### 纹理格式 ### {#texel-formats}

在WGSL中，某些纹理类型由纹素格式进行参数化。


<dfn noexport>纹素格式</dfn>具有以下特征：


: <dfn noexport>通道</dfn>
:: 每个通道包含一个标量。
    纹素格式最多有四个通道：r、g、b和a，通常对应于红色、绿色、蓝色和透明度通道的概念。
: <dfn noexport>通道格式</dfn>
:: 通道中位数的数量以及如何解释这些位数。


WGSL中的每种纹素格式都对应于具有相同名称的WebGPU {{GPUTextureFormat}}。


只有某些纹素格式在WGSL源代码中使用。
用于定义这些纹素格式的通道格式列在通道格式表中。
最后一列指定了从存储的通道位到着色器中使用的值之间的转换。
这也被称为<dfn noexport>通道传输函数</dfn>或CTF。


注意：8unorm的通道传输函数将{0，…，255}映射到浮点数范围[0.0，1.0]。


注意：8snorm的通道传输函数将{-128，…，127}映射到浮点数范围[-1.0，1.0]。

<table class='data'>
  <caption>Channel Formats</caption>
  <thead>
    <tr><th>Channel format
        <th>Number of stored bits
        <th>Interpretation of stored bits
        <th>Shader type<td style="width:25%">Shader value
(Channel Transfer Function)
  </thead>
  <tr><td>8unorm<td>8<td>unsigned integer |v| &isinv; {0,...,255}<td>f32<td> |v| &div; 255
  <tr><td>8snorm<td>8<td>signed integer |v| &isinv; {-128,...,127}<td>f32<td> max(-1, |v| &div; 127)
  <tr><td>8uint<td>8<td>unsigned integer |v| &isinv; {0,...,255}<td>u32<td> |v|
  <tr><td>8sint<td>8<td>signed integer |v| &isinv; {-128,...,127}<td>i32<td> |v|
  <tr><td>16uint<td>16<td>unsigned integer |v| &isinv; {0,...,65535}<td>u32<td> |v|
  <tr><td>16sint<td>16<td>signed integer |v| &isinv; {-32768,...,32767}<td>i32<td> |v|
  <tr><td>16float<td>16<td>[[!IEEE-754|IEEE-754]] binary16 16-bit floating point value |v|, with 1 sign bit, 5 exponent bits, 10 mantissa bits<td>f32<td>|v|
  <tr><td>32uint<td>32<td>32-bit unsigned integer value |v|<td>u32<td>|v|
  <tr><td>32sint<td>32<td>32-bit signed integer value |v|<td>i32<td>|v|
  <tr><td>32float<td>32<td>[[!IEEE-754|IEEE-754]] binary32 32-bit floating point value |v|<td>f32<td>|v|
</table>

存储纹理的像素格式在<dfn lt="storage-texel-formats">存储纹理的Texel格式</dfn>表中列出，对应支持WebGPU纯色格式的WebGPU GPUTextureUsage/STORAGE_BINDING使用。这些像素格式用于参数化在texture-storage中定义的类型/存储纹理类型。


当像素格式不具有四个通道时：

* 在读取像素时：
* 如果像素格式没有绿色通道，则着色器值的第二个分量为0。
* 如果像素格式没有蓝色通道，则着色器值的第三个分量为0。
* 如果像素格式没有alpha通道，则着色器值的第四个分量为1。
* 在写入像素时，将忽略缺失通道的着色器值分量。

下表中的最后一列使用了来自通道格式表的特定格式的通道转换函数。

<table class='data'>
  <caption>Texel Formats for Storage Textures</caption>
  <thead>
    <tr><th>Texel format
        <th>Channel format
        <th>Channels in memory order
        <th style="width:50%">Corresponding shader value
  </thead>
  <tr><td><dfn for="texel format">rgba8unorm</dfn><td>8unorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba8snorm</dfn><td>8snorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba8uint</dfn><td>8uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba8sint</dfn><td>8sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba16uint</dfn><td>16uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba16sint</dfn><td>16sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba16float</dfn><td>16float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">r32uint</dfn><td>32uint<td>r<td>vec4&lt;u32&gt;(CTF(r), 0u, 0u, 1u)
  <tr><td><dfn for="texel format">r32sint</dfn><td>32sint<td>r<td>vec4&lt;i32&gt;(CTF(r), 0, 0, 1)
  <tr><td><dfn for="texel format">r32float</dfn><td>32float<td>r<td>vec4&lt;f32&gt;(CTF(r), 0.0, 0.0, 1.0)
  <tr><td><dfn for="texel format">rg32uint</dfn><td>32uint<td>r, g<td>vec4&lt;u32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td><dfn for="texel format">rg32sint</dfn><td>32sint<td>r, g<td>vec4&lt;i32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td><dfn for="texel format">rg32float</dfn><td>32float<td>r, g<td>vec4&lt;f32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td><dfn for="texel format">rgba32uint</dfn><td>32uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba32sint</dfn><td>32sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba32float</dfn><td>32float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">bgra8unorm</dfn><td>8unorm<td>b, g, r, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
</table>

WGSL为表中的每种纹理格式[=predeclared|predeclares=]一个[=enumerant=]。

### 采样纹理类型 ### {#sampled-texture-type}

一个“采样纹理”可以与“采样器类型”一起被访问。它也可以在不使用采样器的情况下被访问。采样纹理只允许读访问。


“纹素格式”是绑定到纹理变量的“GPUTexture”的“format”属性。WebGPU会在纹理、绑定组布局的“GPUTextureBindingLayout/sampleType”以及纹理变量的“采样类型”之间进行验证以确保兼容性。


纹理由一个“采样类型”参数化，且必须是“f32”、“i32”或“u32”。

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_1d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"1d"|1D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_2d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_2d_array</dfn><*T*>
      <td>{{GPUTextureViewDimension/"2d-array"|2D}}
      <td>Yes
  <tr><td><dfn noexport dfn-for='type'>texture_3d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"3d"|3D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_cube</dfn><*T*>
      <td>{{GPUTextureViewDimension/"cube"|Cube}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_cube_array</dfn><*T*>
      <td>{{GPUTextureViewDimension/"cube-array"|Cube}}
      <td>Yes
</table>

* T 是[=采样类型=]。
* 图像的参数化类型是从采样转换后的类型。 例如，您可以有一个具有8位非规范化分量的纹素图像，但是当您对它们进行采样时，您会得到一个32位浮点数结果（或者f32向量）。

### 多重采样纹理类型 ### {#multisampled-texture-type}

一个多样本纹理具有一个或多个纹理采样点。
尽管名字是这样，但它不能与采样器一起使用。
如果忽略采样索引，它有效地按每个逻辑纹素地址存储多个像素值的数据。


纹素格式是绑定到纹理变量的GPUTexture的format属性。
WebGPU通过验证纹理、绑定组布局的GPUTextureBindingLayout/sampleType以及纹理变量的采样类型之间的兼容性。


纹理由采样类型参数化，必须是f32、i32或u32。

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_multisampled_2d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_depth_multisampled_2d</dfn>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
</table>

T 是被抽样的类型。

### 外部采样纹理类型 ### {#external-texture-type}

一个<dfn noexport dfn-for=‘type’>外部纹理</dfn>是一个不透明的二维浮点数-[=type/sampled texture=]类型，类似于texture_2d<f32>，但可能具有不同的表示形式。
可以使用[[#textureload|textureLoad]]或[[#textureSampleBaseClampToEdge|textureSampleBaseClampToEdge]]内置函数来读取它们，这些函数可以处理这些不同的表示形式。

见 [[WebGPU#gpuexternaltexture]].

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_external</dfn>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
</table>

### 存储纹理类型 ### {#texture-storage}

一种存储纹理支持无需使用采样器即可访问单个纹素值。

* 一个只写的存储纹理支持写入单个纹素，将着色器值自动转换为存储的纹素值。
* 一个只读的存储纹理支持读取单个纹素，将存储的纹素值自动转换为着色器纹素值。
* 一个读写的存储纹理支持读取和写入单个纹素，着色器纹素值和存储纹素值之间自动进行转换。

存储纹理类型必须通过[存储纹素格式]之一进行参数化。纹素格式决定了转换函数，如纹素格式中所述。


在向存储纹理写入纹素时，使用与转换函数相反的函数将着色器值转换为存储的纹素。


<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_storage_1d</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"1d"|1D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_storage_2d</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_storage_2d_array</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"2d-array"|2D}}
      <td>Yes
  <tr><td><dfn noexport dfn-for='type'>texture_storage_3d</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"3d"|3D}}
      <td>No
</table>

* Format 必须是存储纹理的像素格式之一
* Access 必须是访问模式中的一个枚举值。

### 深度纹理类型 ### {#texture-depth}

一个深度纹理（depth texture）可以与类型/采样器比较结合使用，可以被访问。它也可以在不使用采样器的情况下被访问。深度纹理仅允许读取访问。


纹理的像素格式在GPUTextureBindingLayout中被定义。

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_depth_2d</dfn>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_depth_2d_array</dfn>
      <td>{{GPUTextureViewDimension/"2d-array"|2D}}
      <td>Yes
  <tr><td><dfn noexport dfn-for='type'>texture_depth_cube</dfn>
      <td>{{GPUTextureViewDimension/"cube"|Cube}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_depth_cube_array</dfn>
      <td>{{GPUTextureViewDimension/"cube-array"|Cube}}
      <td>Yes
</table>

### 采样器类型 ### {#sampler-type}

一个<dfn>采样器（sampler）</dfn>通过执行以下操作来调节对于[=type/sampled texture=]或[=type/depth texture=]的访问：
* 坐标变换。
* 可选地修改mip级别的选择。
* 对于[=type/sampled texture=]，可选地对检索到的纹素值进行滤波。
* 对于[=type/depth texture=]，确定要应用于检索到的纹素的比较函数。

<dfn noexport>采样器类型（sampler types）</dfn>有：
* [=type/sampler=]
* [=type/sampler_comparison=]

<table class=‘data’>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr algorithm=“sampler type”>
  <td><dfn dfn-for=“type”>sampler</dfn>
  <td>采样器。调节对于[=type/sampled texture=]的访问。</td>
  <tr algorithm=“comparison sampler type”>
  <td><dfn dfn-for=“type”>sampler_comparison</dfn>
  <td>比较采样器。调节对于[=type/depth texture=]的访问。</td>
</table>


采样器在WebGPU API中创建时进行参数化。
它们不能由WGSL模块修改。

采样器只能被[[#texture-builtin-functions|纹理内置函数]]使用。

<pre class='def'>
sampler
sampler_comparison
</pre>

## 所有类型 类型 ## {#alltypes-type}

<dfn noexport>AllTypes</dfn>类型是所有WGSL类型的集合。


在WGSL源代码中无法直接编写AllTypes类型。


请参阅[[#predeclared-types]]以获取所有预定义类型和类型生成器的列表。


<div class=note>
<span class=marker>注意：</span>类型在一般意义上不是一个值。
它不是在运行时由着色器操作的数据。


<p>
相反，AllTypes类型存在是为了使类型检查规则适用于可能包含一般值的任何短语。
WGSL通过将类型定义为一种值的类型，并允许表达式表示一个类型来使规则保持一致。


<p>
动机案例是一个“模板参数”，在各种上下文中可以表示多种事物，包括一个“类型”、一个“枚举值”或一个“基本类型值”。
特别是，“syntax/template_arg_expression”语法规则会展开为“syntax/expression”语法非终结符。
</div>

## 类型别名 ## {#type-aliases}

一个<dfn noexport>类型别名</dfn>为现有类型声明了一个新名称。
声明必须出现在模块范围内，并且其作用域为整个程序。


当类型T被定义为结构类型S的一个类型别名时，
S的成员的所有属性，包括特性，都会传递给T的成员。

<pre class=include>
path: syntax/type_alias_decl.syntax.bs.include
</pre>

<div class='example wgsl global-scope' heading='Type Alias'>
  <xmp>
    alias Arr = array<i32, 5>;

    alias RTArr = array<vec4<f32>>;

    alias single = f32;     // Declare an alias for f32
    const pi_approx: single = 3.1415;
    fn two_pi() -> single {
      return single(2) * pi_approx;
    }
  </xmp>
</div>

## 类型指示语法 ## {#type-specifiers}

请参见[[#type-expr]]。


<pre class=include>
path: syntax/type_specifier.syntax.bs.include
</pre>


<pre class=include>
path: syntax/template_elaborated_ident.syntax.bs.include
</pre>


注意：通过展开的方式，[=expression=]也可以表示一种类型，通过扩展语法/primary_expression=]的语法规则到[syntax/template_elaborated_ident=]，以及通过[[#parenthesized-expressions|parenthesization]]的方式。

## 预声明类型和类型生成器总结 ## {#predeclared-types}

在WGSL源代码中可以拼写的预定义类型包括：
* [=bool=]
* [=f16=]
* [=f32=]
* [=i32=]
* [=type/sampler=]
* [=type/sampler_comparison=]
* [=type/texture_depth_2d=]
* [=type/texture_depth_2d_array=]
* [=type/texture_depth_cube=]
* [=type/texture_depth_cube_array=]
* [=type/texture_depth_multisampled_2d=]
* [=type/texture_external=]
* [=u32=]

WGSL还预先声明了[[#frexp-builtin|frexp]]、[[#modf-builtin|modf]]和[[#atomic-rmw|atomicCompareExchangeWeak]]内建函数的返回类型。
然而，这些类型在WGSL源代码中不能拼写。


以下表格列出了预声明的类型生成器：
<table class=data>
<caption>
  Predeclared type generators
</caption>
<thead>
  <tr><th>Predeclared type-generator<th>Cross-reference
</thead>
  <tr><td>array<td>See [[#array-types]]
  <tr><td>atomic<td>See [[#atomic-types]]
  <tr><td>mat2x2<td rowspan=9>See [[#matrix-types]], which also lists
     predeclared [=type aliases|aliases=] for matrix types.

     Note: These are also used in [=value constructor=] expressions
     to create matrices.
  <tr><td>mat2x3
  <tr><td>mat2x4
  <tr><td>mat3x2
  <tr><td>mat3x3
  <tr><td>mat3x4
  <tr><td>mat4x2
  <tr><td>mat4x3
  <tr><td>mat4x4
  <tr><td>ptr<td>See [[#ref-ptr-types]]
  <tr><td>texture_1d<td rowspan=6>See [[#sampled-texture-type]]
  <tr><td>texture_2d
  <tr><td>texture_2d_array
  <tr><td>texture_3d
  <tr><td>texture_cube
  <tr><td>texture_cube_array
  <tr><td>texture_multisampled_2d<td>See [[#multisampled-texture-type]]
  <tr><td>texture_storage_1d<td rowspan=4>See [[#texture-storage]]
  <tr><td>texture_storage_2d
  <tr><td>texture_storage_2d_array
  <tr><td>texture_storage_3d
  <tr><td>vec2<td rowspan=3>See [[#vector-types]], which also lists
     predeclared [=type aliases|aliases=] for vector types.

     Note: These are also used in [=value constructor=] expressions
     to create vectors.
  <tr><td>vec3
  <tr><td>vec4
</table>

# 变量和值的声明 # {#var-and-value}

[=变量声明|变量=]和[=值声明|值=]声明为数据值提供了名称。


<dfn noexport>值声明</dfn>创建一个值的名称，一旦声明，该值就是不可变的。
值声明有四种种类：const、override、let和形式参数声明，下面会进一步描述（见[[#value-decls]]）。


<dfn noexport>变量声明</dfn>为[=内存位置=]创建一个名称，用于存储值；如果变量具有[=访问/读写=]访问模式，那么存储在该位置的值可以被更新。
变量声明只有一种类型，即var，但可以在各种组合中选择[=地址空间=]和[=访问模式=]的选项，下面会进行描述（见[[#var-decls]]）。


注意：值声明没有关联的内存位置。例如，WGSL表达式无法形成指向该值的指针。


在任何函数定义之外出现的声明位于[=模块作用域=]中。它的名称在整个程序中[=在作用域内=]。


在函数定义中出现的声明位于<dfn noexport>函数作用域</dfn>中。
该名称在声明之后的语句中立即可用，直到声明所包含的大括号列表的结束。
函数作用域声明是一个[=动态上下文=]。


变量和值声明具有相似的总体语法：
<xmp>
  // Specific value declarations.
               const    name [: type]  = initializer ;
  [attribute]* override name [: type] [= initializer];
               let      name [: type]  = initializer ;

  // General variable form.
  [attribute]* var[<address_space[, access_mode]>] name [: type] [= initializer];

  // Specific variable declarations.
  // Function scope.
               var[<function>] name [: type] [= initializer];

  // Module scope.
               var<private>    name [: type] [= initializer];
               var<workgroup>  name : type;
  [attribute]+ var<uniform>    name : type;
  [attribute]+ var             name : texture_type;
  [attribute]+ var             name : sampler_type;
  [attribute]+ var<storage[, access_mode]> name : type;
</xmp>

每个这样的声明都必须具有显式指定的类型或初始化器。
可以同时指定类型和初始化器。
每个这样的声明确定与其关联的数据值的类型，被称为该声明的有效值类型。
该声明的有效值类型为：

* 如果显式指定了类型，则为声明的类型。
* 否则，如果初始化器表达式的类型为 T：
    * 对于 const 声明，有效值类型为 T 本身。
    * 对于 override、let 或 var 声明，有效值类型为 T 的具体化。

如果存在的话，每种值或变量声明方式可以对初始化器表达式的形式和有效值类型施加额外的约束。

<table class='data'>
<caption>
  Variable and Value Declaration Feature Summary.
</caption>
<thead>
  <tr><th>Declaration
      <th>Mutability
      <th>Scope
      <th>[=Effective-value-type=]<sup>1</sup>
      <th>Initializer Support
      <th>Initializer Expression<sup>2</sup>
      <th>Part of Resource Interface
</thead>
<tr><td>[=const-declaration|const=]
    <td>Immutable
    <td>[=module scope|Module=] or [=function scope|function=]
    <td>[=Constructible=] ([=type/concrete|Concrete=] or [=type/abstract|abstract=])
    <td>Required
    <td>[=const-expression=]
    <td>No

<tr><td>[=override-declaration|override=]
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=scalar=]
    <td>Optional<sup>3</sup>
    <td>[=const-expression=] or [=override-expression=]
    <td>No<sup>4</sup>

<tr><td>[=let-declaration|let=]
    <td>Immutable
    <td>[=function scope|Function=]
    <td>[=type/concrete|Concrete=] [=constructible=] or [=pointer type=]
    <td>Required
    <td>[=const-expression=], [=override-expression=], or [=runtime expression=]
    <td>No

<tr><td class="nowrap">
        [=variable|var=]&lt;[=address spaces/storage=], read&gt;<br>
        [=variable|var=]&lt;[=address spaces/storage=]&gt;
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=host-shareable=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=storage buffer=]

<tr><td class="nowrap">
        [=variable|var=]&lt;[=address spaces/storage=], read_write&gt;<sup>5,6</sup>
    <td>Mutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=host-shareable=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=storage buffer=]

<tr><td>[=variable|var=]&lt;[=address spaces/uniform=]&gt;
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=constructible=] [=host-shareable=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=uniform buffer=]

<tr><td>[=variable|var=]<sup>6</sup>
    <td>Immutable<sup>7</sup>
    <td>[=module scope|Module=]
    <td>[=texture type|Texture=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=texture resource=]

<tr><td>[=variable|var=]
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=sampler type|Sampler=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=sampler resource=]

<tr><td>[=variable|var=]&lt;[=address spaces/workgroup=]&gt;<sup>6,8</sup>
    <td>Mutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=plain type=] with a [=fixed footprint=]<sup>9</sup>
    <td>Disallowed<sup>10</sup>
    <td>
    <td>No

<tr><td>[=variable|var=]&lt;[=address spaces/private=]&gt;
    <td>Mutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=constructible=]
    <td>Optional<sup>10</sup>
    <td>[=const-expression=] or [=override-expression=]
    <td>No

<tr><td>[=variable|var=]&lt;[=address spaces/function=]&gt;<br>
        [=variable|var=]
    <td>Mutable
    <td>[=function scope|Function=]
    <td>[=type/concrete|Concrete=] [=constructible=]
    <td>Optional<sup>10</sup>
    <td>[=const-expression=], [=override-expression=], or [=runtime expression=]
    <td>No

</table>
1. 只有 [=const-declarations=] 可以是 [=type/abstract=] 类型，而且只有在类型没有明确指定的情况下。
1. 表达式的类型必须能够 [=可行自动转换|可行转换=] 为 [=effective-value-type=]。
1. 如果没有指定初始化器，则必须在 [=pipeline creation|pipeline-creation time=] 提供一个值。
1. [=Override-declarations=] 是着色器接口的一部分，但不是绑定的资源。
1. 具有与 [=access/read=] 不同的访问模式的 [=storage buffers=] 和 [=type/storage textures=] 不能在 [=vertex shader stage=] 中被 [=静态访问=]。
1. 参见 WebGPU {{GPUDevice/createBindGroupLayout()}}。
1. [=Atomic types=] 只能出现在可变的存储缓冲区或工作组变量中。
1. 具有 [=access/write=] 或 [=access/read_write=] [=access mode=] 的 [[#texture-storage|storage textures]] 中的数据是可变的，但只能通过 [[#texturestore|textureStore]] 内置函数来修改。
1. 变量本身不能被修改。
1. [=address spaces/workgroup=] 地址空间中的变量只能在 [=compute shader stage=] 中被 [=静态访问=]。
1. 最外层的 [=array=] 的 [=element count=] 可以是一个 [=override-expression=]。
1. 如果没有初始化器，则变量被 [=default initial value|default initialized=]。

## 变量与值 ## {#var-vs-value}

【变量声明】是WGSL模块中唯一可变的数据。【值声明】始终是不可变的。
变量可以作为【引用类型】和【指针类型】值的基础，因为变量有关联的【内存位置】，而值声明不能作为指针或引用值的基础。


使用变量通常比使用值声明更昂贵，因为使用变量需要额外的操作来读取或写入与变量关联的【内存位置】。


一般来说，作者应该优先使用以下声明方式，按照首选选项列出：
* 【const声明】
* 【override声明】
* 【let声明】
* 【变量声明】

这通常会导致着色器的整体性能最佳。

## 值声明 ## {#value-decls}

当[=标识符=]解析为[=值声明=]时，该标识符表示该值。


WGSL提供多种类型的值声明。
每种声明的值在[[#shader-lifecycle|着色器生命周期]]的不同点固定。
不同种类的值声明以及其值的固定时间是：
* [=常量声明=]，在[=着色器模块创建|创建着色器时=]
* [=覆盖声明=]，在[=管线创建|创建管线时=]
* [=局部声明=]，当它们被执行时
* [=形式参数=]声明，在关联的[=函数调用=]参数被执行时

注意：[=形式参数=]的描述在[[#functions]]中。

### `const` 声明 ### {#const-decls}

常量声明指定一个在着色器模块创建时固定的数据值的名称。每个常量声明都需要一个初始化器。常量声明可以在模块范围或函数范围内声明。初始化表达式必须是一个常量表达式。常量声明的类型必须是一个具体类型或可构造的抽象类型。常量声明是唯一一个有效值类型可以是抽象类型的声明。

注意：由于WGSL中无法明确表示抽象数值类型，因此只能通过类型推导来使用它们。

<div class='example wgsl global-scope' heading='const-declarations at module scope'>
  <xmp>
    const a = 4;                  // AbstractInt with a value of 4.
    const b : i32 = 4;            // i32 with a value of 4.
    const c : u32 = 4;            // u32 with a value of 4.
    const d : f32 = 4;            // f32 with a value of 4.
    const e = vec3(a, a, a);      // vec3 of AbstractInt with a value of (4, 4, 4).
    const f = 2.0;                // AbstractFloat with a value of 2.
    const g = mat2x2(a, f, a, f); // mat2x2 of AbstractFloat with a value of:
                                  // ((4.0, 2.0), (4.0, 2.0)).
                                  // The AbstractInt a converts to AbstractFloat.
                                  // An AbstractFloat cannot convert to AbstractInt.
    const h = array(a, f, a, f);  // array of AbstractFloat with 4 components:
                                  // (4.0, 2.0, 4.0, 2.0).
  </xmp>
</div>

### `override` 声明 ### {#override-decls}

一个覆盖声明指定了一个流水线可覆盖常量值的名称。流水线可覆盖常量的值在流水线创建时确定。这个值是由WebGPU流水线创建方法提供的，如果指定了的话；否则，它是其初始化表达式的具体化值。覆盖声明的有效值类型必须是一个具体化的标量类型。


初始化表达式是可选的。如果存在，它必须是一个覆盖表达式，并表示流水线可覆盖常量的默认值。如果没有指定初始化器，在流水线创建时如果没有提供一个值，将产生一个流水线创建错误。


如果声明应用了属性ID，字面操作数被称为流水线常量ID，并且必须是一个介于0和65535之间的唯一整数。也就是说，两个覆盖声明不能使用相同的流水线常量ID。


应用程序可以在流水线创建时为覆盖声明指定自己的值。流水线创建API接受一个从可覆盖常量到常量类型值的映射。常量由一个流水线可覆盖常量标识字符串来标识，如果指定了的话，它是流水线常量ID的十进制表示，否则是常量的声明名称。

<div class='example wgsl global-scope' heading='Module constants, pipeline-overrideable'>
  <xmp>
    @id(0)    override has_point_light: bool = true;  // Algorithmic control
    @id(1200) override specular_param: f32 = 2.3;     // Numeric control
    @id(1300) override gain: f32;                     // Must be overridden
              override width: f32 = 0.0;              // Specified at the API level using
                                                      // the name "width".
              override depth: f32;                    // Specified at the API level using
                                                      // the name "depth".
                                                      // Must be overridden.
              override height = 2 * depth;            // The default value
                                                      // (if not set at the API level),
                                                      // depends on another
                                                      // overridable constant.

  </xmp>
</div>


### `let` 声明 ### {#let-decls}

一个<dfn noexport> let-declaration </dfn>指定了一个值的名称，每次在运行时执行语句时都是固定的。
let声明只能在[=函数作用域=]中声明，因此是一个[=动态环境=]。
let声明必须具有初始化表达式。
该值是初始化器的[=value.concretized=]值的[=具体化=]。
let声明的[=有效值类型=]必须是一个[=type/concrete=]可[=构造=]类型或一个[=指针类型=]。

<div class='example wgsl let-declaration at function-scope' heading='let-declared constants at function scope'>
  <xmp>
    // 'blockSize' denotes the i32 value 1024.
    let blockSize: i32 = 1024;

    // 'row_size' denotes the u32 value 16u.  The type is inferred.
    let row_size = 16u;
  </xmp>
</div>

## `var` 声明 ## {#var-decls}

一个<dfn>变量</dfn>是指向内存的命名引用，可以包含特定的[=可存储=]类型的值。


一个变量与两种类型相关联：它的[=存储类型=]（可以放置在引用内存中的值的类型）和它的[=引用类型=]（变量本身的类型）。
如果一个变量的存储类型为T，[=地址空间=]为AS，[=访问模式=]为AM，那么它的引用类型为ref<AS,T,AM>。
一个变量的存储类型总是[=具体类型=]。


一个变量声明：
* 指定变量的[=名称=]。
* 确定变量的[=地址空间=]、[=存储类型=]和[=访问模式=]。 这些共同组成了变量的[=引用类型=]。
    * 存储类型是变量声明的[=有效值类型=]。
* 确保执行环境为存储类型的值在指定的地址空间中分配内存，并支持给定的访问模式，为变量的[=生命周期=]分配内存。
* 可选地具有初始化表达式，如果变量在[=地址空间/私有=]或[=地址空间/函数=]的地址空间中。 如果存在初始化表达式，则该初始化表达式必须求值为变量的存储类型。 如果存在，[=地址空间/私有=]变量的初始化表达式必须是[=const-expression=]或[=override-expression=]。 除[=地址空间/函数=]或[=地址空间/私有=]之外的地址空间中的变量[=着色器创建错误|=不能=]具有初始化器。

当一个[=标识符=]解析为一个变量声明时，该标识符是一个表示变量内存的引用的表达式，其类型是变量的[=引用类型=]。请参见[[#var-identifier-expr]]。

如果程序源代码中指定了变量声明的[=地址空间=]或[=访问模式=]，则它们在var关键字之后作为一个[=模板列表=]写入：
* 首先指定[=地址空间=]，作为预定义的地址空间[=枚举值=]之一。
* 其次指定[=访问模式=]，如果存在的话，作为预定义的地址模式[=枚举值=]之一。
    * 如果指定了访问模式，则必须指定地址空间。

[=地址空间/私有=]、[=地址空间/存储=]、[=地址空间/统一=]、[=地址空间/工作组=]和[=地址空间/句柄=]中的变量只能在[=模块作用域=]中声明，而[=地址空间/函数=]中的变量只能在[=函数作用域=]中声明。
除句柄和函数之外的所有地址空间都必须指定地址空间[=着色器创建错误|必须=]。
句柄地址空间[=着色器创建错误|不能=]被指定。
指定函数地址空间是可选的。


[=访问模式=]始终有一个默认值，除了[=地址空间/存储=]地址空间中的变量之外，[=着色器创建错误|不能=]在WGSL源代码中指定。
请参见[[#address-space]]。


[=地址空间/统一=]地址空间中的变量是一个<dfn noexport>统一缓冲区</dfn>变量。
它的[=存储类型=]必须是一个[=可主机共享=]的[=可构造=]类型，并且必须满足[[#address-space-layout-constraints|地址空间布局约束]]。


[=地址空间/存储=]地址空间中的变量是一个<dfn noexport>存储缓冲区</dfn>变量。
它的[=存储类型=]必须是一个[=可主机共享=]类型，并且必须满足[[#address-space-layout-constraints|地址空间布局约束]]。
该变量可以以[=访问/读=]或[=访问/读写=]访问模式声明；默认值是读。


一个<dfn>纹理资源</dfn>是一个[=有效值类型=]为[=纹理类型=]的变量。
它在[=模块作用域=]中声明。
它保存一个用于访问[=纹理=]中的基础纹素格子的不透明句柄。
句柄本身位于[=地址空间/句柄=]地址空间，并且始终是只读的。
在许多情况下，基础纹素是只读的，我们称纹理变量为不可变的。
对于[=类型/只写存储纹理=]和[=类型/读写存储纹理=]，基础纹素是可变的，按照惯例，我们称纹理变量为可变的。


一个<dfn>采样器资源</dfn>是一个[=有效值类型=]为[=采样器类型=]的变量。
它在[=模块作用域=]中声明，在[=地址空间/句柄=]地址空间中存在，并且是不可变的。


如[[#resource-interface]]所述，统一缓冲区、存储缓冲区、纹理和采样器形成了[=着色器的资源接口=]。

变量的"生命周期"是指在着色器执行期间与变量相关的内存位置的时间段。
模块作用域变量的生命周期是整个着色器阶段的执行过程。
每个调用都有一个独立版本的地址空间/私有和地址空间/函数变量。
函数作用域变量是一个动态上下文。
函数作用域变量的生命周期由其作用域确定：
* 当控制流进入变量定义时，它开始。
* 当名称不再处于任何部分的动态上下文的作用域内时，它结束。 也就是说，生命周期包括名称在作用域内时调用的任何函数。

两个资源变量可能具有重叠的内存位置，但如果其中任何一个变量是可变的，那么这将是一个动态错误。
具有重叠生命周期的其他变量不会有重叠的内存位置。
当变量的生命周期结束时，其内存可以用于另一个变量。


注意：WGSL确保变量的内容仅在变量的生命周期内可观察。


在地址空间/私有、地址空间/函数或地址空间/工作组中创建变量时，它将具有初始值。
如果没有指定初始化器，则初始值为默认初始值。
初始值的计算如下：
* 对于函数地址空间中的变量：
    * 如果变量声明没有指定初始化程序，则为存储类型的零值。
    * 否则，它是在程序执行的那个时间点计算出的值的具体化结果的初始化程序表达式的结果。
* 对于私有地址空间中的变量：
    * 如果变量声明没有指定初始化程序，则为存储类型的零值。
    * 否则，它是计算出的值的具体化结果的初始化程序表达式的结果。 初始化程序必须是一个“覆盖表达式”，所以它的值在“管道创建时间”之前是固定的。
* 对于工作组地址空间中的变量：
    * 当存储类型是可构造的时，使用存储类型的零值。
    * 如果存储类型是原子类型，则零值为底层类型的零值（具体的整数标量类型）。
    * 否则，如果存储类型不可构造，则零值通过递归地将这些规则应用于组合体的每个组件，直到遇到可构造类型来确定。
        * 注意：当使用具有“管道可覆盖”元素计数的数组或包含原子类型的组合体时，通常会发生这种情况。

其他地址空间中的变量是通过“绘制命令”或“调度命令”中的绑定设置的资源。

考虑以下的WGSL片段：
<div class='example wgsl function-scope' heading='Variable initial values'>
  <xmp>
    var i: i32;         // Initial value is 0.  Not recommended style.
    loop {
      var twice: i32 = 2 * i;   // Re-evaluated each iteration.
      i++;
      if i == 5 { break; }
    }
  </xmp>
</div>
循环体将执行六次。
变量 i 将取值0、1、2、3、4、5，而变量 twice 将取值0、2、4、6、8。

请考虑以下 WGSL 代码片段：
<div class='example wgsl function-scope' heading='Reading a variable multiple times'>
  <xmp>
    var x: f32 = 1.0;
    let y = x * x + x + 1;
  </xmp>
</div>
因为x是一个变量，所有对它的访问都变成了载入（load）和存储（store）操作。
然而，预期浏览器或驱动程序会优化这个中间表示，使冗余的载入操作被消除掉。

<div class='example wgsl global-scope' heading="Module scope variable declarations">
  <xmp>
    var<private> decibels: f32;
    var<workgroup> worklist: array<i32,10>;

    struct Params {
      specular: f32,
      count: i32
    }

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    @group(0) @binding(2)
    var<uniform> param: Params;    // A uniform buffer

    // A storage buffer, for reading and writing
    @group(0) @binding(0)
    var<storage,read_write> pbuf: array<vec2<f32>>;

    // Textures and samplers are always in "handle" space.
    @group(0) @binding(1)
    var filter_params: sampler;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Access modes for buffers'>
  <xmp>
    // Storage buffers
    @group(0) @binding(0)
    var<storage,read> buf1: Buffer;       // Can read, cannot write.
    @group(0) @binding(0)
    var<storage> buf2: Buffer;            // Can read, cannot write.
    @group(0) @binding(1)
    var<storage,read_write> buf3: Buffer; // Can both read and write.

    struct ParamsTable {weight: f32}

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    @group(0) @binding(2)
    var<uniform> params: ParamsTable;     // Can read, cannot write.
  </xmp>
</div>

<div class='example wgsl global-scope' heading="Function scope variables and constants">
  <xmp>
    fn f() {
       var<function> count: u32;  // A variable in function address space.
       var delta: i32;            // Another variable in the function address space.
       var sum: f32 = 0.0;        // A function address space variable with initializer.
       var pi = 3.14159;          // Infer the f32 store type from the initializer.
    }
  </xmp>
</div>

## 变量和值声明语法总结 ## {#var-and-value-decl-grammar}

<pre class=include>
path: syntax/variable_or_value_statement.syntax.bs.include
</pre>
<pre class=include>
path: syntax/variable_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/optionally_typed_ident.syntax.bs.include
</pre>
<pre class=include>
path: syntax/global_variable_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/global_value_decl.syntax.bs.include
</pre>

# 表达式 # {#expressions}

[=Expressions=]指定了值如何进行计算。


不同类型的值表达式在它们的计算时机和表达能力之间进行权衡。
计算越早，操作限制越大，但值能够在更多的地方使用。这种权衡导致了每种值声明类型的不同灵活性。
在执行GPU上的操作之前，会先评估[=const-expressions=]和[=override-expressions=]，因此在最终的GPU代码中只需要计算表达式的结果即可。
此外，由于[=const-expressions=]在[=shader module creation|shader-creation time=]时进行评估，因此它们可以在更多的情况下使用，例如在[=function scope=]中调整[=arrays=]的大小或进行[=variable declaration|variables=]。
<dfn noexport>运行时表达式</dfn>是指既不是[=const-expression=]也不是[=override-expression=]的表达式。
运行时表达式在Shader执行期间在GPU上进行计算。
尽管运行时表达式只能被更少的语法元素使用，但它们可以由更大类的表达式计算得出，例如其他运行时值。

## 早期评估表达式 ## {#early-eval-exprs}

WGSL定义了两种在运行时之前可以评估的表达式类型：

* [=const-expressions=]，在 [=着色器模块创建|着色器创建时间=]时评估
* [=override-expressions=]，在 [=管线创建|管线创建时间=]时评估

### `const` 表达式 ### {#const-expr}

在[=shader module creation|shader-creation time=]可以评估的表达式被称为<dfn noexport>常量表达式</dfn>。
如果一个表达式的所有[=identifiers=]都解析为以下类型之一，那么它就是一个常量表达式：
* [=const-declarations=]，或
* [=const-functions=]，或
* [=type aliases=]，或
* [=structure=]名称。

const表达式的类型必须符合[=creation-fixed footprint=]的类型规则。


注意：[=type/abstract|抽象类型=]可以是常量表达式的推断类型。


如果且仅当满足以下条件之一，常量表达式 |E| 将被评估：
* |E| 是一个[=top-level expression=]，或
* |E| 是表达式 |OuterE| 的一个[=subexpression=]，并且 |OuterE| 的评估将被执行，并且 |OuterE| 的评估需要 |E| 被评估。

注意：评估规则意味着短路运算符 && 和 || 会防止对它们右侧的子表达式进行评估。

一个const表达式可以由实现WebGPU API方法的CPU进行评估。
因此，在操作[=AbstractFloat=]值时，准确性要求不再严格，只要满足常见的WebGPU运行环境的要求，比如WebAssembly[[WASM-CORE-2]]和ECMAScript[[ECMASCRIPT]]。
具体浮点类型（例如f32）的准确性要求在[[#concrete-float-accuracy]]中指定。

例如：(42)的分析如下：
* 术语42是[=AbstractInt=]值42。
* 把该术语用括号括起来生成一个新的表达式（42），它的类型是[=AbstractInt=]，值为42。

例如：-5的分析如下：
* 术语5是[=AbstractInt=]值5。
* 在该术语之前加上'-'生成一个新的表达式-5，它的类型是[=AbstractInt=]，值为-5。

示例：-2147483648的分析如下：
* 术语2147483648是一个[=AbstractInt=]值2147483648。 请注意，此值不适合32位有符号整数。
* 在该术语前面加上’-'会产生一个新的表达式-2147483648，其类型为[=AbstractInt=]，值为-2147483648。

示例：const minint = -2147483648;的分析如下：
* 如上所述，-2147483648求得一个[=AbstractInt=]值-2147483648。
* [=const-declaration=]允许初始化器是一个[=abstract numeric type=]。
* 结果是minint被声明为一个[=AbstractInt=]值-2147483648。

示例：let minint = -2147483648;的分析如下：
* 如上所述，-2147483648求得一个[=AbstractInt=]值-2147483648。
* [=let-declaration=]要求初始化器是一个[=type/concrete=] [=constructible=]类型或者是一个指针类型。
* let-declaration没有显式类型，因此使用[=overload resolution=]。 适用的重载候选项使用[=AbstractInt=]到[=i32=]，[=u32=]或[=f32=]的[=feasible automatic conversions=]。 最低等级的一个是到[=i32=]的，因此 [AbstractInt=] -2147483648值被转换为[=i32=]值-2147483648。
* 结果是minint被声明为i32值-2147483648。

示例：false && (10i < i32(5 * 1000 * 1000 * 1000)) 的分析如下:

* 整个表达式是一个常量表达式。
* 然而，逻辑运算符 && 的短路规则适用： 左侧评估为 false，因此右侧的表达式不会被评估。
* 评估 i32(5 * 1000 * 1000 * 1000) 会导致一个[=shader-creation error=]， 因为[=AbstractInt=] 的值 5000000000 溢出了 [=i32=] 类型。


### `override` 表达式 ### {#override-expr}

在[=流水线创建=]时间可评估的表达式被称为<dfn noexport>覆盖表达式</dfn>。
如果一个表达式的所有[=标识符=]都能[=解析=]到以下内容，则该表达式为覆盖表达式：
* [=覆盖声明=]，或
* [=常量声明=]，或
* [=常量函数=]，或
* [=类型别名=]，或
* [=结构名称=]。

注：所有[=常量表达式=]也是覆盖表达式。

当且仅当满足以下条件时，覆盖表达式|E|将会被评估：
* |E|是[=顶层表达式=]，或
* |E|是表达式|OuterE|的[=子表达式=]，且表达式|OuterE|将会被评估， 且|OuterE|的评估需要对|E|进行评估。

注意：并非所有的覆盖表达式都可以用作[=override-declaration=]的初始化器，因为这样的初始化器必须[=type rules|resolve=]为一个[=type/concrete=]的[=scalar=]类型。


例如：override x = 42;的分析如下：
* 术语42是一个[=AbstractInt=]值42。
* 一个[=override-declaration=]需要一个[=type/concrete=]的[=scalar=]类型。
* 通过[=feasible automatic conversion=]将42转换为[=i32=]。

例如：let y = x + 1;的分析如下：
* 从上面可知，x的类型是[=i32=]。
* 表达式x + 1是一个覆盖表达式，因为它由一个[=override-declaration=]和一个[=integer literal=]组成。
* 表达式的类型是[=i32=]，并在[=pipeline creation=]时进行评估。 它的值取决于x是否在管道创建时被覆盖。

示例：'vec3(x,x,x)'的分析如下：
* 从上面来看，'x’是一个类型为’i32’的重写声明。
* 'vec3(x,x,x)'是一个重写表达式，因为只有标识符可以解析为重写声明。
* 表达式的类型是’i32’类型的三个分量的向量（‘vec3<i32>’）。

## 不确定的值 ## {#indeterminate-values}

在有限的情况下，可以使用不支持的值对运行时表达式进行评估。


在这种情况下，评估的结果是表达式的静态类型的一个不确定值，这意味着某个静态类型的任意实现选定的值。


对于表达式的每个唯一的动态上下文，可以生成一个不同的值。例如，如果评估在循环的每次迭代中发生，可能为每个循环迭代计算一个不同的值。


注意：如果类型是浮点类型并且实现支持NaN值，则运行时产生的不确定值可能是NaN值。

<div class='example wgsl global-scope' heading="Indeterminate value example">
  <xmp>
    fn fun() {
       var extracted_values: array<i32,2>;
       const v = vec2<i32>(0,1);

       for (var i: i32 = 0; i < 2 ; i++) {
          // A runtime-expression used to index a vector, but outside the
          // indexing bounds of the vector, produces an indeterminate value
          // of the vector component type.
          let extract = v[i+5];

          // Now 'extract' is any value of type i32.

          // Save it for later.
          extracted_values[i] = extract;

          if extract == extract {
             // This is always executed
          }
          if extract < 2 {
             // This might be executed, but might not be executed.
             // Even though the original vector components are 0 and 1,
             // the extracted value might not be either of those values.
          }
       }
       if extracted_values[0] == extracted_values[1] {
          // This might be executed, but might not be executed.
       }
    }

    fn float_fun(runtime_index: u32) {
       const v = vec2<f32>(0,1); // A vector of floating point values

       // As in the previous example, 'float_extract' is an indeterminate value.
       // Since it is a floating point type, it may be a NaN.
       let float_extract: f32 = v[runtime_index+5];

       if float_extract == float_extract {
          // This *might not* be executed, because:
          //  -  'float_extract' may be NaN, and
          //  -  a NaN is never equal to any other floating point number,
          //     even another NaN.
       }
    }
  </xmp>
</div>


## 字面量表达式 ## {#literal-expressions}

<table class='data'>
  <caption>Scalar literal type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr><td>
      <td>`true`: bool
      <td>`true` boolean value.
  <tr><td>
      <td>`false`: bool
      <td>`false` boolean value.
  <tr><td>|e| is an [=integer literal=] with no suffix
      <td>|e|: AbstractInt
      <td>Abstract integer literal value.
  <tr><td>|e| is a [=floating point literal=] with no suffix
      <td>|e|: AbstractFloat
      <td>Abstract float literal value.
  <tr><td>|e| is an [=integer literal=] with `i` suffix
      <td>|e|: i32
      <td>32-bit signed integer literal value.
  <tr><td>|e| is an [=integer literal=] with `u` suffix
      <td>|e|: u32
      <td>32-bit unsigned integer literal value.
  <tr><td>|e| is an [=floating point literal=] with `f` suffix
      <td>|e|: f32
      <td>32-bit floating point literal value.
  <tr><td>|e| is an [=floating point literal=] with `h` suffix
      <td>|e|: f16
      <td>16-bit floating point literal value.
</table>

## 括号表达式 ## {#parenthesized-expressions}

<table class='data'>
  <caption>Parenthesized expression type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="parenthesized expression">
      <td>|e| : |T|
      <td>`(` |e| `)` : |T|
      <td>Evaluates to |e|.<br>
          Use parentheses to isolate an expression from the surrounding text.
</table>

## 复合值分解表达式 ## {#composite-value-decomposition-expr}
本节描述了获取复合值的一个组成部分的表达式，以及从包含复合值的引用中获取到该组成部分的引用类型的表达式。对于这个讨论，复合值或者对复合值的引用被称为“基础(base)”。

有两种方法可以做到这一点：
: 命名组成部分表达式：基础(B)的表达式后跟一个句点"."（U+002E），然后是组成部分的名称。
:: 当B是矢量(vector)或结构(structure)类型，或者是对矢量或结构类型的引用时，支持这种表达式。
    * 有效的名称取决于B的类型。
: 索引表达式：
:: 基础的表达式后跟一个左括号"[“（U+005B），然后是索引表达式，最后是右括号”]"（U+005D）。
    * 基础可以是矢量、矩阵(matrix)、固定大小数组(fixed-size array)类型，或者是对矢量、矩阵、固定大小数组或运行时大小数组(runtime-sized array)类型的引用。
    * 索引表达式必须是整数标量(integer scalar)类型。

从语法上讲，这两种形式体现了使用"syntax/component_or_swizzle_specifier"语法规则。

<div algorithm="out of bounds index">
一个[=索引表达式=]的索引值|i|是一个<dfn noexport>在边界内的索引</dfn>，如果0 ≤ |i| < |N|，其中|N|是复合类型的组件（元素）的数量：
* 当基类型是向量或者是一个向量的引用时，|N|是向量类型的组件数。
* 当基类型是矩阵或者是一个矩阵的引用时，|N|是矩阵类型的列数。
* 当基类型是固定大小的数组或者是一个固定大小数组的引用时，|N|是固定大小数组的元素数量。
* 当基类型是一个运行时大小的数组的引用时，|N|是基类型的运行时大小。

当索引值不是一个[=在边界内的索引=]时，它是一个<dfn noexport>超出边界的索引</dfn>。
超出边界的索引通常是一个程序缺陷，并且往往会引发错误。
详见下文。
</div>

此外，向量类型还支持使用[=swizzle|swizzling=]语法，从另一个向量的分量创建一个新的向量值。

### 矢量访问表达式 ### {#vector-access-expr}

访问向量的组件可以通过以下两种方式进行：

* 使用数组下标（例如v[2]），
* 使用一组方便的名称（称为<dfn noexport>swizzle</dfn>名称），其表示为一系列映射到源向量组件的方便名称。
    * 方便名称的颜色集：r、g、b、a分别对应向量分量0、1、2和3。
    * 方便名称的尺寸集：x、y、z、w分别对应向量分量0、1、2和3。

可以使用.符号来访问方便名称（例如color.bgra）。
方便名称不应混用。例如，不能使用.rybw。
方便名称不能访问超出向量结尾的组件。
可以以任何顺序应用方便名称，包括根据需要重复使用字母。
提供的字母数必须介于1和4之间。
也就是说，使用方便名称只能生成有效的向量类型。
结果类型取决于提供的字母数。假设一个vec4<f32>

<table>
  <thead>
    <tr><th>Accessor<th>Result type
  </thead>
  <tr><td>r<td>`f32`
  <tr><td>rg<td>`vec2<f32>`
  <tr><td>rgb<td>`vec3<f32>`
  <tr><td>rgba<td>`vec4<f32>`
</table>

<div class='example wgsl function-scope'>
  <xmp>
    var a: vec3<f32> = vec3<f32>(1., 2., 3.);
    var b: f32 = a.y;          // b = 2.0
    var c: vec2<f32> = a.bb;   // c = (3.0, 3.0)
    var d: vec3<f32> = a.zyx;  // d = (3.0, 2.0, 1.0)
    var e: f32 = a[1];         // e = 2.0
  </xmp>
</div>

#### 向量单组件选择 #### {#vector-single-component}

<table class=‘data’>
<caption>矢量分解：单个分量选取</caption>
<thead>
<tr><th>前提<th>结论<th>描述
</thead>
<tr algorithm=“第一个矢量分量选取”><td>|e|: vec|N|<|T|><br>
<td class=“nowrap”>
|e|.x: |T|<br>
|e|.r: |T|
<td>选取矢量|e|的第一个分量
<tr algorithm=“第二个矢量分量选取”><td>|e|: vec|N|<|T|><br>
<td class=“nowrap”>
|e|.y: |T|<br>
|e|.g: |T|
<td>选取矢量|e|的第二个分量
<tr algorithm=“第三个矢量分量选取”><td>|e|: vec|N|<|T|><br>
|N| 为 3 或 4
<td class=“nowrap”>
|e|.z: |T|<br>
|e|.b: |T|
<td>选取矢量|e|的第三个分量
<tr algorithm=“第四个矢量分量选取”><td>|e|: vec4<|T|>
<td class=“nowrap”>
|e|.w: |T|<br>
|e|.a: |T|
<td>选取矢量|e|的第四个分量


<tr algorithm=“具体矢量索引分量选取”>
<td>|e|: vec|N|<|T|><br>
|i|: [INT]<br>
|T| 为 [=type/concrete=]
<td class=“nowrap”>
|e|[|i|]: |T|
<td>选取矢量的第|i|个分量<br>
第一个分量的索引为|i|=0。


       如果|i|超出范围[0,|N|-1]：<br>
       * 如果|i|是一个常量表达式，则为一个[=shader-creation error=]。
       * 如果|i|是一个覆盖表达式，则为一个[=pipeline-creation error=]。
       * 否则可能返回一个[=indeterminate value=]。

<tr algorithm=“抽象矢量索引分量选取”>
<td>|e|: vec|N|<|T|><br>
|i|: [INT]<br>
|T| 为 [=type/abstract=]<br>
|i| 为一个 [=const-expression=]
<td class=“nowrap”>
|e|[|i|]: |T|
<td>选取矢量的第|i|个分量<br>
第一个分量的索引为|i|=0。


       如果|i|超出范围[0,|N|-1]，则为一个[=shader-creation error=]。

       注意：当一个抽象矢量值|e|被一个非[=const-expression=]表达式索引时，
       在应用索引之前，矢量将先进行[=concretization of a value|concretized=]。

</table>

#### 矢量多组件选择 #### {#vector-multi-component}

<table class=‘data’>
<caption>矢量分解：多组件选择
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“使用.x .y进行双组分矢量选择”>
<td class=“nowrap”>
|e|：vec|N|<|T|><br>
|I|为字母x，y，z或w<br>
|J|为字母x，y，z或w<br>
<td class=“nowrap”>
|e|.|I||J|：vec2<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|的双组分矢量。<br>
当|N|为3或4时，字母“z”才有效。<br>
当|N|为4时，字母“w”才有效。
<tr algorithm=“使用.r .g进行双组分矢量选择”>
<td class=“nowrap”>
|e|：vec|N|<|T|><br>
|I|为字母r，g，b或a<br>
|J|为字母r，g，b或a<br>
<td class=“nowrap”>
|e|.|I||J|：vec2<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|的双组分矢量。<br>
当|N|为3或4时，字母“b”才有效。<br>
当|N|为4时，字母“a”才有效。
<tr algorithm=“使用.x .y进行三组分矢量选择”>
<td class=“nowrap”>
|e|：vec|N|<|T|><br>
|I|为字母x，y，z或w<br>
|J|为字母x，y，z或w<br>
|K|为字母x，y，z或w<br>
<td class=“nowrap”>
|e|.|I||J||K|：vec3<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|，第三个分量为|e|.|K|的三组分矢量。<br>
当|N|为3或4时，字母“z”才有效。<br>
当|N|为4时，字母“w”才有效。
<tr algorithm=“使用.r .g进行三组分矢量选择”>
<td class=“nowrap”>
|e|：vec|N|<|T|><br>
|I|为字母r，g，b或a<br>
|J|为字母r，g，b或a<br>
|K|为字母r，g，b或a<br>
<td class=“nowrap”>
|e|.|I||J||K|：vec3<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|，第三个分量为|e|.|K|的三组分矢量。<br>
当|N|为3或4时，字母“b”才有效。<br>
当|N|为4时，字母“a”才有效。
<tr algorithm=“使用.x .y进行四组分矢量选择”>
<td class=“nowrap”>
|e|：vec|N|<|T|><br>
|I|为字母x，y，z或w<br>
|J|为字母x，y，z或w<br>
|K|为字母x，y，z或w<br>
|L|为字母x，y，z或w<br>
<td class=“nowrap”>
|e|.|I||J||K||L|：vec4<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|，第三个分量为|e|.|K|，第四个分量为|e|.|L|的四组分矢量。<br>
当|N|为3或4时，字母“z”才有效。<br>
当|N|为4时，字母“w”才有效。
<tr algorithm=“使用.r .g进行四组分矢量选择”>
<td class=“nowrap”>
|e|：vec|N|<|T|><br>
|I|为字母r，g，b或a<br>
|J|为字母r，g，b或a<br>
|K|为字母r，g，b或a<br>
|L|为字母r，g，b或a<br>
<td class=“nowrap”>
|e|.|I||J||K||L|：vec4<|T|><br>
<td>计算具有第一个分量为|e|.|I|，第二个分量为|e|.|J|，第三个分量为|e|.|K|，第四个分量为|e|.|L|的四组分矢量。<br>
当|N|为3或4时，字母“b”才有效。<br>
当|N|为4时，字母“a”才有效。
</table>

#### 从向量引用中的组件参考 #### {#component-reference-from-vector-reference}

对于向量的组件的写访问可能会访问与该向量关联的所有内存位置。


注意：这意味着如果至少有一个访问是写访问，那么不同调用对向量的不同组件的访问必须进行同步。请参阅［内建同步函数］。

<table class=‘data’>
<caption>从向量引用获取组件引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“first vector component reference selection”>
<td>|r|: ref<|AS|,vec|N|<|T|>,|AM|><br>
<td class=“nowrap”>
|r|.x: ref<|AS|,|T|,|AM|><br>
|r|.r: ref<|AS|,|T|,|AM|><br>
<td>计算对由引用|r|引用的向量的第一个分量的引用。<br>
结果引用的[=来源变量=]与|r|的来源变量相同。
<tr algorithm=“second vector component reference selection”>
<td>|r|: ref<|AS|,vec|N|<|T|>,|AM|><br>
<td class=“nowrap”>
|r|.y: ref<|AS|,|T|,|AM|><br>
|r|.g: ref<|AS|,|T|,|AM|><br>
<td>计算对由引用|r|引用的向量的第二个分量的引用。<br>
结果引用的[=来源变量=]与|r|的来源变量相同。
<tr algorithm=“third vector component reference selection”>
<td>|r|: ref<|AS|,vec|N|<|T|>,|AM|><br>
|N|为3或4
<td class=“nowrap”>
|r|.z: ref<|AS|,|T|,|AM|><br>
|r|.b: ref<|AS|,|T|,|AM|><br>
<td>计算对由引用|r|引用的向量的第三个分量的引用。<br>
结果引用的[=来源变量=]与|r|的来源变量相同。
<tr algorithm=“fourth vector component reference selection”>
<td>|r|: ref<|AS|,vec4<|T|>,|AM|><br>
<td class=“nowrap”>
|r|.w: ref<|AS|,|T|,|AM|><br>
|r|.a: ref<|AS|,|T|,|AM|><br>
<td>计算对由引用|r|引用的向量的第四个分量的引用。<br>
结果引用的[=来源变量=]与|r|的来源变量相同。
<tr algorithm=“vector indexed component reference selection”>
<td>|r|: ref<|AS|,vec|N|<|T|>,|AM|><br>
|i|: [INT]
<td class=“nowrap”>
|r|[|i|] : ref<|AS|,|T|,|AM|>
<td>计算对由引用|r|引用的向量的第|i|个分量的引用。


       如果|i|超出范围[0,|N|-1]：<br>
       * 如果|i|是[=const-expression=]，则为[=着色器创建错误=]。
       * 如果|i|是[=override-expression=]，则为[=管道创建错误=]。
       * 否则，表达式的求值结果为[=无效内存引用=]。

       结果引用的[=来源变量=]与|r|的来源变量相同。

</table>

### 矩阵访问表达式 ### {#matrix-access-expr}

<table class=‘data’>
<caption>列向量提取</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“matrix indexed column vector selection concrete”>
<td class=“nowrap”>
|e|: mat|C|x|R|<|T|><br>
|i|: [INT]<br>
|T| 是 [=具体类型=]
<td class=“nowrap”>
|e|[|i|]: vec|R|<|T|>
<td>结果是 |e| 的第 |i| 列向量。


       如果 |i| 在范围 [0,|C|-1] 之外：<br>
       * 如果 |i| 是一个 [=常数表达式=]，则是一个 [=着色器创建错误=]。
       * 如果 |i| 是一个 [=覆盖表达式=]，则是一个 [=管线创建错误=]。
       * 否则，可能返回一个 vec|R|&lt;|T|&gt; 的 [=不确定值=]。

<tr algorithm=“matrix indexed column vector selection abstract”>
<td class=“nowrap”>
|e|: mat|C|x|R|<|T|><br>
|i|: [INT]<br>
|T| 是 [=抽象类型=]<br>
|i| 是一个 [=常数表达式=]
<td class=“nowrap”>
|e|[|i|]: vec|R|<|T|>
<td>结果是 |e| 的第 |i| 列向量。


       如果 |i| 在范围 [0,|C|-1] 之外，它是一个 [=着色器创建错误=]。

       注意：当一个抽象矩阵值 |e| 被一个非 [=常数表达式=] 的表达式索引时，
       在应用索引之前，矩阵会被进行 [=值的具体化|具体化=]。

</table>

<table class='data'>
  <caption>从对矩阵的引用中获取对列向量的引用</caption>
  <thead>
    <tr><th>前提条件<th>结论<th>描述
  </thead>
  <tr algorithm="matrix indexed column vector reference selection">
       <td class="nowrap">
          |r|: ref&lt;|AS|,mat|C|x|R|&lt;|T|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,vec|R|&lt;|T|&gt;,|AM|&gt;
       <td>计算对引用|r|所引用的矩阵的第|i|列向量的引用。


            如果|i|不在范围[0,|C|-1]之内：
            * 如果|i|是一个常数表达式，则为[=shader-creation error=]。
            * 如果|i|是一个覆盖表达式，则为[=pipeline-creation error=]。
            * 否则，该表达式将求值为[=invalid memory reference=]。

            结果引用的来源变量与|r|的来源变量相同。
</table>

### 数组访问表达式 ### {#array-access-expr}
<table class=‘data’>
<caption>数组元素提取</caption>
<thead>
<tr><th>前提<th>结论<th>描述
</thead>
<tr algorithm=“fixed-size array indexed element selection concrete”>
<td class=“nowrap”>
|e|：array<|T|,|N|><br>
|i|：[INT]<br>
|T| 是 [=type/concrete=]
<td class=“nowrap”>
|e|[|i|]：|T|
<td>结果是数组值 |e| 的第 |i| 个元素的值。


       如果 |i| 超出范围 [0,|N|-1]：<br>
       * 如果 |i| 是一个 [=const-expression=]，那么它是一个 [=shader-creation error=]。
       * 如果 |i| 是一个 [=override-expression=]，那么它是一个 [=pipeline-creation error=]。
       * 否则，可能返回一个对于 |T| 的 [=indeterminate value=]。

<tr algorithm=“fixed-size array indexed element selection abstract”>
<td class=“nowrap”>
|e|：array<|T|,|N|><br>
|i|：[INT]<br>
|T| 是 [=type/abstract=]<br>
|i| 是一个 [=const-expression=]
<td class=“nowrap”>
|e|[|i|]：|T|
<td>结果是数组值 |e| 的第 |i| 个元素的值。


       如果 |i| 超出范围 [0,|N|-1]，那么它是一个 [=shader-creation error=]。

       注意：当一个抽象数组值 |e| 被一个不是 [=const-expression=] 的表达式索引时，索引应用之前数组会进行 [=concretization of a value|concretized=]。

</table>

<table class=‘data’>
<caption>获取引用数组元素的引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“fixed-size array indexed reference selection”>
<td class=“nowrap”>
|r|: ref<|AS|,array<|T|,|N|>,|AM|><br>
|i|: [INT]
<td class=“nowrap”>
|r|[|i|] : ref<|AS|,|T|,|AM|>
<td>计算引用的引用所引用的数组的第|i|个元素的引用。


       如果|i|在范围[0,|N|-1]之外：<br>
       * 如果|i|是一个[=const-expression=]，则为[=shader-creation error=]。
       * 如果|i|是一个[=override-expression=]，则为[=pipeline-creation error=]。
       * 否则，表达式将评估为[=invalid memory reference=]。

       结果引用的[=源变量=]与|r|的[=源变量=]相同。

<tr algorithm=“array indexed reference selection”>
<td>|r|: ref<|AS|,array<|T|>,|AM|><br>
|i|: [INT]
<td class=“nowrap”>
|r|[|i|] : ref<|AS|,|T|,|AM|>
<td>计算引用的引用所引用的运行时大小的数组的第|i|个元素的引用。


       如果在运行时数组有|N|个元素，并且|i|在范围[0,|N|-1]之外，则表达式将评估为[=invalid memory reference=]。

       如果|i|为有符号整数，并且|i|小于0：<br>
       * 如果|i|是一个[=const-expression=]，则为[=shader-creation error=]。
       * 如果|i|是一个[=override-expression=]，则为[=pipeline-creation error=]。

       结果引用的[=源变量=]与|r|的[=源变量=]相同。

</table>


### 结构访问表达式 ### {#struct-access-expr}

<table class=‘data’>
<caption>结构成员提取</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“结构成员提取”>
<td class=“nowrap”>
|S| 是结构类型<br>
|M| 是|S|的成员的标识符名称，具有类型|T|<br>
|e|: |S|<br>
<td class=“nowrap”>
|e|.|M|: |T|
<td>结果是从结构值|e|提取的具有名称|M|的成员的值。
</table>


<table class=‘data’>
<caption>从结构引用中获取对结构成员的引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“结构成员引用选择”>
<td class=“nowrap”>
|S| 是结构类型<br>
|M| 是|S|的成员的标识符名称，具有类型|T|<br>
|r|: ref<|AS|,|S|,|AM|><br>
<td class=“nowrap”>
|r|.|M|: ref<|AS|,|T|,|AM|>
<td>给定一个对结构的引用，结果是对具有标识符名称|M|的结构成员的引用。<br>
结果引用的[=起源变量=]与|r|的起源变量相同。
</table>

## 逻辑表达式 ## {#logical-expr}
<table class=‘data’>
<caption>一元逻辑运算</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“boolean negation”><td>|e|：T<br>|T| 是布尔型或者向量|N|<bool>
<td>!|e|：|T|
<td>逻辑非。
当 |e| 为 false 时结果为 true，当 |e| 为 true 时结果为 false。
当 |T| 为向量时进行[=逐分量运算=]。
</table>


<table class=‘data’>
<caption>二元逻辑表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“short-circuiting or”><td>|e1|：bool<br>|e2|：bool<td>|e1| || |e2|：bool  <td>短路逻辑"或"。当 |e1| 或 |e2| 任一为true时结果为true；   仅当 |e1| 为 false` 时才计算 |e2|。


<tr algorithm=“short-circuiting and”><td>|e1|：bool<br>|e2|：bool
<td>|e1| && |e2|：bool  <td>短路逻辑"与"。当 |e1| 和 |e2| 同时为true时结果为true；   仅当 |e1| 为 true` 时才计算 |e2|。


<tr algorithm=“logical or”><td>|e1|：|T|<br>|e2|：|T|<br>|T| 是布尔型或者向量|N|<bool>
<td>|e1| | |e2|：|T|
<td>逻辑"或"。当 |T| 是向量时进行[=逐分量运算=]。计算 |e1| 和 |e2|。


<tr algorithm=“logical and”><td>|e1|：|T|<br>|e2|：|T|<br>|T| 是布尔型或者向量|N|<bool>
<td>|e1| & |e2|：|T|
<td>逻辑"与"。当 |T| 是向量时进行[=逐分量运算=]。计算 |e1| 和 |e2|。
</table>


## 算术表达式 ## {#arithmetic-expr}

<table class=‘data’>
<caption>一元算术表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“negation”><td>|e|: |T|<br>
|T|是AbstractInt、AbstractFloat、i32、f32、f16、vec|N|<AbstractInt>、vec|N|<AbstractFloat>、vec|N|<i32>、vec|N|<f32>或vec|N|<f16>
<td>-|e|: |T|
<td>否定。当|T|为向量时，逐分量执行。
如果|T|是一个整数标量类型，并且|e|评估为最大的负值，则结果为|e|。
</table>


<table class=‘data’>
<caption>二元算术表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>


<tr algorithm=“addition”>
<td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
<td>|e1| + |e2| : |T|
<td>加法。当|T|为向量时，逐分量执行。
如果|T|是一个具体整数标量类型，结果为模2的32次方。


<tr algorithm=“subtraction”>
<td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
<td>|e1| - |e2| : |T|
<td>减法。当|T|为向量时，逐分量执行。
如果|T|是一个具体整数标量类型，结果为模2的32次方。


<tr algorithm=“multiplication”>
<td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
<td>|e1| * |e2| : |T|
<td>乘法。当|T|为向量时，逐分量执行。
如果|T|是一个具体整数标量类型，结果为模2的32次方。


<tr algorithm=“division”>
<td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
<td>|e1| / |e2| : |T|
<td>除法。当|T|为向量时，逐分量执行。


    如果|T|是有符号的整数标量类型，评估为：
    * 如果|e2|为零：
        * 如果|e2|是一个常量表达式，则是一个着色器创建错误。
        * 如果|e2|是一个覆写表达式，则是一个管道创建错误。
        * 否则，为|e1|。
    * 如果|e1|是|T|中最小的负值，并且|e2|为-1：
        * 如果|e1|和|e2|是常量表达式，则是一个着色器创建错误。
        * 如果|e1|和|e2|是覆写表达式，则是一个管道创建错误。
        * 否则，为|e1|。
    * 否则，为[=truncate=](|x|)，其中|x|是实值商|e1|&nbsp;&div;&nbsp;|e2|。

    注意：
    为了确保截断行为，可能需要执行比计算无符号除法更多的操作。
    当两个操作数具有相同符号时，请使用无符号除法。

    <!--
           where MINIT = |T|中最小的负值
           where Divisor = select(e2, 1, (e2==0) | ((e1 == MININT) & (e2 == -1)))
           结果为truncate(e1/Divisor)
    -->

    如果|T|是一个无符号整数标量类型，评估为：
    * 如果|e2|为零：
        * 如果|e2|是一个常量表达式，则是一个着色器创建错误。
        * 如果|e2|是一个覆写表达式，则是一个管道创建错误。
        * 否则，为|e1|。
</table>

<table class=‘data’>
<caption>使用混合标量和向量操作数的二进制算术表达式</caption>
<thead>
<th>前提<th>结论<th>语义
</thead>
<tr algorithm=“向量-标量算术，任何标量类型”>
<td rowspan=“10”>|S| 是 AbstractInt、AbstractFloat、f32、f16、i32、u32 之一<br>
|V| 是 vec|N|<|S|><br>
|es|: |S|<br>
|ev|: |V|
<td>|ev| + |es|: |V|
<td>|ev| + |V|(|es|)
<tr>
<td>|es| + |ev|: |V|
<td>|V|(|es|) + |ev|
<tr>
<td>|ev| - |es|: |V|
<td>|ev| - |V|(|es|)
<tr>
<td>|es| - |ev|: |V|
<td>|V|(|es|) - |ev|
<tr>
<td>|ev| * |es|: |V|
<td>|ev| * |V|(|es|)
<tr>
<td>|es| * |ev|: |V|
<td>|V|(|es|) * |ev|
<tr>
<td>|ev| / |es|: |V|
<td>|ev| / |V|(|es|)
<tr>
<td>|es| / |ev|: |V|
<td>|V|(|es|) / |ev|
<tr>
<td>|ev| % |es|: |V|
<td>|ev| % |V|(|es|)
<tr>
<td>|es| % |ev|: |V|
<td>|V|(|es|) % |ev|
</table>


<table class=‘data’>
<caption>矩阵算术</caption>
<thead>
<th>前提<th>结论<th>语义
</thead>
<tr algorithm=“矩阵加法”>
<td rowspan=2>|e1|, |e2|: mat|C|x|R|<|T|&gt<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|e1| + |e2|: mat|C|x|R|<|T|&gt<br>
<td>矩阵加法：结果的第 |i| 列为 |e1|[i] + |e2|[i]
<tr algorithm=“矩阵减法”>
<td>|e1| - |e2|: mat|C|x|R|<|T|&gt
<td>矩阵减法：结果的第 |i| 列为 |e1|[|i|] - |e2|[|i|]
<tr algorithm=“矩阵-标量乘法”>
<td rowspan=2>|m|: mat|C|x|R|<|T|&gt<br>
|s|: |T|<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|m| * |s|:  mat|C|x|R|<|T|&gt<br>
<td>逐分量缩放：(|m| * |s|)[i][j] 为 |m|[i][j] * |s|
<tr algorithm=“标量-矩阵乘法”>
<td>|s| * |m|:  mat|C|x|R|<|T|&gt<br>
<td>逐分量缩放：(|s| * |m|)[i][j] 为 |m|[i][j] * |s|
<tr algorithm=“矩阵列-向量乘法”>
<td>|m|: mat|C|x|R|<|T|&gt<br>
|v|: vec|C|<|T|&gt<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|m| * |v|:  vec|R|<|T|&gt<br>
<td>线性代数矩阵列-向量乘积：
结果的第 |i| 个分量为 dot(transpose(|m|)[|i|],|v|)
<tr algorithm=“矩阵行-向量乘法”>
<td>
|m|: mat|C|x|R|<|T|&gt<br>
|v|: vec|R|<|T|&gt<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|v| * |m|:  vec|C|<|T|&gt<br>
<td>线性代数行-向量-矩阵乘积：<br>
[=transpose=](transpose(|m|) * transpose(|v|))
<tr algorithm=“矩阵乘法”>
<td>|e1|: mat|K|x|R|<|T|&gt<br>
|e2|: mat|C|x|K|<|T|&gt<br>
|T| 是 AbstractFloat、f32 或 f16
<td>|e1| * |e2|:  mat|C|x|R|<|T|&gt<br>
<td>线性代数矩阵乘积。


</table>

## 比较表达式 ## {#comparison-expr}

<table class=‘data’>
<caption>Comparisons</caption>
<thead>
<tr><th>Precondition<th>Conclusion<th>Description
</thead>


<tr algorithm=“equality”>
<td>|e1|: |T|<br>|e2|: |T|<br>
|S| is AbstractInt, AbstractFloat, bool, i32, u32, f32, or f16<br>
|T| is |S| or vec|N|<|S|><br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class=“nowrap”>|e1| == |e2|: |TB|
<td>Equality. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm=“inequality”>
<td>|e1|: |T|<br>|e2|: |T|<br>
|S| is AbstractInt, AbstractFloat, bool, i32, u32, f32, or f16<br>
|T| is |S| or vec|N|<|S|><br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class=“nowrap”>|e1| != |e2|: |TB|
<td>Inequality. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm=“less than”>
<td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class=“nowrap”>|e1| < |e2|: |TB|
<td>Less than. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm=“less than equal”>
<td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class=“nowrap”>|e1| <= |e2|: |TB|
<td>Less than or equal. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm=“greater than”>
<td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class=“nowrap”>|e1| > |e2|: |TB|
<td>Greater than. [=Component-wise=] when |T| is a vector.
</tr>
<tr algorithm=“greater than equal”>
<td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
|TB| is vec|N|<bool> if |T| is a vector,<br>
otherwise |TB| is bool
<td class=“nowrap”>|e1| >= |e2|: |TB|
<td>Greater than or equal. [=Component-wise=] when |T| is a vector.
</tr>


</table>

## 比特表达式 ## {#bit-expr}

<table class=‘data’>
<caption>按位一元操作</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“complement”>
<td>|e|: |T|<br>
[ALLINTEGRALDECL]
<td class=“nowrap”>~|e| : |T|
<td>对|e|进行按位取反操作。
结果中的每一位都是|e|中对应位的相反值。
当|T|为向量时为逐分量操作。
</table>


<table class=‘data’>
<caption>按位二元操作</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“bitwise or”>
<td>|e1|: |T|<br>
|e2|: |T|<br>
[ALLINTEGRALDECL]
<td class=“nowrap”>|e1| | |e2|: |T|
<td>按位或。当|T|为向量时为逐分量操作。
<tr algorithm=“bitwise and”>
<td>|e1|: |T|<br>
|e2|: |T|<br>
[ALLINTEGRALDECL]
<td class=“nowrap”>|e1| & |e2|: |T|
<td>按位与。当|T|为向量时为逐分量操作。
<tr algorithm=“bitwise exclusive or”>
<td>|e1|: |T|<br>
|e2|: |T|<br>
[ALLINTEGRALDECL]
<td class=“nowrap”>|e1| ^ |e2|: |T|
<td>按位异或。当|T|为向量时为逐分量操作。
</table>


<table class=‘data’>
<caption>按位移动表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>


<tr algorithm=“concrete shift left”>
<td>|e1|: |T|<br>
|e2|: |TS|<br>
|S| is [INT]<br>
|T| is |S| or vec|N|<|S|><br>
|TS| is u32 when |T| is |S|, otherwise |TS| is vec|N|<u32>
<td class=“nowrap”>|e1| << |e2|: |T|
<td>向左移位（移位值为具体的）：


    将|e1|向左移位，最低有效位插入零位，丢弃最高有效位。

    移位的位数为|e2|的值对|e1|的位宽取模。
    如果|e2|大于等于|e1|的位宽，则：
    * 如果|e2|是一个常量表达式，则是一个[=shader-creation error=]。
    * 如果|e2|是一个[=override-expression=]，则是一个[=pipeline-creation error=]。

    当|e1|和|e2|在[=shader execution start=]之前都已知时，结果不能溢出：
    * 如果|T|是有符号整数类型，并且|e1|的|e2|+1个最高有效位的值不同，则：
        * 如果|e1|和|e2|是[=const-expressions=]，则是一个[=shader-creation error=]。
        * 如果|e1|和|e2|是[=override-expressions=]，则是一个[=pipeline-creation error=]。
    * 如果|T|是无符号整数类型，并且|e1|的任何|e2|个最高有效位的值为1，则：
        * 如果|e1|和|e2|是[=const-expressions=]，则是一个[=shader-creation error=]。
        * 如果|e1|和|e2|是[=override-expressions=]，则是一个[=pipeline-creation error=]。

    当|T|为向量时逐分量操作。

<tr algorithm=“abstract shift left”>
<td>|e1|: |T|<br>
|e2|: |TS|<br>
|T| is AbstractInt or vec|N|<AbstractInt><br>
|TS| is u32 when |T| is AbstractInt, otherwise |TS| is vec|N|<u32>
<td class=“nowrap”>|e1| << |e2|: |T|
<td>向左移位（移位值为抽象的）：


    将|e1|向左移位，最低有效位插入零位，丢弃最高有效位。

    移位的位数为|e2|的值。

    |e1|的|e2|+1个最高有效位必须具有相同的位值，否则会发生溢出。
    这个条件意味着所有丢弃的位必须与原始值的符号位和最终值的符号位相同。

    当|T|为向量时逐分量操作。

<tr algorithm=“concrete shift right”>
<td>|e1|: |T|<br>
|e2|: |TS|<br>
|S| is [INT]<br>
|T| is |S| or vec|N|<|S|><br>
|TS| is u32 when |T| is |S|, otherwise |TS| is vec|N|<u32>
<td class=“nowrap”>|e1| >> |e2|: |T|
<td>向右移位（移位值为具体的）。


    将|e1|向右移位，丢弃最低有效位。

    如果|S|是无符号类型，插入零位到最高有效位。
    如果|S|是有符号类型：
    * 如果|e1|为负数，则插入的每一位为1，因此结果也是负数。
    * 否则，插入的每一位为0。

    移位的位数为|e2|的值对|e1|的位宽取模。

    如果|e2|大于等于|e1|的位宽，则：
    * 如果|e2|是一个常量表达式，则是一个[=shader-creation error=]。
    * 如果|e2|是一个[=override-expression=]，则是一个[=pipeline-creation error=]。

    当|T|为向量时逐分量操作。

<tr algorithm=“abstract shift right”>
<td>|e1|: |T|<br>
|e2|: |TS|<br>
|T| is AbstractInt or vec|N|<AbstractInt><br>
|TS| is u32 when |T| is AbstractInt, otherwise |TS| is vec|N|<u32>
<td class=“nowrap”>|e1| >> |e2|: |T|
<td>向右移位（抽象的）。


    将|e1|向右移位，丢弃最低有效位。

    如果|e1|为负数，则插入的每一位为1，因此结果也是负数。
    否则，插入的每一位为0。

    移位的位数为|e2|的值。

    当|T|为向量时逐分量操作。

</table>

## 函数调用表达式 ## {#function-call-expr}

函数调用表达式执行一个调用函数，被调用的函数具有返回类型。如果被调用的函数没有返回值，应该使用函数调用语句。参见[[#function-call-statement]]。

## 变量标识符表达式 ## {#var-identifier-expr}

<table class=‘data’>
<caption>通过变量名获取引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“variable reference”>
<td>
|v| 是一个解析为在 [=address space=] |AS| 中使用 [=store type=] |T| 且使用 [=access mode=] |AM| 声明的 [=in scope|in-scope=] 变量的 [=identifier=]
<td class=“nowrap”>
|v|: ref<|AS|,|T|,|AM|>
<td>结果是指向命名变量 |v| 的内存的引用。
</table>

## 形式参数表达式  ## {#formal-parameter-expr}

<table class=‘data’>
<caption>获取函数的形式参数声明的标识符的值</caption>
<thead>
<tr><th>前提<th>结论<th>描述
</thead>
<tr algorithm=“formal parameter value”>
<td>
|a|是一个[=标识符=]，并且[=解析为|解析=]具有类型|T|的[=范围内|in-scope=]的形式参数声明
<td class=“nowrap”>
|a|: |T|
<td>结果是在调用该函数实例的[=调用点=]中为相应函数调用操作数提供的值。
</table>

## 地址运算符  ## {#address-of-expr}

<dfn noexport>address-of</dfn> 运算符将引用转换为相应的指针。


<table class=‘data’>
<caption>从引用获取指针</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“address-of expression”>
<td>
|r|: ref<|AS|,|T|,|AM|>
<td class=“nowrap”>
&|r|: ptr<|AS|,|T|,|AM|>
<td>结果是与引用值 |r| 相同[=内存视图=]的指针值。


       如果 |r| 是[=无效的内存引用=]，那么结果指针也是一个无效的内存引用。

       如果 |AS| 是[=地址空间/句柄=]地址空间，那么这是一个[=着色器创建错误=]。

       如果 |r| 是一个[[#component-reference-from-vector-reference|矢量分量的引用]]，那么这是一个[=着色器创建错误=]。

</table>

## 间接表达式  ## {#indirection-expr}

<dfn noexport>间接</dfn>运算符将指针转换为其相应的引用。


<table class=‘data’>
<caption>从指针获取引用</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“间接表达式”>
<td>
|p|: ptr<|AS|,|T|,|AM|>
<td class=“nowrap”>
*|p|: ref<|AS|,|T|,|AM|>
<td>结果是与指针值 |p| 相同的[=内存视图=]对应的引用值。


      如果 |p| 是一个[=无效的内存引用=]，那么结果引用也将是一个无效的内存引用。

</table>

## 值声明的标识符表达式  ## {#value-identifier-expr}

<table class=‘data’>
<caption>获取 const-, override-, 或 let-声明的标识符的值</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“const-declared value”>
<td>
|c| 是一个具有类型 |T| 的在范围内的 const 声明标识符
<td class=“nowrap”>
|c|: |T|
<td>结果是初始化表达式计算出的值。
表达式是一个 const 表达式，并且在着色器模块创建时进行求值。


<tr algorithm=“pipeline-overridable constant value”>
<td>
|c| 是一个具有类型 |T| 的在范围内的 override 声明标识符
<td class=“nowrap”>
|c|: |T|
<td>如果管线创建时指定了一个值给 [=pipeline constant ID|constant ID=]，
那么结果是该值。
对于不同的管线实例，这个值可能是不同的。


       否则，结果是初始化表达式计算出的值。
       可以覆盖管线的常量出现在模块范围，所以求值发生在着色器开始执行之前。

       注意：如果在 API 调用中没有指定初始值且 `let` 声明没有初始化表达式，则管线创建将失败。

<tr algorithm=“let-declared value”>
<td>
|c| 是一个具有类型 |T| 的在范围内的 let 声明标识符
<td class=“nowrap”>
|c|: |T|
<td>结果是初始化表达式计算出的值。
[=let-declaration=] 出现在函数体内部，并且每次控制流到达声明时都会求值。<br>
</table>

## 枚举表达式 ## {#enum-expr}

<table class=‘data’>
<caption>枚举表达式</caption>
<thead>
<tr><th>前提条件<th>结论<th>描述
</thead>
<tr algorithm=“枚举表达式”>
<td>|e| 是一个[=标识符=]，解析为一个[=预定义=]的[=枚举值=]，属于[=枚举类型=] |E|
<td>|e| : |E|
<td>见[[#预定义枚举值]]
</table>

## 类型表达式 ## {#type-expr}

<table class=‘data’>
<caption>Type expressions</caption>
<thead>
<tr><th>Precondition<th>Conclusion<th>Description
</thead>
<tr algorithm=“predeclared type expression”>
<td>|t| is an [=identifier=] [=resolves|resolving=] to a [=predeclared=] [=type=]
<td>|t| : [=AllTypes=]
<td>See [[#predeclared-types]]
<tr algorithm=“type alias expression”>
<td>|a| is an [=identifier=] [=resolves|resolving=] to a [=type alias=].
<td>|a| : [=AllTypes=]
<td>Additionally, |a| denotes the type to which it is aliased.
<tr algorithm=“structure type expression”>
<td>|s| is an [=identifier=] [=resolves|resolving=] to the declaration of a [=structure=] type.
<td>|s| : [=AllTypes=]
<td>Additionally, |s| denotes the structure type.
<tr algorithm=“predeclared type generator expression no trailing comma”>
<td rowspan=2>|tg| is an [=identifier=] [=resolves|resolving=] to a [=type-generator=]


        |e1|: |T1|<br>
          ...<br>
        |eN|: <var ignore>TN</var>
    <td>|tg| [=syntax_sym/_template_args_start=]<br>|e1|,<br>...,<br>|eN|<br> [=syntax_sym/_template_args_end=]<br>: [=AllTypes=]
    <td rowspan=2>Each [=type-generator=] has its own requirements on the template parameters it requires and accepts,
        and defines how the template parameters help determine the resulting type.

        The expressions |e1| through |eN| are the [=template parameters=] for the type-generator.

        For example, the type expression `vec2<f32>` is the [=vector=] of two [=f32=] elements.

        See [[#predeclared-types]] for the list of predeclared type-generators.

        Note: The two variants here differ only in whether they have a trailing comma after |eN|.
<tr algorithm="predeclared type generator expression trailing comma">
    <td><var ignore>tg</var> [=syntax_sym/_template_args_start=]<br>|e1|,<br>...,<br>|eN|,<br> [=syntax_sym/_template_args_end=]<br>: [=AllTypes=]

</table>

## 表达语法概述 ## {#expression-grammar}

当一个[=标识符=]是一个[=语法/调用短语=]中的第一个[=标记=]时，它可以是以下之一：
* 作为[=函数调用=]中的[=用户定义的函数=]或[=内置函数=]的名称。
* 作为[=值构造函数=]表达式中的[=类型=]、=类型别名=或者=类型生成器=的名称。

[[#declaration-and-scope|Declaration and scope]] 规则确保这些名称始终是不同的。

<pre class=include>
path: syntax/primary_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/call_expression.syntax.bs.include
</pre>
Note: The [=syntax/call_expression=] rule exists to ensure [=type checking=] applies to the call expression.
<pre class=include>
path: syntax/call_phrase.syntax.bs.include
</pre>

<pre class=include>
path: syntax/paren_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/argument_expression_list.syntax.bs.include
</pre>
<pre class=include>
path: syntax/expression_comma_list.syntax.bs.include
</pre>
<pre class=include>
path: syntax/component_or_swizzle_specifier.syntax.bs.include
</pre>
<pre class=include>
path: syntax/unary_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/singular_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/lhs_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/core_lhs_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/multiplicative_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/multiplicative_operator.syntax.bs.include
</pre>
<pre class=include>
path: syntax/additive_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/additive_operator.syntax.bs.include
</pre>
<pre class=include>
path: syntax/shift_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/relational_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/short_circuit_and_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/short_circuit_or_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/binary_or_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/binary_and_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/binary_xor_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/bitwise_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/expression.syntax.bs.include
</pre>

## 运算符优先级和结合性 ## {#operator-precedence-associativity}

整个子章节属于非规范性内容。


WGSL表达式中的操作符优先级和结合性源自它们的语法摘要。右侧表达式通过分组操作符来组织它们，如下图所示：

<div class=operators1>
  <figure>
    <figcaption>运算符优先级和结合性图表</figcaption>
    <object type="image/svg+xml" data="img/operators_1.mmd.svg"></object>
  </figure>
</div>

为了提高可读性，以下组织不与其他组织相关联：

* [=syntax/short_circuit_or_expression|Short-circuit OR=]
    (can associate with [=syntax/short_circuit_or_expression|self=] and [=syntax/relational_expression|relational=] weakly),
* [=syntax/short_circuit_and_expression|Short-circuit AND=]
    (can associate with [=syntax/short_circuit_and_expression|self=] and [=syntax/relational_expression|relational=] weakly),
* [=syntax/binary_or_expression|Binary OR=]
    (can associate with [=syntax/binary_or_expression|self=] and [=syntax/unary_expression|unary=] weakly),
* [=syntax/binary_and_expression|Binary AND=]
    (can associate with [=syntax/binary_and_expression|self=] and [=syntax/unary_expression|unary=] weakly),
* [=syntax/binary_xor_expression|Binary XOR=]
    (can associate with [=syntax/binary_xor_expression|self=] and [=syntax/unary_expression|unary=] weakly).

以下这些组之间不形成自我关联：


[=syntax/shift_expression|Shift=] （可以与[=syntax/unary_expression|unary=]弱关联），
[=syntax/relational_expression|Relational=] （可以与[=syntax/additive_expression|additive=]和[=syntax/shift_expression|shift=]弱关联）。

要将上述两个组一起关联，需要使用括号明确设置关系。
以下是这些规则在注释中使表达式无效的示例。

<div class='example wgsl function-scope' heading='Operator precedence corner cases'>
  <xmp>
    let a = x & (y ^ (z | w)); // Invalid: x & y ^ z | w
    let b = (x + y) << (z >= w); // Invalid: x + y << z >= w
    let c = x < (y > z); // Invalid: x < y > z
    let d = x && (y || z); // Invalid: x && y || z
  </xmp>
</div>

新出现的优先级控制了一个表达式的隐含括号，其中优先级更高的运算符将在与优先级较低的运算符在一起时，表现得好像被括号包围。例如，比加法运算符优先级更高的乘法运算符将从表达式a + b * c推断出(a + (b * c))。同样，新出现的关联性控制了这些隐含括号的方向。例如，从表达式a + b + c中，从左到右的关联性推断出((a + b) + c)，而从右到左的关联性推断出(* (* a))。


下表总结了运算符的优先级、关联性和绑定，按从最强到最弱的顺序排列。绑定列包含给定运算符的较强的表达式，意思是，例如，如果值为"All above"，则该运算符可以包括任何较强的表达式。但是，例如，如果值为"Unary"，则比该行运算符较弱但比一元运算符更强的任何内容都需要使用括号与该运算符绑定。这一列对于线性列出运算符是必要的。

<table class=‘data’>
<caption>
操作符优先级、结合性和右手表达式的绑定，从强到弱排序<br>
</caption>
<thead>
<tr><th>Name
<th>Operators
<th>Associativity
<th>Binding
</thead>
<tr><td>[=syntax/paren_expression|Parenthesized=]
<td><code>(…)</code>
<td>
<td>
<tr><td>[=syntax/primary_expression|Primary=]
<td><code>a()</code>, <code>a[]</code>, <code>a.b</code>
<td>从左到右
<td>
<tr><td>[=syntax/unary_expression|Unary=]
<td><code>-a</code>, <code>!a</code>, <code>~a</code>, <code>a</code>, <code>&a</code>
<td>从右到左
<td>上述所有
<tr><td>[=syntax/multiplicative_expression|Multiplicative=]
<td><code>ab</code>, <code>a/b</code>, <code>a%b</code>
<td>从左到右
<td>上述所有
<tr><td>[=syntax/additive_expression|Additive=]
<td><code>a+b</code>, <code>a-b</code>
<td>从左到右
<td>上述所有
<tr><td>[=syntax/shift_expression|Shift=]
<td><code>a<<b</code>, <code>a>>b</code>
<td>需要括号
<td>一元
<tr><td>[=syntax/relational_expression|Relational=]
<td><code>a<b</code>, <code>a>b</code>, <code>a<=b</code>, <code>a>=b</code>, <code>a==b</code>, <code>a!=b</code>
<td>需要括号
<td>上述所有
<tr><td>[=syntax/binary_and_expression|Binary AND=]
<td><code>a&b</code>
<td>从左到右
<td>一元
<tr><td>[=syntax/binary_xor_expression|Binary XOR=]
<td><code>a^b</code>
<td>从左到右
<td>一元
<tr><td>[=syntax/binary_or_expression|Binary OR=]
<td><code>a|b</code>
<td>从左到右
<td>一元
<tr><td>[=syntax/short_circuit_and_expression|Short-circuit AND=]
<td><code>a&&b</code>
<td>从左到右
<td>关系
<tr><td>[=syntax/short_circuit_or_expression|Short-circuit OR=]
<td><code>a||b</code>
<td>从左到右
<td>关系
</table>

# 语句 # {#statements}

一个<dfn>语句</dfn>是控制执行的程序片段。通常情况下，语句按顺序执行；然而，[[#控制流程|控制流程语句]]可能导致程序以非顺序的方式执行。

## 复合语句 ## {#compound-statement-section}

一个复合语句是一个由花括号括起来的零个或多个语句的序列。
当一个声明是这些语句之一时，它的标识符在下一个语句的开始到复合语句的结束之间都处于作用域内。

<pre class=include>
path: syntax/compound_statement.syntax.bs.include
</pre>

[=syntax/continuing_compound_statement=]是复合语句的一种特殊形式，用于构成[[#continuing-statement|continuing]]语句的主体，并允许在末尾添加可选的[[#break-if-statement|break-if]]语句。

## 赋值语句 ## {#assignment}

一个<dfn noexport dfn-for=“statement”>赋值</dfn>语句会评估一个表达式，如果需要的话会将其存储在内存中（从而更新变量的内容）。


<pre class=include>
path: syntax/assignment_statement.syntax.bs.include
</pre>

操作符符号左侧的文本是“左侧”，而操作符符号右侧的表达式是“右侧”。

### 简单的分配 ### {#simple-assignment-section}

当左边是一个表达式且操作符为等号（‘=’）时，一个语句/赋值就是一个简单赋值。在这种情况下，右边的值被写入左边引用的内存中。

<table class=‘data’>
<thead>
<tr><th style=“width:40%”>前提条件<th>语句<th>描述
</thead>
<tr algorithm=“updating assignment”>
<td>|e|: |T|,<br>
|T| 是一个[=类型/具体=]的可构造类型,<br>
|r|: ref<|AS|,|T|,|AM|>,<br>
|AS| 是一个可写的[=地址空间=],<br>
[=访问模式=] |AM| 是[=访问/写入=]或[=访问/读写=]<br>
<td class=“nowrap”>|r| = |e|
<td>先求值 |r|，然后求值 |e|，然后将为 |e| 计算出的值写入被 |r| 引用的[=内存位置=]。


    注意: 如果引用是一个[=无效的内存引用=]，则写操作可能不会执行，或者可能写入与预期不同的内存位置。

</table>

在最简单的情况下，左边是一个变量的名称。
有关其他情况，请参阅[[#forming-references-and-pointers]]。

    <div class='example wgsl' heading='Assignments'>
      <xmp>
        struct S {
            age: i32,
            weight: f32
        }
        var<private> person: S;

        fn f() {
            var a: i32 = 20;
            a = 30;           // Replace the contents of 'a' with 30.

            person.age = 31;  // Write 31 into the age field of the person variable.

            var uv: vec2<f32>;
            uv.y = 1.25;      // Place 1.25 into the second component of uv.

            let uv_x_ptr: ptr<function,f32> = &uv.x;
            *uv_x_ptr = 2.5;  // Place 2.5 into the first component of uv.

            var sibling: S;
            // Copy the contents of the 'person' variable into the 'sibling' variable.
            sibling = person;
        }
      </xmp>
    </div>

### 伪装任务 ### {#phony-assignment-section}

一个[=语句/赋值语句=]是一个<dfn noexport>虚假赋值语句</dfn>，当[=左侧=]是下划线(<a for=syntax_sym lt=equal>'_'</a>)标记时。在这种情况下，[=右侧=]将被计算，然后被忽略。


<table class=‘data’>
<thead>
<tr><th>前置条件<th>语句<th>描述
</thead>
<tr algorithm=“phony-assignment”>
<td>|e|: |T|,<br>
|T| 是可[=构造的=]，一个[=指针类型=]，一个[=纹理类型=]或一个[=采样器类型=]
<td class=“nowrap”>_ = |e|
<td>计算 |e|。


    注意: 结果值不会被存储。
    下划线`_`标记不是一个标识符，因此不能在表达式中使用。

</table>

虚假赋值语句是有用的场景:
* 调用返回值的函数，但明确表示结果值是不需要的。
* [=静态访问=]一个变量，从而将其作为[=着色器资源接口=]的一部分。
    注意：一个缓冲变量的存储类型可能无法被构造，例如它包含原子类型或者是一个运行时大小的数组。在这些情况下，可以使用指向变量内容的指针。



<div class='example wgsl global-scope' heading='Using phony-assignment to throw away an un-needed function result'>
  <xmp>
    var<private> counter: i32;

    fn increment_and_yield_previous() -> i32 {
      let previous = counter;
      counter = counter + 1;
      return previous;
    }

    fn user() {
      // Increment the counter, but don't use the result.
      _ = increment_and_yield_previous();
    }
  </xmp>
</div>


<div class='example wgsl global-scope' heading='Using phony-assignment to occupy bindings without using them'>
  <xmp>
    struct BufferContents {
        counter: atomic<u32>,
        data: array<vec4<f32>>
    }
    @group(0) @binding(0) var<storage> buf: BufferContents;
    @group(0) @binding(1) var t: texture_2d<f32>;
    @group(0) @binding(2) var s: sampler;

    @fragment
    fn shade_it() -> @location(0) vec4<f32> {
      // Declare that buf, t, and s are part of the shader interface, without
      // using them for anything.
      _ = &buf;
      _ = t;
      _ = s;
      return vec4<f32>();
    }
  </xmp>
</div>

### 复合赋值 ### {#compound-assignment-sec}

当“左侧”是一个表达式，操作符是一种“复合赋值操作符”之一时，一个“语句/赋值语句”被称为“复合赋值语句”。

<pre class=include>
path: syntax/compound_assignment_operator.syntax.bs.include
</pre>

每个语句的类型要求、语义和行为被定义为如下表所示的复合赋值展开时的情况，除非：
* 引用表达式 |e1| 仅被评估一次，
* 用于 |e1| 的 [=引用类型=] 必须具有 [=访问/读写=] [=访问模式=]。

<table class='data'>
  <thead>
    <tr><th>Statement<th>Expansion
  </thead>
<tr algorithm="add-assign">
    <td class="nowrap">|e1| += |e2|
    <td>|e1| = |e1| + (|e2|)
<tr algorithm="subtract-assign">
    <td class="nowrap">|e1| -= |e2|
    <td>|e1| = |e1| - (|e2|)
<tr algorithm="multiply-assign">
    <td class="nowrap">|e1| *= |e2|
    <td>|e1| = |e1| * (|e2|)
<tr algorithm="divide-assign">
    <td class="nowrap">|e1| /= |e2|
    <td>|e1| = |e1| / (|e2|)
<tr algorithm="modulus-assign">
    <td class="nowrap">|e1| %= |e2|
    <td>|e1| = |e1| % (|e2|)
<tr algorithm="bitwise-and-assign">
    <td class="nowrap">|e1| &= |e2|
    <td>|e1| = |e1| & (|e2|)
<tr algorithm="bitwise-or-assign">
    <td class="nowrap">|e1| |= |e2|
    <td>|e1| = |e1| | (|e2|)
<tr algorithm="bitwise-xor-assign">
    <td class="nowrap">|e1| ^= |e2|
    <td>|e1| = |e1| ^ (|e2|)
<tr algorithm="bitwise-shiftright-assign">
    <td class="nowrap">|e1| >>= |e2|
    <td>|e1| = |e1| >> (|e2|)
<tr algorithm="bitwise-shiftleft-assign">
    <td class="nowrap">|e1| <<= |e2|
    <td>|e1| = |e1| << (|e2|)
</table>

注意：语法不允许将复合赋值和虚假赋值合并在一起。


注意：尽管引用 |e1| 只被评估一次，但它的基础内存被访问了两次：
首先进行一次读取访问以获取旧值，然后进行一次写入访问来存储更新后的值。

<div class='example wgsl global-scope' heading="Compound assignment">
  <xmp>
    var<private> next_item: i32 = 0;

    fn advance_item() -> i32 {
       next_item += 1;   // Adds 1 to next_item.
       return next_item - 1;
    }

    fn bump_item() {
      var data: array<f32,10>;
      next_item = 0;
      // Adds 5.0 to data[0], calling advance_item() only once.
      data[advance_item()] += 5.0;
      // next_item will be 1 here.
    }

    fn precedence_example() {
      var value = 1;
      // The right-hand side of a compound assignment is its own expression.
      value *= 2 + 3; // Same as value = value * (2 + 3);
      // 'value' now holds 5.
    }
  </xmp>
</div>

<div class=note><span class=marker>注意：</span>
可以将复合赋值重写为使用“[=简单赋值=]”的不同WGSL代码。
其思想是使用指针来保存对引用求值的结果。

<p algorithm="translation compound assignment not vector component">For example,
when |e1| is *not* a reference to a component inside a vector, then
<blockquote>
|e1|` += `|e2|;
</blockquote>
can be rewritten as
<blockquote>
`{ let p = &(`|e1|`); *p = *p + (`|e2|`); }`
</blockquote>
where the identifier `p` is chosen to be different from all other identifiers in the program.
</p>

<p algorithm="translation compound assignment vector component">When
|e1| is a reference to a component inside a vector, the above technique
needs to be modified because WGSL does not allow [[#address-of-expr|taking the address]] in that case.
For example, if <var ignore>ev</var> is a reference to a vector, the statement
<blockquote>
|ev|`[`|c|`] += ` |e2|;
</blockquote>
can be rewritten as
<blockquote>
`{ let p = &(`|ev|`); let c0 = ` |c|`; (*p)[c0] = (*p)[c0] + (`|e2|`); }`
</blockquote>
where identifiers `c0` and `p` are chosen to be different from all other identifiers in the program.
</div>
</div>

## 递增和递减语句 ## {#increment-decrement}

一个<dfn noexport>增量语句</dfn>将1添加到变量的内容。
一个<dfn noexport>递减语句</dfn>从变量的内容中减去1。

<pre class=include>
path: syntax/increment_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/decrement_statement.syntax.bs.include
</pre>

这个表达式必须求值为具有整数标量存储类型和读写访问方式的引用。

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="increment statement">
    <td class="nowrap">|r| : ref&lt;|AS|,|T|,[=access/read_write=]&gt;,<br>
        |T| is a [=type/concrete=] [=integer scalar=]<br>
    <td class="nowrap">|r|`++`
    <td>Adds 1 to the contents of memory referenced by |r|.
        <br>Same as |r| += |T|(1)
  <tr algorithm="decrement statement">
    <td class="nowrap">|r| : ref&lt;|AS|,|T|,[=access/read_write=]&gt;,<br>
        |T| is a [=type/concrete=] [=integer scalar=]<br>
    <td class="nowrap">|r|`--`
    <td>Subtracts 1 from the contents of memory referenced by |r|.
        <br>Same as |r| -= |T|(1)
</table>

    <div class='example wgsl' heading='Increment and decrement'>
      <xmp>
        fn f() {
            var a: i32 = 20;
            a++;
            // Now a contains 21
            a--;
            // Now a contains 20
        }
      </xmp>
    </div>

## 控制流 ## {#control-flow}

控制流语句可以导致程序以非顺序的顺序执行。

### If 语句 ### {#if-statement}

一个<dfn noexport dfn-for=“statement”>if</dfn>语句根据条件表达式的评估情况有条件地执行至多一个[=复合语句=]。


一个if语句有一个if子句，后跟零个或多个else if子句，其后可以是一个可选的else子句。

<pre class=include>
path: syntax/if_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/if_clause.syntax.bs.include
</pre>

<pre class=include>
path: syntax/else_if_clause.syntax.bs.include
</pre>

<pre class=include>
path: syntax/else_clause.syntax.bs.include
</pre>

[=类型规则前提条件=]:
每个if和else if子句中的表达式必须为bool类型。


if语句的执行如下：

* 评估与if子句关联的条件。 如果结果为true，控制转移到条件表达式后的第一个复合语句。
* 否则，按文本顺序评估下一个存在的else if子句的条件， 如果结果为true，控制转移到相关的复合语句。
    * 该行为对所有else if子句都重复，直到某个条件评估为true。
* 如果没有条件评估为true，则控制转移到与else子句关联的复合语句（如果存在）。

### Switch 语句 ### {#switch-statement}

一个<dfn noexport dfn-for=“statement”>switch</dfn>语句根据选择器表达式的计算结果，将控制转移到一组[=case子句=]中的一个，或转移到[=default子句=]。

<pre class=include>
path: syntax/switch_statement.syntax.bs.include
</pre>
<pre class=include>
path: syntax/switch_body.syntax.bs.include
</pre>
<pre class=include>
path: syntax/switch_clause.syntax.bs.include
</pre>
<pre class=include>
path: syntax/case_clause.syntax.bs.include
</pre>
<pre class=include>
path: syntax/default_alone_clause.syntax.bs.include
</pre>
<pre class=include>
path: syntax/case_selectors.syntax.bs.include
</pre>
<pre class=include>
path: syntax/case_selector.syntax.bs.include
</pre>

一个<dfn noexport>case子句</dfn>是由'case'关键字后跟以逗号分隔的一系列[=syntax/case_selector|case选择器=]和以复合语句形式的主体组成。


一个<dfn noexport>default-alone子句</dfn>是以'default'关键字开头，后跟以复合语句形式的主体。


一个<dfn noexport>default子句</dfn>可以是以下两种情况之一：
* 一个包含'default'作为其选择器之一的[=case子句=]，或者
* 一个[=default-alone子句=]。

每个switch语句必须有且仅有一个default子句。


"default"关键字在单个语法/选择器列表中不得出现多次。


类型规则前提条件：
对于单个switch语句，选择器表达式和所有case选择器表达式必须是相同的整数标量类型。


语法/选择器中的表达式必须是常量表达式。


同一个switch语句中的两个不同case选择器表达式的值不能相同。


如果选择器的值等于语法/选择器列表中的表达式的值，则控制流转到该case子句的主体。如果选择器的值不等于任何case选择器的值，则控制流转到default子句的主体。


当控制流到达某个子句的主体末尾时，控制流转到switch语句之后的第一个语句。


当子句的主体中的语句之一是声明时，它遵循复合语句中声明的正常作用域和生存期规则。也就是说，主体是一系列语句，如果其中一个是声明，则该声明的作用域从序列中下一个语句的开始延伸到主体的末尾。当到达声明时，它将被执行，创建一个新的变量声明或值声明的实例，并进行初始化。

<div class='example wgsl function-scope' heading='WGSL Switch'>
  <xmp>
    var a : i32;
    let x : i32 = generateValue();
    switch x {
      case 0: {      // The colon is optional
        a = 1;
      }
      default {      // The default need not appear last
        a = 2;
      }
      case 1, 2, {   // Multiple selector values can be used
        a = 3;
      }
      case 3, {      // The trailing comma is optional
        a = 4;
      }
      case 4 {
        a = 5;
      }
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading='WGSL Switch with default combined'>
  <xmp>
    const c = 2;
    var a : i32;
    let x : i32 = generateValue();
    switch x {
      case 0: {
        a = 1;
      }
      case 1, c {       // Const-expression can be used in case selectors
        a = 3;
      }
      case 3, default { // The default keyword can be used with other clauses
        a = 4;
      }
    }
  </xmp>
</div>

### Loop 语句 ### {#loop-statement}

<pre class=include>
path: syntax/loop_statement.syntax.bs.include
</pre>

一个循环语句（loop statement）会反复执行一个循环体（loop body）；循环体被指定为一个复合语句（compound statement）。每次执行循环体被称为一次迭代（iteration）。


这个重复过程可以通过 break 语句或 return 语句来中断。


循环体中的最后一条语句可以选择是一个 continuing 语句。


当循环体中的某个语句是一个声明语句时，它遵循在复合语句中声明的正常作用域和生命周期规则。也就是说，循环体是一系列语句，如果其中一条是一个声明语句，那么该声明的作用域从序列中下一条语句的开始一直延伸到循环体的结束。每次到达该声明时都会执行它，因此每次新的迭代都会创建一个新的变量声明或值声明的实例，并重新初始化它。


注意：循环语句是与其他着色器语言最大的不同之一。


这种设计直接表达了编译代码中常见的循环习惯用法。特别是将循环更新语句放在循环体末尾，使其可以自然地使用在循环体内定义的值。

<div class='example glsl' heading='GLSL Loop'>
  <xmp>
    int a = 2;
    for (int i = 0; i < 4; i++) {
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;      // <1>
    loop {
      if i >= 4 { break; }

      a = a * 2;

      i++;
    }
  </xmp>
</div>
* <1> The initialization is listed before the loop.

<div class='example glsl' heading='GLSL Loop with continue'>
  <xmp>
    int a = 2;
    int step = 1;
    for (int i = 0; i < 4; i += step) {
      if (i % 2 == 0) continue;
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }

      let step: i32 = 1;

      i = i + step;
      if i % 2 == 0 { continue; }

      a = a * 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue and continuing">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }

      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {   // <2>
        i = i + step;
      }
    }
  </xmp>
</div>
* <2> The continue construct is placed at the end of the `loop`

### For 语句 ### {#for-statement}

<pre class=include>
path: syntax/for_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/for_header.syntax.bs.include
</pre>

<pre class=include>
path: syntax/for_init.syntax.bs.include
</pre>
<pre class=include>
path: syntax/for_update.syntax.bs.include
</pre>

for（initializer; condition; update_part）{ body }是for语句的形式，并且在相同的body部分上附加了语法糖以作为循环语句的替代品。
此外：

* 如果initializer不为空，则在第一次迭代之前在额外的作用域内执行。初始化器中的声明的作用域延伸到循环体的结尾。
* 类型规则前提条件：如果条件不为空，则必须是bool类型的表达式。
    * 如果条件存在，则在执行循环体之前立即评估条件。如果条件为假，则执行中断语句，结束循环的执行。此检查在每次循环迭代开始时执行。
* 如果update_part不为空，则它将成为循环体末尾的continuing语句。

for循环的initializer在执行循环之前执行一次。当initializer中出现声明时，其标识符在body末尾之前都在作用域内。与body中的声明不同，声明不会在每次迭代中重新初始化。

按照condition、body和update_part的顺序执行，形成一个循环迭代。body是一种特殊的复合语句。在body的下一条语句的开始到body的结尾期间，声明的标识符都在作用域内。每次到达声明时都会执行该声明，因此每次新的迭代都会创建一个变量或常量的新实例，并重新初始化它。

<div class='example wgsl function-scope' heading="For to Loop transformation: before">
  <xmp>
    var a: i32 = 2;
    for (var i: i32 = 0; i < 4; i++) {
      if a == 0 {
        continue;
      }
      a = a + 2;
    }
  </xmp>
</div>

转换为：

<div class='example wgsl function-scope' heading="For to Loop transformation: after">
  <xmp>
    var a: i32 = 2;
    { // Introduce new scope for loop variable i
      var i: i32 = 0;
      loop {
        if !(i < 4) {
          break;
        }

        if a == 0 {
          continue;
        }
        a = a + 2;

        continuing {
          i++;
        }
      }
    }
  </xmp>
</div>

### While 语句 ### {#while-statement}

<pre class=include>
path: syntax/while_statement.syntax.bs.include
</pre>

while语句是一种由条件参数化的循环。
在每次循环[=迭代=]开始时，会评估一个布尔条件。
如果条件为false，则while循环结束执行。
否则，将执行剩余的迭代。


[=类型规则前提条件=]：条件[=shader-creation error|必须=]是[=bool=]类型。


while循环可以被看作是一个语法糖，用于表示[=statement/loop=]或[=statement/for=]语句。
以下语句形式是等价的：
* while condition { body_statements }
* loop { if ! condition {break;} body_statements }
* for (; condition ;) { body_statements }

### Break 语句 ### {#break-statement}

<pre class=include>
path: syntax/break_statement.syntax.bs.include
</pre>

一个break语句将控制转移至最近的包含循环或switch语句的主体之后，从而结束循环或switch语句的执行。


break语句只能在循环、for、while和switch语句内部使用。


不得将break语句放置在会从循环的“继续语句”中退出的位置。应改为使用break-if语句。

<div class='example wgsl function-scope' heading="WGSL Invalid loop break from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        if i >= 4 { break; } // Invalid.  Use break-if instead.
      }
    }
  </xmp>
</div>

### Break-If 语句 ### {#break-if-statement}

<pre class=include>
path: syntax/break_if_statement.syntax.bs.include
</pre>
一个<dfn noexport dfn-for=“statement”>break-if</dfn>语句评估一个布尔条件；

如果条件为真，则控制权转移到最近封闭的[=语句/循环=]语句的主体之后，结束该循环的执行。


[=类型规则前提条件=]：条件[=着色器创建错误|必须=]是[=bool=]类型。


注意：break-if语句只能作为[[#continuing-statement|continuing]]语句主体中的最后一条语句出现。

<div class='example wgsl function-scope' heading="WGSL Valid loop break-if from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        break if i >= 4;
      }
    }
  </xmp>
</div>

### Continue 语句 ### {#continue-statement}

<pre class=include>
path: syntax/continue_statement.syntax.bs.include
</pre>

<dfn noexport dfn-for=“statement”>continue</dfn>语句将控制权转移到最近的封闭[=语句/循环=]中：
* 如果存在，转移到该循环体末尾的[=语句/continuing=]语句。
* 否则，向后转移到循环体中的第一条语句，开始下一次[=迭代=]。

continue语句只能在[=语句/循环=]、[=语句/for=]或[=语句/while=]语句中使用。
不能将continue语句放在会转移控制到封闭的[=语句/continuing=]语句的位置。
（当转移到continuing语句时，这是一个“前向”分支。）


不能将continue语句放在会跳过目标[=语句/continuing=]语句中使用的声明的位置。


注意：只有当continue用于在continuing语句中嵌套的另一个循环中传递控制流时，才能在continuing语句中使用continue。也就是说，continue不能用于将控制转移到当前执行的continuing语句的开头。

<div class='example wgsl function-scope expect-error' heading="Invalid continue bypasses declaration">
  <xmp>
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }
      if i % 2 == 0 { continue; } // <3>

      let step: i32 = 2;

      continuing {
        i = i + step;
      }
    }
  </xmp>
</div>
* <3> The `continue` is invalid because it bypasses the declaration of `step` used in the `continuing` construct

### Continuing 语句 ### {#continuing-statement}

<pre class=include>
path: syntax/continuing_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/continuing_compound_statement.syntax.bs.include
</pre>

一个"continuing"语句指定了一个在循环迭代结束时执行的复合语句。这个结构是可选的。

复合语句不能包含返回语句在任何嵌套层。

### Return 语句 ### {#return-statement}

<pre class=include>
path: syntax/return_statement.syntax.bs.include
</pre>

一个<dfn noexport dfn-for=“statement”>return</dfn>语句会结束当前函数的执行。
如果该函数是一个[=入口点=]，那么当前着色器调用将被终止。
否则，在当前函数调用的[=调用点=]求值之后，继续对下一个表达式或语句进行求值。


如果函数没有[=返回类型=]，那么[=语句/返回=]语句是可选的。如果为这样的函数提供了返回语句，它[=创建错误|不能=]提供一个值。
否则，表达式[=创建错误|必须存在=]，并且被称为<dfn>返回值</dfn>。在这种情况下，该函数调用的调用点求值为返回值。
返回值的类型[=创建错误|必须=]与函数的返回类型相匹配。

### Discard 语句 ### {#discard-statement}

一个"discard"语句将调用转换为一个[=辅助调用=]并丢弃该片段。
"discard"语句只能在[=片段=]着色器阶段中使用。


更准确地说，执行"discard"语句会：
* 将当前调用转换为一个[=辅助调用=]，
* 阻止当前片段在[=GPURenderPipeline=]中继续处理。

只有在"discard"语句之前执行的语句才会产生可观察的效果。


注意：任何一个[=片段阶段的函数=]都可以执行"discard"语句，其效果相同：片段将被丢弃。

<div class='example wgsl' heading='Using the discard statement to throw away a fragment'>
  <xmp>
  @group(0) @binding(0)
  var<storage, read_write> will_emit_color : u32;

  fn discard_if_shallow(pos: vec4<f32>) {
    if pos.z < 0.001 {
      // If this is executed, then the will_emit_color variable will
      // never be set to 1 because helper invocations will not write
      // to shared memory.
      discard;
    }
    will_emit_color = 1;
  }

  @fragment
  fn main(@builtin(position) coord_in: vec4<f32>)
    -> @location(0) vec4<f32>
  {
    discard_if_shallow(coord_in);

    // Set the value to 1 and emit red, but only if the helper function
    // did not execute the discard statement.
    will_emit_color = 1;
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
  }
  </xmp>
</div>

## 函数调用语句 ## {#function-call-statement}

<pre class=include>
path: syntax/func_call_statement.syntax.bs.include
</pre>

一个函数调用语句执行一个函数调用。


如果被调用的函数具有属性/必须使用属性，则会导致一个着色器创建错误。


注意：如果函数返回一个值，并且函数没有属性/必须使用属性，则该值会被忽略。

## Const断言语句 ## {#const-assert-statement}

如果表达式求值为`false’，则"const assertion"语句将产生一个shader创建错误。该表达式必须是一个常量表达式。该语句可以满足shader中静态访问的条件，但对编译后的shader没有其他影响。该语句可以在模块作用域和函数作用域内使用。

[=Type rule precondition=]:
The expression [=shader-creation error|must=] be of [=bool=] type.

<pre class=include>
path: syntax/const_assert_statement.syntax.bs.include
</pre>

<div class='example wgsl global-scope' heading="Static assertion examples">
  <xmp>
    const x = 1;
    const y = 2;
    const_assert x < y; // valid at module-scope.
    const_assert(y != 0); // parentheses are optional.

    fn foo() {
      const z = x + y - 2;
      const_assert z > 0; // valid in functions.
      let a  = 3;
      const_assert a != 0; // invalid, the expresion must be a const-expression.
    }
  </xmp>
</div>

## 语句语法总结 ## {#statements-summary}

该[=syntax/statement=]规则匹配可以在函数体内大多数位置使用的语句。

<pre class=include>
path: syntax/statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/variable_updating_statement.syntax.bs.include
</pre>

此外，某些陈述仅可在非常特定的情境中使用：
* [=syntax/break_if_statement=]
* [=syntax/continuing_compound_statement=]

## 语句行为分析 ## {#behaviors}

### 规则 ### {#behaviors-rules}

一些影响控制流的语句只在某些上下文中有效。例如，在循环语句、for循环语句或while循环语句之外，[=statement/continue=]是无效的。此外，统一性分析（参见[[#uniformity]]）需要知道控制流何时可以以多种不同方式退出语句。


这两个目标可以通过一个对语句执行行为进行总结的系统来实现。行为分析将每个语句映射到在该语句评估完成后执行进行的可能方式的集合。与对值和表达式进行类型分析一样，行为分析是从下往上进行的：首先确定某些基本语句的行为，然后通过应用组合规则确定更高级结构的行为。


<dfn export>行为</dfn>是一个集合，其元素可以是：
- 返回（Return）
- 跳出（Break）
- 继续（Continue）
- 下一步（Next）

这些都对应于从复合语句中退出的方式：要么通过关键字，要么通过跳到下一条语句（“Next”）。


我们使用“s: B”表示s遵守行为规则，并具有行为B。


对于每个函数：
- 它的主体必须符合这些规则而成为有效的语句。
- 如果函数有返回类型，则其主体的行为必须为{Return}。
- 否则，其主体的行为必须是{Next, Return}的子集。

我们为每个函数分配一个行为：它是其主体的行为（将主体视为普通语句），其中任何"Return"都被替换为"Next"。根据以上规则，函数行为始终为{}或{Next}之一。


行为分析能够确定每个语句和函数的非空行为。

<table class='data'>
  <caption>Rules for analyzing and validating the behaviors of statements</caption>
  <thead>
    <tr><th>Statement<th>Preconditions<th>Resulting behavior
  </thead>
  <tr>
    <td class="nowrap">*empty statement*
    <td>
    <td class="nowrap">{Next}
  <tr algorithm="braced statement behavior">
    <td class="nowrap">{|s|}
    <td>|s|: |B|
    <td class="nowrap">|B|
  <tr algorithm="statement sequence behavior with next">
    <td class="nowrap" rowspan=2>|s1| |s2|

        Note: |s1| often ends in a semicolon.

    <td class="nowrap">|s1|: |B1|<br>
        Next in |B1|<br>
        |s2|: |B2|
    <td class="nowrap">(|B1|&#x2216;{Next}) &cup; |B2|
  <tr algorithm="statement sequence behavior without next">
    <td class="nowrap">|s1|: |B1|<br>
        Next not in |B1|<br>
        |s2|: <var ignore>B2</var>
    <td class="nowrap">|B1|
  <tr algorithm="variable declaration behavior">
    <td class="nowrap">var x:T;
    <td>
    <td>{Next}
  <tr algorithm="let-declaration behavior">
    <td class="nowrap">let x = |e|;
    <td>
    <td>{Next}
  <tr algorithm="initialized variable declaration behavior">
    <td class="nowrap">var x = |e|;
    <td>
    <td>{Next}
  <tr algorithm="assignment behavior">
    <td class="nowrap">x = |e|;
    <td>
    <td>{Next}
  <tr algorithm="phony assignment behavior">
    <td class="nowrap">_ = |e|;
    <td>
    <td>{Next}
  <tr algorithm="function call statement behavior">
    <td class="nowrap">|f|(|e1|, ..., |en|);
    <td class="nowrap">|f| has behavior |B|
    <td class="nowrap">|B|
  <tr algorithm="return behavior">
    <td>return;
    <td>
    <td>{Return}
  <tr algorithm="return value behavior">
    <td class="nowrap">return |e|;
    <td>
    <td>{Return}
  <tr algorithm="discard behavior">
    <td class="nowrap">discard;
    <td>
    <td>{Next}
  <tr algorithm="break behavior">
    <td>break;
    <td>
    <td>{Break}
  <tr algorithm="break if behavior">
    <td>break if |e|;
    <td>
    <td>{Break, Next}
  <tr algorithm="continue behavior">
    <td>continue;
    <td>
    <td>{Continue}
  <tr algorithm="if statement behavior">
    <td class="nowrap">if |e| |s1| else |s2|
    <td class="nowrap">
        |s1|: |B1|<br>
        |s2|: |B2|
    <td class="nowrap">|B1| &cup; |B2|
  <tr algorithm="loop with continuing without break behavior">
    <td class="nowrap" rowspan=2>loop {|s1| continuing {|s2|}}
    <td class="nowrap">
        |s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return} are in |B2|<br>
        Break is not in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1| &cup; |B2|)&#x2216;{Continue, Next}
  <tr algorithm="loop with continuing with break behavior">
    <td class="nowrap">
        |s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return} are in |B2|<br/>
        Break is in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1| &cup; |B2| &cup; {Next})&#x2216;{Break, Continue}
  <tr algorithm="switch behavior">
    <td class="nowrap" rowspan=2>switch |e|  {case <var ignore>c1</var>: |s1| ... case <var ignore>cn</var>: |sn|}
    <td class="nowrap">
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Break is not in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">|B1| &cup; ... &cup; |Bn|
  <tr algorithm="switch with break behavior">
    <td class="nowrap">
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Break is in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">(|B1| &cup; ... &cup; |Bn| &cup; {Next})&#x2216;Break
</table>

注意：∪表示集合的并操作，∖表示集合的差操作。


注意：当一个循环的主体为空，或者一个for循环缺少初始化或更新语句时，就会出现空语句的情况。


在这个分析中：
- for循环被展开（参见[[#for-statement]]）
- while循环被展开（参见[[#while-statement]]）
- loop {s} 被处理为 loop {s continuing {}}
- 如果语句没有else分支，则处理为有一个空的else分支（其行为会添加Next）
- 如果语句有else if分支，则处理为嵌套的简单if/else语句
- 以default开头的switch语句的行为与以case _ 开头的switch语句相同

每个内置函数的行为为Next。
对于表格中未列出的运算符应用，其行为与使用相同操作数的函数调用相同，并且函数的行为为Next。


函数的行为必须遵守上述规则。


注意：分析表达式的行为是不必要的，因为它们总是Next，或者先前分析的函数会产生错误。

### 注意 ### {#behaviors-notes}

这节是信息性的，非规范性的。


行为分析可能会导致程序在以下方面被拒绝（重新陈述上述要求）：
- 一个函数的主体（被视为常规语句）具有不包含在 {Next, Return} 中的行为。
- 一个带有返回类型的函数的主体具有不为 {Return} 的行为。
- 一个持续块的行为包含任何一个Continue或Return。
- 一些明显无限循环的行为集为空，因此是无效的。

这个分析可以在线性时间内运行，通过自底向上分析调用图（因为一个函数调用的行为可能依赖于函数的代码）。

### 示例 ### {#behaviors-examples}

以下是一些示例展示了这种分析的效果：
<div class='example wgsl expect-error' heading='Trivially dead code is allowed'>
   <xmp>
    fn simple() -> i32 {
      var a: i32;
      return 0;  // Behavior: {Return}
      a = 1;     // Valid, statically unreachable code.
                 //   Statement behavior: {Next}
                 //   Overall behavior (due to sequential statements): {Return}
      return 2;  // Valid, statically unreachable code. Behavior: {Return}
    } // Function behavior: {Return}
   </xmp>
</div>

<div class='example wgsl expect-error' heading='Compound statements are supported'>
   <xmp>
    fn nested() -> i32 {
      var a: i32;
      {             // The start of a compound statement.
        a = 2;      // Behavior: {Next}
        return 1;   // Behavior: {Return}
      }             // The compound statement as a whole has behavior {Return}
      a = 1;        // Valid, statically unreachable code.
                    //   Statement behavior: {Next}
                    //   Overall behavior (due to sequential statements): {Return}
      return 2;     // Valid, statically unreachable code. Behavior: {Return}
    }
   </xmp>
</div>

<div class='example wgsl' heading='if/then behaves as if there is an empty else'>
   <xmp>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        }             // Behavior of the whole if compound statement: {Break, Next},
                      //   as the if has an implicit empty else
        a = a + 1;    // Valid, as the previous statement had "Next" in its behavior
      }
    }
   </xmp>
</div>

<div class='example wgsl expect-error' heading='if/then/else has the behavior of both sides'>
   <xmp>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        } else {
          continue;   // Behavior: {Continue}
        }             // Behavior of the whole if compound statement: {Break, Continue}
        a = a + 1;    // Valid, statically unreachable code.
                      //   Statement behavior: {Next}
                      //   Overall behavior: {Break, Continue}
      }
    }
   </xmp>
</div>

<div class='example wgsl' heading='if/else if/else behaves like a nested if/else'>
   <xmp>
    fn if_example() {
      var a: i32 = 0;
      loop {
        // if e1 s1 else if e2 s2 else s3
        // is identical to
        // if e1 else { if e2 s2 else s3 }
        if a == 5 {
          break;      // Behavior: {Break}
        } else if a == 42 {
          continue;   // Behavior: {Continue}
        } else {
          return;     // Behavior {Return}
        }             // Behavior of the whole if compound statement:
                      //   {Break, Continue, Return}
      }               // Behavior of the whole loop compound statement {Next, Return}
    }                 // Behavior of the whole function {Next}
   </xmp>
</div>

<div class='example wgsl' heading='Break in switch becomes Next'>
   <xmp>
    fn switch_example() {
      var a: i32 = 0;
      switch a {
        default: {
          break;   // Behavior: {Break}
        }
      }            // Behavior: {Next}, as switch replaces Break by Next
      a = 5;       // Valid, as the previous statement had Next in its behavior
    }
   </xmp>
</div>

<div class='example wgsl' heading='Obviously infinite loops'>
   <xmp>
    fn invalid_infinite_loop() {
      loop { }     // Behavior: { }.  Invalid because it's empty.
    }
   </xmp>
</div>

<div class='example wgsl' heading='Discard will not terminate a loop'>
  <xmp>
    fn invalid_infinite_loop() {
      loop {
        discard; // Behavior { Next }.
      }          // Invalid, behavior of the whole loop is { }.
    }
  </xmp>
</div>

<div class='example wgsl' heading='A conditional continue with continuing statement'>
   <xmp>
    fn conditional_continue() {
      var a: i32;
      loop {
        if a == 5 { break; } // Behavior: {Break, Next}
        if a % 2 == 1 {      // Valid, as the previous statement has Next in its behavior
          continue;          // Behavior: {Continue}
        }                    // Behavior: {Continue, Next}
        a = a * 2;           // Valid, as the previous statement has Next in its behavior
        continuing {         // Valid as the continuing statement has behavior {Next}
                             //  which does not include any of:
                             //  {Break, Continue, Return}
          a = a + 1;
        }
      }                      // The loop as a whole has behavior {Next},
                             //  as it absorbs "Continue" and "Next",
                             //  then replaces "Break" with "Next"
    }
   </xmp>
</div>

<div class='example wgsl' heading='A redundant continue with continuing statement'>
   <xmp>
    fn redundant_continue_with_continuing() {
      var a: i32;
      loop {
        if a == 5 { break; }
        continue;   // Valid. This is redundant, branching to the next statement.
        continuing {
          a = a + 1;
        }
      }
    }
   </xmp>
</div>

<div class='example wgsl' heading='A continue at the end of a loop body'>
   <xmp>
    fn continue_end_of_loop_body() {
      for (var i: i32 = 0; i < 5; i++ ) {
        continue;   // Valid. This is redundant,
                    //   branching to the end of the loop body.
      }             // Behavior: {Next},
                    //   as loops absorb "Continue",
                    //   and "for" loops always add "Next"
    }
   </xmp>
</div>
`for`循环会变成一个具有条件中断的loop。如前面的例子所示，条件中断拥有{Break, Next}的行为，这会导致在循环的行为中添加"Next"。

<div class='example wgsl expect-error' heading='return required in functions that have a return type'>
   <xmp>
    fn missing_return () -> i32 {
      var a: i32 = 0;
      if a == 42 {
        return a;       // Behavior: {Return}
      }                 // Behavior: {Next, Return}
    }                   // Error: Next is invalid in the body of a
                        //   function with a return type
   </xmp>
</div>

<div class='example wgsl expect-error' heading='continue must be in a loop'>
   <xmp>
    fn continue_out_of_loop () {
      var a: i32 = 0;
      if a > 0  {
        continue;       // Behavior: {Continue}
      }                 // Behavior: {Next, Continue}
    }                   // Error: Continue is invalid in the body of a function
   </xmp>
</div>
如果将continue替换为break，同样的例子也会因相同原因而无效。

# 函数 # {#functions}

当调用一个函数时，它会执行计算工作。


函数可以通过以下方式之一被调用：
* 通过评估函数调用表达式。见[[#function-call-expr]]。
* 通过执行函数调用语句。见[[#function-call-statement]]。
* 一个"入口点"函数通过WebGPU实现来执行"着色器阶段"在"管线"中的工作。见[[#entry-points]]。

有两种类型的函数：
* "内置函数"由WGSL实现提供，始终可用于WGSL模块。见[[#builtin-functions]]。
* "用户自定义函数"在WGSL模块中声明。

## 声明一个用户定义的函数n ## {#function-declaration-sec}

一个<dfn noexport>函数声明</dfn>通过指定以下内容创建一个<dfn noexport>用户定义函数</dfn>：
* 一个可选的[=属性=]集合。
* 函数的名称。
* 形式参数列表：一个有序的零个或多个[=形式参数=]声明，可以应用属性，由逗号分隔，并用括号括起来。
* 可选的<dfn noexport>返回类型</dfn>，可以应用属性。
* <dfn noexport>函数体</dfn>。这是在函数被[=函数调用|调用=]时要执行的一组语句。

函数声明[=着色器创建错误|必须=]只能在[=模块范围=]内发生。
函数名称在整个程序中[=处于作用域=]。


注意：每个[=用户定义函数=]只有一个[=重载=]。

一个【正式参数】的[声明]指定了一个标识符名称和一个类型，用于在调用函数时提供一个值。
一个正式参数可以具有属性。
参见【#function-calls】。
标识符的【作用域】是【函数体】。
对于给定函数，两个正式参数【不能】具有相同的名称。


注意：一些内置函数可能允许参数为【抽象数值类型】；然而，目前不支持用户声明函数的这种功能。


【返回类型】如果指定，【必须】是可构造的。

WGSL定义了可应用于函数声明的以下属性:
* [=shader stage attributes=]: [=attribute/vertex=], [=attribute/fragment=]和[=attribute/compute=]
* [=attribute/workgroup_size=]

WGSL定义了可应用于函数参数和返回类型的以下属性：
* [=attribute/builtin=]
* [=attribute/location=]
* [=attribute/interpolate=]
* [=attribute/invariant=]

<pre class=include>
path: syntax/function_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/function_header.syntax.bs.include
</pre>
<pre class=include>
path: syntax/param_list.syntax.bs.include
</pre>
<pre class=include>
path: syntax/param.syntax.bs.include
</pre>

<div class='example wgsl' heading='Simple functions'>
  <xmp>
    // Declare the add_two function.
    // It has two formal parameters, i and b.
    // It has a return type of i32.
    // It has a body with a return statement.
    fn add_two(i: i32, b: f32) -> i32 {
      return i + 2;  // A formal parameter is available for use in the body.
    }

    // A compute shader entry point function, 'main'.
    // It has no specified return type.
    // It invokes the add_two function, and captures
    // the resulting value in the named value 'six'.
    @compute @workgroup_size(1)
    fn main() {
       let six: i32 = add_two(4, 5.0);
    }
  </xmp>
</div>

## 函数调用 ## {#function-calls}

一个<dfn noexport>函数调用</dfn>是一个调用函数的语句或表达式。


包含函数调用的函数是<dfn>调用函数</dfn>，或者<dfn noexport>调用者</dfn>。
被调用的函数是<dfn>被调用函数</dfn>，或者<dfn noexport>被调用者</dfn>。


函数调用：
* 命名了[=被调用函数=]，并且
* 提供了一个用括号括起来的、逗号分隔的参数值表达式列表。

函数调用[=shader-creation error|必须=]提供与[=被调用函数=]中的[=形式参数|形式参数=]数量相同的参数值。
每个参数值[=shader-creation error|必须=]按位置与相应的形式参数具有相同的类型进行求值。


总之，当调用一个函数时：
1. [=调用函数=]的执行被暂停。
2. 被调用函数执行直到它[=返回=]。
3. [=调用函数=]的执行继续。

一个被调用的函数的返回方式如下：
* 内置函数在工作完成后返回。
* 带有返回类型的用户定义函数在执行return语句后返回。
* 没有返回类型的用户定义函数在执行return语句或达到函数体末尾时返回。

详细地说，当一个函数调用被执行时，以下步骤会发生：
1. 函数调用的参数值被求值。 参数值的相对顺序是从左到右。
1. 调用函数的执行被暂停。 所有的函数范围变量和常量保持其当前值。
1. 如果被调用的函数是用户定义函数，为该函数范围的每个变量分配内存。
1. 如[[#var-decls]]所述，进行初始化。
1. 被调用函数的形式参数值通过按位置匹配函数调用的参数值来确定。 例如，被调用函数的第一个形式参数将具有调用点的第一个参数的值。
1. 控制权转移到被调用函数。 如果被调用函数是用户定义函数，执行将从函数体的第一条语句开始。
1. 被调用函数被执行，直到它返回。
1. 控制权转回到调用函数，并且被调用函数的执行被恢复。 如果被调用函数有返回值，返回值将作为函数调用表达式的值提供。

函数调用的位置被称为调用点，特指在解析的syntax/call_phrase语法规则实例中首个令牌的位置。
调用点是一个动态上下文。
因此，相同的文本位置可能表示多个调用点。


注意：在一个片段着色器中，如果四个子像素中所有的执行都被丢弃，可能会导致函数调用永远不返回。
在这种情况下，控制权不会返回给调用函数。

## `const` 函数 ## {#const-funcs}

带有[=attribute/const=]属性声明的函数可以在着色器模块创建时进行评估。这些函数被称为<dfn noexport>const-functions（常量函数）</dfn>。对这些函数的调用可以作为[=const-expressions=]的一部分。


如果函数包含任何非[=const-expressions=]的表达式或任何非[=const-declarations=]的声明，则它将导致一个着色器创建错误。


注意：[=attribute/const=]属性不能应用于用户声明的函数。

<div class='example wgsl' heading='const-functions'>
  <xmp>
    const first_one = firstLeadingBit(1234 + 4567); // Evaluates to 12
                                                    // first_one has the type i32, because
                                                    // firstLeadingBit cannot operate on
                                                    // AbstractInt

    @id(1) override x : i32;
    override y = firstLeadingBit(x); // const-expressions can be
                                     // used in override-expressions.
                                     // firstLeadingBit(x) is not a
                                     // const-expression in this context.

    fn foo() {
      var a : array<i32, firstLeadingBit(257)>; // const-functions can be used in
                                                // const-expressions if all their
                                                // parameters are const-expressions.
    }
  </xmp>
</div>

## 功能限制 ## {#function-restriction}

一个顶点着色器[=shader-creation error|必须=]返回内置的值/位置内置的输出值。
* 入口点[=shader-creation error|不能=]成为函数调用的目标。
* 如果函数有返回类型，它[=shader-creation error|必须=]是可构造的类型。
* 函数的形参[=shader-creation error|必须=]是以下类型之一：
    * 可构造类型
    * 指针类型
    * 纹理类型
    * 采样器类型
* 每个函数调用参数[=shader-creation error|必须=]求值为对应的函数参数类型。
* 特别地，作为指针的参数[=shader-creation error|必须=]与形参在地址空间、存储类型和访问模式方面一致。
* 对于自定义函数，指针类型的参数[=shader-creation error|必须=]在以下地址空间之一：
    * 函数地址空间
    * 私有地址空间
* 对于内置函数，指针类型的参数[=shader-creation error|必须=]在以下地址空间之一：
    * 函数地址空间
    * 私有地址空间
    * 工作组地址空间
    * 存储地址空间
每个指向自定义函数的指针类型参数[=shader-creation error|必须=]具有与其根标识符相同的内存视图。
    * 注意：这意味着当从参数通过所有的let声明追溯回根标识符时，不能应用向量、矩阵、数组或结构访问表达式来产生根标识符的内存视图。

注意：不允许递归，因为不允许在任何类型的声明之间存在循环。

<div class='example wgsl' heading='Valid and invalid pointer arguments'>
  <xmp>
    fn bar(p : ptr<function, f32>) {
    }

    fn baz(p : ptr<private, i32>) {
    }

    fn bar2(p : ptr<function, f32>) {
      let a = &*&*(p);

      bar(p); // Valid
      bar(a); // Valid
    }

    struct S {
      x : i32
    }

    var usable_priv : i32;
    var unusable_priv : array<i32, 4>;
    fn foo() {
      var usable_func : f32;
      var unusable_func : S;

      let a_priv = &usable_priv;
      let b_priv = a_priv;
      let c_priv = &*&usable_priv;
      let d_priv = &(unusable_priv.x);
      let e_priv = d_priv;

      let a_func = &usable_func;
      let b_func = &unusable_func;
      let c_func = &(*b_func)[0];
      let d_func = c_func;
      let e_func = &*a_func;

      baz(&usable_priv); // Valid, address-of a variable.
      baz(a_priv);       // Valid, effectively address-of a variable.
      baz(b_priv);       // Valid, effectively address-of a variable.
      baz(c_priv);       // Valid, effectively address-of a variable.
      baz(d_priv);       // Invalid, memory view has changed.
      baz(e_priv);       // Invalid, memory view has changed.

      bar(&usable_func); // Valid, address-of a variable.
      bar(c_func);       // Invalid, memory view has changed.
      bar(d_func);       // Invalid, memory view has changed.
      bar(e_func);       // Valid, effectively address-of a variable.
    }
  </xmp>
</div>

### 别名分析 ### {#alias-analysis}

#### 根标识符 #### {#root-ident-sec}

[=Memory locations=] 在函数执行期间可以使用 [=memory views=] 进行访问。
在函数内部，每个 [=memory view=] 都有一个特定的【根标识符】，用于标识在该函数中首次提供对该内存的访问的变量或形式参数。


派生于函数内的【引用类型】或【指针类型】的本地表达式可能会为特定的根标识符引入新的名称，但是每个表达式都有一个静态可确定的根标识符。

<p algorithm="finding a root identifier">
给定一个类型为指针类型或引用类型的表达式|E|，"根标识符"是指在以下情况下找到的原始变量或形式参数的指针类型：
* 如果|E|是一个解析为变量的标识符，那么根标识符就是该变量。
* 如果|E|是一个解析为指针类型形式参数的标识符，那么根标识符就是该形式参数。
* 如果|E|是一个具有初始值|E2|的let-declaration的标识符，那么根标识符就是|E2|的根标识符。
* 如果|E|的形式是(|E2|)，&|E2|，*|E2|或|E2|[<var ignore>Ei</var>]，那么根标识符就是|E2|的根标识符。
* 如果|E|是具有形式|E2|.|swiz|的向量访问表达式，其中|swiz|是一个swizzle名称，那么根标识符就是|E2|的根标识符。
* 如果|E|是具有形式|E2|.<var ignore>member_name</var>的结构体访问表达式，那么根标识符就是|E2|的根标识符。
<p>

#### Aliasing #### {#aliasing}

虽然一个根标识符的来源变量是一个动态概念，取决于函数的调用点，但是可以静态地分析WGSL模块以确定每个根标识符的所有可能的来源变量集合。


当两个根标识符具有相同的来源变量时，它们被称为“别名”。
在WGSL函数的执行过程中，不能通过别名的根标识符可能访问内存，其中一个访问是写入访问，另一个访问是读取或写入访问。
这是通过从调用图的叶子到根的分析（即拓扑顺序）来确定的。
对于每个函数，分析记录以下集合：
* 在这个函数中调用的函数中写入的模块范围变量。
* 在这个函数中调用的函数中读取的模块范围变量。
* 作为内存视图的根标识符参数，在这个函数或调用的函数中被写入的。
* 作为内存视图的根标识符参数，在这个函数或调用的函数中被读取的。

在函数的每个调用点，如果出现以下情况之一，就会出现“shader-creation error”：
* 两个指针类型的参数具有相同的根标识符，并且相应的参数位于写入参数集合中。
* 指针类型的参数的根标识符是一个模块范围变量，其中：
    * 相应的指针参数位于写入指针参数集合中，并且
    * 模块范围变量位于被调用函数的读取集合中。
* 指针类型的参数的根标识符是一个模块范围变量，其中：
    * 相应的指针参数位于写入指针参数集合中，并且
    * 模块范围变量位于被调用函数的写入集合中。
* 指针类型的参数的根标识符是一个模块范围变量，其中：
    * 相应的指针参数位于读取指针参数集合中，并且
    * 模块范围变量位于被调用函数的写入集合中。

<div class='example wgsl' heading='Alias analysis'>
  <xmp>
    var<private> x : i32 = 0;

    fn f1(p1 : ptr<function, i32>, p2 : ptr<function, i32>) {
      *p1 = *p2;
    }

    fn f2(p1 : ptr<function, i32>, p2 : ptr<function, i32>) {
      f1(p1, p2);
    }

    fn f3() {
      var a : i32 = 0;
      f2(&a, &a);  // Invalid. Cannot pass two pointer parameters
                   // with the same root identifier when one or
                   // more are written (even by a subfunction).
    }

    fn f4(p1 : ptr<function, i32>, p2 : ptr<function, i32>) -> i32 {
      return *p1 + *p2;
    }

    fn f5() {
      var a : i32 = 0;
      let b = f4(&a, &a); // Valid. p1 and p2 in f4 are both only read.
    }

    fn f6(p : ptr<private, i32>) {
      x = *p;
    }

    fn f7(p : ptr<private, i32>) -> i32 {
      return x + *p;
    }

    fn f8() {
      let a = f6(&x); // Invalid. x is written as a global variable and
                      // read as a parameter.
      let b = f7(&x); // Valid. x is only read as both a parameter and
                      // a variable.
    }
  </xmp>
</div>

# 属性 # {#attributes}

一个属性修改一个对象。
WGSL提供了应用属性的统一语法。
属性用于各种不同的目的，比如指定与API的接口。


一般来说，从语言的角度来看，属性在类型和语义检查方面可以被忽略。
此外，属性名称是一个上下文相关的名称，一些属性参数也是上下文相关的名称。


除非在下面明确允许，否则一个属性不能在一个对象或类型中指定多次。

<table class=‘data’>
<caption>在WGSL中定义的属性</caption>
<thead>
<tr><th>属性<th>有效值<th>描述
</thead>


<tr><td><dfn noexport dfn-for=“attribute”>align</dfn>
<td>[=shader-creation error|必须=]是一个等于[=const-expression=]的表达式，该表达式的类型必须解析为[=i32=]或[=u32=]。<br>
[=shader-creation error|必须=]是正数。
<td>[=shader-creation error|必须=]只能应用于结构体类型的成员。


[=shader-creation error|必须=]是2的幂次。

注意：此属性影响封闭结构体类型的值在内存中的表现方式：
结构体本身和其组成成员在哪些字节地址上可以出现。
特别是，在[[#memory-layouts]]中的规则结合起来，暗示了以下约束：

<p class="note" algorithm="implied constraint on align attribute">
如果将 `align(`|n|`)` 应用于类型为 |T| 的 |S| 结构体的成员，
并且 |S| 是所在地址空间为 |C| 的变量的存储类型，或为存储类型，
则 |n| [shader-creation error|必须满足]=：
|n|&nbsp;=&nbsp;|k|&nbsp;&times;&nbsp;[=RequiredAlignOf=](|T|,|C|)
其中 |k| 是正整数。
</p>

<tr><td><dfn noexport dfn-for=“attribute”>binding</dfn>
<td>[=shader-creation error|必须=]是一个等于[=const-expression=]的表达式，该表达式的类型必须解析为[=i32=]或[=u32=]。<br>
[=shader-creation error|必须=]是非负数。
<td>[=shader-creation error|必须=]只能应用于资源变量。


指定绑定分组中资源的绑定号。
参见[[#resource-interface]]。

<tr><td><dfn noexport dfn-for=“attribute”>builtin</dfn>
<td>[=shader-creation error|必须=]是一个[=built-in value=]的[=enumerant=]。
<td>[=shader-creation error|必须=]只能应用于入口点函数参数、入口点返回类型或结构体的成员。


指定关联对象是一个内置值，由指定的[=enumerant=]表示。
参见[[#builtin-inputs-outputs]]。

<tr><td><dfn noexport dfn-for=“attribute”>const</dfn>
<td>无
<td>只能应用于函数声明。


指定该函数可以用作[=const-function=]。
该属性[=shader-creation error|不能=]应用于用户自定义函数。

注意：此属性用作描述可以在[=const-expressions=]中使用哪些内置函数的符号约定。

<tr><td><dfn noexport dfn-for=“attribute”>diagnostic</dfn>
<td>两个参数。


    第一个参数是一个[=syntax/severity_control_name=]。

    第二个参数是一个[=syntax/diagnostic_rule_name=]令牌，
    指定一个[=diagnostic/triggering rule=]。

<td>指定一个[=range diagnostic filter=]。参见[[#diagnostics]]。

    一个语法形式上可以指定多个[=attribute/diagnostic=]属性，
    但它们[=shader-creation error|必须区分]=不同的[=diagnostic/triggering rules=]。

<tr><td><dfn noexport dfn-for=“attribute”>group</dfn>
<td>[=shader-creation error|必须=]是一个等于[=const-expression=]的表达式，该表达式的类型必须解析为[=i32=]或[=u32=]。<br>
[=shader-creation error|必须=]是非负数。
<td>[=shader-creation error|必须=]只能应用于资源变量。


指定资源的绑定组。
参见[[#resource-interface]]。

<tr><td><dfn noexport dfn-for=“attribute”>id</dfn>
<td>[=shader-creation error|必须=]是一个等于[=const-expression=]的表达式，该表达式的类型必须解析为[=i32=]或[=u32=]。<br>
[=shader-creation error|必须=]是非负数。
<td>[=shader-creation error|必须=]只能应用于[=scalar=]类型的[=override-declaration=]。


指定一个数值标识符作为[=pipeline-overridable=]常量的替代名称。

<tr><td><dfn noexport dfn-for=“attribute”>interpolate</dfn>
<td>一个或两个参数。


第一个参数[=shader-creation error|必须=]是一个[=interpolation type=]的[=enumerant=]。

如果第二个参数存在，则第二个参数[=shader-creation error|必须=]是一个[=interpolation sampling=]的[=enumerant=]。

<td>[=shader-creation error|必须=]只能应用于具有[=attribute/location=]属性的声明。

指定如何对用户定义的IO进行插值。
该属性只对用户定义的[=vertex=]输出和[=fragment=]输入有效。
参见[[#interpolation]]。

<tr><td><dfn noexport dfn-for=“attribute”>invariant</dfn>
<td>无
<td>[=shader-creation error|必须=]只能应用于[=built-in values/position=]的内置值。


当应用于顶点着色器的内置输出值的内置输出值时，结果的计算在不同程序和相同入口点的不同调用之间是不变的。
也就是说，如果两个不同入口点中的`position`输出的数据和控制流匹配，则结果值保证相同。
对`position`的内置输入值没有影响。

注意：此属性映射到HLSL中的`precise`限定符，以及GLSL中的`invariant`限定符。
<tr><td><dfn noexport dfn-for=“attribute”>location</dfn>
<td>[=shader-creation error|必须]是一个解析为[=i32=]或[=u32=]的[=const-expression=]。<br>
[=shader-creation error|必须]为非负数。
<td>[=shader-creation error|必须]仅应用于入口点函数参数的声明，入口点返回类型，或[=structure=]类型的成员。
[=shader-creation error|必须]仅应用于具有[=numeric scalar=]或[=numeric vector=]类型的对象的声明。
不得与[=compute=]着色器阶段一起使用。


指定入口点的用户定义IO的一部分。
参见[[#input-output-locations]]。

<tr><td><dfn noexport dfn-for=“attribute”>must_use</dfn>
<td>None
<td>[=shader-creation error|必须]仅应用于具有[=return type=]的[=function/function=]的声明。


    指定对该函数的[=function call|调用=]必须用作[=expression=]。
    也就是说，对该函数的调用不能是一个[[#function-call-statement|函数调用语句]]的全部内容。

    注意：许多函数返回一个值并且没有副作用。
    将这样的函数作为函数调用语句中的唯一内容调用通常是编程缺陷。
    具有这些属性的内置函数被声明为`@ must_use`。
    用户定义的函数也可以具有`@ must_use`属性。

    注意：为了刻意规避`@ must_use`规则，使用[=phony assignment=]或使用函数调用作为初始化器[=value declaration|声明一个值=]。

<tr><td><dfn noexport dfn-for=“attribute”>size</dfn>
<td>[=shader-creation error|必须]为一个将解析为[=i32=]或[=u32=]的[=const-expression=]。<br>
[=shader-creation error|必须]为正数。
<td>[=shader-creation error|必须]仅应用于[=structure=]类型的成员。
成员类型[=shader-creation error|必须]具有[=creation-fixed footprint=]。


在结构体中为此成员保留的字节数。

此数值[=shader-creation error|必须]至少为成员类型的[=byte-size=]：
<p algorithm="byte-size constraint">
如果将`size(`|n|`)`应用于类型为|T|的成员，则[=SizeOf=](|T|)&nbsp;&leq;&nbsp;|n|。
</p>

参见[[#memory-layouts]]

<tr><td><dfn noexport dfn-for=“attribute”>workgroup_size</dfn>
<td>一个、两个或三个参数。


每个参数[=shader-creation error|必须]是一个[=const-expression=]或[=override-expression=]。
所有参数[=shader-creation error|必须]为相同的类型，要么是[=i32=]，要么是[=u32=]。

如果任何指定的参数是[=const-expression=]，且其计算结果为非正数值，则会产生[=shader-creation error=]。

如果任何指定的参数计算结果为非正数值，或超过WebGPU API指定的上限，或者参数值的乘积超过WebGPU API指定的上限，则会产生[=pipeline-creation error=]（参见[[WebGPU#limits]]）。
<td>[=shader-creation error|必须]应用于[=compute shader stage|compute shader=]的入口点函数。
不得应用于任何其他对象。

指定计算着色器的[=workgroup grid=]的x、y和z维度。

第一个参数指定了x维度。
如果提供了第二个参数，则指定了y维度；否则假定为1。
如果提供了第三个参数，则指定了z维度；否则假定为1。

</table>

以下的<dfn noexport>Shader阶段属性</dfn>将一个函数指定为特定Shader阶段的[=入口点=]。
这些属性[=着色器创建错误|必须=]只能应用于 [=函数声明=]，且一个函数上最多只能有一个该属性。
它们不带参数。

<table class=‘data’>
<caption>着色器阶段属性</caption>
<thead>
<tr><th>属性<th>描述
</thead>


<tr><td><dfn noexport dfn-for=“attribute”>vertex</dfn><br>
<td>声明该函数为[顶点着色器阶段]的入口点。


<tr><td><dfn noexport dfn-for=“attribute”>fragment</dfn><br>
<td>声明该函数为[片段着色器阶段]的入口点。


<tr><td><dfn noexport dfn-for=“attribute”>compute</dfn><br>
<td>声明该函数为[计算着色器阶段]的入口点。


</table>

<pre class=include>
path: syntax/attribute.syntax.bs.include
</pre>
<pre class=include>
path: syntax/attrib_end.syntax.bs.include
</pre>
<pre class=include>
path: syntax/diagnostic_control.syntax.bs.include
</pre>

# Entry Points # {#entry-points}

An <dfn noexport>entry point</dfn> is a [=user-defined function=] that performs
the work for a particular [=shader stage=].

## Shader Stages ## {#shader-stages-sec}

WebGPU issues work to the GPU in the form of [=draw command|draw=] or [=dispatch commands=].
These commands execute a pipeline in the context of a set of shader stage
[=shader stage input|inputs=], [=shader stage output|outputs=], and attached
[=resources=].

A <dfn noexport>pipeline</dfn> describes the work to be performed on the GPU, as a sequence
of stages, some of which are programmable.
In WebGPU, a pipeline is created before scheduling a draw or dispatch command for execution.
There are two kinds of pipelines: GPUComputePipeline, and GPURenderPipeline.

A [=dispatch command=] uses a <dfn noexport>GPUComputePipeline</dfn> to run a
<dfn noexport>compute shader stage</dfn> over a logical
grid of points with a controllable amount of parallelism,
while reading and possibly updating buffer and image resources.

A [=draw command=] uses a <dfn noexport>GPURenderPipeline</dfn> to run a multi-stage process with
two programmable stages among other fixed-function stages:

* A <dfn noexport>vertex shader stage</dfn> maps input attributes for a single vertex into
    output attributes for the vertex.
* Fixed-function stages map vertices into graphic primitives (such as triangles)
    which are then rasterized to produce fragments.
* A <dfn noexport>fragment shader stage</dfn> processes each fragment,
    possibly producing a fragment output.
* Fixed-function stages consume a fragment output, possibly updating external state
    such as color attachments and depth and stencil buffers.

The WebGPU specification describes pipelines in greater detail.

WGSL defines three <dfn noexport>shader stages</dfn>, corresponding to the
programmable parts of pipelines:

* <dfn noexport>compute</dfn>
* <dfn noexport>vertex</dfn>
* <dfn noexport>fragment</dfn>

Each shader stage has its own set of features and constraints, described elsewhere.

## Entry Point Declaration ## {#entry-point-decl}

To create an [=entry point=], declare a [=user-defined function=] with a [=shader stage attribute=].

When configuring a [=pipeline=] in the WebGPU API,
the entry point's function name maps to the `entryPoint` attribute of the
WebGPU {{GPUProgrammableStage}} object.

The entry point's [=formal parameters=] denote the stage's [=shader stage inputs=].
The entry point's [=return value=], if specified, denotes the stage's [=shader stage outputs=].

The type of each formal parameter, and the entry point's return type, [=shader-creation error|must=] be one of:
* [=bool=]
* a [=numeric scalar=]
* a [=numeric vector=]
* a [=structure=] whose member types are any of [=bool=], [=numeric scalar=], or [=numeric vector=].

A structure type can be used to group [=user-defined input datum|user-defined inputs=] with each other and optionally with [=built-in input value|built-in inputs=].
A structure type can be used as the [=return type=] to group [=user-defined output datum|user-defined outputs=] with each other and optionally with [=built-in output value|built-in outputs=].

Note: The [=bool=] case is forbidden for user-defined inputs and outputs.
It is only permitted for the [=built-in values|front_facing builtin value=].

Note: [=Compute=] entry points never have a return type.

<div class='example wgsl global-scope' heading='Entry Point'>
  <xmp>
    @vertex
    fn vert_main() -> @builtin(position) vec4<f32> {
      return vec4<f32>(0.0, 0.0, 0.0, 1.0);
    }

    @fragment
    fn frag_main(@builtin(position) coord_in: vec4<f32>) -> @location(0) vec4<f32> {
      return vec4<f32>(coord_in.x, coord_in.y, 0.0, 1.0);
    }

    @compute @workgroup_size(1)
    fn comp_main() { }
  </xmp>
</div>

The set of <dfn noexport>functions in a shader stage</dfn> is the union of:

* The entry point function for the stage.
* The targets of function calls from within the body of a function
    in the shader stage, whether or not that call is executed.

The union is applied repeatedly until it stabilizes.
It will stabilize in a finite number of steps.

### Function Attributes for Entry Points ### {#entry-point-attributes}

WGSL defines the following attributes that can be applied to entry point declarations:
 * the [=shader stage attributes=]: [=attribute/vertex=], [=attribute/fragment=], and [=attribute/compute=]
 * [=attribute/workgroup_size=]

<div class='example wgsl global-scope' heading='workgroup_size Attribute'>
  <xmp>
    @compute @workgroup_size(8,4,1)
    fn sorter() { }

    @compute @workgroup_size(8u)
    fn reverser() { }

    // Using an pipeline-overridable constant.
    @id(42) override block_width = 12u;
    @compute @workgroup_size(block_width)
    fn shuffler() { }

    // Error: workgroup_size must be specified on compute shader
    @compute
    fn bad_shader() { }
  </xmp>
</div>

## Shader Interface ## {#shader-interface}

The shader interface is the set of objects
through which the shader accesses data external to the [=shader stage=],
either for reading or writing, and the [=pipeline-overridable=] constants used to configure the shader.
The interface includes:

* [=Shader stage inputs=]
* [=Shader stage outputs=]
* [=Override-declarations=]
* Attached [=resources=], which include:
    * [=Uniform buffers=]
    * [=Storage buffers=]
    * [=Texture resources=]
    * [=Sampler resources=]

A declaration *D* is <dfn>statically accessed</dfn> by a shader when:
* An identifier [=resolves|resolving=] to *D* appears in the [=function declaration|declaration=]
    of any of the [=functions in a shader stage|functions in the shader stage=].
* An identifier [=resolves|resolving=] to *D* is used to define a type for a [=statically accessed=] declaration.
* An identifier [=resolves|resolving=] to *D* is used in the initializer for a [=statically accessed=] declaration.
* An identifier [=resolves|resolving=] to *D* is used by an attribute used by a [=statically accessed=] declaration.

<div class="note"><span class=marker>Note:</span>Static access is recursively defined, taking into account the following:
* All the parts of a [=function declaration=] including attributes, formal parameters, return type, and function body.
* Any type needed to define the above, including following [=type aliases=].
* As a particular case of helping to define a type,
    any [=override-declaration=] used in an [=override-expression=] that is the [=element count=]
    of an [=array=] type for a variable in the [=address spaces/workgroup=] address space,
    when that variable itself is statically accessed.
* Any override declarations used to support the evaluation of override-expressions in any of the above.
* Any attributes on any of the above.
    </div>

We can now precisely define the <dfn noexport>interface of a shader</dfn> as consisting of:
  - The [=formal parameters=] of the [=entry point=].
     These denote the shader stage inputs.
  - The [=return value=] of the entry point.
     This denotes the shader stage outputs.
  - The [=uniform buffer=], [=storage buffer=], [=texture resource=], and [=sampler resource=] variables
        [=statically accessed=] by the shader.
  - The [=override-declarations=]
        [=statically accessed=] by the shader.

### Inter-stage Input and Output Interface ### {#stage-inputs-outputs}

A <dfn>shader stage input</dfn> is a datum provided to the shader stage from upstream in the pipeline.
Each datum is either a [=built-in input value=], or a [=user-defined input datum|user-defined input=].

A <dfn>shader stage output</dfn> is a datum the shader provides for further processing downstream in the pipeline.
Each datum is either a [=built-in output value=], or a [=user-defined output datum|user-defined output=].

[=IO attributes=] are used to establish an object as a [=shader stage input=] or a [=shader stage output=],
or to further describe the properties of an input or output.
The <dfn noexport>IO attributes</dfn> are:
* [=attribute/builtin=]
* [=attribute/location=]
* [=attribute/interpolate=]
* [=attribute/invariant=]

#### Built-in Inputs and Outputs #### {#builtin-inputs-outputs}

A <dfn noexport>built-in input value</dfn> provides access to system-generated control information.
An entry point [=shader-creation error|must=] not contain duplicated built-in inputs.

A built-in input for stage *S* with name *X* and type *T*<sub>*X*</sub> is accessed via a
[=formal parameter=] to an [=entry point=] for [=shader stage=] *S*, in one of two ways:

1. The parameter has attribute `builtin(`*X*`)` and is of type *T*<sub>*X*</sub>.
2. The parameter has structure type, where one of the structure members has attribute `builtin(`*X*`)` and is of type *T*<sub>*X*</sub>.

Conversely, when a parameter or member of a parameter for an entry point has a [=attribute/builtin=] attribute,
the corresponding builtin [=shader-creation error|must=] be an input for the entry point's shader stage.

A <dfn noexport>built-in output value</dfn> is used by the shader to convey
control information to later processing steps in the pipeline.
An entry point [=shader-creation error|must=] not contain duplicated built-in outputs.

A built-in output for stage *S* with name *Y* and type *T*<sub>*Y*</sub> is set via the [=return value=] for an
[=entry point=] for [=shader stage=] *S*, in one of two ways:

1. The entry point [=return type=] has attribute `builtin(`*Y*`)` and is of type *T*<sub>*Y*</sub>.
2. The entry point [=return type=] has structure type, where one of the structure members has attribute `builtin(`*Y*`)` and is of type *T*<sub>*Y*</sub>.

Conversely, when the return type or member of a return type for an entry point has a [=attribute/builtin=] attribute,
the corresponding builtin [=shader-creation error|must=] be an output for the entry point's shader stage.

Note: The [=built-in values/position=] built-in is both an output of a vertex shader, and an input to the fragment shader.

Collectively, built-in input and built-in output values are known as <dfn noexport>built-in values</dfn>.

The following table summarizes the available built-in values.
Each is a [=predeclared=] [=enumerant=].
Each is described in detail in subsequent sections.

<table class='data'>
  <caption>Built-in input and output values</caption>
  <thead>
    <tr><th>Predeclared Name<th>Stage<th>Direction<th>Type
  </thead>

  <tr><td>[=built-in values/vertex_index=]
      <td>vertex
      <td>input
      <td>u32

  <tr><td>[=built-in values/instance_index=]
      <td>vertex
      <td>input
      <td>u32

  <tr><td rowspan=2>[=built-in values/position=]
      <td>vertex
      <td>output
      <td>vec4&lt;f32&gt;

  <tr>
      <td>fragment
      <td>input
      <td>vec4&lt;f32&gt;

  <tr><td>[=built-in values/front_facing=]
      <td>fragment
      <td>input
      <td>bool

  <tr><td>[=built-in values/frag_depth=]
      <td>fragment
      <td>output
      <td>f32

  <tr><td>[=built-in values/sample_index=]
      <td>fragment
      <td>input
      <td>u32

  <tr><td rowspan=2>[=built-in values/sample_mask=]
      <td>fragment
      <td>input
      <td>u32

  <tr>
      <td>fragment
      <td>output
      <td>u32

  <tr><td>[=built-in values/local_invocation_id=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;

  <tr><td>[=built-in values/local_invocation_index=]
      <td>compute
      <td>input
      <td>u32

  <tr><td>[=built-in values/global_invocation_id=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;

  <tr><td>[=built-in values/workgroup_id=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;

  <tr><td>[=built-in values/num_workgroups=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
</table>

<div class='example wgsl global-scope' heading="Declaring built-in values">
  <xmp>
    struct VertexOutput {
      @builtin(position) my_pos: vec4<f32>
    }

    @vertex
    fn vs_main(
      @builtin(vertex_index) my_index: u32,
      @builtin(instance_index) my_inst_index: u32,
    ) -> VertexOutput {}

    struct FragmentOutput {
      @builtin(frag_depth) depth: f32,
      @builtin(sample_mask) mask_out: u32
    }

    @fragment
    fn fs_main(
      @builtin(front_facing) is_front: bool,
      @builtin(position) coord: vec4<f32>,
      @builtin(sample_index) my_sample_index: u32,
      @builtin(sample_mask) mask_in: u32,
    ) -> FragmentOutput {}

    @compute @workgroup_size(64)
    fn cs_main(
      @builtin(local_invocation_id) local_id: vec3<u32>,
      @builtin(local_invocation_index) local_index: u32,
      @builtin(global_invocation_id) global_id: vec3<u32>,
   ) {}
  </xmp>
</div>

##### `frag_depth` ##### {#frag-depth-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">frag_depth</dfn>
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>f32
  <tr><td style="width:10%">Direction
      <td>Output
  <tr><td style="width:10%">Description
      <td>
      Updated depth of the fragment, in the viewport depth range.

      See [[WebGPU#coordinate-systems]].
</table>

##### `front_facing` ##### {#front-facing-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">front_facing</dfn>
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>bool
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      True when the current fragment is on a [=front-facing=] primitive.
      False otherwise.
</table>

##### `global_invocation_id` ##### {#global-invocation-id-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">global_invocation_id</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>vec3&lt;u32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The current invocation's [=global invocation ID=], i.e. its position in
      the [=compute shader grid=]. The value of [=built-in values/global_invocation_id=]
      is equal to [=built-in values/workgroup_id=] * [=attribute/workgroup_size=] +
      [=built-in values/local_invocation_id=].

</table>

##### `instance_index` ##### {#instance-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">instance_index</dfn>
  <tr><td style="width:10%">Stage
      <td>[=vertex shader stage|vertex=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      Instance index of the current vertex within the current API-level draw command.

      The first instance has an index equal to the `firstInstance` argument of the draw,
      whether provided directly or indirectly.
      The index is incremented by one for each additional instance in the draw.
</table>

##### `local_invocation_id` ##### {#local-invocation-id-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">local_invocation_id</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>vec3&lt;u32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The current invocation's [=local invocation ID=], i.e. its position in
      the [=workgroup grid=].
</table>

##### `local_invocation_index` ##### {#local-invocation-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">local_invocation_index</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The current invocation's [=local invocation index=], a linearized index of
      the invocation's position within the [=workgroup grid=].
</table>

##### `num_workgroups` ##### {#num-workgroups-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">num_workgroups</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>vec3&lt;u32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The [=dispatch size=], `vec3<u32>(group_count_x, group_count_y,
      group_count_z)`, of the compute shader
      [[WebGPU#compute-pass-encoder-dispatch|dispatched]] by the API.
</table>

##### `position` ##### {#position-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">position</dfn>
  <tr><td style="width:10%">Stage
      <td>[=vertex shader stage|vertex=]
  <tr><td style="width:10%">Type
      <td>vec4&lt;f32&gt;
  <tr><td style="width:10%">Direction
      <td>Output
  <tr><td style="width:10%">Description
      <td>
      The [=clip position=] of the current vertex,
      in [=clip space coordinates=].

      An output value (*x*,*y*,*z*,*w*)
      [=behavioral requirement|will=] map to (*x*/*w*, *y*/*w*, *z*/*w*) in
      WebGPU [=normalized device coordinates=].

      See [[WebGPU#coordinate-systems]] and [[WebGPU#primitive-clipping]].
</table>

<table class='data'>
  <tr><td style="width:10%">Name
      <td>position
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>vec4&lt;f32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      <div algorithm="fragment position calculation">
      Input position of the current fragment.

      Let |fp| be the input position of the fragment.<br>
      Let |rp| be the [=RasterizationPoint=] for the fragment.<br>
      Let |vp| be the {{RenderState/[[viewport]]}} in effect for the draw command.

      Then schematically:
      <blockquote>
      |fp|.xy = |rp|.[=rasterizationpoint-destination|destination=].[=fragmentdestination-position|position=]<br>
      |fp|.z = |rp|.[=rasterizationpoint-depth|depth=]<br>
      |fp|.w = |rp|.[=rasterizationpoint-perspectivedivisor|perspectiveDivisor=]
      </blockquote>

      In more detail:
      *  |fp|.x and |fp|.y are the interpolated x and y coordinates of the
          position the current fragment in
          the [=framebuffer=].

          The framebuffer is a two-dimensional grid of pixels with the top-left at (0.0,0.0)
          and the bottom right at (|vp|.width, |vp|.height).
          Each pixel has an extent of 1.0 unit in each of the x and y dimensions,
          and pixel centers are at (0.5,0.5) offset from integer coordinates.

      * |fp|.z is the interpolated depth of the current fragment.
          For example:
          * depth 0 in [=normalized device coordinates=] maps to |fp|.z = |vp|.minDepth,
          * depth 1 in normalized device coordinates maps to |fp|.z = |vp|.maxDepth.

      * |fp|.w is the perspective divisor for the fragment,
          which is the interpolation of 1.0 &divide; |vertex_w|,
          where |vertex_w| is the w component
          of the [=built-in values/position=] output of the vertex shader.

      See [[WebGPU#coordinate-systems]] and [[WebGPU#rasterization]].
      </div>
</table>

##### `sample_index` ##### {#sample-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">sample_index</dfn>
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      Sample index for the current fragment.  The value is least 0 and at most
      `sampleCount`-1, where `sampleCount` is the MSAA sample
      {{GPUMultisampleState/count}} specified for the GPU render pipeline.

      See [[WebGPU#gpurenderpipeline]].
</table>

##### `sample_mask` ##### {#sample-mask-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">sample_mask</dfn>
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      Sample coverage mask for the current fragment.  It contains a bitmask
      indicating which samples in this fragment are covered by the primitive
      being rendered.

      See [[WebGPU#sample-masking]].
</table>

<table class='data'>
  <tr><td style="width:10%">Name
      <td>sample_mask
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Output
  <tr><td style="width:10%">Description
      <td>
      Sample coverage mask control for the current fragment.  The last value
      written to this variable becomes the [=shader-output mask=].  Zero bits
      in the written value will cause corresponding samples in the color
      attachments to be discarded.

      See [[WebGPU#sample-masking]].
</table>

##### `vertex_index` ##### {#vertex-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">vertex_index</dfn>
  <tr><td style="width:10%">Stage
      <td>[=vertex shader stage|vertex=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      Index of the current vertex within the current API-level draw command,
      independent of draw instancing.

      For a non-indexed draw, the first vertex has an index equal to the `firstVertex` argument
      of the draw, whether provided directly or indirectly.
      The index is incremented by one for each additional vertex in the draw instance.

      For an indexed draw, the index is equal to the index buffer entry for the
      vertex, plus the `baseVertex` argument of the draw, whether provided directly or indirectly.
</table>

##### `workgroup_id` ##### {#workgroup-id-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">workgroup_id</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>vec3&lt;u32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The current invocation's [=workgroup ID=], i.e. the position of the
      workgroup in overall [=compute shader grid=].

      All invocations in the same workgroup have the same workgroup ID.

      Workgroup IDs span from (0,0,0) to ([=group_count_x=] - 1,
      [=group_count_y=] - 1, [=group_count_z=] - 1).
</table>

#### User-defined Inputs and Outputs #### {#user-defined-inputs-outputs}

User-defined data can be passed as input to the start of a pipeline, passed
between stages of a pipeline or output from the end of a pipeline.

Each <dfn noexport>user-defined input datum</dfn> and
<dfn noexport>user-defined output datum</abbrev></dfn> [=shader-creation error|must=]:
* be of [=numeric scalar=] type or [=numeric vector=] type.
* be assigned an IO location. See [[#input-output-locations]].


A [=compute=] shader [=shader-creation error|must not=] have user-defined inputs or outputs.

#### Input-output Locations #### {#input-output-locations}

Each input-output location can store a value up to 16 bytes in size.
The byte size of a type is defined using the *SizeOf* column in [[#alignment-and-size]].
For example, a four-component vector of floating-point values occupies a single location.

IO locations are specified via the [=attribute/location=] attribute.

Each user-defined [=user-defined input datum|input=] and [=user-defined output datum|output=] [=shader-creation error|must=] have an explicitly specified IO location.
Each structure member in the entry point IO [=shader-creation error|must=] be one of either a built-in value
(see [[#builtin-inputs-outputs]]), or assigned a location.

Locations [=shader-creation error|must not=] overlap within each of the following sets:
* Members within a structure type.
    This applies to any structure, not just those used in shader stage inputs or outputs.
* An entry point's shader stage inputs,
    i.e. locations for its formal parameters, or for the members of its formal parameters of structure type.

Note: Location numbering is distinct between inputs and outputs:
Location numbers for an entry point's shader stage inputs do not conflict with location numbers for the entry point's shader stage outputs.

Note: No additional rule is required to prevent location overlap within an entry point's outputs.
When the output is a structure, the first rule above prevents overlap.
Otherwise, the output is a scalar or a vector, and can have only a single location assigned to it.

Note: The number of available locations for an entry point is defined by the WebGPU API.

<div class='example wgsl applying location attribute' heading='Applying location attributes'>
  <xmp>
    struct A {
      @location(0) x: f32,
      // Despite locations being 16-bytes, x and y cannot share a location
      @location(1) y: f32
    }

    // in1 occupies locations 0 and 1.
    // in2 occupies location 2.
    // The return value occupies location 0.
    @fragment
    fn fragShader(in1: A, @location(2) in2: f32) -> @location(0) vec4<f32> {
     // ...
    }
  </xmp>
</div>

User-defined IO can be mixed with built-in values in the same structure. For example,

<div class='example wgsl mixing builtins and user-defined IO' heading='Mixing builtins and user-defined IO'>
  <xmp>
    // Mixed builtins and user-defined inputs.
    struct MyInputs {
      @location(0) x: vec4<f32>,
      @builtin(front_facing) y: bool,
      @location(1) @interpolate(flat) z: u32
    }

    struct MyOutputs {
      @builtin(frag_depth) x: f32,
      @location(0) y: vec4<f32>
    }

    @fragment
    fn fragShader(in1: MyInputs) -> MyOutputs {
      // ...
    }
  </xmp>
</div>

<div class='example wgsl invalid locations' heading='Invalid location assignments'>
  <xmp>
    struct A {
      @location(0) x: f32,
      // Invalid, x and y cannot share a location.
      @location(0) y: f32
    }

    struct B {
      @location(0) x: f32
    }

    struct C {
      // Invalid, structures with user-defined IO cannot be nested.
      b: B
    }

    struct D {
      x: vec4<f32>
    }

    @fragment
    // Invalid, location cannot be applied to a structure type.
    fn fragShader1(@location(0) in1: D) {
      // ...
    }

    @fragment
    // Invalid, in1 and in2 cannot share a location.
    fn fragShader2(@location(0) in1: f32, @location(0) in2: f32) {
      // ...
    }

    @fragment
    // Invalid, location cannot be applied to a structure.
    fn fragShader3(@location(0) in1: vec4<f32>) -> @location(0) D {
      // ...
    }
  </xmp>
</div>

#### Interpolation #### {#interpolation}

Authors can control how user-defined IO data is interpolated through the use of
the [=attribute/interpolate=] attribute.
WGSL offers two aspects of interpolation to control: the type of
interpolation, and the sampling of the interpolation.

The <dfn noexport>interpolation type</dfn> [=shader-creation error|must=] be one of the following [=predeclared=] [=enumerants=]:
: <dfn for="interpolation type">perspective</dfn>
:: Values are interpolated in a perspective correct manner.
: <dfn for="interpolation type">linear</dfn>
:: Values are interpolated in a linear, non-perspective correct manner.
: <dfn for="interpolation type">flat</dfn>
:: Values are not interpolated.
    Interpolation sampling is not used with `flat` interpolation.

The <dfn noexport>interpolation sampling</dfn> [=shader-creation error|must=] be one of the following [=predeclared=] [=enumerants=]:
: <dfn for="interpolation sampling">center</dfn>
:: Interpolation is performed at the center of the pixel.
: <dfn for="interpolation sampling">centroid</dfn>
:: Interpolation is performed at a point that lies within all the
    samples covered by the fragment within the current primitive.
    This value is the same for all samples in the primitive.
: <dfn for="interpolation sampling">sample</dfn>
:: Interpolation is performed per sample.
    The [=fragment=] shader is invoked once per sample when this attribute is
    applied.

For user-defined IO of scalar or vector floating-point type:
* If the interpolation attribute is not specified, then `@interpolate(perspective, center)` is assumed.
* If the interpolation attribute is specified with an interpolation type:
    * If the interpolation type is `flat`, then interpolation sampling [=shader-creation error|must not=] be specified.
    * If the interpolation type is `perspective` or `linear`, then:
         * Any interpolation sampling is valid.
         * If interpolation sampling is not specified, `center` is assumed.

User-defined [=vertex=] outputs and [=fragment=] inputs of scalar or vector
integer type [=shader-creation error|must=] always be specified as
`@interpolate(flat)`.

Interpolation attributes [=shader-creation error|must=] match between [=vertex=] outputs and [=fragment=]
inputs with the same [=attribute/location=] assignment within the same [=pipeline=].


### Resource Interface ### {#resource-interface}

A <dfn noexport>resource</dfn> is an object which provides access to data external to a [=shader stage=],
and which is not an [=override-declaration=] and not a [[#stage-inputs-outputs|shader stage input or output]].
Resources are shared by all invocations of the shader.

There are four kinds of resources:

* [=Uniform buffers=]
* [=Storage buffers=]
* [=Texture resources=]
* [=Sampler resources=]

The <dfn noexport>resource interface of a shader</dfn> is the set of module-scope
resource variables [=statically accessed=] by
[=functions in a shader stage|functions in the shader stage=].

Each resource variable [=shader-creation error|must=] be declared with both [=attribute/group=] and [=attribute/binding=]
attributes.
Together with the shader's stage, these identify the binding address
of the resource on the shader's pipeline.
See [[WebGPU#gpupipelinelayout]].

Two different resource variables in a [=shader=] [=shader-creation error|must
not=] have the same [=attribute/group=] and [=attribute/binding=] values, when
considered as a pair.

### Resource Layout Compatibility ### {#resource-layout-compatibility}

WebGPU requires that a shader's resource interface match the [[WebGPU#gpupipelinelayout|layout of the pipeline]]
using the shader.

It is a [=pipeline-creation error=] if a WGSL variable in a resource interface is bound to an incompatible WebGPU
[=binding resource type=] or [=binding type=],
where compatibility is defined by the following table.
<table class='data'>
  <caption>WebGPU binding type compatibility</caption>
  <thead>
    <tr><th>WGSL resource
        <th>WebGPU<br>[=binding resource type|resource type=]
        <th>WebGPU [=binding member=]
        <th colspan=2>WebGPU [=binding type=]
  </thead>
  <tr><td>[=uniform buffer=]
      <td rowspan=3>{{GPUBufferBinding}}
      <td rowspan=3>{{GPUBindGroupLayoutEntry/buffer}}
      <td rowspan=3>GPUBufferBindingType
      <td>{{GPUBufferBindingType/"uniform"}}
  <tr><td>[=storage buffer=] with [=access/read_write=] access
      <td>{{GPUBufferBindingType/"storage"}}
  <tr><td>[=storage buffer=] with [=access/read=] access
      <td>{{GPUBufferBindingType/"read-only-storage"}}
  <tr><td rowspan=2>[=type/sampler=]
      <td rowspan=3>{{GPUSampler}}
      <td rowspan=3>{{GPUBindGroupLayoutEntry/sampler}}
      <td rowspan=3>GPUSamplerBindingType
      <td>{{GPUSamplerBindingType/"filtering"}}
  <tr>
      <td>{{GPUSamplerBindingType/"non-filtering"}}
  <tr><td>[=type/sampler_comparison=]
      <td>{{GPUSamplerBindingType/"comparison"}}
  <tr><td rowspan=5>[=type/sampled texture=],
                    [=type/depth texture=], or
                    [=type/multisampled texture=]
      <td rowspan=5>{{GPUTextureView}}
      <td rowspan=5>{{GPUBindGroupLayoutEntry/texture}}
      <td rowspan=5>GPUTextureSampleType
      <td>{{GPUTextureSampleType/"float"}}
  <tr>
      <td>{{GPUTextureSampleType/"unfilterable-float"}}
  <tr>
      <td>{{GPUTextureSampleType/"sint"}}
  <tr>
      <td>{{GPUTextureSampleType/"uint"}}
  <tr>
      <td>{{GPUTextureSampleType/"depth"}}
  <tr><td>[=type/write-only storage texture=]
      <td rowspan=3>{{GPUTextureView}}
      <td rowspan=3>{{GPUBindGroupLayoutEntry/storageTexture}}
      <td rowspan=3>{{GPUStorageTextureAccess}}
      <td>{{GPUStorageTextureAccess/"write-only"}}
  <tr><td>[=type/read-write storage texture=]
      <td>{{GPUStorageTextureAccess/"read-write"}}
  <tr><td>[=type/read-only storage texture=]
      <td>{{GPUStorageTextureAccess/"read-only"}}
  <tr><td>[=type/external texture=]
      <td>{{GPUExternalTexture}}
      <td>{{GPUBindGroupLayoutEntry/externalTexture}}
      <td colspan=2>(not applicable)
</table>

See the [$validating GPUProgrammableStage|WebGPU API$]
specification for interface validation requirements.

### Buffer Binding Determines Runtime-Sized Array Element Count ### {#buffer-binding-determines-runtime-sized-array-element-count}

When a [=storage buffer=] variable contains a [=runtime-sized=] array, then the number of elements in that array
is determined from the size of the corresponding {{GPUBufferBinding}}:

<blockquote algorithm="element count of runtime-sized array">
* Let |T| be the [=store type=] for a [=storage buffer=] variable,
    where |T| is a [=runtime-sized=] array type or contains a runtime-sized array type.
* Let |EBS| be the
    [=effective buffer binding size=]
    for the {{GPUBufferBinding}} bound to the pipeline binding address corresponding to the storage buffer variable.
* Then <dfn noexport>NRuntime</sub></dfn>, i.e.
    the number of elements in the runtime-sized array,
    is the largest integer such that [=SizeOf=](|T|) &le; |EBS|.

</blockquote>

In more detail, the [=NRuntime=] for a runtime-size array of type *RAT* is:
<blockquote algorithm="element count of runtime-sized array, expanded">
[=truncate=]((EBBS &minus; *array_offset*) &divide; *array_stride*), where:
* EBBS is the [=effective buffer binding size=] associated with the variable,
* *array_offset* is the byte offset of the runtime-sized array within the store type of the variable.
    * It is zero if the store type is |RAT|, the runtime-sized array type itself.
    * Otherwise the store type is a structure, and its last member is the runtime-sized array.
        In this case *array_offset* is the [=OffsetOfMember|byte offset of that member=] within the structure.
* *array_stride* is the stride of the array type, i.e. [=StrideOf=](|RAT|).

</blockquote>

A shader can compute [=NRuntime=] via the [[#arrayLength-builtin|arrayLength]] builtin function.

<div class=note>
<span class=marker>Note:</span>
This algorithm is unambiguous:
When a runtime-sized array is part of a larger type, it may only appear as the last element of a structure,
which itself cannot be part of an enclosing array or structure.

[=NRuntime=] is determined by the size of the corresponding buffer binding, and that can be different for each [=draw command|draw=]
or [=dispatch command=].

WebGPU validation rules ensure that 1 &le; [=NRuntime=].

</div>


<div class=note>
In the following code sample:
* The `weights` variable is a [=storage buffer=].
* Its store type is the runtime-sized arry type `array<f32>`.
* The array offset is 0.
* The array stride is [=StrideOf=](array&lt;f32&gt;), which is 4.

<div class='example wgsl' heading='number of elements in a simple runtime sized array'>
  <xmp>
@group(0) @binding(1) var<storage> weights: array<f32>;
  </xmp>
</div>

The following table shows examples of [=NRuntime=] for the `weights` variable, based on
the corresponding effective buffer binding size.

<table class='data'>
  <caption>Example number of elements for simple runtime-sized array</caption>
  <thead>
    <tr><th style="width:15%">Effective buffer binding size<th>NRuntime for `weights` variable<td>Calculation
  </thead>
  <tr><td>1024<td>256<td>[=truncate=]( 1024 &divide; 4 )
  <tr><td>1025<td>256<td>[=truncate=]( 1025 &divide; 4 )
  <tr><td>1026<td>256<td>[=truncate=]( 1026 &divide; 4 )
  <tr><td>1027<td>256<td>[=truncate=]( 1027 &divide; 4 )
  <tr><td>1028<td>257<td>[=truncate=]( 1028 &divide; 4 )
</table>
</div>

<div class=note>
In the following code sample:
* The `lights` variable is a [=storage buffer=].
* Its store type is `LightStorage`.
* The `point` member of `LightStorage` is a runtime-sized array of type `array<PointLight>`.
    * The member is at byte offset 16 in the variable's storage.
    * The array stride is [=StrideOf=](array&lt;`PointLight`&gt;) = [=roundUp=]([=AlignOf=](`PointLight`),[=SizeOf=](`PointLight`)) = [=roundUp=](16,32) = 32

<div class='example wgsl' heading='number of elements in a complex runtime sized array'>
  <xmp>
struct PointLight {                          //             align(16) size(32)
  position : vec3f,                          // offset(0)   align(16) size(12)
  // -- implicit member alignment padding -- // offset(12)            size(4)
  color : vec3f,                             // offset(16)  align(16) size(12)
  // -- implicit struct size padding --      // offset(28)            size(4)
}

struct LightStorage {                        //             align(16)
  pointCount : u32,                          // offset(0)   align(4)  size(4)
  // -- implicit member alignment padding -- // offset(4)             size(12)
  point : array<PointLight>,                 // offset(16)  align(16) elementsize(32)
}

@group(0) @binding(1) var<storage> lights : LightStorage;
  </xmp>
</div>

The following table shows examples of [=NRuntime=] for the `point` member of the `lights` variable.

<table class='data'>
  <caption>Example number of elements for complex runtime-sized array</caption>
  <thead>
    <tr><th style="width:15%">Effective buffer binding size<th>NRuntime for `point` member of `lights` variable<td>Calculation
  </thead>
  <tr><td>1024<td>31<td>[=truncate=]( ( 1024 - 16 ) &divide; 32) )
  <tr><td>1025<td>31<td>[=truncate=]( ( 1025 - 16 ) &divide; 32) )
  <tr><td>1039<td>31<td>[=truncate=]( ( 1039 - 16 ) &divide; 32) )
  <tr><td>1040<td>32<td>[=truncate=]( ( 1040 - 16 ) &divide; 32) )
  </thead>
</table>
</div>

# Memory # {#memory}

In WGSL, a value of [=storable=] type may be stored in memory, for later retrieval.
This section describes the structure of memory, and the semantics of operations accessing memory.
See [[#memory-views]] for the types of values that can be placed in memory, and the types used to perform memory accesses.

## Memory Locations ## {#memory-locations-section}

Memory consists of a set of distinct <dfn noexport>memory locations</dfn>.
Each memory location is 8-bits in size.
An operation affecting memory interacts with a set of one or more memory locations.
Memory operations on [=composites=] [=behavioral requirement|will not=]
access padding memory locations.
Therefore, the set of memory locations accessed by an operation may not be contiguous.

Two sets of memory locations <dfn noexport>overlap</dfn> if the intersection of
their sets of memory locations is non-empty.

## Memory Access Mode ## {#memory-access-mode}

A <dfn noexport>memory access</dfn> is an operation that acts on [=memory locations=].

* A <dfn noexport>read access</dfn> observes the contents of memory locations.
* A <dfn noexport>write access</dfn> sets the contents of memory locations.

A single operation can read, write, or both read and write.

Particular memory locations may support only certain kinds of accesses, expressed
as the memory's <dfn noexport>access mode</dfn>.

<table class='data'>
  <caption>Access Modes</caption>
  <thead>
    <tr><th>Access mode
        <th>Supported accesses
  </thead>
  <tr><td><dfn noexport dfn-for="access">read</dfn>
      <td>Supports read accesses, but not writes.
  <tr><td><dfn noexport dfn-for="access">write</dfn>
      <td>Supports write accesses, but not reads.
  <tr><td><dfn noexport dfn-for="access">read_write</dfn>
      <td>Supports both read and write accesses.
</table>

WGSL [=predeclared|predeclares=] the [=enumerants=] `read`, `write`, and `read_write`.

## Address Spaces ## {#address-space}

Memory locations are partitioned into <dfn noexport>address spaces</dfn>.
Each address space has unique properties determining
mutability, visibility, the values it may contain,
and how to use variables with it.
See [[#var-and-value]] for more details.

The access mode of a given [=memory view=] is often determined by context:

The [=address spaces/storage=] address spaces supports both [=access/read=] and
[=access/read_write=] access modes.
Each other address space supports only one access mode.
The default access mode for each address space is described in the following
table.

<table class='data'>
  <caption>Address Spaces</caption>
  <thead>
    <tr><th>Address space
        <th>Sharing among invocations
        <th>Default access mode
        <th>Notes
  </thead>
  <tr><td><dfn noexport dfn-for="address spaces">function</dfn>
      <td>Same invocation only
      <td>[=access/read_write=]
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">private</dfn>
      <td>Same invocation only
      <td>[=access/read_write=]
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">workgroup</dfn>
      <td>Invocations in the same [=compute shader stage|compute shader=] [=compute shader stage/workgroup=]
      <td>[=access/read_write=]
      <td>The [=element count=] of an outermost array may be a [=pipeline-overridable=] constant.
  <tr><td><dfn noexport dfn-for="address spaces">uniform</dfn>
      <td>Invocations in the same [=shader stage=]
      <td>[=access/read=]
      <td>For [=uniform buffer=] variables
  <tr><td><dfn noexport dfn-for="address spaces">storage</dfn>
      <td>Invocations in the same [=shader stage=]
      <td>[=access/read=]
      <td>For [=storage buffer=] variables
  <tr><td><dfn noexport dfn-for="address spaces">handle</dfn>
      <td>Invocations in the same shader stage
      <td>[=access/read=]
      <td>For [=sampler resource|sampler=] and [=texture resource|texture=] variables.<br>
</table>

WGSL [=predeclared|predeclares=] an [=enumerant=] for each address space, except for the `handle` address space.

[=Variables=] in the [=address spaces/workgroup=] address space
[=shader-creation error|must=] only be [=statically accessed=] in a [=compute
shader stage=].

[=Variables=] in the [=address spaces/storage=] address space ([=storage
buffers=]) can only be [=statically accessed=] by a [=vertex shader stage=] if the access mode is [=access/read=]. 
Variables whose [=store type=] is a [=type/storage texture=] with a
[=access/write=] or [=access/read_write=] [=access mode=] cannot be
[=statically accessed=] by a [=vertex shader stage=].
See WebGPU {{GPUDevice/createBindGroupLayout()}}.

Note: Each address space may have different performance characteristics.

When writing a [=variable declaration=] or a [=pointer type=] in WGSL source:
* For the [=address spaces/storage=] address space, the access mode is optional, and defaults to [=access/read=].
* For other address spaces, the access mode [=shader-creation error|must not=] be written.

## Memory Layout ## {#memory-layouts}

The layout of types in WGSL is independent of [=address space=].
Strictly speaking, however, that layout can only be observed by host-shareable
buffers.
[=Uniform buffer=] and [=storage buffer=] variables are used to share
bulk data organized as a sequence of bytes in memory.
Buffers are shared between the CPU and the GPU, or between different shader stages
in a pipeline, or between different pipelines.

Because buffer data are shared without reformatting or translation, it is a
[=dynamic error=] if buffer producers and consumers do not agree on the <dfn
noexport>memory layout</dfn>, which is the description of how the bytes in a
buffer are organized into typed WGSL values.
These bytes are [=memory locations=] of a value relative to a common base
location.

The [=store type=] of a buffer variable [=shader-creation error|must=] be
[=host-shareable=], with fully elaborated memory layout, as described below.

Each buffer variable [=shader-creation error|must=] be declared in either the
[=address spaces/uniform=] or [=address spaces/storage=] address spaces.

The memory layout of a type is significant only when evaluating an expression with:
* a variable in the [=address spaces/uniform=] or [=address spaces/storage=] address space, or
* a pointer into the [=address spaces/uniform=] or [=address spaces/storage=] address space.

An 8-bit byte is the most basic unit of [=host-shareable=] memory.
The terms defined in this section express counts of 8-bit bytes.

We will use the following notation:
* <dfn noexport>AlignOf</dfn>(|T|) is the [=alignment=] of host-shareable type |T|.
* <dfn noexport>AlignOfMember</dfn>(|S|, |i|) is the alignment of the |i|'th member of the host-shareable structure |S|.
* <dfn noexport>SizeOf</dfn>(|T|) is the [=byte-size=] of host-shareable type |T|.
* <dfn noexport>SizeOfMember</dfn>(|S|, |i|) is the size of the |i|'th member of the host-shareable structure |S|.
* <dfn noexport>OffsetOfMember</dfn>(|S|, |i|) is the offset of the |i|'th member from the start of the host-shareable structure |S|.
* <dfn noexport>StrideOf</dfn>(|A|) is the <dfn>element stride</dfn> of host-shareable array type |A|, defined
    as the number of bytes from the start of one array element to the start of the next element.
    It equals the size of the array's element type, rounded up to the alignment of the element type:
        <p algorithm="array element stride">
          [=StrideOf=](array<|E|, |N|>) = [=roundUp=]([=AlignOf=](E), [=SizeOf=](E))<br>
          [=StrideOf=](array<|E|>) = [=roundUp=]([=AlignOf=](E), [=SizeOf=](E))
        </p>

### Alignment and Size ###  {#alignment-and-size}

Each [=host-shareable=] or [=fixed footprint=] data type |T| has an alignment and size.

The <dfn>alignment</dfn> of a type is a constraint on where values of that type
may be placed in memory, expressed as an integer:
a type's alignment [=shader-creation error|must=] evenly divide
the byte address of the starting [=memory location=] of a value of that type.
Alignments enable use of more efficient hardware instructions for accessing the values,
or satisfy more restrictive hardware requirements on certain
address spaces. (See [address space layout constraints](#address-space-layout-constraints)).

Note: Each alignment value is always a power of two, by construction.

The <dfn>byte-size</dfn> of a type or structure member is the number of contiguous bytes
reserved in host-shareable memory for the purpose of storing a value of the type
or structure member.
The size may include non-addressable padding at the end of the type.
Consequently, loads and stores of a value might access fewer memory locations
than the value's size.

Alignment and size of [=host-shareable=] types are defined recursively in the
following table:

<table class='data'>
  <caption>
    Alignment and size for host-shareable types<br>
  </caption>
  <thead>
    <tr><th>Host-shareable type |T|
        <th>[=AlignOf=](|T|)
        <th>[=SizeOf=](|T|)
  </thead>
  <tr><td>[=i32=], [=u32=], or [=f32=]
      <td>4
      <td>4
  <tr><td>[=f16=]
      <td>2
      <td>2
  <tr><td>[=atomic type|atomic&lt;|T|&gt;=]
      <td>4
      <td>4
  <tr><td>[=vector|vec=]2&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>8
      <td>8
  <tr><td>vec2&lt;f16&gt;
      <td>4
      <td>4
  <tr><td>vec3&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>12
  <tr><td>vec3&lt;f16&gt;
      <td>8
      <td>6
  <tr><td>vec4&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>16
  <tr><td>vec4&lt;f16&gt;
      <td>8
      <td>8
  <tr><td>[=matrix|mat=]|C|x|R| (col-major)<br>
      <p class="small">(General form)</p>
      <td>[=AlignOf=](vec|R|)
      <td>[=SizeOf=](array&lt;vec|R|, |C|&gt;)
  <tr><td>mat2x2&lt;f32&gt;
      <td>8
      <td>16
  <tr><td>mat2x2&lt;f16&gt;
      <td>4
      <td>8
  <tr><td>mat3x2&lt;f32&gt;
      <td>8
      <td>24
  <tr><td>mat3x2&lt;f16&gt;
      <td>4
      <td>12
  <tr><td>mat4x2&lt;f32&gt;
      <td>8
      <td>32
  <tr><td>mat4x2&lt;f16&gt;
      <td>4
      <td>16
  <tr><td>mat2x3&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x3&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x3&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x3&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x3&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x3&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>mat2x4&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x4&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x4&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x4&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x4&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x4&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>[=structure|struct=] |S| with members M<sub>1</sub>...M<sub>N</sub>
      <td>max([=AlignOfMember=](S,1), ... , [=AlignOfMember=](S,N))<br>
      <td>[=roundUp=]([=AlignOf=](|S|), justPastLastMember)<br><br>
          where justPastLastMember = [=OffsetOfMember=](|S|,N) + [=SizeOfMember=](|S|,N)
  <tr><td>[=array=]<|E|, |N|><br>
      <td>[=AlignOf=](|E|)
      <td>|N| &times; [=roundUp=]([=AlignOf=](|E|), [=SizeOf=](|E|))
  <tr><td>array<|E|><br>
      <td>[=AlignOf=](|E|)
      <td>[=NRuntime=] &times; [=roundUp=]([=AlignOf=](|E|),[=SizeOf=](|E|))<br><br>
          where NRuntime is the runtime-determined number of elements of |T|
</table>

### Structure Member Layout ###  {#structure-member-layout}

The internal layout of a [=structure=] is computed from the sizes and alignments of its members.
By default, the members are arranged tightly, in order, without overlap, while satisfying member alignment
requirements.

This default internal layout can be overriden by using <dfn noexport>layout attributes</dfn>, which are:

* [=attribute/size=]
* [=attribute/align=]

The |i|'th member of structure type |S| has a size and alignment, denoted
by [=SizeOfMember=](|S|, |i|) and [=AlignOfMember=](|S|, |i|), respectively.
The member sizes and alignments are used to calculate each member's byte offset from the start of the structure,
as described in [[#internal-value-layout]].

<p algorithm="structure member size">
  [=SizeOfMember=](|S|, |i|) is |k| if the |i|'th member of |S| has attribute [=attribute/size=](|k|).
  Otherwise, it is [=SizeOf=](|T|) where |T| is the type of the member.
</p>

<p algorithm="structure member alignment">
  [=AlignOfMember=](|S|, |i|) is |k| if the |i|'th member of |S| has attribute [=attribute/align=](|k|).
  Otherwise, it is [=AlignOf=](|T|) where |T| is the type of the member.
</p>

If a structure member has the [=attribute/size=] attribute applied, the
value [=shader-creation error|must=] be at least as large as the size of the
member's type:

<p algorithm="member size constraint">
  [=SizeOfMember=](|S|, |i|) &ge; [=SizeOf=](T)<br>
  Where |T| is the type of the |i|'th member of |S|.
</p>

The first structure member always has a zero byte offset from the start of the
structure:
<p algorithm="offset of first structure member">
  [=OffsetOfMember=](<var ignore>S</var>, 1) = 0
</p>

Each subsequent member is placed at the lowest offset that satisfies the member type alignment,
and which avoids overlap with the previous member.
For each member index |i| > 1:
<p algorithm="structure member offset">
  [=OffsetOfMember=](|S|, |i|) = [=roundUp=]([=AlignOfMember=](|S|, |i| ), [=OffsetOfMember=](|S|, |i|-1) + [=SizeOfMember=](|S|, |i|-1))<br>
</p>

<div class='example wgsl' heading='Layout of structures using implicit member sizes and alignments'>
  <xmp>
    struct A {                                     //             align(8)  size(24)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        x: f32                                     // offset(16)  align(4)  size(4)
        // -- implicit struct size padding --      // offset(20)            size(4)
    }

    struct B {                                     //             align(16) size(160)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(4)
        e: A,                                      // offset(40)  align(8)  size(24)
        f: vec3<f32>,                              // offset(64)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(76)            size(4)
        g: array<A, 3>,    // element stride 24       offset(80)  align(8)  size(72)
        h: i32                                     // offset(152) align(4)  size(4)
        // -- implicit struct size padding --      // offset(156)           size(4)
    }

    @group(0) @binding(0)
    var<storage,read_write> storage_buffer: B;
  </xmp>
</div>

<div class='example wgsl' heading='Layout of structures with explicit member sizes and alignments'>
  <xmp>
    struct A {                                     //             align(8)  size(32)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        @size(16) x: f32                           // offset(16)  align(4)  size(16)
    }

    struct B {                                     //             align(16) size(208)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(12)
        @align(16) e: A,                           // offset(48)  align(16) size(32)
        f: vec3<f32>,                              // offset(80)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(92)            size(4)
        g: array<A, 3>,    // element stride 32       offset(96)  align(8)  size(96)
        h: i32                                     // offset(192) align(4)  size(4)
        // -- implicit struct size padding --      // offset(196)           size(12)
    }

    @group(0) @binding(0)
    var<uniform> uniform_buffer: B;
  </xmp>
</div>

### Array Layout Examples ###  {#array-layout-examples}

<div class='example wgsl function-scope' heading='Fixed-size array layout examples'>
  <xmp>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = roundUp(4,4)
    //   - size is 32 = stride * number_of_elements = 4 * 8
    var small_stride: array<f32, 8>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    //   - size is 128 = stride * number_of_elements = 16 * 8
    var bigger_stride: array<vec3<f32>, 8>;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Runtime-sized array layout examples'>
  <xmp>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = 4
    // If B is the effective buffer binding size for the binding on the
    // draw or dispatch command, the number of elements is:
    //   N_runtime = floor(B / element stride) = floor(B / 4)
    @group(0) @binding(0)
    var<storage> weights: array<f32>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    // If B is the effective buffer binding size for the binding on the
    // draw or dispatch command, the number of elements is:
    //   N_runtime = floor(B / element stride) = floor(B / 16)
    var<storage> directions: array<vec3<f32>>;
  </xmp>
</div>

### Internal Layout of Values ###  {#internal-value-layout}

This section describes how the internals of a value are placed in the byte locations
of a buffer, given an assumed placement of the overall value.
These layouts depend on the value's type,
and the [=attribute/align=] and [=attribute/size=] attributes on structure members.

The buffer byte offset at which a value is placed [=shader-creation
error|must=] satisfy the type alignment requirement: If a value of type |T| is
placed at buffer offset |k|, then |k| = |c| &times; [=AlignOf=](|T|), for some
non-negative integer |c|.

The data [=behavioral requirement|will=] appear identically regardless of the address space.

When a value |V| of type [=u32=] or [=i32=] is placed at byte offset |k| of a
host-shared buffer, then:
   * Byte |k| contains bits 0 through 7 of |V|
   * Byte |k|+1 contains bits 8 through 15 of |V|
   * Byte |k|+2 contains bits 16 through 23 of |V|
   * Byte |k|+3 contains bits 24 through 31 of |V|

Note: Recall that [=i32=] uses twos-complement representation, so the sign bit
is in bit position 31.

A value |V| of type [=f32=] is represented in [[!IEEE-754|IEEE-754]] binary32 format.
It has one sign bit, 8 exponent bits, and 23 fraction bits.
When |V| is placed at byte offset |k| of host-shared buffer, then:
   * Byte |k| contains bits 0 through 7 of the fraction.
   * Byte |k|+1 contains bits 8 through 15 of the fraction.
   * Bits 0 through 6 of byte |k|+2 contain bits 16 through 22 of the fraction.
   * Bit 7 of byte |k|+2 contains bit 0 of the exponent.
   * Bits 0 through 6 of byte |k|+3 contain bits 1 through 7 of the exponent.
   * Bit 7 of byte |k|+3 contains the sign bit.

A value |V| of type [=f16=] is represented in [[!IEEE-754|IEEE-754]] binary16 format.
It has one sign bit, 5 exponent bits, and 10 fraction bits.
When |V| is placed at byte offset |k| of host-shared buffer, then:
   * Byte |k| contains bits 0 through 7 of the fraction.
   * Bits 0 through 1 of byte |k|+1 contain bits 8 through 9 of the fraction.
   * Bits 2 through 6 of byte |k|+1 contain bits 0 through 4 of the exponent.
   * Bit 7 of byte |k|+1 contains the sign bit.

Note: The above rules imply that numeric values in host-shared buffers
are stored in little-endian format.

When a value |V| of [=atomic type=] `atomic`&lt;|T|&gt; is placed in a host-shared buffer,
it has the same internal layout as a value of the underlying type |T|.

When a value |V| of [=vector|vector type=] vec|N|&lt;|T|&gt; is placed at
byte offset |k| of a host-shared buffer, then:
   * |V|.x is placed at byte offset |k|
   * |V|.y is placed at byte offset |k| + [=SizeOf=](|T|)
   * If |N| &ge; 3, then |V|.z is placed at byte offset |k| + 2 &times; [=SizeOf=](|T|)
   * If |N| &ge; 4, then |V|.w is placed at byte offset |k| + 3 &times; [=SizeOf=](|T|)

When a value |V| of [=matrix|matrix type=] mat|C|x|R|&lt;|T|&gt; is placed at
byte offset |k| of a host-shared buffer, then:
  * Column vector |i| of |V| is placed at byte offset |k| + |i| &times; [=AlignOf=](vec|R|&lt;|T|&gt;)

When a value of [=array|array type=] |A| is placed at byte offset |k| of a host-shared memory buffer,
then:
   * Element |i| of the array is placed at byte offset |k| + |i| &times; [=StrideOf=](|A|)

When a value of [=structure|structure type=] |S| is placed at byte offset |k| of a host-shared memory buffer,
then:
   * The |i|'<sup>th</sup> member of the structure value is placed at byte offset |k| + [=OffsetOfMember=](|S|,|i|).
    See [[#structure-member-layout]].

### Address Space Layout Constraints ###  {#address-space-layout-constraints}

The [=address spaces/storage=] and [=address spaces/uniform=] address spaces
have different buffer layout constraints which are described in this section.

Note: All [=address spaces=] except [=address spaces/uniform=] have the same
constraints as the [=address spaces/storage=] address space.

All structure and array types directly or indirectly referenced by a variable
[=shader-creation error|must=] obey the constraints of the variable's address space.
Violations of an address space constraint results in a [=shader-creation error=].

In this section we define <dfn noexport>RequiredAlignOf</dfn>(|S|, |C|) as the
byte offset [=alignment=] requirement of values of host-shareable type |S| when
used in address space |C|.

<table class='data'>
  <caption>
    Alignment requirements of a host-shareable type for
    [=address spaces/storage=] and [=address spaces/uniform=] address spaces
  </caption>
  <thead>
    <tr><th>Host-shareable type |S|
        <th>[=RequiredAlignOf=](|S|, [=address spaces/storage=])
        <th>[=RequiredAlignOf=](|S|, [=address spaces/uniform=])
  </thead>
  <tr><td>[=i32=], [=u32=], [=f32=], or [=f16=]
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=atomic types|atomic=]&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=vector|vec=]N&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of a matrix with C columns and R rows">
      <td>[=matrix|mat=]CxR&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of an array">
      <td>[=array=]&lt;T, N&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of an runtime-sized array">
      <td>array&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of a structure">
      <td>[=structure|struct=] |S|
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))<br>
</table>

Structure members of type |T| [=shader-creation error|must=] have a byte offset
from the start of the structure that is a multiple of the [=RequiredAlignOf=](|T|, |C|)
for the address space |C|:

<p algorithm="structure member minimum alignment">
    [=OffsetOfMember=](|S|, |M|) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    Where |k| is a positive integer and |M| is a member of structure |S| with type |T|
</p>

Arrays of element type |T| [=shader-creation error|must=] have an [=element stride=] that is a
multiple of the [=RequiredAlignOf=](|T|, |C|) for the address space |C|:

<p algorithm="array element minimum alignment">
    [=StrideOf=](array<|T|, |N|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    [=StrideOf=](array<|T|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    Where |k| is a positive integer
</p>

Note: [=RequiredAlignOf=](|T|, |C|) does not impose any additional restrictions
on the values permitted for an [=attribute/align=] attribute, nor does it affect the rules
of [=AlignOf=](|T|). Data is laid out with the rules defined in previous
sections and then the resulting layout is validated against the
[=RequiredAlignOf=](|T|, |C|) rules.

The [=address spaces/uniform=] address space also requires that:
* Array elements are aligned to 16 byte boundaries.
    That is, [=StrideOf=](array&lt;|T|,|N|&gt;) = 16 &times; |k|' for some positive integer |k|'.
* If a structure member itself has a structure type `S`, then the number of
    bytes between the start of that member and the start of any following member
    [=shader-creation error|must=] be at least [=roundUp=](16, [=SizeOf=](S)).

Note: The following examples show how to use [=attribute/align=] and [=attribute/size=] attributes
on structure members to satisfy layout requirements for uniform buffers.
In particular, these techniques can be used mechanically transform a GLSL buffer with std140 layout
to WGSL.

<div class='example wgsl global-scope' heading='Satisfying offset requirements for uniform address space'>
  <xmp>
    struct S {
      x: f32
    }
    struct Invalid {
      a: S,
      b: f32 // invalid: offset between a and b is 4 bytes, but must be at least 16
    }
    @group(0) @binding(0) var<uniform> invalid: Invalid;

    struct Valid {
      a: S,
      @align(16) b: f32 // valid: offset between a and b is 16 bytes
    }
    @group(0) @binding(1) var<uniform> valid: Valid;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Satisfying stride requirements for uniform address space'>
  <xmp>
    struct small_stride {
      a: array<f32,8> // stride 4
    }
    // Invalid, stride must be a multiple of 16
    @group(0) @binding(0) var<uniform> invalid: small_stride;

    struct wrapped_f32 {
      @size(16) elem: f32
    }
    struct big_stride {
      a: array<wrapped_f32,8> // stride 16
    }
    @group(0) @binding(1) var<uniform> valid: big_stride;     // Valid
  </xmp>
</div>

## Memory Model ## {#memory-model}

In general, WGSL follows the [[!VulkanMemoryModel|Vulkan Memory Model]].
The remainder of this section describes how WGSL programs map to the
Vulkan Memory Model.

Note: The Vulkan Memory Model is a textual version of a [formal Alloy
model](https://github.com/KhronosGroup/Vulkan-MemoryModel/blob/master/alloy/spirv.als).

### Memory Operation ### {#memory-operation}

In WGSL, a [=read access=] is equivalent to a memory read operation in
the Vulkan Memory Model.
In WGSL, a [=write access=] is equivalent to a memory write operation in
the Vulkan Memory Model.

A [=read access=] occurs when an invocation executes one of the following:
* An evaluation of the [=Load Rule=]
* Any [[#texture-builtin-functions|texture builtin function]] except:
    * [[#texturedimensions|textureDimensions]]
    * [[#texturestore|textureStore]]
    * [[#texturenumlayers|textureNumLayers]]
    * [[#texturenumlevels|textureNumLevels]]
    * [[#texturenumsamples|textureNumSamples]]
* Any atomic built-in function except [[#atomic-store|atomicStore]]
* A [[#workgroupUniformLoad-builtin|workgroupUniformLoad]] built-in function
* A [=compound assignment=] statement (for the [=left-hand side=] expression)

A [=write access=] occurs when an invocation executes one of the following:
* An [=statement/assignment=] statement ([=simple assignment|simple=] or
    [=compound assignment|compound=] for the [=left-hand side=] expression)
* A [[#texturestore|textureStore]] built-in function
* Any atomic built-in function except [[#atomic-load|atomicLoad]]
    * [[#atomic-rmw|atomicCompareExchangeWeak]] only performs a write if the
        `exchanged` member of the returned result is `true`

[[#atomic-rmw|Atomic read-modify-write]] built-in functions perform a single
memory operation that is both a [=read access=] and a [=write access=].

Read and write accesses do not occur under any other circumstances.
Read and write accesses are collectively known as [=memory model memory
operation|memory operations=] in the Vulkan Memory Model.

A memory operation accesses exactly the set of [=memory location|locations=]
associated with the particular [=memory view=] used in the operation.  For
example, a memory read that accesses a [=u32=] from a struct containing
multiple members, only reads the memory locations associated with that u32
member.

Note: A write access to a component of a vector **may** access all memory locations
associated with that vector.

<div class='example wgsl memory locations accessed' heading="Accessing memory locations">
  <xmp>
    struct S {
      a : f32,
      b : u32,
      c : f32
    }

    @group(0) @binding(0)
    var<storage> v : S;

    fn foo() {
      let x = v.b; // Does not access memory locations for v.a or v.c.
    }
  </xmp>
</div>

### Memory Model Reference ### {#memory-model-reference}

Each module-scope [=resource=] variable forms a [=memory model reference=] for
the unique [=attribute/group=] and [=attribute/binding=] pair.
Each other variable (i.e. variables in the [=address spaces/function=],
[=address spaces/private=], and [=address spaces/workgroup=] address spaces)
forms a unique [=memory model reference=] for the lifetime of the variable.

### Scoped Operations ### {#scoped-operations}

When an invocation performs a scoped operation, it will affect one or two sets
of invocations.
These sets are the memory scope and the execution scope.  The <dfn
noexport>memory scope</dfn> specifies the set of invocations that will see any
updates to memory contents affected by the operation.
For [[#sync-builtin-functions|synchronization built-in functions]], this also
means that all affected memory operations program ordered before the function
are visible to affected operations program ordered after the function.
The <dfn noexport>execution scope</dfn> specifies the set of invocations which
may participate in an operation (see [[#collective-operations]]).

[[#atomic-builtin-functions|Atomic built-in functions]] map to [=memory model atomic
operation|atomic operations=] whose memory [=memory model scope|scope=] is:
* `Workgroup` if the atomic pointer is in the [=address spaces/workgroup=]
    address space
* `QueueFamily` if the atomic pointer is in the [=address spaces/storage=]
    address space

[[#sync-builtin-functions|Synchronization built-in functions]] map to control
barriers whose execution and memory [=memory model scope|scopes=] are
`Workgroup`.

Implicit and explicit [[#derivatives|derivatives]] have an implicit [=quad=]
execution scope.

Note: If the Vulkan memory model is not enabled in generated shaders, `Device`
scope should be used instead of `QueueFamily`.

### Memory Semantics ### {#memory-semantics}

All [[#atomic-builtin-functions|Atomic built-in functions]] use `Relaxed`
[=memory model memory semantics|memory semantics=] and, thus, no storage class
semantics.

Note: Address space in WGSL is equivalent to storage class in SPIR-V.

[[#sync-builtin-functions|workgroupBarrier]] uses `AcquireRelease` [=memory
model memory semantics|memory semantics=] and `WorkgroupMemory` semantics.
[[#sync-builtin-functions|storageBarrier]] uses `AcquireRelease` [=memory model
memory semantics|memory semantics=] and `UniformMemory` semantics.
[[#sync-builtin-functions|textureBarrier]] uses `AcquireRelease` [=memory model
memory semantics|memory semantics=] and `ImageMemory` semantics.

Note: A combined `workgroupBarrier` and `storageBarrier` uses `AcquireRelease`
ordering semantics and both `WorkgroupMemory` and `UniformMemory` memory
semantics.

Note: No atomic or synchronization built-in functions use `MakeAvailable` or
`MakeVisible` semantics.

### Private vs Non-private ### {#private-vs-non-private}

All non-atomic [=read accesses=] in the [=address spaces/storage=] or
[=address spaces/workgroup=] address spaces are considered
[=memory model non-private|non-private=] and correspond to read operations with
`NonPrivatePointer | MakePointerVisible` memory operands with the `Workgroup`
scope.

All non-atomic [=write accesses=] in the [=address spaces/storage=] or
[=address spaces/workgroup=] address spaces are considered
[=memory model non-private|non-private=] and correspond to write operations
with `NonPrivatePointer | MakePointerAvailable` memory operands with the
`Workgroup` scope.

# Execution # {#execution}

[[#overview]] describes how a shader is invoked and partitioned into [=invocations=].
This section describes further constraints on how invocations execute,
individually and collectively.

## Program Order Within an Invocation ## {#program-order}

Each statement in a WGSL module may be executed zero or more times during
execution.
For a given invocation, each execution of a given statement represents a unique
<dfn noexport>dynamic statement instance</dfn>.

When a statement includes an expression, the statement’s semantics determines:
* Whether the expression is evaluated as part of statement execution.
* The relative ordering of evaluation between independent expressions in the statement.

Expression nesting defines data dependencies which must be satisfied to
complete evaluation.
That is, a nested expression must be evaluated before the enclosing expression
can be evaluated.
The order of evaluation for operands of an expression is left-to-right in
WGSL.
For example, `foo() + bar()` must evaluate `foo()` before `bar()`.
See [[#expressions]].

Statements in a WGSL module are executed in control flow order.
See [[#statements]] and [[#function-calls]].

## Uniformity ## {#uniformity}

A [[#collective-operations|collective operation]]
(e.g. barrier, derivative, or a texture operation relying on an implicitly computed derivative)
requires coordination among different invocations running concurrently on the GPU.
The operation executes correctly and portably
when all invocations execute it concurrently, i.e. in [=uniform control flow=].

Conversely, incorrect or non-portable behavior occurs when a strict subset of invocations
execute the operation, i.e. in non-uniform control flow.
Informally, some invocations reach the collective operation, but others do not,
or not at the same time, as a result of non-uniform control dependencies.
Non-uniform control dependencies arise from [[#control-flow|control flow]]
statements whose behavior depends on [=uniform value|non-uniform values=].

> For example, a non-uniform control dependency arises when different invocations compute
    different values for the condition of an
    [=statement/if=], [=statement/break-if=], [=statement/while=], or [=statement/for=],
    different values for the selector of a [=statement/switch=],
    or the left-hand operand of a short-circuiting binary operator (`&&` or `||`).

These non-uniform values can often be traced back to certain sources that are not
statically proven to be uniform.
These sources include, but are not limited to:
* Mutable [=module scope|module-scope=] [=variables=]
* Most [=built-in values=], except [=built-in values/num_workgroups=] and [=built-in values/workgroup_id=]
* [=user-defined input datum|User-defined inputs=]
* Certain [=built-in functions=] (see [[#uniformity-function-calls]])

To ensure correct and portable behavior, a WGSL implementation [=behavioral requirement|will=]
perform a static <dfn>uniformity analysis</dfn>, attempting to prove that each collective operation
executes in [=uniform control flow=].
Subsequent subsections describe the analysis.

A <dfn noexport>uniformity failure</dfn> [=behavioral requirement|will=] be triggered
when [=uniformity analysis=] cannot prove that a particular [[#collective-operations|collective operation]] executes in [=uniform control flow=].
* If a uniformity failure is triggered for a
    [=builtin functions that compute a derivative|builtin function that computes a derivative=], then
    a [=trigger/derivative_uniformity=] [=diagnostic=] is [=triggered=].
    * The diagnostic's [=diagnostic/triggering location=] is the location of the [=call site=] of that builtin.
    * The diagnostic's [=diagnostic/severity=] defaults to an [=severity/error=] but can be controlled with a [=diagnostic filter=].
* If a uniformity failure is triggered for a [[#sync-builtin-functions|synchronization builtin]],
    an [=severity/error=] [=diagnostic=] is [=triggered=],
    which results in a [=shader-creation error=].

### Terminology and Concepts ### {#uniformity-concepts}

The following definitions are merely informative, trying to give an intuition for what the analysis in the next subsection is computing.
The analysis is what actually defines these concepts, and when a program is valid or breaks the uniformity rules.

For a given group of invocations:
- If all invocations in a given scope execute as if they are executing in lockstep at a given
    point in the program, that point is said to have <dfn noexport>uniform control flow</dfn>.
    - For a [=compute shader stage=], the scope of uniform control flow is all invocations
        in the same [=compute shader stage/workgroup=].
    - For other shader stages, the scope of uniform control flow is all invocations for that
        [=entry point=] in the same [=draw command=].
- If an expression is executed in uniform control flow, and all invocations compute the
    same value, it is said to be a <dfn noexport>uniform value</dfn>.
- If invocations hold the same value for a local variable at every point where it is live,
    it is said to be a <dfn noexport>uniform variable</dfn>.

### Uniformity Analysis Overview ### {#uniformity-overview}

The remaining subsections specify a static analysis that verifies that
[[#collective-operations|collective operations]] are only executed in [=uniform
control flow=].

The analysis assumes [=dynamic errors=] do not occur.
A shader stage with a [=dynamic error=] is already non-portable, no matter the outcome
of uniformity analysis.

<div class="note"><span class=marker>Note:</span>This analysis has the following desirable properties:
      - Sound, meaning that a [=uniformity failure=] [=behavioral requirement|will=] be triggered for a program that would break the uniformity requirements of builtins.
      - Linear time complexity, in the number of tokens in the program.
      - Refactoring a piece of code into a function, or inlining a function, cannot make a shader invalid if it was valid before the transformation.
      - If the analysis refuses a program, it provides a straightforward chain of implications that can be used by the user agent to craft a good error message.
</div>

Each function is analyzed, trying to ensure two things:
    * Uniformity requirements are satisfied when it calls other functions, and
    * Uniformity requirements are satisfied whenever it is called.
A [=uniformity failure=] is triggered if either of these two checks fail.

As part of this work, the analysis computes metadata about the function to help analyze its callers in turn.
This means that the call graph must first be built, and functions must be analyzed from the leaves upwards, i.e. from functions that call no function outside the standard library toward the entry point.
This way, whenever a function is analyzed, the metadata for all of its callees has already been computed.
There is no risk of being trapped in a cycle, as recurrence is forbidden in the language.

Note: Another way of saying the same thing is that we do a topological sort of functions ordered by the "is a (possibly indirect) callee of" partial order, and analyze them in that order.

Additionally, for each function call, the analysis computes and propagates
the set of [=diagnostic/triggering rules=], if any, that would be triggered if that call cannot be proven to be in uniform control flow.
We call this the <dfn noexport>potential-trigger-set</dfn> for the call.
The elements of this set are drawn from two possibilites:
* [=trigger/derivative_uniformity=], for functions relying on computing a derivative, or
* an unnamed triggering rule, for the uniformity requirements that cannot be filtered.
    * This is used for compute shader functions relying on [[#sync-builtin-functions|synchronization functions]].

### Analyzing the Uniformity Requirements of a Function ### {#uniformity-function}

Each function is analyzed in two phases.

The first phase walks over the syntax of the function, building a directed graph along the way based on the rules in the following subsections.
The second phase explores that graph, computing the constraints on calling this function,
and potentially triggering a [=uniformity failure=].

<div class="note"><span class=marker>Note:</span>Apart from four special nodes
    [=RequiredToBeUniform.error=],
    [=RequiredToBeUniform.warning=],
    [=RequiredToBeUniform.info=], and [=MayBeNonUniform=], each node can be understood as capturing the truth-value one of the following statements:
        - A specific point of the program must be executed in [=uniform control flow=].
        - An expression must be a [=uniform value=].
        - A variable must be a [=uniform variable=].
        - A value stored in memory, that could be loaded via a pointer, must be a [=uniform value=].

        An edge can be understood as an implication from the statement corresponding to its source node to the statement corresponding to its target node.

        For example, one uniformity requirement is that the `workgroupBarrier` builtin function must only be called within uniform control flow.
        To express this, we add an edge from [=RequiredToBeUniform.error=] to the node corresponding to the `workgroupBarrier` [=call site=].
        One way to understand this is that [=RequiredToBeUniform.error=] corresponds to the proposition True,
        so that [=RequiredToBeUniform.error=] -> X is the same as saying that X is true.

        Reciprocally, to express that we cannot ensure the uniformity of something (e.g. a variable which holds the thread id), we add an edge from the corresponding node to [=MayBeNonUniform=].
        One way to understand this, is that [=MayBeNonUniform=] corresponds to the proposition False, so that X -> [=MayBeNonUniform=] is the same as saying that X is false.

        A consequence of this interpretation is that every node reachable from [=RequiredToBeUniform.error=] corresponds to
        something which is required to be uniform for the program to be valid, and every node from which
        [=MayBeNonUniform=] is reachable corresponds to something whose uniformity we cannot guarantee.
        It follows that we have a uniformity violation, triggering a [=uniformity failure=], if there is any
        path from [=RequiredToBeUniform.error=] to [=MayBeNonUniform=].

        The nodes [=RequiredToBeUniform.warning=] and [=RequiredToBeUniform.info=] are used in a similar way,
        but instead help determine when [=severity/warning=] or [=severity/info=] [=diagnostics=] should be triggered:
        *   If there is a path from [=RequiredToBeUniform.warning=] to [=MayBeNonUniform=], then a [=severity/warning=]
            [=diagnostic=] will be triggered.
        *   If there is a path from [=RequiredToBeUniform.info=] to [=MayBeNonUniform=], then an [=severity/info=]
            [=diagnostic=] will be triggered.

        As described in [[#diagnostics]], lower severity diagnostics may be discarded if higher severity diagnostics have also been generated.
</div>

For each function, two tags are computed:
  * A <dfn noexport>call site tag</dfn> describing the control flow uniformity requirements on the [=call sites=] of the function, and
  * A <dfn noexport>function tag</dfn> describing the function's effects on uniformity.

For each [=formal parameter=] of a function, one or two tags are computed:
  * A <dfn noexport>parameter tag</dfn> describes the uniformity requirement of the parameter value.
  * A <dfn noexport>parameter return tag</dfn> describes how the uniformity of the parameter influences that of the function's [=return value=].
  * A <dfn noexport>pointer parameter tag</dfn>, when the parameter type is a pointer into the  [=address spaces/function=] address space.
      The tag describes whether the value in the memory pointed to by the parameter may become
      [=uniform value|non-uniform=] during the execution of the function call.

<table class='data'>
  <caption>[=Call site tag=] values</caption>
  <thead>
    <tr><th>Call Site Tag<th>Description
  </thead>
  <tr algorithm="CallSiteRequiredToBeUniform tag">
      <td><dfn noexport>CallSiteRequiredToBeUniform.S</dfn>,<br>
          where |S| is one of the severities: [=severity/error=], [=severity/warning=], or [=severity/info=].
      <td>The function must only be called from [=uniform control flow=].
          Otherwise a diagnostic with severity |S| will be triggered.

          Associated with a [=potential-trigger-set=].
  <tr><td><dfn noexport>CallSiteNoRestriction</dfn>
      <td>The function may be called from [=uniform control flow|non-uniform control flow=].
</table>

<table class='data'>
  <caption>[=Function tag=] values</caption>
  <thead>
    <tr><th>Function Tag<th>Description
  </thead>
  <tr><td><dfn noexport>ReturnValueMayBeNonUniform</dfn>
      <td>The [=return value=] of the function may be non-uniform.
  <tr><td><dfn noexport>NoRestriction</dfn>
      <td>The function does not introduce non-uniformity.
</table>

<table class='data'>
  <caption>[=Parameter tag=] values</caption>
  <thead>
    <tr><th>Parameter Tag<th>Description
  </thead>
  <tr algorithm="ParameterRequiredToBeUniformValue tag">
      <td><dfn noexport>ParameterRequiredToBeUniform.S</dfn>,<br>
          where |S| is one of the severities: [=severity/error=], [=severity/warning=], or [=severity/info=].
      <td>The parameter must be a [=uniform value=].
          If the parameter type is a pointer, the memory view, but not
          necessarily its contents, must be uniform.
          Otherwise a diagnostic with severity |S| will be triggered.

          Associated with a [=potential-trigger-set=].
  <tr algorithm="ParameterContentsRequiredToBeUniform tag">
      <td><dfn noexport>ParameterContentsRequiredToBeUniform.S</dfn>,<br>
          where |S| is one of the severities: [=severity/error=], [=severity/warning=], or [=severity/info=].
      <td>The value stored in the memory pointed to by the pointer parameter must be a [=uniform value=].
          Otherwise a diagnostic with severity |S| will be triggered.

          Associated with a [=potential-trigger-set=].
  <tr><td><dfn noexport>ParameterNoRestriction</dfn>
      <td>The parameter value has no uniformity requirement.
</table>

<table class='data'>
  <caption>[=Parameter return tag=] values</caption>
  <thead>
    <tr><th>Parameter Return Tag<th>Description
  </thead>
  <tr><td><dfn noexport>ParameterReturnContentsRequiredToBeUniform</dfn>
      <td>The parameter [=shader-creation error|must=] be a [=uniform value=] in order for the [=return value=] to be a uniform value.
      If the parameter is a pointer, then the values stored in the memory pointed to by the pointer must also be [=uniform value|uniform=].
  <tr><td><dfn noexport>ParameterReturnNoRestriction</dfn>
      <td>The parameter value has no uniformity requirement.
</table>

<table class='data'>
  <caption>[=Pointer parameter tag=] values</caption>
  <thead>
    <tr><th>Pointer Parameter Tag<th>Description
  </thead>
  <tr><td><dfn noexport>PointerParameterMayBeNonUniform</dfn>
      <td>The value stored in the memory pointed to by the pointer parameter may be [=uniform value|non-uniform=] after the function call.
  <tr><td><dfn noexport>PointerParameterNoRestriction</dfn>
      <td>The uniformity of the value stored in the memory pointed to by the pointer parameter is unaffected by the function call.
</table>

The following algorithm describes how to compute these tags for a given function:

* Create the following nodes:
    * <dfn noexport>RequiredToBeUniform.error</dfn>, <dfn noexport>RequiredToBeUniform.warning</dfn>, and <dfn noexport>RequiredToBeUniform.info</dfn>.
        Collectively these are called the <dfn noexport>RequiredToBeUniform.S</dfn> nodes.
        * Each such node is associated with a [=potential-trigger-set=], which is initially empty.
    * <dfn noexport>MayBeNonUniform</dfn>
    * <dfn noexport>CF_start</dfn>, representing the uniformity requirement for control flow when the function begins executing.
    * <dfn noexport>param_i</dfn>, where *i* ranges over the function's [=formal parameters=].
    * If the function has a [=return type=], create a node called <dfn noexport>Value_return</dfn>.
* Desugar pointers as described in [[#pointer-desugar]].
    * For each formal parameter that is a pointer in the [=address spaces/function=] address space,
        create the following nodes:
        * <dfn noexport>param_i_contents</dfn>: this represents the uniformity of the contents of the memory view.
        * <dfn noexport>Value_return_i_contents</dfn>: this represents the function's effects on the uniformity of the contents of the memory view.
* Walk over the syntax of the function, adding nodes and edges to the graph following the rules of the next sections ([[#func-var-value-analysis]], [[#uniformity-statements]], [[#uniformity-function-calls]], [[#uniformity-expressions]]), using [=CF_start=] as the starting control-flow for the function's body.
    * The nodes added in this step are called <dfn noexport>interior nodes</dfn>.
* Initialize as follows:
    * The [=function tag=] is initialized to [=NoRestriction=].
    * The [=call site tag=] is initialized to [=CallSiteNoRestriction=].
    * The [=parameter tag=] for each [=param_i=] is initialized to [=ParameterNoRestriction=].
    * The [=parameter return tag=] for each [=param_i=] is initialized to [=ParameterReturnNoRestriction=].
    * The [=pointer parameter tag=] for each [=param_i=], if it exists, is initialized to [=PointerParameterNoRestriction=].
* For each severity *S* in the order {[=severity/error=], [=severity/warning=], [=severity/info=]}, perform the following:
    * Let *R.S* be the set of unvisited nodes reachable from [=RequiredToBeUniform.S=].
    * Mark the [=interior nodes=] in *R.S* as visited.
    * Let *PTS* be the [=potential-trigger-set=] associated with [=RequiredToBeUniform.S=].
    * If *R.S* includes the node [=MayBeNonUniform=], then trigger a [=uniformity failure=]:
         * [=triggered|Trigger=] a diagnostic with severity *S* and triggering rule *t*, for each *t* in *PTS*.
    * Otherwise:
        * If *R.S* includes [=CF_start=], and the [=call site tag=] has not been updated since initialization, then
             set the [=call site tag=] to [=CallSiteRequiredToBeUniform.S=], and set its [=potential-trigger-set=] to *PTS*.
        * For each [=param_i=] in *R.S*, if its corresponding [=parameter tag=] has not been updated since initialization, then
             set that tag to [=ParameterRequiredToBeUniform.S=], and set its [=potential-trigger-set=] to *PTS*.
        * For each [=param_i_contents=] in *R.S*, if its corresponding [=parameter tag=] has not been updated since initialization, then
             set that tag to [=ParameterContentsRequiredToBeUniform.S=], and set its [=potential-trigger-set=] to *PTS*.
* Mark all the [=interior nodes=] as unvisited.
* If [=Value_return=] exists, let *VR* be the set of nodes reachable from [=Value_return=].
    * If *VR* includes [=MayBeNonUniform=], then set the [=function tag=] to [=ReturnValueMayBeNonUniform=].
    * For each [=param_i=] in *VR*, set the corresponding [=parameter return tag=] to [=ParameterReturnContentsRequiredToBeUniform=].
* For each [=Value_return_i_contents=] node, let *VRi* be the set of nodes reachable from [=Value_return_i_contents=].
    * If *VRi* includes [=MayBeNonUniform=], set the corresponding [=pointer parameter tag=] to [=PointerParameterMayBeNonUniform=].

Note: The entire graph can be destroyed at this point. The tags described above are all that we need to remember to analyze callers of this function.
However, the graph contains information that can be used to provide more informative diagnostics.
For example a value in a one function may not be provably [=uniform value|uniform=],
which then contributes to triggering a uniformity failure in another function.
An informative diagnostic would describe the non-uniform value, as well as the function call at the diagnostic's
[=diagnostic/triggering location|triggered location=].

### Pointer Desugaring ### {#pointer-desugar}

Each [=formal parameter|parameter=] of [=pointer type=] in the [=address
spaces/function=] address space is desugared as a local variable declaration
whose initial value is equivalent to dereferencing the parameter.
That is, function address space pointers are viewed as aliases to a local
variable declaration.
The initial value assignment produces an edge to [=param_i_contents=] for
*i*<sup>th</sup> parameter (i.e. *V(e)* is [=param_i_contents=]).

Each [=let-declaration=], *L*, with an [=effective-value-type=] that is a [=pointer type=] is desugared as follows:
* Visit each subexpression, *SE*, of the initializer expression of *L* in a postorder depth-first traversal:
    * If  *SE* invokes the [=load rule=] during [=type checking=] and the [=root identifier=]
        is a mutable variable then:
        * Create a new let-declaration, *LSE*, immediately prior to *L* initialized with *SE*.
        * Replace *SE* in *L* with a [[#value-identifier-expr|value identifier expression]]
            composed of *LSE*.
* Record the, possibly updated, initializer expression of *L*.
* Substitute each [=identifier=] that [=resolves=] to *L* with the recorded
    initializer expression (wrapped in a [[#parenthesized-expressions|parenthesized expression]]).

This desugaring simplifies the subsequent analyses by exposing the [=root identifier=]
of the pointer directly at each of its uses.

Note: For the purposes of uniformity analysis [=type checking=] is described to
occur both before and after this desugaring has occurred.

<div class='example wgsl' heading='pointers in the uniformity analysis'>
  <xmp>
    fn foo(p : ptr<function, array<f32, 4>>, i : i32) -> f32 {
      let p1 = p;
      var x = i;
      let p2 = &((*p1)[x]);
      x = 0;
      *p2 = 5;
      return (*p1)[x];
    }

    // This is the equivalent version of foo for the analysis.
    fn foo_for_analysis(p : ptr<function, array<f32, 4>>, i : i32) -> f32 {
      var p_var = *p;            // Introduce variable for p.
      let p1 = &p_var;           // Use the variable for p1
      var x = i;
      let x_tmp1 = x;            // Capture value of x
      let p2 = &(p_var[x_tmp1]); // Substitute p1's initializer
      x = 0;
      *(&(p_var[x_tmp1])) = 5;   // Substitute p2's initializer
      return (*(&p_var))[x];     // Substitute p1's initializer
    }
  </xmp>
</div>

### Function-scope Variable Value Analysis ### {#func-var-value-analysis}

The value of each [=function scope|function-scope=] [=variable=] at a
particular statement can be analyzed in terms of the assignments that reach it
and, potentially, its initial value.

An assignment is a <dfn noexport>full assignment</dfn> if:
* The variable's [=effective-value-type=] is a [=scalar=] type, or
* the variable's [=effective-value-type=] is a [=composite=] type and each
    [=component=] of the composite is assigned a value.

Otherwise, an assignment is a <dfn noexport>partial assignment</dfn>.

A <dfn>full reference</dfn> is an expression of [=reference type=] that is one of:
* an identifier *x* that [=resolves=] to a variable, or
* `(`*r*`)` where *r* is a [=full reference=], or
* `*`*p* where *p* is a [=full pointer=].

A <dfn>full pointer</dfn> is an expression of [=pointer type=] that is one of:
* `&`*r* where *r* is a [=full reference=], or
* an identifier *p* that [=resolves=] to a [=let-declaration=] initialized to a [=full pointer=], or
* `(`*p*`)` where *p* is a [=full pointer=].

Note: For the purposes of this analysis, we don't need the case where
a formal parameter of pointer type may be a full pointer.

A [=full reference=], and similarly a [=full pointer=], is a [=memory view=]
for *all* the memory locations for the corresponding [=originating variable=] *x*.

A reference that is not a [=full reference=] is a <dfn noexport>partial reference</dfn>.
As such, a partial reference is either:
* a memory view for a strict subset of the memory locations
    for the corresponding [=originating variable=], or
* a memory view the with same set of locations as the corresponding
    originating variable, but with a different [=store type=].

<div class="note">
<span class=marker>Note:</span> A [=partial reference=] can still cover all the same memory locations
as a full reference, i.e. all the locations used by a variable declaration.
This can occur when the store type is a structure type having only one member,
or when the store type is an array type with one element.

Consider a structure type with a single member, and a variable storing that type:

```
     struct S { member: i32; }
     fn foo () {
        var v: S;
     }
```

Then `v` is a full reference and `v.member` is a partial reference.
Their memory views cover the same memory
locations, but the store type for `v` is `S` and the store type of `v.s` is `i32`.

A similar situation occurs with arrays having a single element:

```
     fn foo () {
        var arr: array<i32,1>;
     }
```

Then `arr` is a full reference and `arr[0]` is a partial reference.
Their memory views cover the same memory
locations, but the store type for `arr` is `array<i32,1>` and the store type of `arr[0]` is `i32`.

To simplify analysis, an assignment via *any* kind of [=partial reference=] is treated as if
it does *not* modify every memory location in the associated [=originating variable=].
This causes the analysis to be conservative, potentially triggering a [=uniformity failure=] for
more programs than strictly necessary.
</div>

An assignment through a [=full reference=] is a [=full assignment=].

An assignment through a [=partial reference=] is a [=partial assignment=].

When the uniformity rules in subsequent sections refer to the value for a
function-scope variable used as an [=RHSValue=], it means the value of the variable
prior to evaluation of the RHSValue expression.
When the uniformity rules in subsequent sections refer to the value for a
function-scope variable used as an [=LHSValue=], it means the value of the variable
after execution of the statement the expression appears in.

Multiple assignments to a variable might reach a use of that variable due to
[[#control-flow|control-flow statements]] or partial assignments.
The analysis joins multiple assignments reaching out of control-flow statements
by unioning the set of assignments that reach each control-flow exit.

The following table describes the rules for joining assignments.
In the uniformity graph, each join is an edge from the result node to node
representing the source of the value.
It is written in terms of an arbitrary variable `x`. It uses the following
notations:
* *Vin*(*S*) is the value of `x` prior the execution of the statement *S*.
* *Vout*(*S*) is the value of `x` after the execution of the statement *S*.
* *Vout*(*prev*) is the value of `x` prior to the execution of the current statement.
* *Vin*(*next*) is the value of `x` prior to the execution of the next statement.
* *V*(*e*) is a value node for an expression as in the subsequent sections.
* *V*(*0*) is the zero value of `x`'s [=effective-value-type=].

<table class='data'>
  <caption>Rules for joining multiple assignments to a function-scope variable.
  <thead>
    <tr><th>Statement
        <th>Result
        <th>Edges from the Result
  </thead>
  <tr><td>
          var *x*;
      <td>*Vin*(*next*)
      <td>*V*(*0*)
  <tr><td>
          var *x* = *e*;<br>
      <td rowspan=3>*Vin*(*next*)
      <td rowspan=3>*V*(*e*)

          Note: This is a [=full assignment=] to *x*.
  <tr><td>
          *x* = *e*;<br>
  <tr><td>
          *r* = *e*;<br>
          where *r* is a [=full reference=] to variable *x*
  <tr><td>
          *r* = *e*;<br>
          where *r* is a [=partial reference=] to variable *x*
      <td>*Vout*(*S*)
      <td>*V*(*e*), *V*(*prev*)

          Note: This is a [=partial assignment=] to *x*.

          Note: Partial assignments include the previous value.
          The assignment either writes only a subset of the stored components,
          or the type of the written value differs from the [=store type=]
          of the [=originating=] variable.
  <tr><td>*s1* *s2*<br>
          where *Next* is in behavior of *s1*.

          Note: *s1* often ends in a semicolon.
      <td>*Vin*(*s2*)
      <td>*Vout*(*s1*)
  <tr><td>
          if *e* *s1* else *s2*<br>
          where *Next* is in the behaviors of both *s1* and *s2*
      <td>*Vin*(*next*)
      <td>*Vout*(*s1*), *Vout*(*s2*)
  <tr><td>
          if *e* *s1* else *s2*<br>
          where *Next* is in the behavior of *s1*, but not *s2*
      <td>*Vin*(*next*)
      <td>*Vout*(*s1*)
  <tr><td>
          if *e* *s1* else *s2*<br>
          where *Next* is in the behavior of *s2*, but not *s1*
      <td>*Vin*(*next*)
      <td>*Vout*(*s2*)
  <tr><td>loop { *s1* continuing { *s2* } }
      <td>*Vin*(*s1*)
      <td>*Vout*(*prev*), *Vout*(*s2*)
  <tr><td>loop { *s1* continuing { *s2* } }
      <td>*Vin*(*s2*)
      <td>*Vout*(*s1*),<br>
          *Vout*(*s*<sub>i</sub>)<br>
          for all *s*<sub>i</sub> in *s1* whose behavior is {*Continue*} and transfer control to *s2*
  <tr><td>loop { *s1* continuing { *s2* } }
      <td>*Vin*(*next*)
      <td>*Vout*(*s2*),<br>
          *Vout*(*s*<sub>i</sub>)<br>
          for all *s*<sub>i</sub> in *s1* whose behavior is {*Break*} and transfer control to *next*
  <tr><td>switch *e* {<br>
            case _: *s1*<br>
            case _: *s2*<br>
            ...<br>
            case _: *s3*<br>
          }<br>
      <td>*Vin*(*s*<sub>i</sub>)
      <td>*Vout*(*prev*)
  <tr><td>switch *e* {<br>
            case _: *s1*<br>
            case _: *s2*<br>
            ...<br>
            case _: *s3*<br>
          }<br>
      <td>*Vin*(*next*)
      <td>*Vout*(*s*<sub>i</sub>),<br>
          for all *s*<sub>i</sub> whose behavior includes *Next* or *Break*, and<br>
          *Vout*(*s*<sub>j</sub>)<br>
          for all statements inside *s*<sub>j</sub> whose behavior is {*Break*} and trasfer control to *next*
</table>

For all other statements (except function calls), *Vin*(*next*) is equivalent
to *Vout*(*prev*).

Note: The same desugarings apply as in [[#behaviors|statement behavior analysis]].

### Uniformity Rules for Statements ### {#uniformity-statements}

The rules for analyzing statements take as argument both the statement itself and the node corresponding to control flow at the beginning of it (which we'll note "CF" below) and return both of the following:

* A node corresponding to control flow at the exit of it
* A set of new nodes and edges to add to the graph

In the table below, `(CF1, S) => CF2` means "run the analysis on S starting
with control flow CF1, apply the required changes to the graph, and name the
resulting control flow CF2".
Similarly, `(CF1, E) => (CF2, V)` means "run the analysis on expression E,
starting with control flow CF1, apply the required changes to the graph, and
name the resulting control flow node CF2 and the resulting value node V" (see
next section for the analysis of expressions).
This evaluation of expressions is used for any expression that is not part of
the [=left-hand side=] of an [=statement/assignment=] and is called an <dfn
noexport>RHSValue</dfn>.

There is a similar set of rules for expressions that are part of the
[=left-hand side=] of an [=statement/assignment=], the <dfn noexport>LHSValue</dfn>,
that we denote by `LHSValue: (CF, E) => (CF, L)`. Instead of computing the node
which corresponds to the uniformity of the value, it computes the node which
corresponds to the uniformity of the variable we are addressing.

Note: [=LHSValues=] include expressions in [=increment statement|increment=] and
[=decrement statement|decrement=] statements.

Note: [=RHSValues=] include expression that are part of the [=right-hand side=] of
an [=statement/assignment=] statement or expressions that are not part of an
assignment, [=increment statement|increment=], or [=decrement statement|decrement=] statement.

When several edges have to be created we use `X -> {Y, Z}` as a short-hand for `X -> Y, X -> Z`.

<table class='data'>
  <caption>Uniformity rules for statements</caption>
  <thead>
    <tr><th>Statement<th>New nodes<th>Recursive analyses<th>Resulting control flow node<th>New edges
  </thead>
  <tr><td class="nowrap">{*s*}
      <td>
      <td class="nowrap">(*CF*, *s*) => *CF'*
      <td>*CF'*
      <td>
  <tr><td class="nowrap">*s1* *s2*,<br>
        with Next in behavior of *s1*

        Note: *s1* often ends in a semicolon.

      <td>
      <td class="nowrap">(*CF*, *s1*) => *CF1*<br>
          (*CF1*, *s2*) => *CF2*
      <td>*CF2*
      <td>
  <tr><td class="nowrap">*s1* *s2*,<br>
        without Next in behavior of *s1*

        Note: *s1* often ends in a semicolon.

      <td>
      <td>(*CF*, *s1*) => *CF1*<br>

      Note: *s2* is statically unreachable and not recursively analyzed.
      *s2* does not contribute to the uniformity analysis.
      <td>*CF1*
      <td>
  <tr><td class="nowrap">if *e* *s1* else *s2*<br> with behavior {Next}
      <td>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)<br>
          (*V*, *s1*) => *CF1*<br>
          (*V*, *s2*) => *CF2*
      <td>*CF*
      <td>
  <tr><td class="nowrap">if *e* *s1* else *s2*<br> with another behavior
      <td>*CFend*
      <td>*CFend*
      <td class="nowrap">*CFend* -> {*CF1*, *CF2*}
  <tr><td class="nowrap">loop {*s1* continuing {*s2*}}<br> with behavior {Next}
      <td rowspan=2>*CF'*
      <td rowspan=2 class="nowrap">(*CF'*, *s1*) => *CF1*<br>
          (*CF1*, *s2*) => *CF2*
      <td>*CF*
      <td rowspan=2 class="nowrap">*CF'* -> {*CF2*, *CF*}
  <tr><td class="nowrap">loop {*s1* continuing {*s2*}}<br> with another behavior
      <td>*CF'*
  <tr><td class="nowrap">loop {*s1*}<br> with behavior {Next}
      <td rowspan=2>*CF'*
      <td rowspan=2 class="nowrap">(*CF'*, *s1*) => *CF1*
      <td>*CF*
      <td rowspan=2 class="nowrap">*CF'* -> {*CF1*, *CF*}
  <tr><td class="nowrap">loop {*s1*}<br> with another behavior
      <td>*CF'*
  <tr><td class="nowrap">switch *e* case _: *s_1* .. case _: *s_n*<br> with behavior {Next}
      <td>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)<br>
        (*V*, *s_1*) => *CF_1*<br>
        ...<br>
        (*V*, *s_n*) => *CF_n*
      <td>*CF*
      <td>
  <tr><td class="nowrap">switch *e* case _: *s_1* .. case _: *s_n*<br> with another behavior
      <td>*CFend*
      <td>*CFend*
      <td class="nowrap">*CFend* -> {*CF_1*, ..., *CF_n*}
  <tr><td class="nowrap">var x: T;
      <td rowspan=3>
      <td rowspan=3>
      <td rowspan=3>*CF*
      <td rowspan=3>
      Note: If x is a [=address spaces/function=] address space variable, *CF*
      is used as the zero value initializer in the
      [[#func-var-value-analysis|value analysis]].
  <tr><td class="nowrap">break;
  <tr><td class="nowrap">continue;
  <tr><td class="nowrap">break if *e*;
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>
  <tr><td class="nowrap">return;
      <td>
      <td>
      <td>*CF*
      <td>
      For each [=address spaces/function=] address space pointer parameter *i*,
      [=Value_return_i_contents=] -> *Vin*(*prev*) (see [[#func-var-value-analysis]])
  <tr><td class="nowrap">return *e*;
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>[=Value_return=] -> *V*

      For each [=address spaces/function=] address space pointer parameter *i*,
      [=Value_return_i_contents=] -> *Vin*(*prev*) (see [[#func-var-value-analysis]])
  <tr><td class="nowrap">*e1* = *e2*;
      <td>
      <td class="nowrap">[=LHSValue=]: (*CF*, *e1*) => (*CF1*, *LV*)<br>
          (*CF1*, *e2*) => (*CF2*, *RV*)
      <td>*CF2*
      <td>*LV* -> *RV*

      Note: *LV* is the result value from the [[#func-var-value-analysis|value analysis]].
  <tr><td class="nowrap">_ = *e*
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>
  <tr><td class="nowrap">let x = *e*;
      <td>
      <td>(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>
  <tr><td class="nowrap">var x = *e*;
      <td>
      <td>(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>Note: If x is a [=address spaces/function=] address space variable,
      *V* is used as the result value in the [[#func-var-value-analysis|value analysis]].
</table>

Analysis of [[#for-statement|for]] and [[#while-statement|while]] loops follows
from their respective desugaring translations to [[#loop-statement|loop]] statements.

In [[#switch-statement|switch]], a [=default-alone clause=] block is treated exactly like a [=case clause=] with regards to uniformity.

To maximize performance, implementations often try to minimize the amount of
[=uniform control flow|non-uniform control flow=].
However, the points at which invocations can be said to be uniform varies
depending on a number of factors.  WGSL's static analysis conservatively
assumes a return to uniform control flow occuring at the end of
[=statement/if=], [=statement/switch=], and [=statement/loop=] statements if
the [[#behaviors|behavior]] for the statement is {Next}.
This is modeled in the preceding table as the resulting control flow node
being the same as input control flow node.

### Uniformity Rules for Function Calls ### {#uniformity-function-calls}

The most complex rule is for function calls:
- For each argument, apply the corresponding expression rule, with the control flow at the exit of the previous argument (using the control flow at the beginning of the function call for the first argument). Name the corresponding value nodes <dfn noexport>arg_i</dfn> and the corresponding control flow nodes <dfn noexport>CF_i</dfn>
- Create two new nodes, named <dfn noexport>Result</dfn> and <dfn noexport>CF_after</dfn>
- If the [=call site tag=] of the function is [=CallSiteRequiredToBeUniform.S=], then:
    - Add an edge from [=RequiredToBeUniform.S=] to the last [=CF_i=].
    - Add the members of the [=potential-trigger-set=] of the [=call site tag=] to the potential-trigger-set associated with [=RequiredToBeUniform.S=].
- Add an edge from [=CF_after=] to the last [=CF_i=]
- If the [=function tag=] is [=ReturnValueMayBeNonUniform=], then add an edge from [=Result=] to [=MayBeNonUniform=]
- Add an edge from [=Result=] to [=CF_after=]
- For each argument *i*:
    - If the corresponding [=parameter tag=] is [=ParameterRequiredToBeUniform.S=], then:
        - Add an edge from [=RequiredToBeUniform.S=] to [=arg_i=].
        - Add the members of the [=potential-trigger-set=] of the [=parameter tag=] to the potential-trigger-set associated with [=RequiredToBeUniform.S=].
    - If the [=parameter return tag=] is [=ParameterReturnContentsRequiredToBeUniform=], then add an edge from [=Result=] to [=arg_i=]
    - If the corresponding parameter has a [=pointer parameter tag=] of [=PointerParameterMayBeNonUniform=], then add an edge from *Vout*(*call*) to [=MayBeNonUniform=]
    - If the parameter is a pointer in the [=address spaces/function=] address space, add an edge from *Vout*(*call*) to each corresponding [=arg_i=] for the reachable parameters recorded previously
        - If the [=parameter tag=] is [=ParameterContentsRequiredToBeUniform.S=], add an edge from [=RequiredToBeUniform.S=] to *Vout*(*call*)

Note: Refer to [[#func-var-value-analysis]] for the definition of *Vout*(*call*).

Most built-in functions have tags of:
- A [=call site tag=] of [=CallSiteNoRestriction=].
- A [=function tag=] of [=NoRestriction=].
- For each parameter:
    - a [=parameter tag=] of [=ParameterNoRestriction=].
    - a [=parameter return tag=] of [=ParameterReturnContentsRequiredToBeUniform=].

Here is the list of exceptions:
- A call to a function in [[#sync-builtin-functions]]:
    - Has a [=function tag=] of [=NoRestriction=].
    - Has a [=call site tag=] of [=CallSiteRequiredToBeUniform.S|CallSiteRequiredToBeUniform.error=], with [=potential-trigger-set=]
        consisting of an unnamed [=diagnostic/triggering rule=].
        - Note: The triggering rule has no name, and so it cannot be filtered.
    - Additionally for the case of a call to [[#workgroupUniformLoad-builtin|workgroupUniformLoad]],
        the parameter `p` has a [=parameter tag=] of [=ParameterRequiredToBeUniform.S|ParameterRequiredToBeUniform.error=],
        with [=potential-trigger-set=] consisting of an unnamed [=diagnostic/triggering rule=].
- A call to a function in
    [[#derivative-builtin-functions]], [[#texturesample]], [[#texturesamplebias]], and [[#texturesamplecompare]]:
    - Has a [=function tag=] of [=ReturnValueMayBeNonUniform=].
    - Has a [=call site tag=] as follows:
        - Let *DF* be the [=nearest enclosing diagnostic filter=] for the call site location and triggering rule [=trigger/derivative_uniformity=]
        - If *DF* exists, then let *S* be the *DF*'s new severity parameter.
            - If *S* is the severity [=severity/off=], the call site tag is [=CallSiteNoRestriction=].
            - Otherwise the call site tag is [=CallSiteRequiredToBeUniform.S=], with [=potential-trigger-set=]
                consisting of a [=trigger/derivative_uniformity=] element.
        - If there is no such *DF*,
            the call site tag is [=CallSiteRequiredToBeUniform.S|CallSiteRequiredToBeUniform.error=], with [=potential-trigger-set=]
            consisting of a [=trigger/derivative_uniformity=] element.
- A call to [[#textureload]]:
    - Has a [=call site tag=] of [=CallSiteNoRestriction=]
    - Has a [=function tag=] as follows:
        - [=ReturnValueMayBeNonUniform=] if the argument corresponding to the `t` parameter
            is a [=type/read-write storage texture=]
        - [=NoRestriction=] otherwise


Note: A WGSL implementation will ensure that if control flow prior to a
function call is [=uniform control flow|uniform=], it will also be uniform
after the function call.

### Uniformity Rules for Expressions ### {#uniformity-expressions}

The rules for analyzing expressions take as argument both the expression itself and the node corresponding to control flow at the beginning of it (which we'll note "CF" below) and return the following:

* A node corresponding to control flow at the exit of it
* A node corresponding to its value
* A set of new nodes and edges to add to the graph

<table class='data'>
  <caption>Uniformity rules for [=RHSValue=] expressions</caption>
  <thead>
    <tr><th>Expression<th>New nodes<th>Recursive analyses<th>Resulting control flow node, value node<th>New edges
  </thead>
  <tr><td class="nowrap">*e1* || *e2*
      <td rowspan=2>
      <td rowspan=2 class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          (*V1*, *e2*) => (*CF2*, *V2*)
      <td rowspan=2 class="nowrap">*CF*, *V2*
      <td rowspan=2>
  <tr><td class="nowrap">*e1* && *e2*
  <tr><td class="nowrap">Literal
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td>identifier [=resolves|resolving=] to function-scope variable "x",
      where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is invoked on *MVE* during
      [=type checking=]
      <td>*Result*
      <td class>*X* is the node corresponding to the value of "x" at the input to the statement containing this expression
      <td class="nowrap">*CF*, *Result*
      <td class>*Result* -> {*CF*, *X*}

      Note: *X* is equivalent to *Vout*(*prev*) for "x"<br>
      (see [[#func-var-value-analysis]])
   <tr><td>identifier [=resolves|resolving=] to function-scope variable "x",
      where "x" is the desugared pointer parameter *i*, and
      where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is not invoked on *MVE* during
      [=type checking=]
      <td>
      <td class>
      <td class="nowrap">*CF*, [=param_i=]
      <td class>
   <tr><td>identifier [=resolves|resolving=] to function-scope variable "x",
      where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is not invoked on *MVE* during
      [=type checking=]
      <td>
      <td class>
      <td class="nowrap">*CF*, *CF*
      <td class>
   <tr><td>identifier [=resolves|resolving=] to [=const-declaration=], [=override-declaration=],
      [=let-declaration=], or non-built-in [=formal parameter=] "x"
      <td>*Result*
      <td>*X* is the node corresponding to "x"
      <td class="nowrap">*CF*, *Result*
      <td class="nowrap">*Result* -> {*CF*, *X*}
   <tr><td>identifier [=resolves|resolving=] to uniform built-in value "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td>identifier [=resolves|resolving=] to non-uniform built-in value "x"
      <td>
      <td>
      <td class="nowrap">*CF*,<br>
      [=MayBeNonUniform=]
      <td>
   <tr><td>identifier [=resolves|resolving=] to read-only module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td>identifier [=resolves|resolving=] to non-read-only module-scope
      variable "x" where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is invoked on *MVE* during
      [=type checking=]
      <td>
      <td>
      <td class="nowrap">*CF*,<br>
      [=MayBeNonUniform=]
      <td>
   <tr><td>identifier [=resolves|resolving=] to non-read-only module-scope
      variable "x" where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is not invoked on *MVE* during
      [=type checking=]
      <td>
      <td>
      <td class="nowrap">*CF*,*CF*
      <td>
   <tr><td class="nowrap">*op* *e*,<br> where *op* is a unary operator
      <td rowspan=2>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td rowspan=2 class="nowrap">*CF'*, *V*
      <td rowspan=2>
   <tr><td class="nowrap">*e*.field
   <tr><td>*e1* *op* *e2*,<br> where *op* is a non-short-circuiting binary operator
      <td rowspan=2> *Result*
      <td rowspan=2 class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          (*CF1*, *e2*) => (*CF2*, *V2*)
      <td rowspan=2 class="nowrap">*CF2*, *Result*
      <td rowspan=2 class="nowrap">*Result* -> {*V1*, *V2*}
   <tr><td class="nowrap">e1[e2]
</table>

The following built-in input variables are considered uniform:
- [=built-in values/workgroup_id=]
- [=built-in values/num_workgroups=]

All other ones (see [=built-in values=]) are considered non-uniform.

Note: An author should avoid grouping the uniform built-in values together with
other non-uniform inputs because the analysis does not analyze the [=components=]
of a [=composite=] type separately.

<table class='data'>
  <caption>Uniformity rules for [=LHSValue=] expressions</caption>
  <thead>
    <tr><th>Expression<th>New nodes<th>Recursive analyses<th>Resulting control flow node, variable node<th>New edges
  </thead>
   <tr><td>identifier [=resolves|resolving=] to function-scope variable "x"
      <td>*Result*
      <td>*X* is the node corresponding to the value of "x" at the output of the statement containing this expression.
      <td class="nowrap">*CF*, *Result*
      <td class>*Result* -> {*CF*, *X*}

      Note: *X* is equivalent to *Vin*(*next*) for "x"<br>
      (see [[#func-var-value-analysis]])
  <tr><td>identifier [=resolves|resolving=] to
          [=const-declaration=], [=override-declaration=], [=let-declaration=], or [=formal parameter=] "x"
      <td>
      <td>*X* is the node corresponding to "x"
      <td class="nowrap">*CF*, *X*
      <td>
  <tr><td>identifier [=resolves|resolving=] to module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*,<br>
      [=MayBeNonUniform=]
      <td>
  <tr><td class="nowrap">*e*.field
      <td>
      <td class="nowrap">[=LHSValue=]: (*CF*, *e*) => (*CF1*, *L1*)
      <td class="nowrap">*CF1*, *L1*
      <td>
  <tr><td class="nowrap">*e1*[*e2*]
      <td>
      <td class="nowrap">[=LHSValue=]: (*CF*, *e1*) => (*CF1*, *L1*)<br>
          (*CF1*, *e2*) => (*CF2*, *V2*)
      <td class="nowrap">*CF2*, *L1*
      <td class="nowrap">*L1* -> *V2*
</table>

### Annotating the Uniformity of Every Point in the Control-flow ### {#uniformity-optional-diagnosis-mode}

This entire subsection is non-normative.

If implementers want to provide developers with a diagnostic mode that shows for each point in the control-flow of the entire shader whether it is uniform or not (and thus whether it would be valid to call a function that requires uniformity there), we suggest the following:
- Run the (mandatory, normative) analysis described in the previous subsections, keeping the graph for every function.
- Reverse all edges in all of those graphs
- Go through each function, starting with the entry point and never visiting a function before having visited all of its callers:
    - Add an edge from [=MayBeNonUniform=] to every argument that was non-uniform in at least one caller.
    - Add an edge from [=MayBeNonUniform=] to [=CF_start=] if the function was called in non-uniform control-flow in at least one caller.
    - Look at which nodes are reachable from [=MayBeNonUniform=]. Every node visited is an expression or point in the control-flow whose uniformity cannot be proven by the analysis.

Any node which is not visited by these reachability analyses can be proven to be uniform by the analysis (and so it would be safe to call a derivative or similar function there).

Note: The bottom-up analysis is still required, as it lets us know what edges to add to the graphs when encountering calls.

### Examples ### {#uniformity-examples}

The graphs in the subsequent example use the following conventions for nodes:
* Rectangles represent value nodes.
* Rounded  rectangles represent control flow nodes.

#### Invalid `textureSample` Function Call #### {#uniformity-example1}

This example shows an invalid use of a [[#texturesample|textureSample]]
built-in function call.
The function call is made within an if statement whose condition depends on a
non-uniform value (i.e. the built-in value `position`).
The invalid dependency chain is highlighted in red.

<div class='example wgsl' heading='WGSL invalid textureSample'>
  <xmp>
    @group(0) @binding(0) var t : texture_2d<f32>;
    @group(0) @binding(1) var s : sampler;

    @fragment
    fn main(@builtin(position) pos : vec4<f32>) {
      if (pos.x < 0.5) {
        // Invalid textureSample function call.
        _ = textureSample(t, s, pos.xy);
      }
    }
  </xmp>
</div>

<div class=example1>
  <figure>
    <figcaption>Uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_1.mmd.svg"></object>
  </figure>
</div>

The example also shows that uniformity of the control flow after the if
statement is the same as the uniformity prior to the if statement (CF_return
being connected to [=CF_start=]).
That is, the control flow is once again uniform after the if statement (because
it is guaranteed to start as uniform control flow at the beginning of the entry
point).
If the `textureSample` function call had been moved outside the if statement
the program would have been valid.
Likewise, if the condition of the if statement were a uniform value (e.g. each
invocation read the same value from a [=uniform buffer=]), the program would
also have been valid.

#### Function-scope Variable Uniformity #### {#uniformity-example2}

This example shows both a valid and an invalid
[[#sync-builtin-functions|barrier]] function call that depend on the value of a
function-scope variable.
The `workgroupBarrier` is invalid because the value of `x` is derived from the
mutable module-scope variable `a`.
The `storageBarrier` is valid because the value of `x` is derived from the
immutable module-scope variable `b`.
This example highlights the [[#func-var-value-analysis|value analysis']]
ability to separate different periods of uniformity in a function-scope
variable's lifetime.
This example also clearly shows that control flow becomes uniform again after
the end of the first [=statement/if=] statement.
We know this because that section of the graph is independent from the second
if statement.

<div class='example wgsl' heading='WGSL using function variable'>
  <xmp>
    @group(0) @binding(0) var<storage, read_write> a : i32;
    @group(0) @binding(1) var<uniform> b : i32;

    @compute @workgroup_size(16,1,1)
    fn main() {
      var x : i32;
      x = a;
      if x > 0 {
        // Invalid barrier function call.
        workgroupBarrier();
      }
      x = b;
      if x < 0 {
        // Valid barrier function call.
        storageBarrier();
      }
    }
  </xmp>
</div>

<div class=example2>
  <figure>
    <figcaption>Uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_2.mmd.svg"></object>
  </figure>
</div>

Note: The subgraphs are only included in the example for ease of understanding.


#### Composite Value Analysis Limitations #### {#uniformity-example3}

One limitation of the uniformity analysis is that it does not track the
[=components=] of a [=composite=] value independently.
That is, any non-uniform component value [=behavioral requirement|will=] cause
the analysis to treat the entire composite value as non-uniform.
This example illustrates this issue and a potential workaround that shader
authors can employ to avoid this limitation.

<div class='example wgsl' heading='Invalid composite value WGSL'>
  <xmp>
    struct Inputs {
      // workgroup_id is a uniform built-in value.
      @builtin(workgroup_id) wgid : vec3<u32>,
      // local_invocation_index is a non-uniform built-in value.
      @builtin(local_invocation_index) lid : u32
    }

    @compute @workgroup_size(16,1,1)
    fn main(inputs : Inputs) {
      // This comparison is always uniform,
      // but the analysis cannot determine that.
      if inputs.wgid.x == 1 {
        workgroupBarrier();
      }
    }
  </xmp>
</div>

<div class=example2>
  <figure>
    <figcaption>Invalid uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_3.mmd.svg"></object>
  </figure>
</div>

The easiest way to work around this limitation of the analysis is to split the
composite up so that values that are known to be uniform are separate from
value that are known to be non-uniform.
In the alternative WGSL below, splitting the two built-in values into separate
parameters satisfies the uniformity analysis.
This can be seen by the lack of a path from [=RequiredToBeUniform.S=] to
[=MayBeNonUniform=] in the graph.

<div class='example wgsl' heading='Valid alternative WGSL'>
  <xmp>
    @compute @workgroup_size(16,1,1)
    fn main(@builtin(workgroup_id) wgid : vec3<u32>,
            @builtin(local_invocation_index) lid : u32) {
      // The uniformity analysis can now correctly determine this comparison is
      // always uniform.
      if wgid.x == 1 {
        // Valid barrier function call.
        workgroupBarrier();
      }
    }
  </xmp>
</div>

<div class=example3>
  <figure>
    <figcaption>Valid alternative uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_3b.mmd.svg"></object>
  </figure>
</div>

#### Uniformity in a Loop #### {#uniformity-example4}

In this example, there is an invalid `workgroupBarrier` function call in a
loop.
The non-uniform built-in value `local_invocation_index` is the ultimate cause
despite the fact that it appears after the barrier in the loop.
This occurs, because on later iterations some of the invocations in the
workgroup will have exited the loop prematurely while others attempt to execute
the barrier.
The analysis models the inter-iteration dependencies as an edge, where the control
at the start of the loop body (CF_loop_body) depends on the control flow at the
end of the loop body (CF_after_if).

<div class='example wgsl' heading='Loop uniformity WGSL'>
  <xmp>
    @compute @workgroup_size(16,1,1)
    fn main(@builtin(local_invocation_index) lid : u32) {
      for (var i = 0u; i < 10; i++) {
        workgroupBarrier();
        if (lid + i) > 7 {
          break;
        }
      }
    }
  </xmp>
</div>

<div class=example4>
  <figure>
    <figcaption>Uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_4.mmd.svg"></object>
  </figure>
</div>

#### User-defined Function Calls #### {#uniformity-example5}

This example is modification of the [[#uniformity-example1|first example]], but
uses a user-defined function call.
The analysis sets the [=parameter return tag=] of both parameters of `scale` as
[=ParameterReturnContentsRequiredToBeUniform=].
This leads to the path in `main` between the return value of the `scale`
function call and the `position` built-in value.
That path is a subpath of the overall invalid path from [=RequiredToBeUniform.S=] to
[=MayBeNonUniform=].

<div class='example wgsl' heading='User-defined function call uniformity WGSL'>
  <xmp>
    fn scale(in1 : f32, in2 : f32) -> f32 {
      let v = in1 / in2;
      return v;
    }

    @group(0) @binding(0) var t : texture_2d<f32>;
    @group(0) @binding(1) var s : sampler;

    @fragment
    fn main(@builtin(position) pos : vec4<f32>) {
      let tmp = scale(pos.x, 0.5);
      if tmp > 1.0 {
        _ = textureSample(t, s, pos.xy);
      }
    }
  </xmp>
</div>

<div class=example5>
  <figure>
    <figcaption>Uniformity graph for scale</figcaption>
    <object type="image/svg+xml" data="img/uniformity_5scale.mmd.svg"></object>
  </figure>

  <figure>
    <figcaption>Uniformity graph for main</figcaption>
    <object type="image/svg+xml" data="img/uniformity_5main.mmd.svg"></object>
  </figure>
</div>

Note: The subgraphs are only included in the example for ease of understanding.

## Compute Shaders and Workgroups ## {#compute-shader-workgroups}

A <dfn noexport for="compute shader stage">workgroup</dfn> is a set of invocations which
concurrently execute a [=compute shader stage=] [=entry point=],
and share access to shader variables in the [=address spaces/workgroup=] address space.

The <dfn noexport>workgroup grid</dfn> for a compute shader is the set of points
with integer coordinates *(i,j,k)* with:

*  0 &leq; i &lt; workgroup_size_x
*  0 &leq; j &lt; workgroup_size_y
*  0 &leq; k &lt; workgroup_size_z

where *(workgroup_size_x, workgroup_size_y, workgroup_size_z)* is
the value specified for the [=attribute/workgroup_size=] attribute of the
entry point.

There is exactly one invocation in a workgroup for each point in the workgroup grid.

An invocation's <dfn noexport>local invocation ID</dfn> is the coordinate
triple (i,j,k) for the invocation's corresponding workgroup grid point.

When an invocation has [=local invocation ID=], then its
<dfn noexport>local invocation index</dfn> is

  i +
  (j * workgroup_size_x) +
  (k * workgroup_size_x * workgroup_size_y)

<p algorithm="local index range">Note that if a workgroup has |W| invocations,
then each invocation |I| the workgroup has a unique local invocation index |L|(|I|)
such that 0 &le; |L|(|I|) &lt; |W|,
and that entire range is covered.</p>

A compute shader begins execution when a WebGPU implementation
removes a dispatch command from a queue and begins the specified work on the GPU.
The dispatch command specifies a <dfn noexport>dispatch size</dfn>,
which is an integer triple (<dfn>group_count_x</dfn>, <dfn>group_count_y</dfn>, <dfn>group_count_z</dfn>)
indicating the number of workgroups to be executed, as described in the following.

The <dfn noexport>compute shader grid</dfn> for a particular dispatch
is the set of points with integer coordinates *(CSi,CSj,CSk)* with:

*  0 &leq; CSi &lt; workgroup_size_x &times; group_count_x
*  0 &leq; CSj &lt; workgroup_size_y &times; group_count_y
*  0 &leq; CSk &lt; workgroup_size_z &times; group_count_z

where *workgroup_size_x*,
*workgroup_size_y*, and
*workgroup_size_z* are as above for the compute shader entry point.

The work to be performed by a compute shader dispatch is to execute exactly one
invocation of the entry point for each point in the compute shader grid.

An invocation's <dfn noexport>global invocation ID</dfn> is the coordinate
triple for the invocation's corresponding compute shader grid point.

The invocations are organized into workgroups, so that each invocation's
[=global invocation ID=] *(CSi, CSj, CSk)* maps to
a single workgroup, identified by <dfn noexport>workgroup ID</dfn>:

   ( &lfloor; *CSi* &div; workgroup_size_x &rfloor;,
     &lfloor; *CSj* &div; workgroup_size_y &rfloor;,
     &lfloor; *CSk* &div; workgroup_size_z &rfloor;)

and a single invocation within that workgroup, identified by [=local invocation ID=]:

   ( *CSi* mod workgroup_size_x ,
     *CSj* mod workgroup_size_y ,
     *CSk* mod workgroup_size_z ).

Note: Workgroup IDs span from (0,0,0) to ([=group_count_x=] - 1, [=group_count_y=] - 1, [=group_count_z=] - 1).

WebGPU provides no guarantees about:

* Whether invocations from different workgroups execute concurrently.
    That is, you cannot assume more than one workgroup executes at a time.
* Whether, once invocations from a workgroup begin executing, that other workgroups
    are blocked from execution.
    That is, you cannot assume that only one workgroup executes at a time.
    While a workgroup is executing, the implementation may choose to
    concurrently execute other workgroups as well, or other queued but unblocked work.
* Whether invocations from one particular workgroup begin executing before
    the invocations of another workgroup.
    That is, you cannot assume that workgroups are launched in a particular order.

## Fragment Shaders and Helper Invocations ## {#fragment-shaders-helper-invocations}

Invocations in the [=fragment shader stage=] are divided into 2x2 grids of
invocations with neighbouring [=built-in values/position|positions=] in the X and Y dimensions.
Each of these grids is referred to as a <dfn noexport>quad</dfn>.
Quads can collaborate in some collective operations (see [[#derivatives]]).

Ordinarily, [[WebGPU#fragment-processing|fragment processing]] creates one
invocation of a fragment shader for each
[=RasterizationPoint=] produced by
[[WebGPU#rasterization|rasterization]].
Sometimes there may be insufficient RasterizationPoints to fully populate a
quad, for example at the edge of a graphics primitive.
When a quad has only 1, 2, or 3 invocations corresponding to
RasterizationPoints, fragment processing [=behavioral requirement|will=] create
a <dfn noexport>helper invocation</dfn> for each unpopulated position in the
quad.

Helper invocations do not have observable effects, except that they help
compute [[#derivatives|derivatives]].
As such, helper invocations are subject to the following restrictions:
* No [=write access|write accesses=] (see also [[#memory-operation]])
    [=behavioral requirement|will=] be performed on the [=address
    spaces/storage=] or [=address spaces/handle=] address spaces.
* [[#atomic-builtin-functions|Atomic built-in functions]] [=behavioral requirement|will=]
    return [=indeterminate value|indeterminate=] results.
* The [=Entry point=] [=return value=] [=behavioral requirement|will=] not be further processed
    downstream in the [=GPURenderPipeline=].

If all of the invocations in a quad become helper invocations (e.g. due to
executing a [=statement/discard=] statement), execution of the quad may be
terminated; however, such termination is not considered to produce [=uniform
control flow|non-uniform control flow=].

## Collective Operations ## {#collective-operations}

### Barriers ### {#barrier}

A barrier is a [[#sync-builtin-functions|synchronization built-in function]]
that orders memory operations in a program.
A <dfn noexport>control barrier</dfn> is executed by all invocations in the
same [=compute shader stage/workgroup=] as if it were executed concurrently.
As such, control barriers [=shader-creation error|must=] only be executed in [=uniform control flow=] in a
[=compute shader stage|compute=] shader.

### Derivatives ### {#derivatives}

A <dfn noexport>partial derivative</dfn> is the rate of change of a value along an axis.
Fragment shader invocations within the same [=quad=] collaborate to compute
approximate partial derivatives.

The <dfn noexport>builtin functions that compute a derivative</dfn> are:
* [[#texturesample|textureSample]], [[#texturesamplebias|textureSampleBias]], and [[#texturesamplecompare|textureSampleCompare]]
* [[#dpdx-builtin|dpdx]], [[#dpdxCoarse-builtin|dpdxCoarse]], and [[#dpdxFine-builtin|dpdxFine]]
* [[#dpdy-builtin|dpdy]], [[#dpdyCoarse-builtin|dpdyCoarse]], and [[#dpdyFine-builtin|dpdyFine]]
* [[#fwidth-builtin|fwidth]], [[#fwidthCoarse-builtin|fwidthCoarse]], and [[#fwidthFine-builtin|fwidthFine]]

Partial derivatives of the *fragment coordinate* are computed implicitly as part
of operation of the following built-in functions:
* [[#texturesample|textureSample]],
* [[#texturesamplebias|textureSampleBias]], and
* [[#texturesamplecompare|textureSampleCompare]].

For these, the derivatives help determine the mip levels of texels to be sampled, or in the case of
`textureSampleCompare`, sampled and compared against a reference value.

Partial derivatives of *invocation-specified* values are computed by the
built-in functions described in [[#derivative-builtin-functions]]:
* [[#dpdx-builtin|dpdx]], [[#dpdxCoarse-builtin|dpdxCoarse]], and [[#dpdxFine-builtin|dpdxFine]] compute partial derivatives along the x axis.
* [[#dpdy-builtin|dpdy]], [[#dpdyCoarse-builtin|dpdyCoarse]], and [[#dpdyFine-builtin|dpdyFine]] compute partial derivatives along the y axis.
* [[#fwidth-builtin|fwidth]], [[#fwidthCoarse-builtin|fwidthCoarse]], and [[#fwidthFine-builtin|fwidthFine]]
    compute the Manhattan metric over the associated x and y partial derivatives.

Because neighbouring invocations collaborate to compute derivatives, these
functions should only be invoked in [=uniform control flow=] in a fragment shader.
For each call to one of these functions, a [=trigger/derivative_uniformity=] [=diagnostic=] is triggered if
[[#uniformity|uniformity analysis]] cannot prove the call occurs in uniform control flow.

If one of these functions is called in non-uniform control flow, then the result is an [=indeterminate value=].

## Floating Point Evaluation ## {#floating-point-evaluation}

WGSL follows the [[!IEEE-754|IEEE-754]] standard for floating point computation with
the following differences:
* No rounding mode is specified. An implementation may round a value up or down.
* No floating point exceptions are generated.
    * A floating point operation in WGSL [=behavioral requirement|will=] produce an intermediate result
        according to IEEE-754 rules, but exceptions mandated by IEEE-754 will map to different
        behaviors depending on whether the expression is
        a [=const-expression=], an [=override-expression=], or a [=runtime expression=].
    * IEEE-754 defines five kinds of exceptions:
        * Invalid operation. These operations yield a NaN.  An example of an invalid operation is 0 &times; &infin;.
        * Division by zero. This occurs when an operation on finite operands is defined as having an exact infinite result.
            Examples are 1 &divide; 0, and log(0).
        * Overflow. See [[#floating-point-overflow]].
        * Underflow. This occurs when the rounded or unrounded result is subnormal.
        * Inexact. This occurs when the rounded result is different from the intermediate result,
            or when overflow occurs.
    * Consider an operation on finite operands.
        The operation produces overflow, infinity, or a NaN if and only if IEEE-754 would require the
        operation to signal an invalid operation, division-by-zero, or overflow exception.
* Signaling NaNs may not be generated.
    Any signaling NaN may be converted to a quiet NaN.
* Overflow, infinities, and NaNs generated before runtime are errors.
    * [=Const-expressions=] and [=override-expressions=] over finite values
        [=behavioral requirement|will=] generate overflow, infinities, and NaNs
        as intermediate values, following IEEE-754 rules.
        * Note: This rule requires implementations to reliably detect overflow, infinities, and NaNs
            to within accuracy limits for these kinds of expressions, so that errors can be generated consistently.
    * A [=shader-creation error=] results if any [=const-expression=] of
        floating-point type overflows or evaluates to NaN or infinity.
    * A [=pipeline-creation error=] results if any [=override-expression=] of
        floating-point type overflows or evaluates to NaN or infinity.
* Implementations may assume that overflow, infinities, and NaNs are not present at runtime.
    * In such an implementation, if the intermediate result of evaluating a [=runtime expression=] overflows,
        or yields infinity or a NaN, the final result [=behavioral requirement|will=] be
        an [=indeterminate value=] of the target type.
    * Note: This means some functions (e.g. `min` and `max`)
        may not return the expected result due to optimizations about the presence
        of NaNs and infinities.
* Implementations may ignore the sign of a zero.
    That is, a zero with a positive sign may behave like a zero a with a negative sign, and vice versa.
* To <dfn noexport title="flushed to zero">flush to zero</dfn> is to replace a denormalized value for a floating point type
    with a zero value of that type.
    * Any inputs or outputs of operations listed in [[#floating-point-accuracy]] may be flushed to zero.
    * Additionally, intermediate values of operations listed in
        [[#pack-builtin-functions]] or [[#unpack-builtin-functions]] may be flushed to zero.
    * Other operations are required to preserve denormalized numbers.
* The accuracy of operations is given in [[#floating-point-accuracy]].

### Floating Point Overflow ### {#floating-point-overflow}

Overflowing computations can round to infinity or to the
nearest finite value.
The outcome depends on the magnitude of the overflowing value and on whether
evaluation occurs during shader execution.

For a floating point type *T*, define *MAX(T)* as the largest positive finite value of *T*,
and 2<sup>*EMAX(T)*</sup> as the largest power of 2 representable by *T*.
In particular, EMAX([=f32=]) = 127, and EMAX([=f16=]) = 15.

Let *X* be an infinite-precision intermediate result from a floating point computation.
The final value of the expression is determined in two stages, via intermediate values *X'* and *X''* as follows:

From *X*, compute *X'* in *T* by rounding:
* If *X* is in the finite range of *T* then *X'* is the result of rounding *X* up or down.
* If *X* is NaN, then *X'* is NaN.
* If *MAX(T)* &lt; *X* &lt; 2<sup>*EMAX(T)+1*</sup>, then either rounding direction is used: *X'* is *MAX(T)* or &plus;&infin;.
* If 2<sup>*EMAX(T)+1*</sup> &le; *X*, then *X'* = &plus;&infin;.
    * Note: This matches the [[!IEEE-754|IEEE-754]] rule.
* If &minus;*MAX(T)* &gt; *X* &gt; &minus;2<sup>*EMAX(T)+1*</sup>, then either rounding direction is used: *X'* is &minus;*MAX(T)* or &minus;&infin;.
* If &minus;2<sup>*EMAX(T)+1*</sup> &ge; *X*, then *X'* = &minus;&infin;.
    * Note: This matches the IEEE-754 rule.

From *X'*, compute the final value of the expression, *X''*, or detect a program error:
* If *X'* is infinity or NaN, then:
    * If the expression is a [=const-expression=], generate a [=shader-creation error=].
    * If the expression is a [=override-expression=], generate a [=pipeline-creation error=].
    * Otherwise the expression is a [=runtime expression=] and *X''* is an [=indeterminate value=].
* Otherwise *X''* = *X'*.


### Floating Point Accuracy ### {#floating-point-accuracy}

<div algorithm="correctly rounded">
Let |x| be the exact real-valued or infinite result of an operation when computed with unbounded precision.
The <dfn>correctly rounded</dfn> result of the operation for floating point type |T| is:
* |x|, when |x| is in |T|,
* Otherwise:
    * the smallest value in |T| greater than |x|, or
    * the largest value in |T| less than |x|.

</div>

That is, the result may be rounded up or down:
WGSL does not specify a rounding mode.

Note: Floating point types include positive and negative infinity, so
the correctly rounded result may be finite or infinite.

The units in the last place, <dfn noexport>ULP</dfn>, for a floating point
number `x` is defined as follows [[!Muller2005]]:
* If `x` is in the finite range of the floating point type, then ULP(x) is
    the minimum distance between two non-equal, finite floating point numbers
    `a` and `b` such that `a` &le; `x` &le; `b` (i.e. `ulp(x) =
    min`<sub>`a,b`</sub>`|b - a|`).
* Otherwise, ULP(x) is `|b - a|` where `b` and `a` are the largest and second-largest
    representable finite floating point values.

The accuracy of an operation is provided among five
possibilities:
* Correct result (for non-floating point result values).
* [=Correctly rounded=].
* An absolute error bound.
* A relative error bound expressed as [=ULP=].
* An expression that the accuracy is <dfn noexport>inherited from</dfn>.
    That is, the accuracy of the operation is defined as the accuracy of evaluating the given WGSL expression.
    The given expression is only one valid implementation of the function.
    A WebGPU implementation may implement the operation differently, with better accuracy
    or with greater tolerance for extreme inputs.

When the accuracy for an operation is specified over an input range,
the accuracy is undefined for input values outside that range.

If an allowed result is outside the finite range of the result type, then
the rules in [[#floating-point-overflow]] apply.

#### Accuracy of Concrete Floating Point Expressions #### {#concrete-float-accuracy}

<table class='data'>
  <caption>Accuracy of concrete floating point operations</caption>
  <thead>
    <tr><th>Expression<th>Accuracy for f32<th>Accuracy for f16
  </thead>

  <tr><td>`x + y`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`x - y`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`x * y`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`x / y`<td>2.5 ULP for `|y|` in the range [2<sup>-126</sup>, 2<sup>126</sup>]<td>2.5 ULP for `|y|` in the range [2<sup>-14</sup>, 2<sup>14</sup>]
  <tr><td>`x % y`<td colspan=2 style="text-align:left;">Inherited from `x - y * trunc(x/y)`
  <tr><td>`-x`<td colspan=2 style="text-align:left;">Correctly rounded

  <tr><td>`x == y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x != y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x < y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x <= y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x > y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x >= y`<td colspan=2 style="text-align:left;">Correct result
</table>

<table class='data'>
  <caption>Accuracy of concrete floating point built-in functions</caption>
  <thead>
    <tr><th>Built-in Function<th>Accuracy for f32<th>Accuracy for f16
  </thead>

  <tr><td>`abs(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`acos(x)`<td>
       The worse of:
       * Absolute error 6.77&times;10<sup>-5</sup>
       * Inherited from `atan2(sqrt(1.0 - x * x), x)`

      <td>The worse of:
       * Absolute error 3.91&times;10<sup>-3</sup>
       * Inherited from `atan2(sqrt(1.0 - x * x), x)`
          <p>TODO: check this with conformance tests
  <tr><td>`acosh(x)`<td colspan=2 style="text-align:left;">Inherited from `log(x + sqrt(x * x - 1.0))`
  <tr><td>`asin(x)`<td>
       The worse of:
       * Absolute error 6.77&times;10<sup>-5</sup>
       * Inherited from `atan2(x, sqrt(1.0 - x * x))`

      <td>The worse of:
       * Absolute error 3.91&times;10<sup>-3</sup>
       * Inherited from `atan2(x, sqrt(1.0 - x * x))`
          <p>TODO: check this with conformance tests
  <tr><td>`asinh(x)`<td colspan=2 style="text-align:left;">Inherited from `log(x + sqrt(x * x + 1.0))`
  <tr><td>`atan(x)`<td>4096 ULP<td>5 ULP
  <tr><td>`atan2(y, x)`<td>4096 ULP for `|x|` in the range [2<sup>-126</sup>, 2<sup>126</sup>], and `y` is finite and normal<td>5 ULP for `|x|` in the range [2<sup>-14</sup>, 2<sup>14</sup>], and `y` is finite and normal
  <tr><td>`atanh(x)`<td colspan=2 style="text-align:left;">Inherited from `log( (1.0 + x) / (1.0 - x) ) * 0.5`
  <tr><td>`ceil(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`clamp(x,low,high)`<td colspan=2 style="text-align:left;">Correctly rounded.

    The infinitely precise result is computed as either `min(max(x,low),high)`, or with a median-of-3-values formulation.
    These may differ when `low > high`.

    If `x` and either `low` or `high` are denormalized, the result may be any of the denormalized values.
    This follows from the possible results from the `min` and `max` functions on denormalized inputs.
  <tr><td>`cos(x)`
      <td>Absolute error at most 2<sup>-11</sup> when `x` is in the interval [-&pi;, &pi;]
      <td>Absolute error at most 2<sup>-7</sup> when `x` is in the interval [-&pi;, &pi;]
  <tr><td>`cosh(x)`<td colspan=2 style="text-align:left;">Inherited from `(exp(x) + exp(-x)) * 0.5`
  <tr><td>`cross(x, y)`<td colspan=2 style="text-align:left;">Inherited from `(x[i] * y[j] - x[j] * y[i])`
  <tr><td>`degrees(x)`<td colspan=2 style="text-align:left;">Inherited from `x * 57.295779513082322865`
  <tr><td>`determinant(m:mat2x2<T>)`<br>
          `determinant(m:mat3x3<T>)`<br>
          `determinant(m:mat4x4<T>)`
     <td colspan=2 style="text-align:left;">Infinite ULP.

     <div class=note>
     <span class=marker>Note:</span>WebGPU implementations should provide a pragmatically useful determinant function.

     In ideal math, determinants are computed with add, subtract, and multiply operations.

     However, GPUs use floating point math, and GPU implementations of determinant
     favour speed and simplicity over robustness against overflow and error.

     For example, the naive computation of even a 2x2 determinant (`m[0][0] * m[1][1] - m[1][0] * m[0][1]`)
     fails to guard against catastrophic cancellation.
     Providing tighter error bounds for 2x2 determinants is the subject of relatively recent research [[Jeannerod2013]].
     The challenges compound quickly as matrix sizes increase.

     The lack of a finite error bound for determinants in WGSL reflects the same lack in underlying implementations.
     </div>
  <tr><td>`distance(x, y)`<td colspan=2 style="text-align:left;">Inherited from `length(x - y)`
  <tr><td>`dot(x, y)`<td colspan=2 style="text-align:left;">Inherited from sum of `x[i] * y[i]`
  <tr><td>`exp(x)`<td>`3 + 2 * |x|` ULP<td>`1 + 2 * |x|` ULP
  <tr><td>`exp2(x)`<td>`3 + 2 * |x|` ULP<td>`1 + 2 * |x|` ULP
  <tr><td class="nowrap">`faceForward(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `select(-x, x, dot(z, y) < 0.0)`
  <tr><td>`floor(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`fma(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `x * y + z`
  <tr><td>`fract(x)`<td colspan=2 style="text-align:left;">Inherited from `x - floor(x)`
  <tr><td>`frexp(x)`<td colspan=2 style="text-align:left;">Correctly rounded, when `x` is zero or normal.
  <tr><td>`inverseSqrt(x)`<td colspan=2 style="text-align:left;">2 ULP
  <tr><td>`ldexp(x, y)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`length(x)`<td colspan=2 style="text-align:left;">Inherited from `sqrt(dot(x, x))` in the vector case, and `sqrt(x*x)` in the scalar case.
  <tr><td>`log(x)`
      <td>Absolute error at most 2<sup>-21</sup> when `x` is in the interval [0.5, 2.0].<br>
          3 ULP when `x` is outside the interval [0.5, 2.0].<br>
      <td>Absolute error at most 2<sup>-7</sup> when `x` is in the interval [0.5, 2.0].<br>
          3 ULP when `x` is outside the interval [0.5, 2.0].<br>
  <tr><td>`log2(x)`
      <td>Absolute error at most 2<sup>-21</sup> when `x` is in the interval [0.5, 2.0].<br>
          3 ULP when `x` is outside the interval [0.5, 2.0].<br>
      <td>Absolute error at most 2<sup>-7</sup> when `x` is in the interval [0.5, 2.0].<br>
          3 ULP when `x` is outside the interval [0.5, 2.0].<br>
  <tr><td>`max(x, y)`<td colspan=2 style="text-align:left;">Correctly rounded
  <p>If both `x` and `y` are denormalized, the result may be either input.
  <tr><td>`min(x, y)`<td colspan=2 style="text-align:left;">Correctly rounded.
  <p>If both `x` and `y` are denormalized, the result may be either input.
  <tr><td>`mix(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `x * (1.0 - z) + y * z`
  <tr><td>`modf(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`normalize(x)`<td colspan=2 style="text-align:left;">Inherited from `x / length(x)`

  <tr><td>`pack4x8snorm(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.
  <tr><td>`pack4x8unorm(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.
  <tr><td>`pack2x16snorm(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.
  <tr><td>`pack2x16unorm(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.
  <tr><td>`pack2x16float(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.

  <tr><td>`pow(x, y)`<td colspan=2 style="text-align:left;">Inherited from `exp2(y * log2(x))`
  <tr><td>`quantizeToF16(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`radians(x)`<td colspan=2 style="text-align:left;">Inherited from `x * 0.017453292519943295474`
  <tr><td>`reflect(x, y)`<td colspan=2 style="text-align:left;">Inherited from `x - 2.0 * dot(x, y) * y`
  <tr><td>`refract(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `z * x - (z * dot(y, x) + sqrt(k)) * y`,<br>where `k = 1.0 - z * z * (1.0 - dot(y, x) * dot(y, x))`<br>If `k < 0.0` the result is precisely 0.0
  <tr><td>`round(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`sign(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`sin(x)`
      <td>Absolute error at most 2<sup>-11</sup> when `x` is in the interval [-&pi;, &pi;]
      <td>Absolute error at most 2<sup>-7</sup> when `x` is in the interval [-&pi;, &pi;]
  <tr><td>`sinh(x)`<td colspan=2 style="text-align:left;">Inherited from `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`saturate(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`smoothstep(low, high, x)`<td colspan=2 style="text-align:left;">Inherited from `t * t * (3.0 - 2.0 * t)`,<br>where `t = clamp((x - low) / (high - low), 0.0, 1.0)`
  <tr><td>`sqrt(x)`<td colspan=2 style="text-align:left;">Inherited from `1.0 / inverseSqrt(x)`
  <tr><td>`step(edge, x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`tan(x)`<td colspan=2 style="text-align:left;">Inherited from `sin(x) / cos(x)`
  <tr><td>`tanh(x)`<td colspan=2 style="text-align:left;">Inherited from `sinh(x) / cosh(x)`
  <tr><td>`transpose(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`trunc(x)`<td colspan=2 style="text-align:left;">Correctly rounded

  <tr><td>`unpack4x8snorm(x)`<td>3 ULP<td>N/A
  <tr><td>`unpack4x8unorm(x)`<td>3 ULP<td>N/A
  <tr><td>`unpack2x16snorm(x)`<td>3 ULP<td>N/A
  <tr><td>`unpack2x16unorm(x)`<td>3 ULP<td>N/A
  <tr><td>`unpack2x16float(x)`<td>Correctly rounded<td>N/A

</table>

#### Accuracy of AbstractFloat Expressions #### {#abstract-float-accuracy}

The accuracy of an [=AbstractFloat=] operation is as follows:
* A correct result is required when the corresponding [=f32=] operation requires a correct result.
* A [=correctly rounded=] result is required when the corresponding [=f32=] operation requires a correctly rounded result.
* Otherwise, the error of the corresponding [=f32=] operation is an absolute error, a relative error, an error inherited
    from a potential implementation, or a combination of these.
    In this case the error of the [=AbstractFloat=] is unbounded.
    * However, the error of the [=AbstractFloat=] operation *should* be at most
        the error of the corresponding operation in [=f32=], in absolute terms.
    * This recommendation is meant to avoid surprises: the accuracy of
        an expression should not be *reduced* when changing its type from f32 to AbstractFloat.
    * The operation may be evaluated in a WebAssembly [[WASM-CORE-2]] or an ECMAScript [[ECMASCRIPT]]
        environment, and those specifications do not specify error bounds on many
        of the corresponding numeric computations.
        For example, ECMAScript specifies many floating point operations as being
        [[ECMASCRIPT#sec-terms-and-definitions-implementation-approximated|implementation-approximated]].
        Implementations are encouraged to strive to approximate the ideal, but
        no strict requirement is specified.

<div class=note algorithm="ulp translation">
<span class=marker>Note:</span>A given absolute error bound, when quantified as ULP,
depends critically on the underlying floating point type.

The [=ULP=] for an [=AbstractFloat=] value assumes
AbstractFloat is identical to the [[!IEEE-754|IEEE-754]] binary64 type.

One [=ULP=] for an f32 value is 2<sup>29</sup> times larger than 1 ULP for an IEEE 754 binary64 value,
since the significand in the binary64 format is 29 bits longer than the significand in the f32 type.

For example, suppose the true result value of an operation is |x|, but it is computed as <var>x'</var>.
If its error |x|-<var>x'</var> is 3 ULP in f32, then the same absolute error, |x|-<var>x'</var>,
is 3&middot;2<sup>29</sup> ULP in AbstractFloat.
</div>

### Reassociation and Fusion ### {#reassociation-and-fusion}

<dfn noexport>Reassociation</dfn> is the reordering of operations in an
expression such that the answer is the same if computed exactly. For example:
* `(a + b) + c` reassociates to `a + (b + c)`
* `(a - b) + c` reassociates to `(a + c) - b`
* `(a * b) / c` reassociates to `(a / c) * b`

However, the result may not be the same when computed in floating point.
The reassociated result may be inaccurate due to approximation, or may trigger
an overflow or NaN when computing intermediate results.

An implementation may reassociate operations.

An implementation may fuse operations if the transformed expression is
at least as accurate as the original formulation.
For example, some fused multiply-add implementations can be more accurate
than performing a multiply followed by an addition.

### Floating Point Conversion ### {#floating-point-conversion}

In this section, a floating point type may be any of:
* The [=f32=], [=f16=], and [=AbstractFloat=] types in WGSL.
* A hypothetical type corresponding to a binary format defined by the [[!IEEE-754|IEEE-754]]
    floating point standard.

Note: Recall that the [=f32=] WGSL type corresponds to the IEEE-754 binary32 format, and the [=f16=] WGSL type corresponds to the IEEE-754 binary16 format.

The <dfn noexport>scalar floating point to integral conversion</dfn> algorithm is:
<blockquote algorithm="convert a float value to an integral value">
To convert a floating point scalar value |X| to an [=integer scalar=] type |T|:
* If the original value of |X| is exactly representable in the target type |T|, then the result is that value.
* Otherwise, the result is the value in |T| that is closest to [=truncate=](|X|).

</blockquote>

Note: In other words, floating point to integer conversion rounds toward zero, then saturates in the target type.

<div class=note><span class=marker>Note:</span> For example:
* 3.9f converted to [=u32=] is 3u
* -1f converted to [=u32=] is 0u
* 1e20f converted to [=u32=] is the maximum u32 value, 4294967295u
* -3.9f converted to [=i32=] is -3i
* 1e20f converted to [=i32=] is the maximum i32 value, 2147483647i
* -1e20f converted to [=i32=] is the minimum i32 value, i32(-2147483648)

</div>

Note: There are no direct conversions from [=AbstractFloat=] to an integer scalar type.
All conversions first convert to another floating point type ([=f32=] usually).

The <dfn noexport>numeric scalar conversion to floating point</dfn> algorithm is:
<blockquote>
When converting a [=numeric scalar=] value to a floating point type:
* If the original value is exactly representable in the destination type, then the result is that value.
    * Additionally, if the original value is zero and of [=integer scalar=] type, then the resulting value has a zero sign bit.
* Otherwise, the original value is not exactly representable.
    * If the original value is different from but lies between two adjacent finite values representable in the destination type,
         then the result is one of those two values.
         WGSL does not specify whether the larger or smaller representable
         value is chosen, and different instances of such a conversion may choose differently.
    * Otherwise, the original value lies outside the finite range of the destination type:
         * A [=shader-creation error=] results if the original expression is a [=const-expression=].
         * A [=pipeline-creation error=] results if the original expression is an [=override-expression=].
         * Otherwise the conversion proceeds as follows:
             1. Set |X| to the original value.
             2. If the source type is a floating point type with more mantissa bits than the destination type,
                 the extra mantissa bits of the source value *may* be discarded (i.e. treated as if they are 0).
                 Update |X| accordingly.
             3. If |X| is the most-positive or most-negative normal value of the destination type, then the result is |X|.
             4. Otherwise, the result is the infinity value of the destination type, with the same sign as |X|.
    * Otherwise, if the original value is a NaN for the source type, then the result is a NaN in the destination type.

</blockquote>

NOTE: An integer value may lie between two adjacent representable floating point values.
In particular, the [=f32=] type uses 23 explicit fractional bits.
Additionally, when the floating point value is in the normal range (the exponent is neither extreme value), then the mantissa is
the set of fractional bits together with an extra 1-bit at the most significant position at bit position 23.
Then, for example, integers 2<sup>28</sup> and 1+2<sup>28</sup> both map to the same floating point value: the difference in the
least significant 1 bit is not representable by the floating point format.
This kind of collision occurs for pairs of adjacent integers with a magnitude of at least 2<sup>25</sup>.

Note: The original value is always within range of the destination type when
the original type is one of [=i32=] or [=u32=] and the destination type is [=f32=].

Note: The original value is always within range of the destination type when
the source type is a floating point type with fewer exponent and mantissa bits than the target floating point type.

# Keyword and Token Summary # {#grammar}

## Keyword Summary ## {#keyword-summary}

* <dfn for=syntax_kw noexport>`alias`</dfn>
* <dfn for=syntax_kw noexport>`break`</dfn>
* <dfn for=syntax_kw noexport>`case`</dfn>
* <dfn for=syntax_kw noexport>`const`</dfn>
* <dfn for=syntax_kw noexport>`const_assert`</dfn>
* <dfn for=syntax_kw noexport>`continue`</dfn>
* <dfn for=syntax_kw noexport>`continuing`</dfn>
* <dfn for=syntax_kw noexport>`default`</dfn>
* <dfn for=syntax_kw noexport>`diagnostic`</dfn>
* <dfn for=syntax_kw noexport>`discard`</dfn>
* <dfn for=syntax_kw noexport>`else`</dfn>
* <dfn for=syntax_kw noexport>`enable`</dfn>
* <dfn for=syntax_kw noexport>`false`</dfn>
* <dfn for=syntax_kw noexport>`fn`</dfn>
* <dfn for=syntax_kw noexport>`for`</dfn>
* <dfn for=syntax_kw noexport>`if`</dfn>
* <dfn for=syntax_kw noexport>`let`</dfn>
* <dfn for=syntax_kw noexport>`loop`</dfn>
* <dfn for=syntax_kw noexport>`override`</dfn>
* <dfn for=syntax_kw noexport>`requires`</dfn>
* <dfn for=syntax_kw noexport>`return`</dfn>
* <dfn for=syntax_kw noexport>`struct`</dfn>
* <dfn for=syntax_kw noexport>`switch`</dfn>
* <dfn for=syntax_kw noexport>`true`</dfn>
* <dfn for=syntax_kw noexport>`var`</dfn>
* <dfn for=syntax_kw noexport>`while`</dfn>

## Reserved Words ## {#reserved-words}

A <dfn>reserved word</dfn> is a [=token=] which is reserved for future use.
A WGSL module [=shader-creation error|must not=] contain a reserved word.

The following are reserved words:

<pre class=include>
path: wgsl.reserved.bs.include
</pre>

## Syntactic Tokens ## {#syntactic-tokens}

A <dfn>syntactic token</dfn> is a sequence of special code points, used:
* to spell an expression operator, or
* as punctuation: to group, sequence, or separate other grammar elements.

The [=syntactic tokens=] are:

* <dfn for=syntax_sym lt='and' noexport>`'&'` (Code point: `U+0026`)</dfn>
* <dfn for=syntax_sym lt='and_and' noexport>`'&&'` (Code points: `U+0026` `U+0026`)</dfn>
* <dfn for=syntax_sym lt='arrow' noexport>`'->'` (Code points: `U+002D` `U+003E`)</dfn>
* <dfn for=syntax_sym lt='attr' noexport>`'@'` (Code point: `U+0040`)</dfn>
* <dfn for=syntax_sym lt='forward_slash' noexport>`'/'` (Code point: `U+002F`)</dfn>
* <dfn for=syntax_sym lt='bang' noexport>`'!'` (Code point: `U+0021`)</dfn>
* <dfn for=syntax_sym lt='bracket_left' noexport>`'['` (Code point: `U+005B`)</dfn>
* <dfn for=syntax_sym lt='bracket_right' noexport>`']'` (Code point: `U+005D`)</dfn>
* <dfn for=syntax_sym lt='brace_left' noexport>`'{'` (Code point: `U+007B`)</dfn>
* <dfn for=syntax_sym lt='brace_right' noexport>`'}'` (Code point: `U+007D`)</dfn>
* <dfn for=syntax_sym lt='colon' noexport>`':'` (Code point: `U+003A`)</dfn>
* <dfn for=syntax_sym lt='comma' noexport>`','` (Code point: `U+002C`)</dfn>
* <dfn for=syntax_sym lt='equal' noexport>`'='` (Code point: `U+003D`)</dfn>
* <dfn for=syntax_sym lt='equal_equal' noexport>`'=='` (Code points: `U+003D` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='not_equal' noexport>`'!='` (Code points: `U+0021` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='greater_than' noexport>`'>'` (Code point: `U+003E`)</dfn> (also <dfn for=syntax_sym lt='_greater_than' noexport>`_greater_than`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='greater_than_equal' noexport>`'>='` (Code points: `U+003E` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_greater_than_equal' noexport>`_greater_than_equal`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='shift_right' noexport>`'>>'` (Code point: `U+003E` `U+003E`)</dfn> (also <dfn for=syntax_sym lt='_shift_right' noexport>`_shift_right`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='less_than' noexport>`'<'` (Code point: `U+003C`)</dfn> (also <dfn for=syntax_sym lt='_less_than' noexport>`_less_than`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='less_than_equal' noexport>`'<='` (Code points: `U+003C` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_less_than_equal' noexport>`_less_than_equal`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='shift_left' noexport>`'<<'` (Code points: `U+003C` `U+003C`)</dfn> (also <dfn for=syntax_sym lt='_shift_left' noexport>`_shift_left`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='modulo' noexport>`'%'` (Code point: `U+0025`)</dfn>
* <dfn for=syntax_sym lt='minus' noexport>`'-'` (Code point: `U+002D`)</dfn>
* <dfn for=syntax_sym lt='minus_minus' noexport>`'--'` (Code points: `U+002D` `U+002D`)</dfn>
* <dfn for=syntax_sym lt='period' noexport>`'.'` (Code point: `U+002E`)</dfn>
* <dfn for=syntax_sym lt='plus' noexport>`'+'` (Code point: `U+002B`)</dfn>
* <dfn for=syntax_sym lt='plus_plus' noexport>`'++'` (Code points: `U+002B` `U+002B`)</dfn>
* <dfn for=syntax_sym lt='or' noexport>`'|'` (Code point: `U+007C`)</dfn>
* <dfn for=syntax_sym lt='or_or' noexport>`'||'` (Code points: `U+007C` `U+007C`)</dfn>
* <dfn for=syntax_sym lt='paren_left' noexport>`'('` (Code point: `U+0028`)</dfn>
* <dfn for=syntax_sym lt='paren_right' noexport>`')'` (Code point: `U+0029`)</dfn>
* <dfn for=syntax_sym lt='semicolon' noexport>`';'` (Code point: `U+003B`)</dfn>
* <dfn for=syntax_sym lt='star' noexport>`'*'` (Code point: `U+002A`)</dfn>
* <dfn for=syntax_sym lt='tilde' noexport>`'~'` (Code point: `U+007E`)</dfn>
* <dfn for=syntax_sym lt='underscore' noexport>`'_'` (Code point: `U+005F`)</dfn>
* <dfn for=syntax_sym lt='xor' noexport>`'^'` (Code point: `U+005E`)</dfn>
* <dfn for=syntax_sym lt='plus_equal' noexport>`'+='` (Code points: `U+002B` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='minus_equal' noexport>`'-='` (Code points: `U+002D` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='times_equal' noexport>`'*='` (Code points: `U+002A` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='division_equal' noexport>`'/='` (Code points: `U+002F` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='modulo_equal' noexport>`'%='` (Code points: `U+0025` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='and_equal' noexport>`'&='` (Code points: `U+0026` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='or_equal' noexport>`'|='` (Code points: `U+007C` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='xor_equal' noexport>`'^='` (Code points: `U+005E` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='shift_right_assign' noexport>`'>>='` (Code point: `U+003E` `U+003E` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_shift_right_assign' noexport>`_shift_right_assign`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='shift_left_assign' noexport>`'<<='` (Code points: `U+003C` `U+003C` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_shift_left_assign' noexport>`_shift_left_assign`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='_template_args_end' noexport>`_template_args_end`</dfn>
    * Text:  `'>'` (Code point: `U+003E`)
    * This token is textually the same as the [=syntax_sym/greater_than=] syntactic token.
    * It is generated by template list disambiguation, and is used as the last token in a template list.
* <dfn for=syntax_sym lt='_template_args_start' noexport>`_template_args_start`</dfn>
    * Text: `'<'` (Code point: `U+003C`)
    * This token is textually the same as the [=syntax_sym/less_than=] syntactic token.
    * It is generated by template list disambiguation, and is used as the first token in a template list.
* <dfn for=syntax_sym lt='_disambiguate_template' noexport>`_disambiguate_template`</dfn>
    * Text: None
    * This token informs parser to scan for template lists.
    * It triggers template list disambiguation.

## Context-Dependent Name Tokens ## {#context-dependent-name-tokens}

This section lists the tokens used as [=context-dependent names=].

The [=syntax/attribute=] names are:

* `'align'`
* `'binding'`
* `'builtin'`
* `'compute'`
* `'const'`
* `'fragment'`
* `'group'`
* `'id'`
* `'interpolate'`
* `'invariant'`
* `'location'`
* `'size'`
* `'vertex'`
* `'workgroup_size'`

The [=diagnostic filter=] severity control names names are:

<pre class=include>
path: syntax/severity_control_name.syntax.bs.include
</pre>

The valid [=enable-extension=] names are listed in [[#enable-extensions-sec]] but in general have the same form as an [=identifier=]:

<pre class=include>
path: syntax/enable_extension_name.syntax.bs.include
</pre>

There are no [=language extension=] names, but they have the same form as an [=identifier=]:
<pre class=include>
path: syntax/software_extension_name.syntax.bs.include
</pre>

The [=swizzle=] names are used in [[#vector-access-expr|vector access expressions]]:

<pre class=include>
path: syntax/swizzle_name.syntax.bs.include
</pre>

# Built-in Functions # {#builtin-functions}

Certain functions are [=predeclared=], provided by the implementation, and
therefore always available for use in a WGSL module.
These are called <dfn noexport>built-in functions</dfn>.

A built-in function is a family of functions, all with the same name,
but distinguished by the number, order, and types of their [=formal parameters=].
Each of these distinct function variations is an [=overload=].

Note: Each [=user-defined function=] only has one [=overload=].

Each [=overload=] is described below via:
* Type parameterizations, if any.
* The built-in function name, a parenthesized list of [=formal parameters=], and optionally a [=return type=].
* The behavior of this overload of the function.

When calling a built-in function, all arguments to the function are evaluated
before function evaluation begins.
See [[#function-calls]].

## Constructor Built-in Functions ## {#constructor-builtin-function}

A <dfn noexport>value constructor</dfn> built-in function explicitly creates a
value of a given type.

WGSL provides value constructors for all [=predeclared=] types and all
[=constructible=] [=structure=] types.
The constructor built-in functions have the same spelling as the types.
Wherever such a built-in function is used, the [=identifier=]
[=shader-creation error|must=] be [=in scope=] of the type and the [=identifier=]
[=shader-creation error|must not=] [=resolve=] to another declaration.

Note: The structure types returned by [[#frexp-builtin|frexp]],
[[#modf-builtin|modf]], and [[#atomic-rmw|atomicCompareExchangeWeak]] cannot be
written in WGSL modules.

Note: A value declaration of the type needs to be valid at that statement of
the WGSL text.

WGSL provides two kinds of value constructors:
* [[#zero-value-builtin-function|zero value constructors]]
* [[#value-constructor-builtin-function|value constructors]] (which also provide conversion)

### Zero Value Built-in Functions ### {#zero-value-builtin-function}

Each [=type/concrete=], [=constructible=] *T* has a unique <dfn noexport>zero value</dfn>,
and a corresponding built-in function written in WGSL as the type followed by an empty pair of parentheses: *T* `()`.

The zero values are as follows:

* `bool()` is `false`
* `i32()` is 0
* `u32()` is 0
* `f32()` is 0.0
* `f16()` is 0.0
* The zero value for an *N*-component vector of type *T* is the *N*-component vector of the zero value for *T*.
* The zero value for an *C*-column *R*-row matrix of type *T* is the matrix of those dimensions filled with the zero value for *T*.
* The zero value for a [=constructible=] *N*-element array with element type *E* is an array of *N* elements of the zero value for *E*.
* The zero value for a [=constructible=] structure type *S* is the structure value *S* with zero-valued members.

Note: WGSL does not have zero built-in functions for [=atomic types=],
[=runtime-sized=] arrays, or other types that are not [=constructible=].

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn T() -> T</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=constructible=] type.<br>
  <tr><td>Description
      <td>Construct [=zero value=] of the type `T`.
</table>

Note: Zero-filled vectors of AbstractInt can be written as
`vec2()`, `vec3()`, and `vec4()`.

<div class='example' heading="Zero-valued vectors">
  <xmp>
    vec2<f32>()                 // The zero-valued vector of two f32 components.
    vec2<f32>(0.0, 0.0)         // The same value, written explicitly.

    vec3<i32>()                 // The zero-valued vector of three i32 components.
    vec3<i32>(0, 0, 0)          // The same value, written explicitly.
  </xmp>
</div>

<div class='example' heading="Zero-valued arrays">
  <xmp>
    array<bool, 2>()               // The zero-valued array of two booleans.
    array<bool, 2>(false, false)   // The same value, written explicitly.
  </xmp>
</div>

<div class='example wgsl global-scope' heading="Zero-valued structures">
  <xmp>
    struct Student {
      grade: i32,
      GPA: f32,
      attendance: array<bool,4>
    }

    fn func() {
      var s: Student;

      // The zero value for Student
      s = Student();

      // The same value, written explicitly.
      s = Student(0, 0.0, array<bool,4>(false, false, false, false));

      // The same value, written with zero-valued members.
      s = Student(i32(), f32(), array<bool,4>());
    }
  </xmp>
</div>

### Value Constructor Built-in Functions ### {#value-constructor-builtin-function}

The built-in functions defined in following subsections create a [=constructible=] value by:
* Copying an existing value of the same type (i.e. the identity function), or
* Creating a composite value from an explicit list of components.
* Converting from another value type.

The vector and matrix forms construct vector and matrix values from various combinations of components and subvectors
with matching component types.
There are [=overloads=] for constructing vectors and matrices that specify the dimensions of the target type without having to
specify the component type; the component type is inferred from the constructor arguments.

#### `array` #### {#array-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn array<T, N>(e1 : T, ..., eN : T) -> array<T, N>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=type/concrete=] and [=constructible=]
  <tr><td>Description
      <td>Construction of an [=array=] from elements.

      Note: array&lt;|T|,|N|&gt; is [=constructible=] because its [=element count=]
      is equal to the number of arguments to the constructor, and hence
      fully determined at [=shader module creation|shader-creation=] time.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn array(e1 : T, ..., eN : T) -> array<T, N>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=constructible=]
  <tr><td>Description
      <td>Construction of an [=array=] from elements.

      The component type is inferred from the elements' type.
      The size of the array is determined by the number of elements.
</table>

#### `bool` #### {#bool-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bool(e : T) -> bool</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type.
  <tr><td>Description
      <td>Construct a [=bool=] value.

      If `T` is [=bool=], this is an identity operation.<br>
      Otherwise this is a boolean coercion.
      The result is `false` if `e` is a [=zero value=] (or -0.0 for floating point types) and `true` otherwise.
</table>

#### `f16` #### {#f16-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn f16(e : T) -> f16</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type
  <tr><td>Description
      <td>Construct an [=f16=] value.

      If `T` is [=f16=], this is an identity operation.<br>
      If `T` is a [[#integer-types|integer type]] or [=f32=], `e` is converted to [=f16=] (including invalid conversions).<br>
      If `T` is [=bool=], the result is `1.0h` if `e` is `true` and `0.0h` otherwise.
</table>

#### `f32` #### {#f32-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn f32(e : T) -> f32</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type
  <tr><td>Description
      <td>Construct an [=f32=] value.

      If `T` is [=f32=], this is an identity operation.<br>
      If `T` is a [[#integer-types|integer type]] or [=f16=], `e` is converted to [=f32=] (including invalid conversions).<br>
      If `T` is [=bool=], the result is `1.0f` if `e` is `true` and `0.0f` otherwise.
</table>

#### `i32` #### {#i32-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn i32(e : T) -> i32</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type
  <tr><td>Description
      <td>Construct an [=i32=] value.

      If `T` is [=i32=], this is an identity operation.<br>
      If `T` is [=u32=], this is a reinterpretation of bits (i.e. the result is the unique value in [=i32=] that has the same bit pattern as `e`).<br>
      If `T` is a [[#floating-point-types|floating point type]], `e` is [=scalar floating point to integral conversion|converted=] to [=i32=], rounding towards zero.<br>
      If `T` is [=bool=], the result is `1i` if `e` is `true` and `0i` otherwise.
</table>

#### `mat2x2` #### {#mat2x2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x2<T>(e : mat2x2<S>) -> mat2x2<T>
          @const @must_use fn mat2x2(e : mat2x2<S>) -> mat2x2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 2x2 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x2<T>(v1 : vec2<T>, v2 : vec2<T>) -> mat2x2<T>
          @const @must_use fn mat2x2(v1 : vec2<T>, v2 : vec2<T>) -> mat2x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x2 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x2<T>(e1 : T, e2 : T, e3 : T, e4 : T) -> mat2x2<T>
          @const @must_use fn mat2x2(e1 : T, e2 : T, e3 : T, e4 : T) -> mat2x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x2 column-major [=matrix=] from elements.

          Same as mat2x2(vec2(e1,e2), vec2(e3,e4)).
</table>

#### `mat2x3` #### {#mat2x3-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x3<T>(e : mat2x3<S>) -> mat2x3<T>
          @const @must_use fn mat2x3(e : mat2x3<S>) -> mat2x3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 2x3 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x3<T>(v1 : vec3<T>, v2 : vec3<T>) -> mat2x3<T>
          @const @must_use fn mat2x3(v1 : vec3<T>, v2 : vec3<T>) -> mat2x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x3 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x3<T>(e1 : T, ..., e6 : T) -> mat2x3<T>
          @const @must_use fn mat2x3(e1 : T, ..., e6 : T) -> mat2x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x3 column-major [=matrix=] from elements.

          Same as mat2x3(vec3(e1,e2,e3), vec3(e4,e5,e6)).
</table>

#### `mat2x4` #### {#mat2x4-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x4<T>(e : mat2x4<S>) -> mat2x4<T>
          @const @must_use fn mat2x4(e : mat2x4<S>) -> mat2x4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 2x4 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x4<T>(v1 : vec4<T>, v2 : vec4<T>) -> mat2x4<T>
          @const @must_use fn mat2x4(v1 : vec4<T>, v2 : vec4<T>) -> mat2x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x4 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x4<T>(e1 : T, ..., e8 : T) -> mat2x4<T>
          @const @must_use fn mat2x4(e1 : T, ..., e8 : T) -> mat2x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x4 column-major [=matrix=] from elements.

          Same as mat2x4(vec4(e1,e2,e3,e4), vec4(e5,e6,e7,e8)).
</table>

#### `mat3x2` #### {#mat3x2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x2<T>(e : mat3x2<S>) -> mat3x2<T>
          @const @must_use fn mat3x2(e : mat3x2<S>) -> mat3x2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 3x2 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x2<T>(v1 : vec2<T>,
                                        v2 : vec2<T>,
                                        v3 : vec2<T>) -> mat3x2<T>
          @const @must_use fn mat3x2(v1 : vec2<T>,
                                     v2 : vec2<T>,
                                     v3 : vec2<T>) -> mat3x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x2 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x2<T>(e1 : T, ..., e6 : T) -> mat3x2<T>
          @const @must_use fn mat3x2(e1 : T, ..., e6 : T) -> mat3x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x2 column-major [=matrix=] from elements.

          Same as mat3x2(vec2(e1,e2), vec2(e3,e4), vec2(e5,e6)).
</table>

#### `mat3x3` #### {#mat3x3-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x3<T>(e : mat3x3<S>) -> mat3x3<T>
          @const @must_use fn mat3x3(e : mat3x3<S>) -> mat3x3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 3x3 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x3<T>(v1 : vec3<T>,
                                        v2 : vec3<T>,
                                        v3 : vec3<T>) -> mat3x3<T>
          @const @must_use fn mat3x3(v1 : vec3<T>,
                                     v2 : vec3<T>,
                                     v3 : vec3<T>) -> mat3x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x3 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x3<T>(e1 : T, ..., e9 : T) -> mat3x3<T>
          @const @must_use fn mat3x3(e1 : T, ..., e9 : T) -> mat3x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x3 column-major [=matrix=] from elements.

          Same as mat3x3(vec3(e1,e2,e3), vec3(e4,e4,e6), vec3(e7,e8,e9)).
</table>

#### `mat3x4` #### {#mat3x4-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x4<T>(e : mat3x4<S>) -> mat3x4<T>
          @const @must_use fn mat3x4(e : mat3x4<S>) -> mat3x4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 3x4 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x4<T>(v1 : vec4<T>,
                                        v2 : vec4<T>,
                                        v3 : vec4<T>) -> mat3x4<T>
          @const @must_use fn mat3x4(v1 : vec4<T>,
                                     v2 : vec4<T>,
                                     v3 : vec4<T>) -> mat3x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x4 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x4<T>(e1 : T, ..., e12 : T) -> mat3x4<T>
          @const @must_use fn mat3x4(e1 : T, ..., e12 : T) -> mat3x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x4 column-major [=matrix=] from elements.

          Same as mat3x4(vec4(e1,e2,e3,e4), vec4(e5,e6,e7,e8), vec4(e9,e10,e11,e12)).
</table>

#### `mat4x2` #### {#mat4x2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x2<T>(e : mat4x2<S>) -> mat4x2<T>
          @const @must_use fn mat4x2(e : mat4x2<S>) -> mat4x2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 4x2 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x2<T>(v1 : vec2<T>,
                                        v2 : vec2<T>,
                                        v3 : vec2<T>,
                                        v4: vec2<T>) -> mat4x2<T>
          @const @must_use fn mat4x2(v1 : vec2<T>,
                                     v2 : vec2<T>,
                                     v3 : vec2<T>,
                                     v4: vec2<T>) -> mat4x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x2 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x2<T>(e1 : T, ..., e8 : T) -> mat4x2<T>
          @const @must_use fn mat4x2(e1 : T, ..., e8 : T) -> mat4x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x2 column-major [=matrix=] from elements.

          Same as mat4x2(vec2(e1,e2), vec2(e3,e4), vec2(e5,e6), vec2(e7,e8)).
</table>

#### `mat4x3` #### {#mat4x3-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x3<T>(e : mat4x3<S>) -> mat4x3<T>
          @const @must_use fn mat4x3(e : mat4x3<S>) -> mat4x3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 4x3 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x3<T>(v1 : vec3<T>,
                                        v2 : vec3<T>,
                                        v3 : vec3<T>,
                                        v4 : vec3<T>) -> mat4x3<T>
          @const @must_use fn mat4x3(v1 : vec3<T>,
                                     v2 : vec3<T>,
                                     v3 : vec3<T>,
                                     v4 : vec3<T>) -> mat4x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x3 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x3<T>(e1 : T, ..., e12 : T) -> mat4x3<T>
          @const @must_use fn mat4x3(e1 : T, ..., e12 : T) -> mat4x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x3 column-major [=matrix=] from elements.

          Same as mat4x3(vec3(e1,e2,e3), vec3(e4,e5,e6), vec3(e7,e8,e9), vec3(e10,e11,e12)).
</table>

#### `mat4x4` #### {#mat4x4-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x4<T>(e : mat4x4<S>) -> mat4x4<T>
          @const @must_use fn mat4x4(e : mat4x4<S>) -> mat4x4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 4x4 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x4<T>(v1 : vec4<T>,
                                        v2 : vec4<T>,
                                        v3 : vec4<T>,
                                        v4 : vec4<T>) -> mat4x4<T>
          @const @must_use fn mat4x4(v1 : vec4<T>,
                                     v2 : vec4<T>,
                                     v3 : vec4<T>,
                                     v4 : vec4<T>) -> mat4x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x4 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x4<T>(e1 : T, ..., e16 : T) -> mat4x4<T>
          @const @must_use fn mat4x4(e1 : T, ..., e16 : T) -> mat4x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x4 column-major [=matrix=] from elements.

          Same as mat4x4(vec4(e1,e2,e3,e4), vec4(e5,e6,e7,e8), vec4(e9,e10,e11,e12), vec4(e13,e14,e15,e16)).
</table>

#### Structures #### {#structures-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn S(e1 : T1, ..., eN : TN) -> S</xmp>
  <tr><td>Parameterization
      <td>`S` is a [=constructible=] structure type with members having types `T1` ... `TN`.
  <tr><td>Description
      <td>Construct a [=structure=] of type `S` from members.
</table>

#### `u32` #### {#u32-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn u32(e : T) -> u32</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type or [=AbstractInt=]
  <tr><td>Description
      <td>Construct a [=u32=] value.

      If `T` is [=u32=], this is an identity operation.<br>
      If `T` is [=i32=], this is a reinterpretation of bits (i.e. the result is the unique value in [=u32=] that has the same bit pattern as `e`).<br>
      If `T` is a [[#floating-point-types|floating point type]], `e` is [=scalar floating point to integral conversion|converted=] to [=u32=], rounding towards zero.<br>
      If `T` is [=bool=], the result is `1u` if `e` is `true` and `0u` otherwise.<br>
      If `T` is [=AbstractInt=], this is an identity operation if the `e` can be represented in [=u32=], otherwise it produces a [=shader-creation error=].
  <tr><td>
      <td>

      Note: The overload from [=AbstractInt=] exists so expressions such as `u32(4*1000*1000*1000)` can create a u32 value that would otherwise overflow the i32 type. If this overload did not exist, [=overload resolution=] would select the `u32(i32)` overload, the AbstractInt expression would automatically convert to i32, and this would cause a shader-creation error due to overflow.
</table>

#### `vec2` #### {#vec2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec2<T>(e : T) -> vec2<T>
          @const @must_use fn vec2(e : S) -> vec2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>Construction of a two-component [=vector=] with `e` as both components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec2<T>(e : vec2<S>) -> vec2<T>
          @const @must_use fn vec2(e : vec2<S>) -> vec2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a two-component [=vector=] with `e.x` and `e.y` as components.

      If `T` does not match `S` a conversion is used and the components are `T(e.x)` and `T(e.y)`.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec2<T>(e1 : T, e2 : T) -> vec2<T>
          @const @must_use fn vec2(e1 : T, e2 : T) -> vec2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a two-component [=vector=] with `e1` and `e2` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec2() -> vec2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is AbstractInt
  <tr><td>Description
      <td>Returns the value `vec2(0,0)`.
</table>

#### `vec3` #### {#vec3-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(e : T) -> vec3<T>
          @const @must_use fn vec3(e : S) -> vec3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>Construction of a three-component [=vector=] with `e` as all components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(e : vec3<S>) -> vec3<T>
          @const @must_use fn vec3(e : vec3<S>) -> vec3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a three-component [=vector=] with `e.x`, `e.y`, and `e.z` as components.

      If `T` does not match `S` a conversion is used and the components are `T(e.x)`, `T(e.y)`, and  `T(e.z)`.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(e1 : T, e2 : T, e3 : T) -> vec3<T>
          @const @must_use fn vec3(e1 : T, e2 : T, e3 : T) -> vec3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a three-component [=vector=] with `e1`, `e2`, and `e3` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(v1 : vec2<T>, e1 : T) -> vec3<T>
          @const @must_use fn vec3(v1 : vec2<T>, e1 : T) -> vec3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a three-component [=vector=] with `v1.x`, `v1.y`, and `e1` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(e1 : T, v1 : vec2<T>) -> vec3<T>
          @const @must_use fn vec3(e1 : T, v1 : vec2<T>) -> vec3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a three-component [=vector=] with `e1`, `v1.x`, and `v1.y` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3() -> vec3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is AbstractInt
  <tr><td>Description
      <td>Returns the value `vec3(0,0,0)`.
</table>

#### `vec4` #### {#vec4-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e : T) -> vec4<T>
          @const @must_use fn vec4(e : S) -> vec4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>Construction of a four-component [=vector=] with `e` as all components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e : vec4<S>) -> vec4<T>
          @const @must_use fn vec4(e : vec4<S>) -> vec4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e.x`, `e.y`, `e.z`, and `e.w` as components.

      If `T` does not match `S` a conversion is used and the components are `T(e.x)`, `T(e.y)`, `T(e.z)` and  `T(e.w)`.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e1 : T, e2 : T, e3 : T, e4 : T) -> vec4<T>
          @const @must_use fn vec4(e1 : T, e2 : T, e3 : T, e4 : T) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e1`, `e2`, `e3`, and `e4` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e1 : T, v1 : vec2<T>, e2 : T) -> vec4<T>
          @const @must_use fn vec4(e1 : T, v1 : vec2<T>, e2 : T) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e1`, `v1.x`, `v1.y`, and `e2` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e1 : T, e2 : T, v1 : vec2<T>) -> vec4<T>
          @const @must_use fn vec4(e1 : T, e2 : T, v1 : vec2<T>) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e1`, `e2`, `v1.x`, and `v1.x` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(v1 : vec2<T>, v2 : vec2<T>) -> vec4<T>
          @const @must_use fn vec4(v1 : vec2<T>, v2 : vec2<T>) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `v1.x`, `v1.y`, `v2.x`, and `v2.y` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(v1 : vec2<T>, e1 : T, e2 : T) -> vec4<T>
          @const @must_use fn vec4(v1 : vec2<T>, e1 : T, e2 : T) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `v1.x`, `v1.y`, `e1`, and `e2` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(v1 : vec3<T>, e1 : T) -> vec4<T>
          @const @must_use fn vec4(v1 : vec3<T>, e1 : T) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `v1.x`, `v1.y`, `v1.z`, and `e1` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e1 : T, v1 : vec3<T>) -> vec4<T>
          @const @must_use fn vec4(e1 : T, v1 : vec3<T>) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e1`, `v1.x`, `v1.y`, and `v1.z` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4() -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is AbstractInt
  <tr><td>Description
      <td>Returns the value `vec4(0,0,0,0)`.
</table>

## Bit Reinterpretation Built-in Functions ## {#bit-reinterp-builtin-functions}

### `bitcast` ### {#bitcast-builtin}

A `bitcast` built-in function is used to reinterpret the bit representation of
a value in one type as a value in another type.

The internal layout rules are described in [[#internal-value-layout]].

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<T>(e : T) -> T</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=numeric scalar=] or [=type/concrete=] [=numeric vector=]
  <tr><td>Description
      <td>Identity transform.<br>
      [=Component-wise=] when `T` is a [=vector=].<br>
      The result is `e`.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<T>(e : S) -> T</xmp>
  <tr><td>Parameterization
      <td>`S` is i32, u32, or f32<br>
      `T` is not `S` and is i32, u32, or f32
  <tr><td>Description
      <td>Reinterpretation of bits as `T`.<br>
      The result is the reintepretation of bits in `e` as a `T` value.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<vecN<T>>(e : vecN<S>) -> T</xmp>
  <tr><td>Parameterization
      <td>`S` is i32, u32, or f32<br>
      `T` is not `S` and is i32, u32, or f32
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as `T`.<br>
      The result is the reintepretation of bits in `e` as a `vecN<T>` value.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<u32>(e : AbstractInt) -> T

                            @const @must_use fn bitcast<vecN<u32>>(e : vecN<AbstractInt>) -> T</xmp>
  <tr><td>Parameterization
      <td>
  <tr><td>Description
      <td>The identity operation if `e` can be represented as [=u32=],
      otherwise it produces a [=shader-creation error=].
      That is, produces the same result as `u32(e)`.

      [=Component-wise=] when `e` is a vector.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<T>(e : vec2<f16>) -> T</xmp>
  <tr><td>Parameterization
      <td>`T` is i32, u32, or f32
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as `T`.<br>
      The result is the reintepretation of the 32 bits in `e` as a `T` value, following the internal layout rules.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<vec2<T>>(e : vec4<f16>) -> vec2<T></xmp>
  <tr><td>Parameterization
      <td>`T` is i32, u32, or f32<br>
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as `T`.<br>
      The result is the reintepretation of the 64 bits in `e` as a `T` value, following the internal layout rules.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<vec2<f16>>(e : T) -> vec2<f16></xmp>
  <tr><td>Parameterization
      <td>`T` is i32, u32, or f32
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as f16.<br>
      The result is the reintepretation of the 32 bits in `e` as an f16 value, following the internal layout rules.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<vec4<f16>>(e : vec2<T>) -> vec4<f16></xmp>
  <tr><td>Parameterization
      <td>`T` is i32, u32, or f32
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as `vec2<f16>`.<br>
      The result is the reintepretation of the 64 bits in `e` as an f16 value, following the internal layout rules.
</table>

## Logical Built-in Functions ## {#logical-builtin-functions}

### `all` ### {#all-builtin}
<table class='data builtin'>
  <tr algorithm="vector all">
    <td style="width:10%">Overload
    <td>
      <xmp>@const @must_use fn all(e: vecN<bool>) -> bool</xmp>
  <tr>
    <td>Description
    <td>Returns true if each component of `e` is true.
</table>

<table class='data builtin'>
  <tr algorithm="scalar all">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>@const @must_use fn all(e: bool) -> bool</xmp>
  <tr>
    <td>Description
    <td>Returns `e`.
</table>

### `any` ### {#any-builtin}
<table class='data builtin'>
  <tr algorithm="vector any">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn any(e: vecN<bool>) -> bool
      </xmp>
  <tr>
    <td style="width:10%">Description
    <td>Returns true if any component of `e` is true.
</table>

<table class='data builtin'>
  <tr algorithm="scalar any">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>@const @must_use fn any(e: bool) -> bool</xmp>
  <tr>
    <td>Description
    <td>Returns `e`.
</table>

### `select` ### {#select-builtin}
<table class='data builtin'>
  <tr algorithm="scalar select">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn select(f: T,
                                   t: T,
                                   cond: bool) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [=scalar=] or [=vector=]
  <tr>
    <td>Description
    <td>Returns `t` when `cond` is true, and `f` otherwise.
</table>

<table class='data builtin'>
  <tr algorithm="vector select">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn select(f: vecN<T>,
                                   t: vecN<T>,
                                   cond: vecN<bool>) -> vecN<T>
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [=scalar=]
  <tr>
    <td>Description
    <td>[=Component-wise=] selection. Result component `i` is evaluated
        as `select(f[i], t[i], cond[i])`.
</table>

## Array Built-in Functions ## {#array-builtin-functions}

### `arrayLength` ### {#arrayLength-builtin}
<table class='data builtin'>
  <tr algorithm="runtime-sized array length">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn arrayLength(p: ptr<storage, array<E>, AM>) -> u32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`E` is an element type for a [=runtime-sized=] array,<br>
        [=access mode=] `AM` is [=access/read=] or [=access/read_write=]
  <tr>
    <td>Description
    <td>Returns [=NRuntime=], the number of elements in the [=runtime-sized=] array.

        See [[#buffer-binding-determines-runtime-sized-array-element-count]]
</table>

<div class='example wgsl global-scope' heading='Getting the number of elements in a runtime-sized array'>
  <xmp>
struct PointLight {
  position : vec3f,
  color : vec3f,
}

struct LightStorage {
  pointCount : u32,
  point : array<PointLight>,
}

@group(0) @binding(1) var<storage> lights : LightStorage;

fn num_point_lights() -> u32 {
  return arrayLength( &lights.point );
}
  </xmp>
</div>

## Numeric Built-in Functions ## {#numeric-builtin-functions}

### `abs` ### {#abs-float-builtin}
<table class='data builtin'>
  <tr algorithm="float abs">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn abs(e: T ) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLNUMERICDECL]
  <tr>
    <td>Description
    <td>The absolute value of `e`.
    [=Component-wise=] when `T` is a vector.

    If `e` is a floating-point type, then the result is `e` with a positive sign bit.
    If `e` is an unsigned [=integer scalar=] type, then the result is `e`.
    If `e` is a signed [=integer scalar=] type and evaluates to the largest
    negative value, then the result is `e`.
</table>

### `acos` ### {#acos-builtin}
<table class='data builtin'>
  <tr algorithm="acos">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn acos(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the principal value, in radians, of the inverse cosine (cos<sup>-1</sup>) of `e`.<br>
    That is, approximates `x` with 0 &le; `x` &le; &pi;, such that `cos`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful when `abs(e)` &gt; 1.
</table>

### `acosh` ### {#acosh-builtin}
<table class='data builtin'>
  <tr algorithm="acosh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn acosh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the inverse hyperbolic cosine (cosh<sup>-1</sup>) of `e`, as a
    hyperbolic [=angle=] in radians.<br>
    That is, approximates `x` with 0 &le; x &le; &infin;, such that `cosh`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful when `e` &lt; 1.

</table>

### `asin` ### {#asin-builtin}
<table class='data builtin'>
  <tr algorithm="asin">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn asin(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the principal value, in radians, of the inverse sine (sin<sup>-1</sup>) of `e`.<br>
    That is, approximates `x` with -&pi;/2 &le; `x` &le; &pi;/2, such that `sin`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful when `abs(e)` &gt; 1.
</table>

### `asinh` ### {#asinh-builtin}
<table class='data builtin'>
  <tr algorithm="asinh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn asinh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the inverse hyperbolic sine (sinh<sup>-1</sup>) of `e`, as a hyperbolic [=angle=] in radians.<br>
    That is, approximates `x` such that `sinh`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
</table>

### `atan` ### {#atan-builtin}
<table class='data builtin'>
  <tr algorithm="atan">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn atan(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the principal value, in radians, of the inverse tangent (tan<sup>-1</sup>) of `e`.<br>
    That is, approximates `x` with &pi;/2 &le; `x` &le; &pi;/2, such that `tan`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
</table>

### `atanh` ### {#atanh-builtin}
<table class='data builtin'>
  <tr algorithm="atanh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn atanh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the inverse hyperbolic tangent (tanh<sup>-1</sup>) of `e`, as a hyperbolic [=angle=] in radians.<br>
    That is, approximates `x` such that `tanh`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful when `abs(e)` &ge; 1.

</table>

### `atan2` ### {#atan2-builtin}
<table class='data builtin'>
  <tr algorithm="atan2">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn atan2(y: T,
                                  x: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns an [=angle=], in radians, in the interval [-&pi;, &pi;] whose tangent is `y`&divide;`x`.

    The quadrant selected by the result depends on the signs of `y` and `x`.
    For example, the function may be implemented as:

    * `atan(y/x)` when `x` &gt; 0
    * `atan(y/x)` + &pi; when (`x` &lt; 0) and (`y` &gt; 0)
    * `atan(y/x)` - &pi; when (`x` &lt; 0) and (`y` &lt; 0)

    <div class=note>
    <span class=marker>Note:</span> The error in the result is unbounded:
    * When `abs(x)` is very small, e.g. subnormal for its type,
    * At the origin (`x`,`y`) = (0,0), or
    * When `y` is subnormal or infinite.

    </div>

    [=Component-wise=] when `T` is a vector.
</table>

### `ceil` ### {#ceil-builtin}
<table class='data builtin'>
  <tr algorithm="ceil">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn ceil(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the [=ceiling expression|ceiling=] of `e`.
    [=Component-wise=] when `T` is a vector.
</table>

### `clamp` ### {#clamp}
<table class='data builtin'>
  <tr algorithm="clamp">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>
      @const @must_use fn clamp(e: T,
                                low: T,
                                high: T) -> T
    </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLNUMERICDECL]
  <tr>
    <td>Description
    <td>Restricts the value of `e` within a range.

    If `T` is an integer type, then the result is `min(max(e, low), high)`.

    If `T` is a floating-point type, then the result is either `min(max(e,
    low), high)`, or the median of the three values `e`, `low`, `high`.

    [=Component-wise=] when `T` is a vector.

    If `low` is greater than `high`, then:
    * It is a [=shader-creation error=] if `low` and `high` are [=const-expressions=].
    * It is a [=pipeline-creation error=] if `low` and `high` are [=override-expressions=].
</table>

### `cos` ### {#cos-builtin}
<table class='data builtin'>
  <tr algorithm="cos">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>@const @must_use fn cos(e: T) -> T</xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the cosine of `e`, where `e` is in radians.
    [=Component-wise=] when `T` is a vector.
</table>

### `cosh` ### {#cosh-builtin}
<table class='data builtin'>
  <tr algorithm="cosh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn cosh(arg: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the hyperbolic cosine of `arg`, where `arg` is a hyperbolic [=angle=] in radians.
    Approximates the pure mathematical function (*e*<sup>arg</sup> + *e*<sup>&minus;arg</sup>)&divide;2,
    but not necessarily computed that way.

    [=Component-wise=] when `T` is a vector
</table>

### `countLeadingZeros` ### {#countLeadingZeros-builtin}
<table class='data builtin'>
  <tr algorithm="count leading zeroes">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn countLeadingZeros(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>The number of consecutive 0 bits starting from the most significant bit
        of `e`, when `T` is a scalar type.<br>
        [=Component-wise=] when `T` is a vector.<br>
        Also known as "clz" in some languages.
</table>

### `countOneBits` ### {#countOneBits-builtin}
<table class='data builtin'>
  <tr algorithm="count 1 bits">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn countOneBits(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>The number of 1 bits in the representation of `e`.<br>
        Also known as "population count".<br>
        [=Component-wise=] when `T` is a vector.
</table>

### `countTrailingZeros` ### {#countTrailingZeros-builtin}
<table class='data builtin'>
  <tr algorithm="count trailing zeroes">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn countTrailingZeros(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>The number of consecutive 0 bits starting from the least significant bit
        of `e`, when `T` is a scalar type.<br>
        [=Component-wise=] when `T` is a vector.<br>
        Also known as "ctz" in some languages.
</table>

### `cross` ### {#cross-builtin}
<table class='data builtin'>
  <tr algorithm="vector case, cross">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn cross(e1: vec3<T>,
                                  e2: vec3<T>) -> vec3<T>
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>Returns the cross product of `e1` and `e2`.
</table>

### `degrees` ### {#degrees-builtin}
<table class='data builtin'>
  <tr algorithm="degrees">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn degrees(e1: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Converts radians to degrees, approximating `e1`&nbsp;&times;&nbsp;180&nbsp;&div;&nbsp;&pi;.
    [=Component-wise=] when `T` is a vector
</table>

### `determinant` ### {#determinant-builtin}
<table class='data builtin'>
  <tr algorithm="determinant">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn determinant(e: matCxC<T>) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>Returns the determinant of `e`.
</table>

### `distance` ### {#distance-builtin}
<table class='data builtin'>
  <tr algorithm="distance">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn distance(e1: T,
                                     e2: T) -> S
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the distance between `e1` and `e2` (e.g. `length(e1 - e2)`).
</table>

### `dot` ### {#dot-builtin}
<table class='data builtin'>
  <tr algorithm="dot">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn dot(e1: vecN<T>,
                                e2: vecN<T>) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractInt, AbstractFloat, i32, u32, f32, or f16
  <tr>
    <td>Description
    <td>Returns the dot product of `e1` and `e2`.
</table>

### `exp` ### {#exp-builtin}
<table class='data builtin'>
  <tr algorithm="exp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn exp(e1: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the natural exponentiation of `e1` (e.g. `e`<sup>`e1`</sup>).
    [=Component-wise=] when `T` is a vector.
</table>

### `exp2` ### {#exp2-builtin}
<table class='data builtin'>
  <tr algorithm="exp2">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn exp2(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns 2 raised to the power `e` (e.g. `2`<sup>`e`</sup>).
    [=Component-wise=] when `T` is a vector.
</table>

### `extractBits` (signed) ### {#extractBits-signed-builtin}
<table class='data builtin'>
  <tr algorithm="signed extract bits">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn extractBits(e: T,
                                        offset: u32,
                                        count: u32) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [SIGNEDINTEGRAL]
  <tr>
    <td>Description
    <td>Reads bits from an integer, with sign extension.

    When `T` is a scalar type, then:
    <ul>
    <li>`w` is the bit width of `T`
    <li>`o = min(offset, w)`
    <li>`c = min(count, w - o)`
    <li>The result is 0 if `c` is 0.
    <li>Otherwise, bits `0..c - 1` of the result are copied from bits
       `o..o + c - 1` of `e`.
       Other bits of the result are the same as bit `c - 1` of the result.
    </ul>
    [=Component-wise=] when `T` is a vector.

    If `count` + `offset` is greater than `w`, then:
    * It is a [=shader-creation error=] if `count` and `offset` are [=const-expressions=].
    * It is a [=pipeline-creation error=] if `count` and `offset` are [=override-expressions=].
</table>

### `extractBits` (unsigned) ### {#extractBits-unsigned-builtin}
<table class='data builtin'>
  <tr algorithm="unsigned extract bits">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn extractBits(e: T,
                                        offset: u32,
                                        count: u32) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [UNSIGNEDINTEGRAL]
  <tr>
    <td>Description
    <td>Reads bits from an integer, without sign extension.

    When `T` is a scalar type, then:
    <ul>
    <li>`w` is the bit width of `T`
    <li>`o = min(offset, w)`
    <li>`c = min(count, w - o)`
    <li>The result is 0 if `c` is 0.
    <li>Otherwise, bits `0..c - 1` of the result are copied from bits
       `o..o + c - 1` of `e`.
       Other bits of the result are 0.
    </ul>
    [=Component-wise=] when `T` is a vector.

    If `count` + `offset` is greater than `w`, then:
    * It is a [=shader-creation error=] if `count` and `offset` are [=const-expressions=].
    * It is a [=pipeline-creation error=] if `count` and `offset` are [=override-expressions=].
</table>

### `faceForward` ### {#faceForward-builtin}
<table class='data builtin'>
  <tr algorithm="faceForward">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn faceForward(e1: T,
                                        e2: T,
                                        e3: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;AbstractFloat&gt;, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
  <tr>
    <td>Description
    <td>Returns `e1` if `dot(e2, e3)` is negative, and `-e1` otherwise.
</table>

### `firstLeadingBit` (signed) ### {#firstLeadingBit-signed-builtin}
<table class='data builtin'>
  <tr algorithm="signed find most significant one bit">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn firstLeadingBit(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [SIGNEDINTEGRAL]
  <tr>
    <td>Description
    <td>For scalar `T`, the result is:
        <ul>
        <li>-1 if `e` is 0 or -1.
        <li>Otherwise the position of the most significant bit in
            `e` that is different from `e`'s sign bit.
        </ul>

        [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: Since signed integers use twos-complement representation,
the sign bit appears in the most significant bit position.

</table>

### `firstLeadingBit` (unsigned) ### {#firstLeadingBit-unsigned-builtin}
<table class='data builtin'>
  <tr algorithm="unsigned find most significant one bit">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn firstLeadingBit(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [UNSIGNEDINTEGRAL]
  <tr>
    <td>Description
    <td>For scalar `T`, the result is:
        <ul>
        <li>`T(-1)` if `e` is zero.
        <li>Otherwise the position of the most significant 1
            bit in `e`.
        </ul>
        [=Component-wise=] when `T` is a vector.
</table>

### `firstTrailingBit` ### {#firstTrailingBit-builtin}
<table class='data builtin'>
  <tr algorithm="find least significant one bit">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn firstTrailingBit(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>For scalar `T`, the result is:
        <ul>
        <li>`T(-1)` if `e` is zero.
        <li>Otherwise the position of the least significant 1
            bit in `e`.
        </ul>
        [=Component-wise=] when `T` is a vector.
</table>

### `floor` ### {#floor-builtin}
<table class='data builtin'>
  <tr algorithm="floor">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn floor(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the [=floor expression|floor=] of `e`.
    [=Component-wise=] when `T` is a vector.
</table>

### `fma` ### {#fma-builtin}
<table class='data builtin'>
  <tr algorithm="fma">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>
      @const @must_use fn fma(e1: T,
                              e2: T,
                              e3: T) -> T
    </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns `e1 * e2 + e3`.
    [=Component-wise=] when `T` is a vector.

    Note: The name `fma` is short for "fused multiply add".

    Note:
    The [[!IEEE-754|IEEE-754]] `fusedMultiplyAdd` operation computes the intermediate results
    as if with unbounded range and precision, and only the final result is rounded
    to the destination type.
    However, the [[#floating-point-accuracy]] rule for `fma` allows an implementation
    which performs an ordinary multiply to the target type followed by an ordinary addition.
    In this case the intermediate values may overflow or lose accuracy, and the overall
    operation is not "fused" at all.
</table>

### `fract` ### {#fract-builtin}
<table class='data builtin'>
  <tr algorithm="fract">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn fract(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the fractional part of `e`, computed as `e - floor(e)`.<br>
    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: Valid results are in the closed interval [0, 1.0].
For example, if `e` is a very small negative number, then `fract(e)` may be 1.0.

</table>

### `frexp` ### {#frexp-builtin}
<table class='data builtin'>
  <tr algorithm="scalar case, binary32, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_f32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32
  <tr>
    <td>Description
    <td>Splits `e` into a fraction and an exponent.

    * When `e` is zero, the fraction is zero.
    * When `e` is non-zero and normal, `e` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * Otherwise, `e` is denormalized, NaN, or infinite. The result fraction and exponent are [=indeterminate values=].

    Returns the `__frexp_result_f32` built-in structure, defined as follows:
    ```
struct __frexp_result_f32 {
  fract : f32, // fraction part
  exp : i32    // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>
    <div class='example wgsl function-scope' heading='frexp usage'>
    <xmp>
     // Infers result type
     let fraction_and_exponent = frexp(1.5);
     // Sets fraction_only to 0.75
     let fraction_only = frexp(1.5).fract;
    </xmp>
    </div>
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_f32`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="scalar case, binary16, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_f16
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f16
  <tr>
    <td>Description
    <td>Splits `e` into a fraction and an exponent.

    * When `e` is zero, the fraction is zero.
    * When `e` is non-zero and normal, `e` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * Otherwise, `e` is denormalized, NaN, or infinite. The result fraction and exponent are [=indeterminate values=].

    Returns the `__frexp_result_f16` built-in structure, defined as if as follows:
    ```
struct __frexp_result_f16 {
  fract : f16, // fraction part
  exp : i32    // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_f16`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="scalar case, abstract, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_abstract
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat
  <tr>
    <td>Description
    <td>Splits `e` into a fraction and an exponent.

    * When `e` is zero, the fraction is zero.
    * When `e` is non-zero and normal, `e` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * When `e` is denormalized, the fraction and exponent are have unbounded error.
        The fraction may be any AbstractFloat value, and the exponent may be any AbstractInt value.

    Note: AbstractFloat expressions resulting in infinity or NaN cause a [=shader-creation error=].

    Returns the `__frexp_result_abstract` built-in structure, defined as follows:
    ```
struct __frexp_result_abstract {
  fract : AbstractFloat, // fraction part
  exp : AbstractInt      // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>
    <div class='example wgsl function-scope' heading='abstract frexp usage'>
    <xmp>
     // Infers result type
     const fraction_and_exponent = frexp(1.5);
     // Sets fraction_only to 0.75
     const fraction_only = frexp(1.5).fract;
    </xmp>
    </div>
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_abstract`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary32, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_vecN_f32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Splits components `ei` of `e` into a fraction and an exponent.

    * When `ei` is zero, the fraction is zero.
    * When `ei` is non-zero and normal, `ei` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * Otherwise, `ei` is NaN or infinite. The result fraction and exponent are [=indeterminate values=].

    Returns the `__frexp_result_vecN_f32` built-in structure, defined as follows:
    ```
struct __frexp_result_vecN_f32 {
  fract : vecN<f32>, // fraction part
  exp : vecN<i32>    // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_vecN_f32`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary16, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_vecN_f16
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;f16&gt;
  <tr>
    <td>Description
    <td>Splits components `ei` of `e` into a fraction and an exponent.

    * When `ei` is zero, the fraction is zero.
    * When `ei` is non-zero and normal, `ei` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * Otherwise, `ei` is NaN or infinite. The result fraction and exponent are [=indeterminate values=].

    Returns the `__frexp_result_vecN_f16` built-in structure, defined as if as follows:
    ```
struct __frexp_result_vecN_f16 {
  fract : vecN<f16>, // fraction part
  exp : vecN<i32>    // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_vecN_f16`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, abstract, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_vecN_abstract
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;AbstractFloat&gt;
  <tr>
    <td>Description
    <td>Splits components `ei` of `e` into a fraction and an exponent.

    * When `ei` is zero, the fraction is zero.
    * When `ei` is non-zero and normal, `ei` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * When `ei` is denormalized, the fraction and exponent are have unbounded error.
        The fraction may be any AbstractFloat value, and the exponent may be any AbstractInt value.

    Note: AbstractFloat expressions resulting in infinity or NaN cause a [=shader-creation error=].

    Returns the `__frexp_result_vecN_abstract` built-in structure, defined as follows:
    ```
struct __frexp_result_vecN_abstract {
  fract : vecN<AbstractFloat>, // fraction part
  exp : vecN<AbstractInt>      // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_vecN_abstract`,
but a value may infer the type.

</table>

### `insertBits` ### {#insertBits-builtin}
<table class='data builtin'>
  <tr algorithm="insert bits">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn insertBits(e: T,
                                      newbits: T,
                                      offset: u32,
                                      count: u32) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>Sets bits in an integer.

    When `T` is a scalar type, then:
    <ul>
    <li>`w` is the bit width of `T`
    <li>`o = min(offset, w)`
    <li>`c = min(count, w - o)`
    <li>The result is `e` if `c` is 0.
    <li>Otherwise,
       bits `o..o + c - 1` of the result are copied from bits `0..c - 1` of `newbits`.
       Other bits of the result are copied from `e`.
    </ul>
    [=Component-wise=] when `T` is a vector.

    If `count` + `offset` is greater than `w`, then:
    * It is a [=shader-creation error=] if `count` and `offset` are [=const-expressions=].
    * It is a [=pipeline-creation error=] if `count` and `offset` are [=override-expressions=].
</table>

### `inverseSqrt` ### {#inverseSqrt-builtin}
<table class='data builtin'>
  <tr algorithm="inverseSqrt">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn inverseSqrt(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the reciprocal of `sqrt(e)`.
    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful if `e` &le; 0.
</table>

### `ldexp` ### {#ldexp-builtin}
<table class='data builtin'>
  <tr algorithm="ldexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn ldexp(e1: T,
                                  e2: I) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]<br>
        `I` is [ALLSIGNEDINTEGRAL]<br>
        `I` is a vector if and only if `T` is a vector<br>
        `I` is [=type/concrete=] if and only if `T` is a [=type/concrete=]
  <tr>
    <td>Description
    <td>Returns `e1 * 2`<sup>`e2`</sup>, except:
    * The result may be zero if `e2` + *bias* &le; 0.
    * If `e2` &gt; *bias* + 1
         * It is a [=shader-creation error=] if `e2` is a [=const-expression=].
         * It is a [=pipeline-creation error=] if `e2` is an [=override-expression=].
         * Otherwise the result is an [=indeterminate value=] for `T`.

    Here, *bias* is the exponent bias of the floating point format:
    * 15 for `f16`
    * 127 for `f32`
    * 1023 for AbstractFloat, when AbstractFloat is [[!IEEE-754|IEEE-754]] binary64

    If `x` is zero or a finite normal value for its type, then:

    <blockquote>
    x = ldexp(frexp(x).fract, frexp(x).exp)
    </blockquote>

    [=Component-wise=] when `T` is a vector.

    Note: A mnemonic for the name `ldexp` is "load exponent".
    The name may have been taken from the corresponding instruction in the floating point unit of
    the PDP-11.
</table>

### `length` ### {#length-builtin}
<table class='data builtin'>
  <tr algorithm="length">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn length(e: T) -> S
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the length of `e`.<br>
        Evaluates to the absolute value of `e` if `T` is [=scalar=].<br>
        Evaluates to `sqrt(e[0]`<sup>`2`</sup> `+ e[1]`<sup>`2`</sup> `+ ...)` if `T` is a vector type.

        Note: The scalar case may be evaluated as `sqrt(e * e)`,
        which may unnecessarily overflow or lose accuracy.
</table>

### `log` ### {#log-builtin}
<table class='data builtin'>
  <tr algorithm="log">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn log(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the natural logarithm of `e`.
    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful if `e` &lt; 0.
</table>

### `log2` ### {#log2-builtin}
<table class='data builtin'>
  <tr algorithm="log2">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn log2(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the base-2 logarithm of `e`.
    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful if `e` &lt; 0.
</table>

### `max` ### {#max-float-builtin}
<table class='data builtin'>
  <tr algorithm="max">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn max(e1: T,
                                e2: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLNUMERICDECL]
  <tr>
    <td>Description
    <td>Returns `e2` if `e1` is less than `e2`, and `e1` otherwise.
    [=Component-wise=] when `T` is a vector.

    If `e1` and `e2` are floating-point values, then:
    * If both `e1` and `e2` are denormalized, then the result may be *either* value.
    * If one operand is a NaN, the other is returned.
    * If both operands are NaNs, a NaN is returned.
</table>

### `min` ### {#min-float-builtin}
<table class='data builtin'>
  <tr algorithm="min">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn min(e1: T,
                                e2: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLNUMERICDECL]
  <tr>
    <td>Description
    <td>Returns `e2` if `e2` is less than `e1`, and `e1` otherwise.
    [=Component-wise=] when `T` is a vector.

    If `e1` and `e2` are floating-point values, then:
    * If both `e1` and `e2` are denormalized, then the result may be *either* value.
    * If one operand is a NaN, the other is returned.
    * If both operands are NaNs, a NaN is returned.
</table>

### `mix` ### {#mix-builtin}
<table class='data builtin'>
  <tr algorithm="mix all same type operands">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn mix(e1: T,
                                e2: T,
                                e3: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the linear blend of `e1` and `e2` (e.g. `e1 * (1 - e3) + e2 * e3`).
    [=Component-wise=] when `T` is a vector.
</table>

<table class='data builtin'>
  <tr algorithm="vector mix with scalar blending factor">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn mix(e1: T2,
                                e2: T2,
                                e3: T) -> T2
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16<br>
        `T2` is vecN&lt;T&gt;
  <tr>
    <td>Description
    <td>Returns the component-wise linear blend of `e1` and `e2`,
        using scalar blending factor `e3` for each component.<br>
        Same as `mix(e1, e2, T2(e3))`.
</table>

### `modf` ### {#modf-builtin}
<table class='data builtin'>
  <tr algorithm="scalar case, binary32, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_f32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32
  <tr>
    <td>Description
    <td>Splits `e` into fractional and whole number parts.

    The whole part is [[#trunc-builtin|trunc]](`e`), and the fractional part is `e` - [[#trunc-builtin|trunc]](`e`).

    Returns the `__modf_result_f32` built-in structure, defined as follows:
    ```
struct __modf_result_f32 {
  fract : f32, // fractional part
  whole : f32  // whole part
}
    ```
  <tr>
    <td>
    <td>
    <div class='example wgsl function-scope' heading='modf usage'>
    <xmp>
     // Infers result type
     let fract_and_whole = modf(1.5);
     // Sets fract_only to 0.5
     let fract_only = modf(1.5).fract;
     // Sets whole_only to 1.0
     let whole_only = modf(1.5).whole;
    </xmp>
    </div>
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_f32`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="scalar case, binary16, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_f16
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f16
  <tr>
    <td>Description
    <td>Splits `e` into fractional and whole number parts.

    The whole part is [[#trunc-builtin|trunc]](`e`), and the fractional part is `e` - [[#trunc-builtin|trunc]](`e`).

    Returns the `__modf_result_f16` built-in structure, defined as if as follows:
    ```
struct __modf_result_f16 {
  fract : f16, // fractional part
  whole : f16  // whole part
}
    ```
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_f16`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="scalar case, abstract, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_abstract
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat
  <tr>
    <td>Description
    <td>Splits `e` into fractional and whole number parts.

    The whole part is [[#trunc-builtin|trunc]](`e`), and the fractional part is `e` - [[#trunc-builtin|trunc]](`e`).

    Returns the `__modf_result_abstract` built-in structure, defined as follows:
    ```
struct __modf_result_abstract {
  fract : AbstractFloat, // fractional part
  whole : AbstractFloat  // whole part
}
    ```
  <tr>
    <td>
    <td>
    <div class='example wgsl function-scope' heading='modf abstract usage'>
    <xmp>
     // Infers result type
     const fract_and_whole = modf(1.5);
     // Sets fract_only to 0.5
     const fract_only = modf(1.5).fract;
     // Sets whole_only to 1.0
     const whole_only = modf(1.5).whole;
    </xmp>
    </div>
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_abstract`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary32, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_vecN_f32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Splits the components of `e` into fractional and whole number parts.

    The `i`'th component of the whole and fractional parts equal the whole and fractional parts
    of `modf(e[i])`.

    Returns the `__modf_result_vecN_f32` built-in structure, defined as follows:
    ```
struct __modf_result_vecN_f32 {
  fract : vecN<f32>, // fractional part
  whole : vecN<f32>  // whole part
}
    ```
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_vecN_f32`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary16, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_vecN_f16
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;f16&gt;
  <tr>
    <td>Description
    <td>Splits the components of `e` into fractional and whole number parts.

    The `i`'th component of the whole and fractional parts equal the whole and fractional parts
    of `modf(e[i])`.

    Returns the `__modf_result_vecN_f16` built-in structure, defined as if as follows:
    ```
struct __modf_result_vecN_f16 {
  fract : vecN<f16>, // fractional part
  whole : vecN<f16>  // whole part
}
    ```
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_vecN_f16`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, abstract, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_vecN_abstract
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;AbstractFloat&gt;
  <tr>
    <td>Description
    <td>Splits the components of `e` into fractional and whole number parts.

    The `i`'th component of the whole and fractional parts equal the whole and fractional parts
    of `modf(e[i])`.

    Returns the `__modf_result_vecN_abstract` built-in structure, defined as follows:
    ```
struct __modf_result_vecN_abstract {
  fract : vecN<AbstractFloat>, // fractional part
  whole : vecN<AbstractFloat>  // whole part
}
    ```
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_vecN_abstract`,
but a value may infer the type.

</table>

### `normalize` ### {#normalize-builtin}
<table class='data builtin'>
  <tr algorithm="vector case, normalize">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn normalize(e: vecN<T> ) -> vecN<T>
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>Returns a unit vector in the same direction as `e`.
</table>

### `pow` ### {#pow-builtin}
<table class='data builtin'>
  <tr algorithm="pow">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pow(e1: T,
                                e2: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns `e1` raised to the power `e2`.
    [=Component-wise=] when `T` is a vector.
</table>

### `quantizeToF16` ### {#quantizeToF16-builtin}
<table class='data builtin'>
  <tr algorithm="quantize to f16">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn quantizeToF16(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Quantizes a 32-bit floating point value `e` as if `e` were converted to
        a [[!IEEE-754|IEEE 754]] binary16 value, and then converted back to a
        IEEE 754 binary32 value.

        If `e` is outside the finite range of binary16, then:
        * It is a [=shader-creation error=] if `e` is a [=const-expression=].
        * It is a [=pipeline-creation error=] if `e` is an [=override-expression=].
        * Otherwise the result is an [=indeterminate value=] for `T`.

        The intermediate binary16 value may be [=flushed to zero=], i.e. the final
        result may be zero if the intermediate binary16 value is denormalized.

        See [[#floating-point-conversion]].

        [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The vec2&lt;f32&gt; case is the same as `unpack2x16float(pack2x16float(e))`.

</table>

### `radians` ### {#radians-builtin}
<table class='data builtin'>
  <tr algorithm="radians">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn radians(e1: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Converts degrees to radians, approximating `e1`&nbsp;&times;&nbsp;&pi;&nbsp;&div;&nbsp;180.
    [=Component-wise=] when `T` is a vector
</table>

### `reflect` ### {#reflect-builtin}
<table class='data builtin'>
  <tr algorithm="reflect">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn reflect(e1: T,
                                    e2: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;AbstractFloat&gt;, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
  <tr>
    <td>Description
    <td>For the incident vector `e1` and surface orientation `e2`, returns the reflection direction
    `e1 - 2 * dot(e2, e1) * e2`.
</table>

### `refract` ### {#refract-builtin}
<table class='data builtin'>
  <tr algorithm="refract">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn refract(e1: T,
                                    e2: T,
                                    e3: I) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;I&gt;<br>
        `I` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>For the incident vector `e1` and surface normal `e2`, and the ratio of
    indices of refraction `e3`,
    let `k = 1.0 - e3 * e3 * (1.0 - dot(e2, e1) * dot(e2, e1))`.
    If `k < 0.0`, returns the refraction vector 0.0, otherwise return the refraction vector
    `e3 * e1 - (e3 * dot(e2, e1) + sqrt(k)) * e2`.
</table>

### `reverseBits` ### {#reverseBits-builtin}
<table class='data builtin'>
  <tr algorithm="bit reversal">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn reverseBits(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>Reverses the bits in `e`:  The bit at position `k` of the result equals the
        bit at position `31 -k` of `e`.<br>
        [=Component-wise=] when `T` is a vector.
</table>

### `round` ### {#round-builtin}
<table class='data builtin'>
  <tr algorithm="round">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn round(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Result is the integer `k` nearest to `e`, as a floating point value.<br>
        When `e` lies halfway between integers `k` and `k + 1`,
        the result is `k` when `k` is even, and `k + 1` when `k` is odd.<br>
        [=Component-wise=] when `T` is a vector.
</table>

### `saturate` ### {#saturate-float-builtin}
<table class='data builtin'>
  <tr algorithm="saturate">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>@const @must_use fn saturate(e: T) -> T</xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns `clamp(e, 0.0, 1.0)`.
    [=Component-wise=] when `T` is a vector.
</table>

### `sign` ### {#sign-builtin}
<table class='data builtin'>
  <tr algorithm="numeric sign">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn sign(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLSIGNEDNUMERICDECL]
  <tr>
    <td>Description
    <td>Result is:
      <ul>
      <li> 1 when `e` &gt; 0
      <li> 0 when `e` = 0
      <li> -1 when `e` &lt; 0
      </ul>

    [=Component-wise=] when `T` is a vector.
</table>

### `sin` ### {#sin-builtin}
<table class='data builtin'>
  <tr algorithm="sin">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn sin(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the sine of `e`, where `e` is in radians.
    [=Component-wise=] when `T` is a vector.
</table>

### `sinh` ### {#sinh-builtin}
<table class='data builtin'>
  <tr algorithm="sinh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn sinh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the hyperbolic sine of `e`, where `e` is a hyperbolic [=angle=] in radians.
    Approximates the pure mathematical function
    (*e*<sup>arg</sup> &minus; *e*<sup>&minus;arg</sup>)&divide;2,
    but not necessarily computed that way.

    [=Component-wise=] when `T` is a vector.
</table>

### `smoothstep` ### {#smoothstep-builtin}
<table class='data builtin'>
  <tr algorithm="smoothstep">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn smoothstep(low: T,
                                       high: T,
                                       x: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the smooth Hermite interpolation between 0 and 1.
    [=Component-wise=] when `T` is a vector.

    For scalar `T`, the result is
    `t * t * (3.0 - 2.0 * t)`,
    where `t = clamp((x - low) / (high - low), 0.0, 1.0)`.
</table>

### `sqrt` ### {#sqrt-builtin}
<table class='data builtin'>
  <tr algorithm="sqrt">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn sqrt(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the square root of `e`.
    [=Component-wise=] when `T` is a vector.
</table>

### `step` ### {#step-builtin}
<table class='data builtin'>
  <tr algorithm="step">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn step(edge: T,
                                 x: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns 1.0 if `edge` &le; `x`, and 0.0 otherwise.
    [=Component-wise=] when `T` is a vector.
</table>

### `tan` ### {#tan-builtin}
<table class='data builtin'>
  <tr algorithm="tan">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn tan(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the tangent of `e`, where `e` is in radians.
    [=Component-wise=] when `T` is a vector.
</table>

### `tanh` ### {#tanh-builtin}
<table class='data builtin'>
  <tr algorithm="tanh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn tanh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the hyperbolic tangent of `e`, where `e` is a hyperbolic [=angle=] in radians.
    Approximates the pure mathematical function
    (*e*<sup>arg</sup> &minus; *e*<sup>&minus;arg</sup>) &divide (*e*<sup>arg</sup> + *e*<sup>&minus;arg</sup>)
    but not necessarily computed that way.

    [=Component-wise=] when `T` is a vector.
</table>

### `transpose` ### {#transpose-builtin}
<table class='data builtin'>
  <tr algorithm="transpose">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn transpose(e: matRxC<T>) -> matCxR<T>
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>Returns the transpose of `e`.
</table>

### `trunc` ### {#trunc-builtin}
<table class='data builtin'>
  <tr algorithm="trunc">
        <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn trunc(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns [=truncate=](`e`), the nearest whole number whose absolute value
    is less than or equal to the absolute value of `e`.
    [=Component-wise=] when `T` is a vector.
</table>

## Derivative Built-in Functions ## {#derivative-builtin-functions}

See [[#derivatives]].

Calls to these functions:
* [=shader-creation error|Must=] only be used in a [=fragment=] shader stage.
* [=Trigger=] a [=trigger/derivative_uniformity=] [=diagnostic=] if [=uniformity analysis=]
    cannot prove the call is in [=uniform control flow=].

### `dpdx` ### {#dpdx-builtin}
<table class='data builtin'>
  <tr algorithm="dpdx">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdx(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Partial derivative of `e` with respect to window x coordinates.
    The result is the same as either `dpdxFine(e)` or `dpdxCoarse(e)`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdxCoarse` ### {#dpdxCoarse-builtin}
<table class='data builtin'>
  <tr algorithm="dpdxCoarse">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdxCoarse(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns the partial derivative of `e` with respect to window x coordinates using local differences.
    This may result in fewer unique positions that `dpdxFine(e)`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdxFine` ### {#dpdxFine-builtin}
<table class='data builtin'>
  <tr algorithm="dpdxFine">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdxFine(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns the partial derivative of `e` with respect to window x coordinates.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdy` ### {#dpdy-builtin}
<table class='data builtin'>
  <tr algorithm="dpdy">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>@must_use fn dpdy(e: T) -> T</xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Partial derivative of `e` with respect to window y coordinates.
    The result is the same as either `dpdyFine(e)` or `dpdyCoarse(e)`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdyCoarse` ### {#dpdyCoarse-builtin}
<table class='data builtin'>
  <tr algorithm="dpdyCoarse">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdyCoarse(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns the partial derivative of `e` with respect to window y coordinates using local differences.
    This may result in fewer unique positions that `dpdyFine(e)`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdyFine` ### {#dpdyFine-builtin}
<table class='data builtin'>
  <tr algorithm="dpdyFine">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdyFine(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns the partial derivative of `e` with respect to window y coordinates.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `fwidth` ### {#fwidth-builtin}
<table class='data builtin'>
  <tr algorithm="fwidth">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn fwidth(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns `abs(dpdx(e)) + abs(dpdy(e))`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `fwidthCoarse` ### {#fwidthCoarse-builtin}
<table class='data builtin'>
  <tr algorithm="fwidthCoarse">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn fwidthCoarse(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns `abs(dpdxCoarse(e)) + abs(dpdyCoarse(e))`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `fwidthFine` ### {#fwidthFine-builtin}
<table class='data builtin'>
  <tr algorithm="fwidthFine">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn fwidthFine(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns `abs(dpdxFine(e)) + abs(dpdyFine(e))`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

## Texture Built-in Functions ## {#texture-builtin-functions}

Parameter values [=shader-creation error|must=] be valid for the respective texture types.

### `textureDimensions` ### {#texturedimensions}

Returns the dimensions of a texture, or texture's mip level in texels.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureDimensions 1d">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_1d<ST>` or `texture_storage_1d<F,A>`
    <td>
      <xmp>@must_use fn textureDimensions(t: T) -> u32</xmp>

  <tr algorithm="textureDimensions 1d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        |T| is `texture_1d<ST>`

        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureDimensions(t: T,
                                       level: L) -> u32
      </xmp>

  <tr algorithm="textureDimensions 2d">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_2d<ST>`, `texture_2d_array<ST>`, `texture_cube<ST>`,
               `texture_cube_array<ST>`, `texture_multisampled_2d<ST>`,
               `texture_depth_2d`, `texture_depth_2d_array`, `texture_depth_cube`,
               `texture_depth_cube_array`, `texture_depth_multisampled_2d`,
               `texture_storage_2d<F,A>`, `texture_storage_2d_array<F,A>`,
               or `texture_external`
    <td>
      <xmp>@must_use fn textureDimensions(t: T) -> vec2<u32></xmp>

  <tr algorithm="textureDimensions 2d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        |T| is `texture_2d<ST>`, `texture_2d_array<ST>`, `texture_cube<ST>`,
               `texture_cube_array<ST>`, `texture_depth_2d`, `texture_depth_2d_array`,
               `texture_depth_cube`, or `texture_depth_cube_array`

        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureDimensions(t: T,
                                       level: L) -> vec2<u32>
      </xmp>

  <tr algorithm="textureDimensions 3d">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_3d<ST>` or `texture_storage_3d<F,A>`
    <td>
      <xmp>@must_use fn textureDimensions(t: T) -> vec3<u32></xmp>

  <tr algorithm="textureDimensions 3d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        |T| is `texture_3d<ST>`

        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureDimensions(t: T,
                                       level: L) -> vec3<u32>
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type),
  [multisampled](#multisampled-texture-type), [depth](#texture-depth),
  [storage](#texture-storage), or [external](#external-texture-type) texture.
  <tr><td>`level`<td>
  The [=mip level=], with level 0 containing a full size version of the texture.<br>
  If omitted, the dimensions of level 0 are returned.
</table>

**Returns:**

The coordinate dimensions of the texture.

That is, the result provides the integer bounds on the coordinates of the [=logical texel address=],
excluding the [=texture/mip level count=], [=texture/array size=], and [=texture/sample count=].

For textures based on cubes, the results are the dimensions of each face of the cube.
Cube faces are square, so the x and y components of the result are equal.

If `level` is outside the range `[0, textureNumLevels(t))` then an [=indeterminate value=]
for the return type may be returned.

### `textureGather` ### {#texturegather}

A <dfn noexport>texture gather</dfn> operation reads from a 2D, 2D array, cube, or cube array texture,
computing a four-component vector as follows:
* Find the four texels that would be used in a sampling operation with linear filtering,
    from [=mip level=] 0:
    * Use the specified coordinate, array index (when present), and offset (when present).
    * The texels are adjacent, forming a square, when considering their texture space coordinates (*u*,*v*).
    * Selected texels at the texture edge, cube face edge, or cube corners are handled
        as in ordinary texture sampling.
* For each texel, read one channel and convert it into a scalar value.
    * For non-depth textures, a zero-based `component` parameter specifies the channel to use.
        * If the texture format supports the specified channel, i.e. has more than `component` channels:
             * Yield scalar value `v[component]` when the texel value is `v`.
        * Otherwise:
             * Yield 0.0 when `component` is 1 or 2.
             * Yield 1.0 when `component` is 3 (the alpha channel).
    * For [=type/depth textures=], yield the texel value. (Depth textures only have one channel.)
* Yield the four-component vector, arranging scalars produced by the previous step into components
    according to the relative coordinates of the texels, as follows:
    * <table>
        <thead class='data'><td>Result component<td>Relative texel coordinate</thead>
        <tr><td>x<td>(*u*<sub>min</sub>,*v*<sub>max</sub>)
        <tr><td>y<td>(*u*<sub>max</sub>,*v*<sub>max</sub>)
        <tr><td>z<td>(*u*<sub>max</sub>,*v*<sub>min</sub>)
        <tr><td>w<td>(*u*<sub>min</sub>,*v*<sub>min</sub>)
        </table>

TODO: The four texels are the "sample footprint" that should be described by the WebGPU spec.
https://github.com/gpuweb/gpuweb/issues/2343

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureGather 2d">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_2d<ST>,
                                   s: sampler,
                                   coords: vec2<f32>) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather 2d offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_2d<ST>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   offset: vec2<i32>) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather 2d array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_2d_array<ST>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather 2d array offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_2d_array<ST>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A,
                                   offset: vec2<i32>) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather cube">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_cube<ST>,
                                   s: sampler,
                                   coords: vec3<f32>) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather cube array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_cube_array<ST>,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   array_index: A) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_2d,
                                   s: sampler,
                                   coords: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_2d,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_cube,
                                   s: sampler,
                                   coords: vec3<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_2d_array,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_2d_array,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A,
                                   offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_cube_array,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   array_index: A) -> vec4<f32>
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`component`<td>
  Only applies to non-depth textures.
  <br>The index of the channel to read from the selected texels.
  <br>When provided, the `component` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `1`).<br>
  Its value must be at least 0 and at most 3.
  Values outside of this range will result in a [=shader-creation error=].
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type) or [depth](#texture-depth) texture to read from.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A four component vector with components extracted from the specified channel from the selected texels, as described above.

<div class='example wgsl global-scope' heading="Gather components from texels in 2D texture">
  <xmp>
    @group(0) @binding(0) var t: texture_2d<f32>;
    @group(0) @binding(1) var dt: texture_depth_2d;
    @group(0) @binding(2) var s: sampler;

    fn gather_x_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(0,t,s,c);
    }
    fn gather_y_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(1,t,s,c);
    }
    fn gather_z_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(2,t,s,c);
    }
    fn gather_depth_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(dt,s,c);
    }
  </xmp>
</div>

### `textureGatherCompare` ### {#texturegathercompare}

A <dfn noexport>texture gather compare</dfn> operation performs a depth comparison on four texels in a depth
texture and collects the results into a single vector, as follows:

* Find the four texels that would be used in a depth sampling operation with linear filtering,
    from [=mip level=] 0:
    * Use the specified coordinate, array index (when present), and offset (when present).
    * The texels are adjacent, forming a square, when considering their texture space coordinates (*u*,*v*).
    * Selected texels at the texture edge, cube face edge, or cube corners are handled
        as in ordinary texture sampling.
* For each texel, perform a comparison against the depth reference value,
    yielding a 0.0 or 1.0 value, as controlled by the comparison sampler parameters.
* Yield the four-component vector where the components are the comparison results with the texels with
       relative texel coordinates as follows:
    * <table>
        <thead class='data'><td>Result component<td>Relative texel coordinate</thead>
        <tr><td>x<td>(*u*<sub>min</sub>,*v*<sub>max</sub>)
        <tr><td>y<td>(*u*<sub>max</sub>,*v*<sub>max</sub>)
        <tr><td>z<td>(*u*<sub>max</sub>,*v*<sub>min</sub>)
        <tr><td>w<td>(*u*<sub>min</sub>,*v*<sub>min</sub>)
        </table>

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureGatherCompare 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth cube">
    <td>
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_cube,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          depth_ref: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_cube_array,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> vec4<f32>
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [depth](#texture-depth) texture to read from.
  <tr><td>`s`<td>
  The [sampler comparison](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A four component vector with comparison result for the selected texels, as described above.

<div class='example wgsl global-scope' heading="Gather depth comparison">
  <xmp>
    @group(0) @binding(0) var dt: texture_depth_2d;
    @group(0) @binding(1) var s: sampler;

    fn gather_depth_compare(c: vec2<f32>, depth_ref: f32) -> vec4<f32> {
      return textureGatherCompare(dt,s,c,depth_ref);
    }
  </xmp>
</div>

### `textureLoad` ### {#textureload}

Reads a single texel from a texture without sampling or filtering.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureLoad 1d">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_1d<ST>,
                                 coords: C,
                                 level: L) -> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 2d">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_2d<ST>,
                                 coords: vec2<C>,
                                 level: L) -> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 2d array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_2d_array<ST>,
                                coords: vec2<C>,
                                array_index: A,
                                level: L) -> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 3d">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_3d<ST>,
                                 coords: vec3<C>,
                                 level: L) -> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 2d multisampled">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>S</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_multisampled_2d<ST>,
                                 coords: vec2<C>,
                                 sample_index: S)-> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 2d depth">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_depth_2d,
                                 coords: vec2<C>,
                                 level: L) -> f32
      </xmp>

  <tr algorithm="textureLoad 2d depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_depth_2d_array,
                                 coords: vec2<C>,
                                 array_index: A,
                                 level: L) -> f32
      </xmp>

<tr algorithm="textureLoad 2d depth multisampled">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>S</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_depth_multisampled_2d,
                                 coords: vec2<C>,
                                 sample_index: S)-> f32
      </xmp>

  <tr algorithm="textureLoad external">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_external,
                                 coords: vec2<C>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureLoad 1d storage">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/read=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format <var ignore>F</var>.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        @must_use fn textureLoad(t : texture_storage_1d<F, AM>,
                                 coords : C) -> vec4<CF>
      </xmp>

  <tr algorithm="textureLoad 2d storage">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/read=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format <var ignore>F</var>.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        @must_use fn textureLoad(t : texture_storage_2d<F, AM>,
                                 coords : vec2<C>) -> vec4<CF>
      </xmp>

  <tr algorithm="textureLoad 2d array storage">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/read=] or [=access/read_write=]<br>
        <var ignore>A</var> is [=i32=] or [=u32=]<br>
        <var ignore>CF</var> depends on the storage texel format <var ignore>F</var>.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        @must_use fn textureLoad(t : texture_storage_2d_array<F, AM>,
                                 coords : vec2<C>,
                                 array_index : A) -> vec4<CF>
      </xmp>

  <tr algorithm="textureLoad 3d storage">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/read=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format <var ignore>F</var>.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        @must_use fn textureLoad(t : texture_storage_3d<F, AM>,
                                 coords : vec3<C>) -> vec4<CF>
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=],
  [=type/multisampled texture|multisampled=],
  [=type/depth texture|depth=],
  [=type/storage texture|storage=], or
  [=type/external texture|external=]
  texture
  <tr><td>`coords`<td>
  The 0-based texel coordinate.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`level`<td>
  The [=mip level=], with level 0 containing a full size version of the texture.
  <tr><td>`sample_index`<td>
  The 0-based sample index of the [=type/multisampled texture=].
</table>

**Returns:**

The unfiltered texel data.

The [=logical texel address=] is invalid if:
* any element of `coords` is outside the range `[0, textureDimensions(t, level))`
    for the corresponding element, or
* `array_index` is outside the range `[0, textureNumLayers(t))`, or
* `level` is outside the range `[0, textureNumLevels(t))`, or
* `sample_index` is outside the range `[0, textureNumSamples(s))`

If the logical texel addresss is invalid, the built-in function returns one of:
* The data for some texel within bounds of the texture
* A vector (0,0,0,0) or (0,0,0,1) of the appropriate type for non-depth textures
* 0.0 for depth textures

### `textureNumLayers` ### {#texturenumlayers}

Returns the number of layers (elements) of an [=texture/arrayed=] texture.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="texturenumlayers">
    <td><var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        <var ignore>T</var> is `texture_2d_array<ST>`, `texture_cube_array<ST>`,
                               `texture_depth_2d_array`, `texture_depth_cube_array`,
                               or `texture_storage_2d_array<F,A>`
    <td>
      <xmp>@must_use fn textureNumLayers(t: T) -> u32</xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=],
  [=type/depth texture|depth=], or
  [=type/storage texture=] array texture.
</table>

**Returns:**

If the texture is based on cubes, returns the number of cubes in the cube arrayed texture.

Otherwise returns the number of layers (homogeneous grids of texels) in the arrayed texture.

### `textureNumLevels` ### {#texturenumlevels}

Returns the number of mip levels of a texture.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="texturenumlevels">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        <var ignore>T</var> is `texture_1d<ST>`, `texture_2d<ST>`,
                               `texture_2d_array<ST>`, `texture_3d<ST>`,
                               `texture_cube<ST>`, `texture_cube_array<ST>`,
                               `texture_depth_2d`, `texture_depth_2d_array`,
                               `texture_depth_cube`, or `texture_depth_cube_array`
    <td>
      <xmp>@must_use fn textureNumLevels(t: T) -> u32</xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=] or [=type/depth texture|depth=] texture.
</table>

**Returns:**

The [=texture/mip level count=] for the texture.


### `textureNumSamples` ### {#texturenumsamples}

Returns the number samples per texel in a [=type/multisampled texture=].

<table class='data'>
  <thead>
    <tr><td style="width:45%">Parameterization<th>Overload
  </thead>
  <tr algorithm="texturenumsamples">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        <var ignore>T</var> is `texture_multisampled_2d<ST>`
                                or `texture_depth_multisampled_2d`
    <td>
      <xmp>@must_use fn textureNumSamples(t: T) -> u32</xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/multisampled texture=].
</table>

**Returns:**

The [=texture/sample count=] for the [=type/multisampled texture=].


### `textureSample` ### {#texturesample}

Samples a texture.

[=shader-creation error|Must=] only be used in a [=fragment=] shader stage.

If [=uniformity analysis=] cannot prove a call to this function is in [=uniform control flow=],
then a [=trigger/derivative_uniformity=] [=diagnostic=] is [=triggered=].

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSample 1d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_1d<f32>,
                                   s: sampler,
                                   coords: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_2d<f32>,
                                   s: sampler,
                                   coords: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_2d<f32>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_2d_array<f32>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_2d_array<f32>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A,
                                   offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSample(t: T,
                                   s: sampler,
                                   coords: vec3<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_3d<f32>,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   offset: vec3<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_cube_array<f32>,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   array_index: A) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_2d,
                                   s: sampler,
                                   coords: vec2<f32>) -> f32
      </xmp>

  <tr algorithm="textureSample 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_2d,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSample 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_2d_array,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A) -> f32
      </xmp>

  <tr algorithm="textureSample 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_2d_array,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A,
                                   offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSample cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_cube,
                                   s: sampler,
                                   coords: vec3<f32>) -> f32
      </xmp>

  <tr algorithm="textureSample cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_cube_array,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   array_index: A) -> f32
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=] or [=type/depth texture|depth=]
  texture to sample.
  <tr><td>`s`<td>
  The [=sampler=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.

An [=indeterminate value=] results if called in [=uniform control flow|non-uniform control flow=].

### `textureSampleBias` ### {#texturesamplebias}

Samples a texture with a bias to the mip level.

[=shader-creation error|Must=] only be used in a [=fragment=] shader stage.

If [=uniformity analysis=] cannot prove a call to this function is in [=uniform control flow=],
then a [=trigger/derivative_uniformity=] [=diagnostic=] is [=triggered=].

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleBias 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       bias: f32) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       bias: f32,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       bias: f32) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       bias: f32,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: T,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       bias: f32) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_3d<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       bias: f32,
                                       offset: vec3<i32>) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_cube_array<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       array_index: A,
                                       bias: f32) -> vec4<f32>
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture=] to sample.
  <tr><td>`s`<td>
  The [=type/sampler=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`bias`<td>
  The bias to apply to the mip level before sampling.
  `bias` [=shader-creation error|must=] be between `-16.0` and `15.99`.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.

An [=indeterminate value=] results if called in [=uniform control flow|non-uniform control flow=].

### `textureSampleCompare` ### {#texturesamplecompare}

Samples a [=type/depth texture=] and compares the sampled depth values against a reference value.

[=shader-creation error|Must=] only be used in a [=fragment=] shader stage.

If [=uniformity analysis=] cannot prove a call to this function is in [=uniform control flow=],
then a [=trigger/derivative_uniformity=] [=diagnostic=] is [=triggered=].

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleCompare 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_cube,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_cube_array,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> f32
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/depth texture=] to sample.
  <tr><td>`s`<td>
  The [=type/sampler_comparison=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A value in the range `[0.0..1.0]`.

Each sampled texel is compared against the reference value using the comparison
operator defined by the `sampler_comparison`, resulting in either a `0` or `1`
value for each texel.

If the sampler uses bilinear filtering then the returned value is
the filtered average of these values, otherwise the comparison result of a
single texel is returned.

An [=indeterminate value=] results if called in [=uniform control flow|non-uniform control flow=].

### `textureSampleCompareLevel` ### {#texturesamplecomparelevel}

Samples a [=type/depth texture=] and compares the sampled depth values against a reference value.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleCompareLevel 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_2d,
                                               s: sampler_comparison,
                                               coords: vec2<f32>,
                                               depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_2d,
                                               s: sampler_comparison,
                                               coords: vec2<f32>,
                                               depth_ref: f32,
                                               offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_2d_array,
                                               s: sampler_comparison,
                                               coords: vec2<f32>,
                                               array_index: A,
                                               depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
    <xmp>
      @must_use fn textureSampleCompareLevel(t: texture_depth_2d_array,
                                             s: sampler_comparison,
                                             coords: vec2<f32>,
                                             array_index: A,
                                             depth_ref: f32,
                                             offset: vec2<i32>) -> f32
    </xmp>

  <tr algorithm="textureSampleCompareLevel cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_cube,
                                               s: sampler_comparison,
                                               coords: vec3<f32>,
                                               depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_cube_array,
                                               s: sampler_comparison,
                                               coords: vec3<f32>,
                                               array_index: A,
                                               depth_ref: f32) -> f32
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/depth texture=] to sample.
  <tr><td>`s`<td>
  The [=type/sampler_comparison=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A value in the range `[0.0..1.0]`.

The `textureSampleCompareLevel` function is the same as `textureSampleCompare`, except that:

* `textureSampleCompareLevel` always samples texels from mip level 0.
    * The function does not compute derivatives.
    * There is no requirement for `textureSampleCompareLevel` to be invoked in [=uniform control flow=].
* `textureSampleCompareLevel` may be invoked in any shader stage.

### `textureSampleGrad` ### {#texturesamplegrad}

Samples a texture using explicit gradients.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleGrad 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: T,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       ddx: vec3<f32>,
                                       ddy: vec3<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_3d<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       ddx: vec3<f32>,
                                       ddy: vec3<f32>,
                                       offset: vec3<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_cube_array<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       array_index: A,
                                       ddx: vec3<f32>,
                                       ddy: vec3<f32>) -> vec4<f32>
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture=] to sample.
  <tr><td>`s`<td>
  The [=type/sampler=].
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`ddx`<td>
  The x direction derivative vector used to compute the sampling locations.
  <tr><td>`ddy`<td>
  The y direction derivative vector used to compute the sampling locations.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.


### `textureSampleLevel` ### {#texturesamplelevel}

Samples a texture using an explicit mip level.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleLevel 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: f32,
                                        offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d_array<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d_array<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: f32,
                                        offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: T,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_3d<f32>,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        level: f32,
                                        offset: vec3<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_cube_array<f32>,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        array_index: A,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth">
    <td><var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: L) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth offset">
    <td><var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: L,
                                        offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d_array,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: L) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d_array,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: L,
                                        offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel cube depth">
    <td><var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_cube,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        level: L) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_cube_array,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        array_index: A,
                                        level: L) -> f32
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=] or [=type/depth texture|depth=] texture to
  sample.
  <tr><td>`s`<td>
  The [=sampler=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`level`<td>
  The mip level, with level 0 containing a full size version of the texture.
  For the functions where `level` is a `f32`, fractional values may interpolate
  between two levels if the format is filterable according to the
  [Texture Format Capabilities](https://gpuweb.github.io/gpuweb/#texture-format-caps).
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.

### `textureSampleBaseClampToEdge` ### {#textureSampleBaseClampToEdge}

Samples a texture view at its base level,
with texture coordinates clamped to the edge as described below.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>

  <tr algorithm="textureSampleBaseClampToEdge">
    <td><var ignore>T</var> is `texture_2d<f32>` or `texture_external`
    <td>
      <xmp>
        @must_use fn textureSampleBaseClampToEdge(t: T,
                                                  s: sampler,
                                                  coords: vec2<f32>) -> vec4<f32>
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=] or [=type/external texture|external=] texture to sample.
  <tr><td>`s`<td>
  The [=type/sampler=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.

  Before sampling, the given coordinates [=behavioral requirement|will=] be clamped to the rectangle

  > [ *half_texel*, 1 - *half_texel* ]

  where

  >  *half_texel* = vec2(0.5) / vec2&lt;f32&gt;(textureDimensions(t))

  Note: The half-texel adjustment ensures that,
  independent of the sampler's {{GPUAddressMode|addressing}}
  and {{GPUFilterMode|filter}} modes,
  wrapping will not occur.
  That is, when sampling near an edge, the sampled texels
  will be at or adjacent to that edge, and not selected from the opposite edge.
</table>

**Returns:**

The sampled value.

### `textureStore` ### {#texturestore}

Writes a single texel to a texture.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureStore 1d">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/write=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        fn textureStore(t: texture_storage_1d<F,AM>,
                        coords: C,
                        value: vec4<CF>)
      </xmp>

  <tr algorithm="textureStore 2d">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/write=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        fn textureStore(t: texture_storage_2d<F,AM>,
                        coords: vec2<C>,
                        value: vec4<CF>)
      </xmp>

  <tr algorithm="textureStore 2d array">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/write=] or [=access/read_write=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        fn textureStore(t: texture_storage_2d_array<F,AM>,
                        coords: vec2<C>,
                        array_index: A,
                        value: vec4<CF>)
      </xmp>

  <tr algorithm="textureStore 3d">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/write=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        fn textureStore(t: texture_storage_3d<F,AM>,
                        coords: vec3<C>,
                        value: vec4<CF>)
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/write-only storage texture=] or
  [=type/read-write storage texture=]
  <tr><td>`coords`<td>
  The 0-based texel coordinate.<br>
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`value`<td>
  The new texel value.<br>
</table>

**Note:**

The [=logical texel address=] is invalid if:
* any element of `coords` is outside the range `[0, textureDimensions(t))`
    for the corresponding element, or
* `array_index` is outside the range of `[0, textureNumLayers(t))`

If the logical texel addresss is invalid, the built-in function may do any of the following:
* not be executed
* store `value` to some in bounds texel

## Atomic Built-in Functions ## {#atomic-builtin-functions}

Atomic built-in functions can be used to read/write/read-modify-write atomic
objects. They are the only operations allowed on [[#atomic-types]].

All atomic built-in functions use a `relaxed` [[#memory-semantics|memory
ordering]].  This means synchronization and ordering guarantees only apply among
atomic operations acting on the same [=memory locations=].  No synchronization
or ordering guarantees apply between atomic and non-atomic memory accesses, or
between atomic accesses acting on different memory locations.

Atomic built-in functions [=shader-creation error|must not=] be used in a [=vertex=] shader stage.

The address space `AS` of the `atomic_ptr` parameter in all atomic built-in
functions [=shader-creation error|must=] be either [=address spaces/storage=] or [=address spaces/workgroup=].

|T| [=shader-creation error|must=] be either [=u32=] or [=i32=]

### Atomic Load ### {#atomic-load}

```
fn atomicLoad(atomic_ptr: ptr<AS, atomic<T>, read_write>) -> T
```

Returns the atomically loaded the value pointed to by `atomic_ptr`.
It does not [=atomic modification|modify=] the object.

### Atomic Store ### {#atomic-store}

```
fn atomicStore(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T)
```

Atomically stores the value `v` in the atomic object pointed to by `atomic_ptr`.

### Atomic Read-modify-write ### {#atomic-rmw}

```
fn atomicAdd(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicSub(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicMax(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicMin(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicAnd(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicOr(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicXor(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
```
Each function performs the following steps atomically:

1. Load the original value pointed to by `atomic_ptr`.
2. Obtains a new value by performing the operation (e.g. max) from the function
    name with the value |v|.
3. Store the new value using `atomic_ptr`.

Each function returns the original value stored in the atomic object.

```
fn atomicExchange(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
```

Atomically stores the value `v` in the atomic object pointed to
`atomic_ptr` and returns the original value stored in the atomic object.

```
fn atomicCompareExchangeWeak(
      atomic_ptr: ptr<AS, atomic<T>, read_write>,
      cmp: T,
      v: T) -> __atomic_compare_exchange_result<T>

struct __atomic_compare_exchange_result<T> {
  old_value : T; // old value stored in the atomic
  exchanged : bool; // true if the exchange was done
}
```

Note: A value cannot be explicitly declared with the type
`__atomic_compare_exchange_result`, but a value may infer the type.

Performs the following steps atomically:

1. Load the original value pointed to by `atomic_ptr`.
2. Compare the original value to the value `cmp` using an equality operation.
3. Store the value `v` `only if` the result of the equality comparison was `true`.

Returns a two member structure, where the first member, `old_value`, is the
original value of the atomic object and the second member, `exchanged`, is
whether or not the comparison succeeded.

Note: The equality comparison may spuriously fail on some implementations. That
is, the second component of the result vector may be `false` even if the first
component of the result vector equals `cmp`.

## Data Packing Built-in Functions ## {#pack-builtin-functions}

Data packing builtin functions can be used to encode values using data formats that
do not correspond directly to types in WGSL.
This enables a program to write many densely packed values to memory, which can
reduce a shader's memory bandwidth demand.

Each builtin applies the *inverse* of a [=channel transfer function=] to several input values, then combines
their results into a single output value.

Note: For packing unorm values, the normalized floating point values are in the interval [0.0, 1.0].

Note: For packing snorm values, the normalized floating point values are in the interval [-1.0, 1.0].

### `pack4x8snorm` ### {#pack4x8snorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 4x8snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack4x8snorm(e: vec4<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts four normalized floating point values to 8-bit signed integers, and then combines them
        into one `u32` value.<br>
        Component `e[i]` of the input is converted to an 8-bit twos complement integer value
        &lfloor; 0.5 + 127 &times; min(1, max(-1, e[i])) &rfloor; which is then placed in bits
        8 &times; `i` through
        8 &times; `i` + 7 of the result.
</table>

### `pack4x8unorm` ### {#pack4x8unorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 4x8unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack4x8unorm(e: vec4<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts four normalized floating point values to 8-bit unsigned integers, and then combines them
        into one `u32` value.<br>
        Component `e[i]` of the input is converted to an 8-bit unsigned integer value
        &lfloor; 0.5 + 255 &times; min(1, max(0, e[i])) &rfloor; which is then placed in bits
        8 &times; `i` through
        8 &times; `i` + 7 of the result.
</table>

### `pack2x16snorm` ### {#pack2x16snorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 2x16snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack2x16snorm(e: vec2<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts two normalized floating point values to 16-bit signed integers, and then combines them
        into one `u32` value.<br>
        Component `e[i]` of the input is converted to a 16-bit twos complement integer value
        &lfloor; 0.5 + 32767 &times; min(1, max(-1, e[i])) &rfloor; which is then placed in bits
        16 &times; `i` through
        16 &times; `i` + 15 of the result.
</table>

### `pack2x16unorm` ### {#pack2x16unorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 2x16unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack2x16unorm(e: vec2<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts two normalized floating point values to 16-bit unsigned integers, and then combines them
        into one `u32` value.<br>
        Component `e[i]` of the input is converted to a 16-bit unsigned integer value
        &lfloor; 0.5 + 65535 &times; min(1, max(0, e[i])) &rfloor; which is then placed in bits
        16 &times; `i` through
        16 &times; `i` + 15 of the result.
</table>

### `pack2x16float` ### {#pack2x16float-builtin}
<table class='data builtin'>
  <tr algorithm="packing 2x16float">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack2x16float(e: vec2<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts two floating point values to half-precision floating point numbers, and then combines
        them into one `u32` value.<br>
        Component `e[i]` of the input is converted to a [[!IEEE-754|IEEE-754]] binary16 value, which is then
        placed in bits
        16 &times; `i` through
        16 &times; `i` + 15 of the result.
        See [[#floating-point-conversion]].

        If either `e[0]` or `e[1]` is outside the finite range of binary16 then:
        * It is a [=shader-creation error=] if `e` is a [=const-expression=].
        * It is a [=pipeline-creation error=] if `e` is an [=override-expression=].
        * Otherwise the result is an [=indeterminate value=] for u32.
</table>

## Data Unpacking Built-in Functions ## {#unpack-builtin-functions}

Data unpacking builtin functions can be used to decode values in
data formats that do not correspond directly to types in WGSL.
This enables a program to read many densely packed values from memory, which can
reduce a shader's memory bandwidth demand.

Each builtin breaks up an input value into channels, then applies a [=channel transfer function=] to each.

Note: For unpacking unorm values, the normalized floating point result is in the interval [0.0, 1.0].

Note: For unpacking snorm values, the normalized floating point result is in the interval [-1.0, 1.0].

### `unpack4x8snorm` ### {#unpack4x8snorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 4x8snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack4x8snorm(e: u32) -> vec4<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br>
        Component `i` of the result is max(v &div; 127, -1), where `v` is the interpretation of
        bits 8&times;`i` through 8&times;`i + 7` of `e` as a twos-complement signed integer.
</table>

### `unpack4x8unorm` ### {#unpack4x8unorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 4x8unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack4x8unorm(e: u32) -> vec4<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br>
        Component `i` of the result is `v` &div; 255, where `v` is the interpretation of
        bits 8&times;`i` through 8&times;`i + 7` of `e` as an unsigned integer.
</table>

### `unpack2x16snorm` ### {#unpack2x16snorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 2x16snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack2x16snorm(e: u32) -> vec2<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br>
        Component `i` of the result is max(v &div; 32767, -1), where `v` is the interpretation of
        bits 16&times;`i` through 16&times;`i + 15` of `e` as a twos-complement signed integer.
</table>

### `unpack2x16unorm` ### {#unpack2x16unorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 2x16unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack2x16unorm(e: u32) -> vec2<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br>
        Component `i` of the result is `v` &div; 65535, where `v` is the interpretation of
        bits 16&times;`i` through 16&times;`i + 15` of `e` as an unsigned integer.
</table>

### `unpack2x16float` ### {#unpack2x16float-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 2x16float">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack2x16float(e: u32) -> vec2<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into two 16-bit chunks, and reinterpets each chunk
        as a floating point value.<br>
        Component `i` of the result is the f32 representation of `v`,
        where `v` is the interpretation of bits 16&times;`i` through 16&times;`i + 15` of `e`
        as an [[!IEEE-754|IEEE-754]] binary16 value.
        See [[#floating-point-conversion]].
</table>

## Synchronization Built-in Functions ## {#sync-builtin-functions}

All synchronization functions execute a [=control barrier=] with
Acquire/Release [[#memory-semantics|memory ordering]].
That is, all synchronization functions, and affected memory and atomic
operations are ordered in [[#program-order|program order]] relative to the
synchronization function.
Additionally, the affected memory and atomic operations program-ordered before
the synchronization function must be visible to all other threads in the
workgroup before any affected memory or atomic operation program-ordered after
the synchronization function is executed by a member of the workgroup.

All synchronization functions use the `Workgroup` [=memory scope=].<br>
All synchronization functions have a `Workgroup` [=execution scope=].<br>
All synchronization functions [=shader-creation error|must=] only be used in
the [=compute=] shader stage.
All synchronization functions [=shader-creation error|must=] only be invoked in
[=uniform control flow=].

### `storageBarrier` ### {#storageBarrier-builtin}

<table class='data builtin'>
  <tr algorithm="storageBarrier">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        fn storageBarrier()
      </xmp>
  <tr>
    <td>Description
    <td>Executes a [=control barrier=] synchronization function that affects
    memory and atomic operations in the [=address spaces/storage=] address
    space.
</table>

### `textureBarrier` ### {#textureBarrier-builtin}

<table class='data builtin'>
  <tr algorithm="textureBarrier">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        fn textureBarrier()
      </xmp>
  <tr>
    <td>Description
    <td>Executes a [=control barrier=] synchronization function that affects
    memory operations in the [=address spaces/handle=] address space.
</table>

### `workgroupBarrier` ### {#workgroupBarrier-builtin}

<table class='data builtin'>
  <tr algorithm="workgroupBarrier">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        fn workgroupBarrier()
      </xmp>
  <tr>
    <td>Description
    <td>Executes a [=control barrier=] synchronization function that affects
    memory and atomic operations in the [=address spaces/workgroup=] address
    space.
</table>

### `workgroupUniformLoad` ### {#workgroupUniformLoad-builtin}

<table class='data builtin'>
  <tr algorithm="workgroupUniformLoad">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn workgroupUniformLoad(p : ptr<workgroup, T>) -> T
      </xmp>
  <tr>
    <td>Parameterization
    <td>`T` is a [=type/concrete=] [=plain type=] with a [=fixed footprint=]
    that does not contain any [=atomic types=]
  <tr>
    <td>Description
    <td>Returns the value pointed to by `p` to all invocations in the workgroup.
    The return value is [=uniform value|uniform=].
    `p` [=shader-creation error|must=] be a [=uniform value=].

    Executes a [=control barrier=] synchronization function that affects
    memory and atomic operations in the [=address spaces/workgroup=] address
    space.
</table>

# Grammar for Recursive Descent Parsing # {#grammar-recursive-descent}

This section is non-normative.

The WGSL grammar is specified in a form suitable for an LALR(1) parser.
An implementation may want to use a recursive-descent parser instead.

The normative grammar cannot be used directly in a recursive-descent parser, because
several of its rules are left-recursive.
A grammar rule is directly left-recursive when the nonterminal being defined appears first
in one of its productions.

The following is the WGSL grammar, but mechanically transformed to:
* Eliminate direct and indirect left-recursion.
* Avoid empty productions. (That is, avoid epsilon-rules.)
* Bring together common prefixes among sibling productions.

However, it is not LL(1).
For some nonterminals, several productions have common lookahead sets.
For example, all productions for the `attribute` nonterminal start with the `attr` token.
A more subtle example is `global_decl`, where three productions start with an `attribute *`
phrase, but then are distinguished by tokens `fn`, `override`, and `var`.


For the sake of brevity, many token definitions are not repeated.
Use token definitions from the main part of the specification.


<pre class=include>
path: wgsl.recursive.bs.include
</pre>

# Appendix A: The `text/wgsl` Media Type # {#text-wgsl-media-type}

The Internet Assigned Numbers Authority (IANA) maintains a registry of media types, at [[IANA-MEDIA-TYPES]].

The following is the definition of the `text/wgsl` media type for WGSL modules.
It has been registered at IANA,
appearing at [https://www.iana.org/assignments/media-types/text/wgsl](https://www.iana.org/assignments/media-types/text/wgsl).

: Type name
:: text
: Subtype name
:: wgsl
: Required parameters
:: N/A
: Optional parameters
:: None
: Encoding considerations
::  binary
::  WGSL is Unicode text using the UTF-8 encoding, with no byte order mark (BOM).
    See [[!WGSL]] Section 3. Textual Structure.
: Security considerations:
:: WebGPU Shading Language (WGSL) is a programming language for GPU
    code to be executed in the context of the WebGPU API. For security
    considerations, see [[!WebGPU]] Section 2.1 Security Considerations.
    For privacy considerations, see [[!WebGPU]] Section 2.2 Privacy
    Considerations.
: Interoperability considerations:
:: Implementations of WebGPU may have different capabilities, and
    these differences may affect what features may be exercised by
    WGSL programs. See [[!WebGPU]] Section 3.6 Optional capabilities,
    and [[!WGSL]] Section 11. Language Extensions.

    It is expected that implementations will behave as if this
    registration applies to later editions of WGSL, and its published
    specification references may be updated accordingly from time to
    time.  Although this expectation is unusual among media type
    registrations, it matches widespread industry conventions.
: Published specification:
:: [[!WGSL]]
: Applications that use this media type:
::  Implementations of WebGPU. This is expected to include web browsers.
: Fragment identifier considerations
:: None
: Additional information:
:: Magic number(s): None
:: File extension(s): `.wgsl`
:: Macintosh file type code(s): `TEXT`
: Person & email address to contact for further information:
:: David Neto, dneto@google.com, or the Editors listed in WGSL.
: Intended usage
:: COMMON
: Author
:: W3C. See the Editors listed in WGSL.
: Change controller
:: W3C
: Normative References
:: [[!WebGPU]] W3C, "WebGPU” W3C Working Draft, January 2023.  https://w3.org/TR/webgpu
:: [[!WGSL]] W3C, “WebGPU Shading Language” W3C Working Draft, January 2023.  https://w3.org/TR/WGSL
