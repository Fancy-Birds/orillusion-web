<pre class='metadata'>
Title: WebGPU Shading Language
Shortname: WGSL
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/wgsl/
TR: https://www.w3.org/TR/WGSL/
Repository: gpuweb/gpuweb
Text Macro: INT i32 or u32
Text Macro: UNSIGNEDINTEGRAL u32 or vecN&lt;u32&gt;
Text Macro: SIGNEDINTEGRAL i32 or vecN&lt;i32&gt;
Text Macro: ALLSIGNEDINTEGRAL AbstractInt, i32, vecN&lt;AbstractInt&gt;, or vecN&lt;i32&gt;
Text Macro: INTEGRAL i32, u32, vecN&lt;i32&gt;, or vecN&lt;u32&gt;
Text Macro: FLOATING f32, f16, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
Text Macro: NUMERIC i32, u32, f32, f16, vecN&lt;i32&gt;, vecN&lt;u32&gt;, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
Text Macro: FLOATSCALAR [=AbstractFloat=], [=f16=], or [=f32=]
Text Macro: ALLINTEGRALDECL S is AbstractInt, i32, or u32<br>T is S or vecN&lt;S&gt;
Text Macro: ALLFLOATINGDECL S is AbstractFloat, f32, or f16<br>T is S or vecN&lt;S&gt;
Text Macro: ALLNUMERICDECL S is AbstractInt, AbstractFloat, i32, u32, f32, or f16<br>T is S, or vecN&lt;S&gt;
Text Macro: ALLSIGNEDNUMERICDECL S is AbstractInt, AbstractFloat, i32, f32, or f16<br>T is S, or vecN&lt;S&gt;
Ignored Vars: i, c0, e, e1, e2, e3, edge, eN, p, s1, s2, sn, AS, AM, N, newbits, M, C, R, v, Stride, Offset, Align, Extent, T, T1

!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new?labels=wgsl">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues?q=is%3Aissue+is%3Aopen+label%3Awgsl">open issues</a>)
!Tests: <a href=https://github.com/gpuweb/cts/tree/main/src/webgpu/shader/>WebGPU CTS shader/</a>

Editor: Alan Baker, Google https://www.google.com, alanbaker@google.com, w3cid 129277
Editor: Mehmet Oguz Derin, mehmetoguzderin@mehmetoguzderin.com, w3cid 101130
Editor: David Neto, Google https://www.google.com, dneto@google.com, w3cid 99785
Former Editor: Myles C. Maxfield, Apple Inc., mmaxfield@apple.com, w3cid 77180
Former Editor: dan sinclair, Google https://www.google.com, dsinclair@google.com, w3cid 107549
Abstract: Shading language for WebGPU.
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
</pre>

<style>
tr:nth-child(2n) {
  background-color: #b0b0b050;
}
thead {
  background-color: #b0b0b050;
  font-weight: bold;
}
.nowrap {
  white-space:nowrap;
}
.small {
  font-size: smaller;
}
div.syntax {
  display: block;
  page-break-before: avoid;
  padding: .5em 1em;
  background: var(--def-bg);
  border-left: 0.5em solid var(--def-border);
  color: var(--def-text);
  margin-block-start: 1em;
  margin-block-end: 1em;
}
div.syntax > p {
  color: var(--text);
  font-weight: 100;
  margin: 0;
}
div.syntax > p > .choice {
  display: inline-block;
  width: 1em;
  text-align: center;
}
div.syntax > p > a {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  font-style: italic;
  font-weight: normal;
  color: var(--text);
}
div.syntax > p > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
div.syntax > p > a > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
[data-dfn-for="syntax"] {
  font-style: italic;
  font-weight: normal;
  color: var(--text);
}
[data-dfn-for="syntax_kw"] {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
[data-dfn-for="syntax_sym"] {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
  color: var(--text);
  font-style: normal;
  font-weight: bold;
}
.hidden {
  display: none
}
table.data.builtin tbody{
  border-bottom: 0;
}
table.builtin {
  border-bottom: 2px solid grey;
}
table.builtin tr:nth-child(2n) {
    background-color: #00000000;
}
table.builtin td {
    vertical-align: top;
}
/* Our SVGs aren't responsive to light/dark mode, so they're opaque with a
 * white or black background. Rounded corners make them a bit less jarring. */
object[type="image/svg+xml"] {
    border-radius: .5em;
}
</style>

<pre class=biblio>
{
  "WebGPU": {
    "authors": [
      "Kai Ninomiya",
      "Brandon Jones",
      "Myles C. Maxfield"
    ],
    "href": "https://w3.org/TR/webgpu",
    "title": "WebGPU",
    "status": "Working Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "WGSL": {
    "authors": [
      "Alan Baker",
      "Mehmet Oguz Derin",
      "David Neto"
    ],
    "href": "https://www.w3.org/TR/WGSL/",
    "title": "WebGPU Shading Language",
    "status": "Working Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "IEEE-754":{
    "href":"http://ieeexplore.ieee.org/servlet/opac?punumber=4610933",
    "title":"IEEE Standard for Floating-Point Arithmetic",
    "publisher":"Institute of Electrical and Electronics Engineers",
    "isbn":"978-0-7381-5752-8",
    "versions":["IEEE-754-2008","IEEE-754-1985"],
    "id":"IEEE-754",
    "date":"29 August 2008"
  },
  "VulkanMemoryModel": {
    "authors": [
      "Jeff Bolz",
      "Alan Baker",
      "Tobias Hector",
      "David Neto",
      "Robert Simpson",
      "Brian Sumner"
    ],
    "href": "https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model",
    "title": "Vulkan Memory Model",
    "publisher": "Khronos Group"
  },
  "UnicodeVersion14": {
    "href":"http://www.unicode.org/versions/Unicode14.0.0/",
    "author":"The Unicode Consortium",
    "title":"The Unicode Standard, Version 14.0.0",
    "isbn":"978-1-936213-29-0",
    "id":"UnicodeVersion14"
  },
  "DeRemer1969": {
    "href":"http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-065.pdf",
    "author":"F. L. DeRemer",
    "publisher":"Massachusetts Institute of Technology",
    "date":"24 October 1969",
    "title":"Practical Translators for LR(k) Languages"
  },
  "Muller2005": {
    "title":"On the definition of ulp(x)",
    "href":"https://inria.hal.science/inria-00070503",
    "source":"[Research Report] RR-5504, LIP RR-2005-09, INRIA, LIP",
    "author":"Jean-Michel Muller",
    "publisher":"INRIA",
    "date":"February 2005",
    "rawDate": "2005-02"
  },
  "Jeannerod2013": {
    "href":"https://www.ams.org/journals/mcom/2013-82-284/S0025-5718-2013-02679-8/S0025-5718-2013-02679-8.pdf",
    "title":"Further Analysis of Kahan's Algorithm for the Accurate Computation of 2x2 Determinants",
    "authors": [
      "Claude-Pierre Jeannerod",
      "Nicolas Louvet",
      "Jean-Michel Muller"
    ],
    "publisher": "American Mathematical Society",
    "rawDate":"2013-10",
    "pages": "2245-2264"
  },
  "VanWyk2007": {
    "href":"https://dl.acm.org/doi/10.1145/1289971.1289983",
    "title":"Context-Aware Scanning for Parsing Extensible Languages",
    "authors": [
      "Eric R. Van Wyk",
      "August C. Schwerdfeger"
    ],
    "publisher":"Association for Computing Machinery",
    "series":"GCPE'07",
    "date":"2007"
  }
}
</pre>

<pre class='anchors'>
spec: Vulkan ; urlPrefix: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#
    type: dfn
        text: memory model memory operation; url: memory-model-memory-operation
        text: memory model reference; url: memory-model-references
        text: memory model atomic operation; url: memory-model-atomic-operation
        text: memory model scope; url:memory-model-scope
        text: memory model memory semantics; url:memory-model-memory-semantics
        text: memory model non-private; url: memory-model-non-private
spec: UAX14; urlPrefix: https://www.unicode.org/reports/tr14
    type: dfn
        text: UAX14 Section 6.1 Non-tailorable Line Breaking Rules; url: BreakingRules
        text: UAX14 LB4; url: LB4
        text: UAX14 LB5; url: LB5
spec: UAX31; urlPrefix: https://www.unicode.org/reports/tr31/tr31-35.html
    type: dfn
        text: Unicode Standard Annex #31 for Unicode Version 14.0.0
        text: UAX31 Lexical Classes; url: Table_Lexical_Classes_for_Identifiers
        text: UAX31 Grammar; url: D1
spec: Unicode Character Database for Unicode Version 14.0.0; urlPrefix: https://www.unicode.org/Public/14.0.0/ucd/DerivedCoreProperties.txt
    type: dfn
        text: Unicode Character Database for Unicode Version 14.0.0
spec: UnicodeVersion14; urlPrefix: https://www.unicode.org/versions/Unicode14.0.0/UnicodeStandard-14.0.pdf
    type: dfn
        text: code point; url:
spec: WebGPU; urlPrefix: https://gpuweb.github.io/gpuweb/#
    type: dfn
        text: GPU command; url: gpu-command
        text: RasterizationPoint; url: rasterizationpoint
        text: effective buffer binding size; url: abstract-opdef-effective-buffer-binding-size
        text: binding member; url: binding-member
        text: binding resource type; url: binding-resource-type
        text: binding type; url: binding-type
        text: GPU error scope; url: gpu-error-scope
        text: front-facing; url: front-facing
        text: shader-output mask; url: shader-output-mask
        text: framebuffer; url: framebuffer
        text: normalized device coordinates; url: ndc
        text: clip space coordinates; url: clip-space-coordinates
        text: clip position; url: clip-position
        text: viewport; url: dom-renderstate-viewport-slot
        text: rasterizationpoint-destination; url: rasterizationpoint-destination
        text: rasterizationpoint-depth; url: rasterizationpoint-depth
        text: rasterizationpoint-perspectivedivisor; url: rasterizationpoint-perspectivedivisor
        text: fragmentdestination-position; url: fragmentdestination-position
        for: supported limits
            text: maxComputeWorkgroupStorageSize; url: dom-supported-limits-maxcomputeworkgroupstoragesize
    type: attribute
        for: GPU
            text: wgslLanguageFeatures; url: gpuwgsllanguagefeatures
    type: abstract-op
        text: validating GPUProgrammableStage; url: abstract-opdef-validating-gpuprogrammablestage
    type: enum-value
        for: GPUStorageTextureAccess
            text: read-only; url: dom-gpustoragetextureaccess-read-only
            text: read-write; url: dom-gpustoragetextureaccess-read-write
</pre>

# 介绍 # {#intro}

WebGPU着色语言（WGSL）是[[!WebGPU]]的着色语言。换句话说，使用WebGPU API的应用程序使用WGSL来表达在GPU上运行的程序，也称为着色器。

<div class='example wgsl global-scope'>
  <xmp>
    // A fragment shader which lights textured geometry with point lights.

    // Lights from a storage buffer binding.
    struct PointLight {
      position : vec3f,
      color : vec3f,
    }

    struct LightStorage {
      pointCount : u32,
      point : array<PointLight>,
    }
    @group(0) @binding(0) var<storage> lights : LightStorage;

    // Texture and sampler.
    @group(1) @binding(0) var baseColorSampler : sampler;
    @group(1) @binding(1) var baseColorTexture : texture_2d<f32>;

    // Function arguments are values from the vertex shader.
    @fragment
    fn fragmentMain(@location(0) worldPos : vec3f,
                    @location(1) normal : vec3f,
                    @location(2) uv : vec2f) -> @location(0) vec4f {
      // Sample the base color of the surface from a texture.
      let baseColor = textureSample(baseColorTexture, baseColorSampler, uv);

      let N = normalize(normal);
      var surfaceColor = vec3f(0);

      // Loop over the scene point lights.
      for (var i = 0u; i < lights.pointCount; i++) {
        let worldToLight = lights.point[i].position - worldPos;
        let dist = length(worldToLight);
        let dir = normalize(worldToLight);

        // Determine the contribution of this light to the surface color.
        let radiance = lights.point[i].color * (1 / pow(dist, 2));
        let nDotL = max(dot(N, dir), 0);

        // Accumulate light contribution to the surface color.
        surfaceColor += baseColor.rgb * radiance * nDotL;
      }

      // Return the accumulated surface color.
      return vec4(surfaceColor, baseColor.a);
    }
  </xmp>
</div>

## 总览 ## {#overview}

WebGPU通过GPU命令将工作单元发送到GPU中。WGSL关注两种类型的GPU命令：

  * 一个draw command在着色器阶段输入、着色器阶段输出和附加资源的上下文中执行render pipeline。
  * 一个dispatch command在着色器阶段输入和附加资源的上下文中执行compute pipeline。

这两种类型的管线都使用WGSL编写的着色器。


一个shader是WGSL程序中执行管线中的着色器阶段的部分。
一个着色器由以下部分组成：

  * 一个入口函数。
  * 从入口函数开始的所有被调用函数的传递闭包。 这个集合包括用户定义函数和内置函数。(更严格的定义请参见“着色器阶段中的函数”。)
  * 所有这些函数静态访问的变量和常量集合。
  * 用于定义或分析所有这些函数、变量和常量的类型集合。

注意：一个WGSL程序不需要入口函数；然而，API无法执行这样的程序，因为创建GPUProgrammableStage需要入口函数。

执行着色器阶段时，实现的操作：
* 计算在模块范围声明的常量的值。
* 将资源绑定到着色器的资源接口中的变量，使得这些资源的内容在执行期间对着色器可用。
* 为其他模块范围变量分配内存，并使用指定的初始值填充该内存。
* 如果存在，将入口点的形式参数与着色器阶段的输入连接。
* 将入口点的返回值（如果存在）连接到着色器阶段的输出。
* 然后调用入口点。

一个WGSL程序的组织结构包括：

* 指令，用于指定模块级别的行为控制。
* 函数，用于指定执行行为。
* 语句，即声明或可执行行为的单元。
* 文字字面量，用于表示纯数学值的文本表示。
* 常量，为每个特定时间计算的值提供一个名称。
* 变量，为存储值的内存提供一个名称。
* 表达式，每个表达式组合一组值以产生一个结果值。
* 类型，每个类型描述：
    * 一组值。
    * 支持的表达式的约束。
    * 这些表达式的语义。
* 属性，用于修改对象以指定额外信息，例如：
    * 指定接口与入口点。
    * 指定诊断过滤器。

注意：目前，WGSL程序由单个WGSL模块组成。

WGSL是一种命令式语言：行为被指定为要执行的一系列语句。
语句可以：

* 声明[[#value-decls|常量]]或[[#var-decls|变量]]。
* 修改变量的内容。
* 使用结构化编程结构修改执行顺序：
    * 有选择性的执行：[[#if-statement|if]]（可选的else if和else子句），[[#switch-statement|switch]]。
    * 循环执行：[[#loop-statement|loop]]，[[#while-statement|while]]，[[#for-statement|for]]。
    * 退出嵌套的执行结构：[[#continue-statement|continue]]，[[#break-statement|break]]，[[#break-if-statement|break if]]。
    * 重构：[[#function-calls|函数调用]]和[[#return-statement|return]]。
* 评估表达式以计算上述行为的值。
* 在[=shader模块创建|shader creation=]时间使用[=const-expression|常量表达式=]检查[[#const-assert-statement|假设]]。

WGSL是静态类型的：特定表达式计算的每个值都有一个特定类型，只能通过检查程序源代码来确定。

WGSL具有描述布尔值和数字（整数和浮点数）的类型。
这些类型可以组合成复合类型（向量、矩阵、数组和结构体）。
WGSL具有特殊类型（例如原子类型），提供独特的操作。
WGSL描述了可以存储在内存中的类型，称为内存视图。
WGSL以纹理和采样器的形式提供常用的渲染类型。
这些类型有相关的内置函数，用于暴露常见的用于图形渲染的GPU硬件。


WGSL不支持从具体类型自动进行隐式转换或提升，但可以从抽象类型进行隐式转换和提升。
将一个值从一个具体的数值或布尔类型转换为另一个类型需要显式的转换、值构造函数或位的重新解释。
然而，WGSL确实提供了一些有限的方法来将标量类型提升为向量类型。
这同样适用于复合类型。

着色器阶段的工作被划分为一个或多个<dfn noexport>调用</dfn>，每个调用在稍微不同的条件下执行入口点。
着色器阶段中的调用共享某些变量的访问权限：

* 阶段中的所有调用共享着色器接口中的资源。
* 在计算着色器阶段中，同一个计算着色器阶段/工作组中的调用共享地址空间/工作组（address spaces/workgroup）中的变量。不同工作组中的调用不共享这些变量。

然而，调用作用于不同的着色器阶段输入集，包括提供标识值以区分调用与其同行的内建输入。
每个调用都有自己独立的内存空间，即在地址空间/私有（address spaces/private）和地址空间/函数（address spaces/function）中的变量。


在着色器阶段内部，调用并发执行，并且通常可以并行执行。
着色器作者负责确保着色器阶段中调用的动态行为：


满足某些原始操作（包括纹理采样和控制栅栏）的[[#uniformity|一致性]]要求。
协调对共享变量的潜在冲突访问，以避免数据竞争。

在某些情况下，WGSL允许多种可能的行为。
这是一个可移植性风险，因为不同的实现可能表现出不同的行为。
WGSL的设计旨在尽量减少这种情况，但受到可行性和在广泛设备范围内实现高性能的目标的限制。


<dfn noexport>行为要求</dfn>是实现处理或执行WGSL程序时执行的操作。它们描述了实现与程序员的合同中的义务。当这些义务可能不明显时，规范会明确说明这些义务。

## 语法符号表示法 ## {#syntax-notation}

以下语法符号表示WGSL的语法规则约定：

* 在规则两侧的斜体文本表示语法规则。
* 在规则右侧以单引号（'）开始和结束的粗体等宽文本表示关键字和令牌。
* 正常文本中的冒号（:）注册一个语法规则。
* 正常文本中的竖线（|）表示多个可选项。
* 正常文本中的问号（?）表示前一个关键字、令牌、规则或组出现零次或一次（可选）。
* 正常文本中的星号（*）表示前一个关键字、令牌、规则或组出现零次或多次。
* 正常文本中的加号（+）表示前一个关键字、令牌、规则或组出现一次或多次。
* 正常文本中的配对的括号（( 和 )）表示一组元素。

## 数学术语和符号 ## {#terms-and-notation}

<dfn noexport>Angles</dfn>:
* 按照惯例，角度用弧度来表示。
* 测量角度的参考射线是从原点(0,0)指向(+∞,0)的射线。
* 设θ为比较射线和参考射线所对应的角度。那么当比较射线逆时针移动时，θ增加。
* 一个完整的圆周有2π弧度。
* 例子：
    * 角度0从原点指向右边，即指向(1,0)
    * 角度2π从原点指向右边，即指向(1,0)
    * 角度π/4从原点指向(1,1)点
    * 角度π/2从原点指向(0,1)点
    * 角度π从原点指向(-1,0)点
    * 角度(3/2)π从原点指向(0,-1)点

一个间隔是一个有下界和上界的连续数集。
根据上下文，它们可以是整数、浮点数或实数集合。

* 闭区间[a, b]是一组数字x，使得a ≤ x ≤ b。
* 半开区间[a, b)是一组数字x，使得a ≤ x < b。
* 半开区间(a, b]是一组数字x，使得a < x ≤ b。

地板函数是定义在实数 |x| 扩展为正无穷和负无穷的范围内的：

* ⌊ + ∞ ⌋ = +∞
* ⌊ − ∞ ⌋ = −∞
* 对于实数 |x|，⌊|x|⌋ = |k|，其中 |k| 是满足 |k| ≤ |x| < |k|+1 的唯一整数

天花板函数是定义在实数 |x| 扩展为正无穷和负无穷的范围内的：

* ⌈ +∞ ⌉ = +∞
* ⌈ −∞ ⌉ = −∞
* 对于实数 |x|，⌈|x|⌉ = |k|，其中 |k| 是满足 |k|-1 < |x| ≤ |k| 的唯一整数

截断函数是定义在实数 |x| 扩展为正无穷和负无穷的范围内的：

* truncate(+∞) = +∞
* truncate(−∞) = −∞
* 对于实数 |x|，计算绝对值小于或等于 |x| 的最近整数：
    * 如果 |x| ≥ 0，则 truncate(|x|) = ⌊|x|⌋，否则为 ⌈|x|⌉

向上取整函数对于正整数 |k| 和 |n| 定义如下：

* roundUp(|k|, |n|) = ⌈|n| ÷ |k|⌉ × |k|

一个 |c| 列 |r| 行矩阵 |A| 的转置是通过将 |A| 的行复制为 |A|<sup>T</sup> 的列来形成的 |r| 列 |c| 行矩阵：

* transpose(|A|) = |A|<sup>T</sup>
* transpose(|A|)<sub>|i|,|j|</sub> = |A|<sub>|j|,|i|</sub>

列向量的转置是通过将列向量解释为一个 1 行矩阵来定义的。类似地，行向量的转置是通过将行向量解释为一个 1 列矩阵来定义的。

# WGSL 模块 # {#wgsl-module}

一个WGSL程序由一个单独的WGSL模块组成。

一个模块是一个可选指令序列，后面跟着模块作用域声明和const_assert语句。
一个模块按以下方式组织：

* 指令，用于指定模块级别的行为控制。
* 函数，用于指定执行行为。
* 表达式，包括声明或可执行行为的单元。
* 文字量，是纯数学值的文本表示。
* 变量，每个变量提供一个存储值的名称。
* 常量，每个常量提供一个在特定时间计算的值的名称。
* 表达式，每个表达式将一组值组合在一起产生一个结果值。
* 类型，每个类型描述：
    * 一组值。
    * 支持表达式的限制。
    * 表达式的语义。
* 属性，用于修改对象以指定额外的信息，例如：
    * 指定接口到入口点的接口。
    * 指定诊断过滤器。

<pre class=include>
路径：syntax/translation_unit.syntax.bs.include
</pre>

<pre class=include>
路径：syntax/global_decl.syntax.bs.include
</pre>

## 着色器生命周期 ## {#shader-lifecycle}

一个WGSL程序和它可能包含的着色器的生命周期中有四个关键事件。
前两个对应于用于准备执行WGSL程序的WebGPU API方法。
最后两个是着色器执行的开始和结束。


这些事件包括：

1. <dfn noexport>着色器模块创建</dfn>
    * 当调用WebGPU的{{GPUDevice/createShaderModule()}}方法时发生。 此时提供了WGSL程序的源文本。
2. <dfn noexport>管线创建</dfn>
    * 当调用WebGPU的{{GPUDevice/createComputePipeline()}}方法或{{GPUDevice/createRenderPipeline()}}方法时发生。 这些方法使用一个或多个先前创建的着色器模块，以及其他配置信息。
3. <dfn noexport>着色器执行开始</dfn>
    * 当向GPU发出绘制命令或调度命令时发生， 着色器开始执行指定的管线， 并调用着色器阶段的入口点函数。
4. <dfn noexport>着色器执行结束</dfn>
    * 当着色器中的所有工作完成时发生：
        * 所有执行终止，
        * 所有对资源的访问完成，
        * 如果有输出，将传递给下游管线阶段。

事件的排序是基于以下原因：

* 数据依赖性：着色器执行需要流水线，而流水线需要着色器模块。
* 因果关系：着色器必须在完成执行前开始执行。

## 错误 ## {#errors}

WebGPU 实现可能由于两个原因无法处理着色器：

* 如果着色器不满足 WGSL 或 WebGPU 规范的要求，则会出现 <dfn export>程序错误</dfn>。
* 即使满足了所有 WGSL 和 WebGPU 的要求，也可能出现 <dfn noexport>未分类错误</dfn>。 可能的原因包括：
    * 着色器过于复杂，超出了实现的能力，但无法轻松捕捉到预定的[[#limits |limits]]。简化着色器可能可以解决此问题。
    * WebGPU 实现中的缺陷。

着色器的生命周期中可能会发生处理错误的三个阶段：

* <dfn export>着色器创建错误</dfn> 是在[=着色器模块创建=]过程中可能检测到的错误。 检测仅依赖于 WGSL 模块源文本和可用于 createShaderModule API 方法的其他信息。 如果程序违反了规范中描述的必须进行的某些操作，则通常会产生着色器创建错误。

* <dfn export>管线创建错误</dfn> 是在[=管线创建=]过程中可能检测到的错误。 检测依赖于 WGSL 模块源文本和可用于特定管线创建 API 方法的其他信息。

* <dfn export>动态错误</dfn>是在着色器执行过程中发生的错误。 这些错误可能可检测，也可能不可检测。


注意：例如，数据竞争可能无法检测到。


每个要求的[=行为要求|行为=]将在最早的机会进行检查。
也就是说：

* 如果在着色器创建时未满足可在着色器创建时检测到的要求，则会导致着色器创建错误。
* 如果在管线创建时未满足可在管线创建时检测到的要求，则会导致管线创建错误，但不会在此之前检测到。

在上下文不清楚的情况下，该规范会指出
未满足特定要求的结果是着色器创建错误、管线创建错误还是动态错误。

错误的后果如下：

* 具有[=着色器创建错误=]或[=管线创建错误=]错误的 WGSL 模块将不会合并到[=管线=]中，因此不会被执行。
* 可检测到的错误[=行为要求|将=]会触发[=诊断=]。
* 如果发生[=动态错误=]：
    * [=内存访问=]只能限制为：
        * [=着色器阶段输入=]，
        * [=着色器阶段输出=]，
        * 绑定到 WGSL 模块变量的[=资源=]的任何部分以及
        * 在 WGSL 模块中声明的其他变量。
    * 否则，程序可能不会按照本规范的其余部分描述的那样运行。 注意：这些效果可能是非局部的。

## 诊断 ## {#diagnostics}


在“着色器模块创建”或“管线创建”过程中，实现可能会产生诊断信息。
诊断信息是为了应用程序作者的利益而由实现生成的消息。


当满足特定条件时，会创建或触发诊断，这被称为“触发规则”。
在源文本中满足条件的位置，表示为源文本中的点或范围，被称为“触发位置”。


诊断具有以下属性：

* 诊断严重性。
* 触发规则。
* 触发位置。

诊断的严重性可以是以下类型，按照从高到低排序：
: <dfn dfn-for="severity" noexport>错误</a>
:: 该诊断是一个错误。
这对应于“着色器创建错误”或“管线创建错误”。
: <dfn dfn-for="severity" noexport>警告</a>
:: 该诊断描述了值得应用程序开发人员注意的异常，但不是错误。
: <dfn dfn-for="severity" noexport>信息</a>
:: 该诊断描述了值得应用程序开发人员注意的显著条件，但不是错误或警告。
: <dfn dfn-for="severity" noexport>关闭</a>
:: 该诊断已被禁用。不会传达给应用程序。

“触发规则”的名称可以是：

* 一个“诊断名称标记”，或
* 两个“诊断名称标记”，由句点“.”（U+002E）分隔。

<pre class=include>
路径：syntax/diagnostic_rule_name.syntax.bs.include
</pre>

### 诊断处理 ### {#diagnostic-processing}

触发的诊断行为将按以下方式进行处理：

1. 对于每个诊断D，找到包含D的触发位置的最小受影响范围的诊断过滤器，并且该过滤器具有相同的触发规则。
    * 如果存在这样的过滤器，将其应用于D，更新D的严重程度。
    * 否则，D保持不变。
2. 丢弃严重程度为关闭的诊断。
3. 如果至少有一个剩余的诊断DI的严重程度为信息：
    * 可能会丢弃其他具有相同触发规则的信息诊断，只保留原始诊断DI。
4.如果至少有一个剩余的诊断DW的严重程度为警告：
    * 可能会丢弃其他严重程度为信息或警告的具有相同触发规则的诊断，只保留原始诊断DW。
5. 如果至少有一个剩余的诊断的严重程度为错误：
    * 可能会丢弃其他诊断，包括其他严重程度为错误的诊断。
    * 生成一个程序错误。
        * 如果诊断在着色器模块创建时触发，错误是一个着色器创建错误。
        * 如果诊断在管线创建时触发，错误是一个管线创建错误。
6. 如果在着色器模块创建期间进行处理，剩余的诊断将填充WebGPU GPUCompilationInfo对象的GPUCompilationInfo/messages成员。
7. 如果在管线创建期间进行处理，严重程度为错误的诊断将导致WebGPU验证失败，验证GPUProgrammableStage。

注意：规则允许实现在检测到错误后停止处理WGSL模块。
此外，针对特定警告的分析可以在第一个警告上停止，
针对特定信息诊断的分析可以在第一次出现时停止。
WGSL不指定执行不同种类分析的顺序，或在单个分析中的顺序。
因此，对于相同的WGSL模块，不同的实现可能报告相同严重程度的不同诊断实例。

### 可过滤的触发规则 ### {#filterable-triggering-rules}

大多数诊断信息都会直接报告给WebGPU应用程序。
某些类型的诊断信息可以通过命名其诊断/触发规则来进行[[#diagnostic-filtering|过滤]]。
以下表格列出了可以进行过滤的标准触发规则集。

<table class='data'>
  <caption>可筛选的诊断触发规则</caption>
  <thead>
    <tr><th>可筛选的触发规则<th>默认的严重性<th>触发位置<th>描述
  </thead>

  <tr>
    <td><dfn noexport dfn-for="trigger">derivative_uniformity</dfn>
    <td>[=severity/error=]
    <td>The location of the [=call site=] for any
        [=builtin functions that compute a derivative|builtin function that computes a derivative=].
        That is, the location of a call to any of:
        * the [[#derivative-builtin-functions|derivative builtin functions]]
        * [[#texturesample|textureSample]]
        * [[#texturesamplebias|textureSampleBias]]
        * [[#texturesamplecompare|textureSampleCompare]]

    <td>一个对内置函数的调用会计算出导数，但是[=uniformity analysis=]无法证明该调用发生在[=uniform control flow=]中。

    见 [[#uniformity]].
</table>

使用一个单一的[=diagnostic name-token=]组成的未识别的触发规则应该触发用户代理的警告。


实现可以支持此处未指定的触发规则，只要它们使用[=syntax/diagnostic_rule_name=]的多令牌形式拼写。
使用多令牌形式拼写的未识别的触发规则本身可能触发诊断。


未来版本的规范可能会删除特定的规则或降低其默认严重程度
（即用较轻的默认值替换其当前默认值），但仍被视为满足向后兼容性要求。
例如，未来版本的WGSL可能会将[=trigger/derivative_uniformity=]的默认严重程度从“错误”更改为“警告”或“信息”。
在规范更改后，先前有效的程序仍将保持有效。

### 诊断过滤 ### {#diagnostic-filtering}


一旦具有可过滤的诊断和触发规则的诊断被触发，WGSL提供机制来丢弃诊断或修改其严重性。

一个诊断过滤器DF有三个参数：

* AR：称为受影响范围的源文本范围
* NS：新的诊断严重性
* TR：触发规则

将诊断过滤器DF（AR，NS，TR）应用于诊断D具有以下效果：

* 如果D的触发位置在AR内，且D的触发规则为TR，则将D的严重性属性设置为NS。
* 否则，D保持不变。

范围诊断过滤器是一个受影响范围为指定源文本范围的诊断过滤器。
范围诊断过滤器指定为开始处的@diagnostic属性，如下表所示。
@diagnostic属性不能出现在其他位置。

范围诊断过滤器的放置位置和受影响范围如下表所示。

注意：以下也是复合语句：函数体、case子句、default-alone子句、while和for循环的循环体，if子句、else_if子句和else子句的主体。

例如，在纹理采样上使用范围诊断过滤器的示例：

var<private> d: f32;
fn helper() -> vec4<f32> {
  // 在"if"的主体中禁用derivative_uniformity诊断。
  if (d < 0.5) @diagnostic(off,derivative_uniformity) {
    return textureSample(t,s,vec2(0,0));
  }
  return vec4(0.0);
}

全局诊断过滤器可以用于将诊断过滤器应用于整个WGSL模块。


例如，具有导数一致性的全局诊断过滤器的示例：

diagnostic(off,derivative_uniformity);
var<private> d: f32;
fn helper() -> vec4<f32> {
  if (d < 0.5) {
    // 通过全局诊断过滤器在此处禁用导数一致性诊断。
    return textureSample(t,s,vec2(0,0));
  } else {
    // 导数一致性诊断设置为警告级别。
    @diagnostic(warning,derivative_uniformity) {
      return textureSample(t,s,vec2(0,0));
    }
  }
  return vec4(0.0);
}

两个诊断过滤器DF1（AR1，NS1，TR1）和DF2（AR2，NS2，TR2）冲突，当：

* （AR1 = AR2），且
* （TR1 = TR2），且
* （NS1 ≠ NS2）。

诊断过滤器不能冲突。

WGSL的诊断过滤器设计为受影响范围完美嵌套。
如果DF1的受影响范围与DF2的受影响范围重叠，那么DF1的受影响范围要么完全包含在DF2的受影响范围内，要么反之亦然。

对于源位置L和触发规则TR，如果存在最近的封闭诊断过滤器，则是诊断过滤器DF（AR，NS，TR），其中：

L位于受影响范围AR内，且
如果有另一个过滤器DF’（AR’，NS’，TR），其中L位于AR’内，则AR包含在AR’内。

因为受影响范围可以嵌套，最近的封闭诊断是唯一的或不存在。

## 限制 ## {#limits}

一个WGSL实现将支持满足以下限制的着色器。
一个WGSL实现可以支持超出指定限制的着色器。

注意：如果一个WGSL实现不支持超出指定限制的着色器，应该发出错误。

<table class=‘data’>
  <caption>可量化的着色器复杂度限制</caption>
  <thead>
    <tr><th>限制<th>最小支持值
  </thead>
  <tr><td>结构类型中的成员最大数量<td>16383
  <tr><td>复合类型的最大嵌套深度<td>255
  <tr><td>函数中花括号包围语句的最大嵌套深度<td>127
  <tr><td>函数的最大形式参数数量<td>255
  <tr><td>switch语句中的case选择器的最大数量<td>16383
  <tr><td>在地址空间/函数或地址空间/私有地址空间中实例化的数组类型的最大字节大小
          对于这个限制，bool类型的大小为1字节。
      <td>65535
  <tr><td>在地址空间/工作组地址空间中实例化的数组类型的最大字节大小。
          对于这个限制，bool类型的大小为1字节，并且当替代覆盖值时，固定尺寸的数组被视为创建固定尺寸的数组。
          这将WebGPU的支持限制maxComputeWorkgroupStorageSize映射到一个独立的WGSL限制。
          注意：虽然满足这个限制的多个工作组变量仍然可以组合超过API限制。
      <td>[=supported limits/maxComputeWorkgroupStorageSize|16384=]
  <tr><td>数组类型的常量表达式中的最大元素数量<td>65535
</table>

# 文本结构 # {#textual-structure}

text/wgsl 媒体类型用于将内容标识为 WGSL 模块。
参见[[#text-wgsl-media-type]]。

WGSL 模块是使用 UTF-8 编码的 Unicode 文本，没有字节顺序标记（BOM）。

WGSL 模块文本由一系列 Unicode [=码点=] 组成，这些码点分组为连续非空的集合，形成：

* [=注释=]
* [=标记=]
* [=空白字符=]

程序文本 [=着色器创建错误|不得=] 包含空代码点（U+0000）。

## 解析 ## {#parsing}

解析WGSL模块的步骤如下:
<blockquote>
1. 移除[=comments=]：
    * 用空格代码点(U+0020)替换第一个注释。
    * 重复此过程直到没有注释为止。
2. 使用[[#template-lists-sec]]中的[=template list discovery=]算法，寻找[=template lists=]。
3. 解析整个文本，尝试匹配[=syntax/translation_unit=]语法规则。 解析使用了一个LALR(1)解析器(一次向前看一个标记) [[!DeRemer1969]]，以下是定制内容:
    * Tokenization与解析交错进行，并且具有上下文感知功能。 当解析器请求下一个标记时:
        * 消耗并忽略一系列以[=blankspace=]代码点开头的字符。
        * 如果下一个代码点是[=template list=]的开始，消耗它并返回[=syntax_sym/_template_args_start=]。
        * 如果下一个代码点是[=template list=]的结束，消耗它并返回[=syntax_sym/_template_args_end=]。
        * 否则:
            * 一个<dfn>token candidate</dfn>是由剩下未消耗代码点的非空前缀构成的WGSL[=token=]。
            * 返回的标记是最长的、同时也是当前解析器状态的有效向前看标记的[=token candidate=]。[[!VanWyk2007]]
</blockquote>


如果发生[=shader-creation error=]，则可能是因为:
* 整个源代码无法转换为有效标记的有限序列，或者
* [=syntax/translation_unit=]语法规则与整个标记序列不匹配。

## 空白处和换行 ## {#blankspace-and-line-breaks}

<dfn>空格</dfn>是来自Unicode的一个或多个代码点的组合。
下面是Unicode版本14.0.0的[=Unicode标准附录＃31：Pattern_White_Space=]属性中的代码点集合：

* 空格（U+0020）
* 水平制表符（U+0009）
* 换行符（U+000A）
* 垂直制表符（U+000B）
* 换页符（U+000C）
* 回车符（U+000D）
* 下一行（U+0085）
* 从左到右的标记（U+200E）
* 从右到左的标记（U+200F）
* 行分隔符（U+2028）
* 段落分隔符（U+2029）

<dfn>换行符</dfn>是一系列[=空格=]代码点的连续序列，表示行的结束。
它被定义为[=UAX14第6.1节不可调整的换行规则=]中定义的一个“强制换行”信号，即[=UAX14 LB4|LB4=]和[=UAX14 LB5|LB5=]。
换行符可以是以下之一：

* 换行符（U+000A）
* 垂直制表符（U+000B）
* 换页符（U+000C）
* 回车符（U+000D），但未跟随换行符（U+000A）
* 回车符（U+000D）后跟换行符（U+000A）
* 下一行（U+0085）
* 行分隔符（U+2028）
* 段落分隔符（U+2029）

注意：以行号报告源文本位置的诊断应使用[=换行符=]来计算行数。

## 注释 ## {#comments}

一个<dfn>注释(comment)</dfn>是一段文本，它不会影响WGSL程序的有效性或含义，除非它能够分隔[=标记(tokens)=]。着色器作者可以使用注释来对他们的程序进行文档记录。

一个<dfn noexport>行尾注释(line-ending comment)</dfn>是一种注释，由两个代码点// (U+002F后跟U+002F)和随后的代码点组成，直到但不包括:

* 下一个[=换行符(line break)=]，或
* 程序结束。

一个<dfn noexport>块注释(block comment)</dfn>是一种注释，由以下组成:

* 两个代码点/* (U+002F后跟U+002A)
* 任意序列:
    * 一个[=块注释(block comment)=]，或
    * 不包含*/ (U+002A后跟U+002F)或/* (U+002F后跟U+002A)的文本
* 两个代码点*/ (U+002A后跟U+002F)

注意：块注释可以嵌套。由于块注释需要匹配的开始和结束文本序列，并且允许任意嵌套，因此无法使用正则表达式识别块注释。这是正则语言泵引理的一个结果。

<div class='example wgsl' heading='Comments'>
  <xmp>
  const f = 1.5; // This is line-ending comment.
  const g = 2.5; /* This is a block comment
                  that spans lines.
                  /* Block comments can nest.
                   */
                  But all block comments must terminate.
                 */
  </xmp>
</div>

## 令牌 ## {#tokens}
一个<dfn>标记</dfn>是由连续的代码点形成的一种：

* 一个[=文字=]。
* 一个[=关键词=]。
* 一个[=保留字=]。
* 一个[=语法标记=]。
* 一个[=标识符=]。
* 一个[=上下文相关名称=]。

## 字面量 ## {#literals}

一个<dfn>字面量</dfn>是以下之一：

* 一个<dfn noexport>布尔字面量</dfn>：要么是true，要么是false。
* 一个<dfn>数值字面量</dfn>：要么是一个整数字面量，要么是一个浮点数字面量， 用来表示一个数字。

<pre class=include>
path: syntax/literal.syntax.bs.include
</pre>

### 布尔字面量 ### {#boolean-literals}

<div class='example wgsl bool-literals' heading='boolean literals'>
  <xmp>
    const a = true;
    const b = false;
  </xmp>
</div>

<pre class=include>
path: syntax/bool_literal.syntax.bs.include
</pre>

### 数值字面量 ### {#numeric-literals}

数字字面值的形式是通过模式匹配来定义的。

一个整数字面值是：

* 一个表示整数的方式，可以是以下任意一种：
    * 0
    * 一串十进制数字，其中第一个数字不是0。
    * 0x或0X后跟一个十六进制数字序列。
* 然后是可选的i或u后缀。

<pre class=include>
path: syntax/int_literal.syntax.bs.include
</pre>

<pre class=include>
path: syntax/decimal_int_literal.syntax.bs.include
</pre>

<div class='example wgsl decimal-int-literals' heading='decimal integer literals'>
  <xmp>
    const a = 1u;
    const b = 123;
    const c = 0;
    const d = 0i;
  </xmp>
</div>

<pre class=include>
path: syntax/hex_int_literal.syntax.bs.include
</pre>

<div class='example wgsl hexadecimal-int-literals' heading='hexadecimal integer literals'>
  <xmp>
    const a = 0x123;
    const b = 0X123u;
    const c = 0x3f;
  </xmp>
</div>

<dfn>浮点数字面值</dfn>是指十进制浮点数字面值或十六进制浮点数字面值。

<pre class=include>
path: syntax/float_literal.syntax.bs.include
</pre>

一个浮点数字面量有两个逻辑部分：表示分数的尾数和一个可选的指数。
大致上，字面量的值等于尾数乘以一个基础值的给定指数次方。
如果一个尾数数字非零，或者它的左边和右边都有非零的尾数数字，那么这个数字就是【尾数】中的【有效数字】。
有效数字从左到右进行计数：第n个有效数字左边有n-1个有效数字。

一个<dfn noexport>十进制浮点数字面量</dfn>是：

* 一个尾数，由一系列数字指定，其中可以选用一个小数点（.）放置在其中某个位置。 尾数表示一个十进制数分数。
* 然后是一个可选的指数后缀，包括：
    * e 或 E。
    * 然后是一个十进制数指定的指数，可以带有可选的符号（+ 或 -）。
    * 然后是一个可选的 f 或 h 后缀。
* 小数点、指数或 f 或 h 后缀中至少要有一个。 如果没有其中任何一个，则该标记实际上是一个整数字面值。

<pre class=include>
path: syntax/decimal_float_literal.syntax.bs.include
</pre>

<div class='example wgsl decimal-float-literals' heading='decimal floating point literals'>
  <xmp>
    const a = 0.e+4f;
    const b = 01.;
    const c = .01;
    const d = 12.34;
    const f = .0f;
    const g = 0h;
    const h = 1e-3;
  </xmp>
</div>

<div algorithm="mathematical value of decimal floating point literal">

一个十进制浮点字面量的数学值计算如下：
* 根据 |mantissa| 计算出 |effective_mantissa|：
    * 如果 |mantissa| 有20个或更少的有效数字，那么 |effective_mantissa| 就是 |mantissa|。
    * 否则：
        * 令 |truncated_mantissa| 与 |mantissa| 相同，除了第20个有效数字右边的每个数字被替换为0。
        * 令 |truncated_mantissa_next| 与 |mantissa| 相同，除了：
            * 第20个有效数字增加1，并将进位传递到左侧，以确保每个数字仍在0到9的范围内，
            * 第20个有效数字右边的每个数字被替换为0。
        * 将 |effective_mantissa| 设置为 |truncated_mantissa| 或 |truncated_mantissa_next|。这是一个实现选择。
* 字面量的数学值是以十进制小数形式表示的 |effective_mantissa| 的数学值，乘以10的指数次方。 当未指定指数时，假定指数为0。

</div>

注意：小数尾数在20位小数后被截断，保留了大约log(10)/log(2)×20约等于66.4个有效位数的小数部分。

一个<dfn noexport>十六进制浮点字面量</dfn>包括：

* 一个以0x或0X开头的前缀
* 之后是一个尾数，表示为一串十六进制数字，其中可以选择包含一个十六进制小数点（.）。 尾数表示一个十六进制的分数。
* 之后是一个可选的指数后缀，包括：
    * p或P
    * 之后是一个指数，表示为一个十进制数字，可以选择带有一个可选的符号（+或-）。
    * 之后是一个可选的f或h后缀。
* 十六进制小数点或指数中至少有一个必须存在。 如果两者都不存在，则该标记实际上是一个整数字面量。

<pre class=include>
path: syntax/hex_float_literal.syntax.bs.include
</pre>

<div class='example wgsl hexadecimal-float-literals' heading='hexadecimal floating point literals'>
  <xmp>
    const a = 0xa.fp+2;
    const b = 0x1P+4f;
    const c = 0X.3;
    const d = 0x3p+2h;
    const e = 0X1.fp-4;
    const f = 0x3.2p+2h;
  </xmp>
</div>

<div algorithm="mathematical value of hexadecimal floating point literal">
十六进制浮点数文字的数学值计算如下：

* 根据尾数计算有效尾数：
    * 如果尾数有16位或更少的有效数字，则有效尾数等于尾数。
    * 否则：
        * 将截断后的尾数设为与尾数相同，除了第16位有效数字右边的每一位都被替换为0。
        * 将截断后的下一个尾数设为与尾数相同，除了：
            * 第16位有效数字增加1，并根据需要向左传播进位，以确保每一位数字保持在0到f的范围内，以及
            * 第16位有效数字右边的每一位都被替换为0。
        * 将有效尾数设为截断尾数或截断后的下一个尾数之一。这是一个实现选择。
* 文字的数学值是以十六进制分数的形式表示的有效尾数的数学值，乘以2的指数次方。 如果没有指定指数，则假定指数为0。

</div>

注意：十六进制尾数在16个十六进制数字后被截断，保留大约64个有效比特的小数部分。

当一个数值字面量有后缀时，这个字面量表示特定标量类型的值。
否则，字面量表示下面定义的一个抽象数值类型的值。
无论哪种情况，字面量表示的值是将其转换为目标类型后的数学值，
遵循[[#floating-point-conversion]]中的规则。

<table class=data>
  <caption>Mapping numeric literals to types</caption>
  <thead>
    <tr><th>Numeric Literal<th>Suffix<th>Type<th>Examples
  </thead>

  <tr><td>[=integer literal=]<td>`i`<td>[=i32=]<td>42i
  <tr><td>[=integer literal=]<td>`u`<td>[=u32=]<td>42u
  <tr><td>[=integer literal=]<td><td>[=AbstractInt=]<td>124
  <tr><td>[=floating point literal=]<td>`f`<td>[=f32=]<td>42f 1e5f 1.2f 0x1.0p10f
  <tr><td>[=floating point literal=]<td>`h`<td>[=f16=]<td>42h 1e5h 1.2h 0x1.0p10h
  <tr><td>[=floating point literal=]<td><td>[=AbstractFloat=]<td>1e5 1.2 0x1.0p10
</table>

如果发生以下情况之一，将导致“shader-creation error”：

* 带有“i”或“u”后缀的整数字面量无法由目标类型表示。
* 带有“f”或“h”后缀的十六进制浮点数字面量溢出或无法被目标类型准确表示。
* 带有“f”或“h”后缀的十进制浮点数字面量溢出目标类型。
* 在未启用“extension/f16|f16 extension”时使用带有“h”后缀的浮点数字面量。

注意：十六进制浮点值“0x1.00000001p0”需要33个尾数位才能准确表示，而“f32”只有23个显式尾数位。


注意：如果您想使用“f”后缀强制将十六进制浮点数字面量标记为某种类型，字面量还必须使用二进制指数。例如，写作“0x1p0f”。相比之下，“0x1f”是一个十六进制整数字面量。

## Keywords ## {#keywords}

一个<dfn>关键字</dfn>是指一个预定义的语言概念的[=标记=]。
请参阅[[#keyword-summary]]以获取WGSL关键字列表。

## 标识符 ## {#identifiers}

标识符是一种被用作名称的令牌。参见[[#declaration-and-scope]]。

WGSL使用两种语法非终结符来区分用例：

* 语法非终结符"ident"用于命名一个声明的对象。
* 语法非终结符"member_ident"用于命名一个结构类型的成员。

<pre class=include>
path: syntax/ident.syntax.bs.include
</pre>
<pre class=include>
path: syntax/member_ident.syntax.bs.include
</pre>

标识符的形式基于《Unicode标准附录 #31 - Unicode版本14.0.0》中描述的规范，并有以下详细说明。

标识符使用根据《UAX31语法》描述的以下配置文件。

```
<Identifier> := <Start> <Continue>* (<Medial> <Continue>+)*

<Start> := XID_Start + U+005F
<Continue> := <Start> + XID_Continue
<Medial> :=
```

这意味着像Δέλτα，réflexion，Кызыл，𐰓𐰏𐰇，朝焼け，سلام，검정，שָׁלוֹם，गुलाबी，փիրուզ这样具有非ASCII代码点的标识符是有效的。

With the following exceptions:
* An identifier [=shader-creation error|must not=] have the same spelling as a [=keyword=] or as a [=reserved word=].
* An identifier [=shader-creation error|must not=] be `_` (a single underscore, `U+005F`).
* An identifier [=shader-creation error|must not=] start with `__` (two underscores, `U+005F` followed by `U+005F`).

<pre class=include>
path: syntax/ident_pattern_token.syntax.bs.include
</pre>

[=Unicode Character Database for Unicode Version 14.0.0=] 包含了非规范性的列表，其中包含了所有有效的编码点，包括 [=UAX31 Lexical Classes|XID_Start=] 和 [=UAX31 Lexical Classes|XID_Continue=]。

注意：一些内建函数的返回类型是结构类型，这些结构类型的名称在WGSL源代码中不能使用。这些结构类型被描述得好像它们是以两个下划线开头的预声明类型。结果值可以使用类型推断保存到新声明的let或var中，或者可以立即通过名称提取其中的一个成员。请参阅frexp和modf的描述中的示例用法。

### 标识符比较 ### {#identifier-comparison}

如果且仅当两个WGSL标识符由相同的代码点序列组成时，它们才是相同的。


注意：本规范不允许对值进行Unicode归一化以进行比较。
视觉上和语义上相同但使用不同Unicode字符序列的值将不匹配。
建议内容作者在选择值时要么始终使用相同的编码序列，要么避免使用可能会引起问题的字符。
有关更多信息，请参阅[[CHARMOD-NORM]]。


注意：当一个WGSL模块的含义会随着将所有标识符的实例替换为该标识符的形状相同的标识符之一而发生改变时，用户代理应发出开发者可见的警告。
（同形异意是一串代码点的序列，可能对读者来说与另一串代码点的序列看起来相同。
检测同形异意的映射示例包括前一段中提到的转换、映射和匹配算法。如果标识符可以通过重复替换子序列来将一个序列转换为另一个序列，则这两个序列是同形异意的。）

## 依赖上下文的名称 ## {#context-dependent-names}

一个<dfn>上下文相关名称（context-dependent name）</dfn>是一个用于命名概念的<b><dfn>标记（token）</dfn></b>，但仅在特定的语法上下文中使用。
这个标记的拼写可能与<b><dfn>标识符（identifier）</dfn></b>相同，但该标记并不会<b><dfn>解析（resolve）</dfn></b>为一个已声明的对象。

章节[[#context-dependent-name-tokens]]列出了所有这样的标记。

## 诊断规则名称 ## {#diagnostic-rule-names}
<dfn noexport>诊断性名词令牌</dfn>是诊断触发规则名称中使用的令牌。令牌的拼写可能与标识符相同，但不会解析为已声明的对象。该令牌不能是关键字或保留字。

参见[[#diagnostics]]。

<pre class=include>
path: syntax/diagnostic_name_token.syntax.bs.include
</pre>

## 模板列表 ## {#template-lists-sec}

<dfn noexport>模板参数化</dfn>是一种指定修改常规概念的参数的方式。
要编写一个模板参数化，先写出常规概念，然后是一个[=模板列表=]。

忽略[=注释=]和[=空格=]，一个<dfn noexport>模板列表</dfn>由以下部分组成：

* 一个初始的'<'（U+003C）代码点，然后
* 一个[=syntax_sym/comma=]分隔的一个或多个<dfn noexport>模板参数</dfn>的列表，然后
* 一个可选的尾部[=syntax_sym/comma=]，然后
* 一个终止的'>'（U+003E）代码点。

一个[=模板参数=]的形式是通过下面的[=模板列表发现=]算法隐式定义的。
通常，它们是名称、表达式或类型。

注意：例如，短语vec3<f32>是一个模板参数化，其中vec3是被修改的常规概念，
而<f32>是包含一个参数的模板列表，该参数是类型[=f32=]。
一起来看，vec3<f32>表示一个特定的[=向量=]类型。

注意：例如，短语var<storage,read_write>用模板参数storage和read_write修改了通用的var概念。

<div class=note>
  <span class=marker>注意：</span>例如，短语array<vec4<f32>>有两个模板参数化：

  * vec4<f32>用模板参数f32修改了通用的vec4概念。
  * array<vec4<f32>>用模板参数vec4<f32>修改了通用的array概念。

</div>

将界定模板列表的'<'（U+003C）和'>'（U+003E）代码点，也用于拼写：

* 在[=syntax/relational_expression=]中的比较操作符。
* 在[=syntax/shift_expression=]中的移位操作符。
* 在执行移位操作后进行赋值的[=syntax/compound_assignment_operator=]。

在语法上，会优先解决模板列表的歧义：

* 在解析的早期阶段，模板列表会在[=declarations=]、[=expressions=]、[=statements=]解析之前被发现。
* 在后续的词法标记化过程中， 模板列表的初始'<'（U+003C）被映射为[=syntax_sym/_template_args_start=]标记，而 模板列表的结束'>'（U+003E）被映射为[=syntax_sym/_template_args_end=]标记。

以下是[=template list discovery=]算法。
算法使用以下假设和属性：

1. 模板参数是一个表达式，因此不以'<'（U+003C）或'='（U+003D）代码点开头。
2. 表达式不包含代码点';'（U+003B）、'{'（U+007B）或':'（U+003A）。
3. 表达式不包含[=statement/assignment=]。
4. '='（U+003D）代码点仅用于比较操作，即出现在下列其中之一中：
    <a for=syntax_sym lt=less_than_equal>'<='</a>，
    <a for=syntax_sym lt=greater_than_equal>'>='</a>，
    <a for=syntax_sym lt=equal_equal>'=='</a>或 <a for=syntax_sym lt=not_equal>'!='</a>。
    否则，'='（U+003D）代码点将用于赋值。
5. 模板列表的分隔符会考虑由括号’(…)‘和数组索引’[…]'形成的嵌套表达式。 模板列表的起始和结束必须出现在相同的嵌套级别。

<blockquote algorithm="template list discovery">
**Algorithm:** <dfn noexport>Template list discovery</dfn>

**Input:** 程序源文本.

**Record types:**

定义一个记录类型|UnclosedCandidate|包含：
* |position|，源文本中的位置
* |depth|，一个整数，表示在|position|处的表达式嵌套深度


定义一个记录类型|TemplateList|包含：
* |start_position|，表示此模板列表开始的’<’ (U+003C)字符的源位置
* |end_position|，表示此模板列表结束的’>’ (U+003E)字符的源位置


输出： |DiscoveredTemplateLists|，一个包含|TemplateList|记录的列表。

**Algorithm:**
* 将|DiscoveredTemplateLists|初始化为空列表。
* 将|Pending|变量初始化为空的|UnclosedCandidate|记录的堆栈。
* 将|CurrentPosition|整数变量初始化为0。 它编码了正在检查的代码点的位置，以源文本开始后的代码点数为计数。
    * 在执行算法时，该变量会向前移动文本。 当到达文本末尾时，立即终止算法，并使其返回|DiscoveredTemplateLists|。
* 将|NestingDepth|整数变量初始化为0。
* 重复以下步骤：
    * 将 |CurrentPosition| 推进过 [=blankspace=]、[=comments=] 和 [=literals=]。
    * 如果 [=syntax/ident_pattern_token=] 与 |CurrentPosition| 处的文本匹配，则：
        * 将 |CurrentPosition| 推进过 [=syntax/ident_pattern_token=]。
        * 如果有空格和注释，将 |CurrentPosition| 推进过它们。
        * 如果 |CurrentPosition| 处出现 '<' (U+003C)，则：
            * 注意：这个代码点有可能是模板列表的开始。 保存足够的状态以便在输入中稍后出现的 '>' (U+003E) 进行匹配。
            * 将 |UnclosedCandidate|(|position|=|CurrentPosition|,|depth|=|NestingDepth|) 推入 |Pending| 栈。
            * 将 |CurrentPosition| 推进到下一个代码点。
            * 如果 |CurrentPosition| 处出现 '<' (U+003C)，则：
                * 注意：根据假设1，没有模板参数以 '<' (U+003C) 开始，因此前一个代码点不能是模板列表的开始。 因此当前和前一个代码点必须是 <a for=syntax_sym lt=shift_left>'<<'</a> 运算符。
                * 弹出 |Pending| 栈中的顶部条目。
                * 将 |CurrentPosition| 推进过这个代码点，并开始下一次循环迭代。
            * 如果 |CurrentPosition| 处出现 '=' (U+003D)，则：
                * 注意：根据假设1，没有模板参数以 '=' (U+003C) 开始，因此前一个代码点不能是模板列表的开始。 假设当前和前一个代码点组成一个 <a for=syntax_sym lt=less_than_equal>'<='</a> 比较运算符。 跳过 '=' (U+003D) 代码点，以防后续步骤错误地将其视为赋值运算符。
                * 弹出 |Pending| 栈中的顶部条目。
                * 将 |CurrentPosition| 推进过这个代码点，并开始下一次循环迭代。
    * 如果‘>’（U+003E）出现在|CurrentPosition|处，则：
        * 注意：该代码点有可能是模板列表的结尾候选项。
        * 如果|Pending|不为空，则令|T|为其顶部项，如果|T|的|depth|等于|NestingDepth|，则：
            * 注意：该代码点结束了以|T|记录的当前模板列表的开头。
            * 将|TemplateList|（|start_position|=|T|.|position|，|end_position|=|CurrentPosition|）添加到|DiscoveredTemplateLists|中。
            * 从|Pending|栈中弹出|T|。
            * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
        * 否则，该代码点不结束模板列表：
            * 将|CurrentPosition|向前移动至此代码点的下一个位置。
            * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
                * 注意：假设当前代码点和前一个代码点形成一个<a for=syntax_sym lt=greater_than_equal>'>='</a>比较运算符。 跳过‘=’（U+003D）代码点，以免在后面的步骤中将其误认为是一个赋值。
                * 将|CurrentPosition|向前移动至此代码点的下一个位置。
                * 开始循环的下一次迭代。
    * 如果‘(’（U+0028）或‘[’（U+005B）出现在|CurrentPosition|处，则：
        * 注意：进入一个嵌套表达式。
        * 在|NestingDepth|上加1。
        * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果‘)’（U+0029）或‘]’（U+005D）出现在|CurrentPosition|处，则：
        * 注意：退出一个嵌套表达式。
        * 从|Pending|栈中弹出条目，直到它为空，或者直到其顶部条目的|depth| < |NestingDepth|为止。
        * 将|NestingDepth|设置为0或|NestingDepth| − 1中的较大值。
          * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果‘!’（U+0021）出现在|CurrentPosition|处，则：
        * 将|CurrentPosition|向前移动至此代码点的下一个位置。
        * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
            * 注意：假设当前代码点和前一个代码点形成一个<a for=syntax_sym lt=not_equal>'!='</a>比较运算符。 跳过‘=’（U+003D）代码点，以免在后面的步骤中将其误认为是一个赋值。
            * 将|CurrentPosition|向前移动至此代码点的下一个位置。
        * 开始循环的下一次迭代。
    * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
        * 将|CurrentPosition|向前移动至此代码点的下一个位置。
        * 如果‘=’（U+003D）出现在|CurrentPosition|处，则：
            * 注意：假设当前代码点和前一个代码点形成一个<a for=syntax_sym lt=equal_equal>'=='</a>比较运算符。 跳过‘=’（U+003D）代码点，以免在后面的步骤中将其误认为是一个赋值。
            * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
        * 注意：假设此代码点是赋值的一部分，它不能作为表达式的一部分出现，因此不能出现在模板列表中。 清除未完成的候选项。
        * 将|NestingDepth|设置为0。
        * 从|Pending|栈中删除所有条目。
        * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果‘;’（U+003B）或‘{’（U+007B）或‘:’（U+003A）出现在|CurrentPosition|处，则：
        * 注意：这些不能出现在表达式的中间，因此不能出现在模板列表中。 清除未完成的候选项。
        * 将|NestingDepth|设置为0。
        * 从|Pending|栈中删除所有条目。
        * 将|CurrentPosition|向前移动至此代码点的下一个位置，并开始循环的下一次迭代。
    * 如果<a for=syntax_sym lt=and_and>'&&'</a>或<a for=syntax_sym lt=or_or>'||'</a>与|CurrentPosition|处的文本匹配，则：
        * 注意：这些是低于比较运算符优先级的运算符。拒绝当前表达式级别中未完成的候选项。
        * 注意：按此规则，在程序片段a<b || c>d中，将找不到模板列表。 而它将被识别为两个比较运算的短路或运算。
        * 从|Pending|栈中弹出条目，直到它为空，或者直到其顶部条目的|depth| < |NestingDepth|为止。
        * 将|CurrentPosition|向前移动两个代码点，并开始循环的下一次迭代。
    * 将|CurrentPosition|向前移动至当前代码点的下一个位置。

</blockquote>

<div class=note algorithm="find template paramters">
<span class=marker>Note:</span>算法可以修改为找到[=模板参数=]的源范围，如下所示：

* 修改|UnclosedCandidate|，添加以下字段：
    * |parameters|，模板参数的源范围列表。
    * |parameter_start_position|，源位置。
* 修改|TemplateList|，添加一个字段：
    * |parameters|，模板参数的源范围列表。
* 当将新的|UnclosedCandidate|推入|待处理|栈时：
    * 将其|parameters|字段设置为空列表。
    * 将|parameter_start_position|设置为|CurrentPosition|的下一个代码点。
* 当将|TemplateList|，|TL|，添加到<var ignore>DiscoveredTemplateLists</var>中时：
    * 让|T|成为栈|Pending|的顶部，就像原算法中一样。
    * 将从|T|.|parameter_start_position|开始到|CurrentPosition|−1结束的源范围推入|T|.|parameters|中。
    * 按照原算法准备|TL|。
    * 将|TL|.|parameters|设置为|T|.|parameters|。
* 在循环结束之前，在推进到当前代码点之前插入一个检查：
    * 如果在|CurrentPosition|处出现了’,'（U+002C），并且|Pending|不为空，则：
      * 让|T|成为栈|Pending|的顶部。
      * 将从|T|.|parameter_start_position|开始到|CurrentPosition|−1结束的源范围推入|T|.|parameters|中。
      * 将|T|.|parameter_start_position|设置为|CurrentPosition|+1。

</div>
注意：该算法显式跳过字面值，因为有些数值字面值以字母结尾，例如1.0f。终止的f不应该被误认为是一个[=syntax/ident_pattern_token=]的开始。


注意：在短语A ( B < C, D > ( E ) )中，段落< C, D >是一个[=template list=]。


注意：该算法遵循表达式嵌套：特定模板列表的起始和结束不可以出现在不同的表达式嵌套层级上。
例如，在array<i32,select(2,3,a>b)>中，模板列表有三个参数，其中最后一个是select(2,3,a>b)。
a>b中的'>'并不终止模板列表，因为它被括在调用select函数的表达式的括号部分中。


注意：模板列表的两端必须出现在同一个[=indexing expression=]中。例如，a[b<d]>()不包含合法的模板列表。


注意：在短语A<B<<C>中，短语B<<C被解析为B后面跟着左移运算符 <a for=syntax_sym lt=shift_left>'<<'</a> 然后是C。
模板发现算法开始检查B，然后是'<' (U+003C)，但是发现紧接着的'<' (U+003C)不可能是模板参数的开始，因此
紧接在B后面的'<'并不是模板列表的开始。
初始的'<'和最后的'>'是唯一的模板列表分界符，它有模板参数B<<C。


注意：短语A<B<=C>的解析和前面的说明类似，因此短语B<=C被解析为B后面跟着小于或等于的运算符 <a for=syntax_sym lt=less_than_equal>'<='</a> 然后是C。
模板发现算法开始检查B，然后是'<' (U+003C)，但是发现紧接着的'=' (U+003D) 不可能是模板参数的开始，因此
紧接在B后面的'<'并不是模板列表的开始。
初始的'<'和最后的'>'是唯一的模板列表分界符，它有模板参数B<=C。


注意：在检查短语A<(B>=C)>时，有一个模板列表，起始于第一个'<' (U+003C) 代码点，并以最后一个'>' (U+003E) 代码点结束，参数为B>=C。
在检查到第一个'>' (U+003E) 代码点（在B之后）后，需要特殊识别'=' (U+003D) 代码点，以免被认为是赋值的一部分。


注意：在检查短语A<(B!=C)>时，有一个模板列表，起始于第一个'<’ (U+003C) 代码点，并以最后一个'>' (U+003E) 代码点结束，参数为B!=C。
在检查到'!' (U+0021) 代码点（在'B'之后）后，需要特殊识别'=' (U+003D) 代码点，以免被认为是赋值的一部分。


注意：在检查短语A<(B==C)>时，有一个模板列表，起始于第一个'<' (U+003C) 代码点，并以最后一个'>' (U+003E) 代码点结束，参数为B==C。
在检查到第一个'=' (U+003D) 代码点（在'B'之后）后，需要特殊识别第二个'=' (U+003D) 代码点，以免被认为是赋值的一部分。


在[=template list discovery=]完成后，
[[#parsing|parsing]] [=behavioral requirement|将会=] 尝试将每个模板列表与[=syntax/template_list=]语法规则匹配。

<pre class=include>
path: syntax/template_list.syntax.bs.include
</pre>

<pre class=include>
path: syntax/template_arg_comma_list.syntax.bs.include
</pre>

<pre class=include>
path: syntax/template_arg_expression.syntax.bs.include
</pre>

# 指令 # {#directives}

<dfn noexport>指令</dfn>是一系列的令牌，用于修改WGSL程序在WebGPU实现中的处理方式。


指令是可选的。
如果存在，则必须在任何声明或常量断言之前出现所有指令。

<pre class=include>
path: syntax/global_directive.syntax.bs.include
</pre>

## 扩展 ## {#extensions}

预计WGSL会随着时间的推移进行演变。

[=扩展=]是对WGSL规范进行一致性修改的命名分组，可以包含以下任意组合：

* 通过新的语法添加新的概念和行为，包括：
    * 声明、语句、属性和内置函数。
* 删除当前规范或先前发布的扩展中的限制。
* 用于减少可行行为集的语法。
* 对程序的某个部分可用功能进行限制的语法。
* 描述扩展与现有规范以及可能与其他扩展交互的方式。

假设，扩展可以：

* 添加数值标量类型，如不同位宽的整数。
* 添加语法以限制浮点数的舍入模式。
* 添加语法以表示着色器不使用原子类型。
* 添加新的语句类型。
* 添加新的内置函数。
* 添加语法以限制着色器执行方式。
* 添加新的着色器阶段。

有两种类型的扩展：[=启用扩展=]和[=语言扩展=]。

### 启用扩展 ### {#enable-extensions-sec}

一个<dfn noexport>enable-extension</dfn>是一种[=扩展=]，其功能仅在满足以下条件时才可用：


* 实现支持它，且
* 着色器通过一个[=enable指令=]明确请求它，且
* 在创建{{GPUDevice}}时，相应的WebGPU {{GPUFeatureName}}是所请求的必需功能之一。

[=Enable-extensions=]旨在公开不是普遍可用的硬件功能。


一个<dfn noexport>enable指令</dfn>是一个[=指令=]，它开启对一个或多个enable-extensions的支持。
如果实现不支持列出的所有enable-extensions，则会产生一个[=着色器创建错误=]。

<pre class=include>
path: syntax/enable_directive.syntax.bs.include
</pre>
<pre class=include>
path: syntax/enable_extension_list.syntax.bs.include
</pre>

与其他指示符一样，如果存在 [=enable directive=]，则它必须出现在所有 [=declarations=] 和 [[#const-assert-statement|const assertions]] 之前。
扩展名不是 [=identifiers=]：它们不会 [=resolve=] 为 [=declarations=]。

The valid [=enable-extensions=] are listed in the following table.
<table class='data'>
  <caption>Enable-extensions</caption>
  <thead>
    <tr><th>WGSL enable-extension
        <th>WebGPU {{GPUFeatureName}}
        <th>Description
  </thead>
  <tr><td><dfn noexport dfn-for="extension">`f16`</dfn>
      <td>`"shader-f16"`
      <td>在WGSL模块中使用“f16”类型是有效的。否则，直接或间接使用“f16”将会导致着色器创建错误.
</table>

<div class='example wgsl using extensions expect-error' heading="Using hypothetical enable-extensions">
  <xmp>
    // Enable a hypothetical extension for arbitrary precision floating point types.
    enable arbitrary_precision_float;
    enable arbitrary_precision_float; // A redundant enable directive is ok.

    // Enable a hypothetical extension to control the rounding mode.
    enable rounding_mode;

    // Assuming arbitrary_precision_float enables use of:
    //    - a type f<E,M>
    //    - as a type in function return, formal parameters and let-declarations
    //    - as a value constructor from AbstractFloat
    //    - operands to division operator: /
    // Assuming @rounding_mode attribute is enabled by the rounding_mode enable directive.
    @rounding_mode(round_to_even)
    fn halve_it(x : f<8, 7>) -> f<8, 7> {
      let two = f<8, 7>(2);
      return x / 2; // uses round to even rounding mode.
    }
  </xmp>
</div>

### 语言扩展 ### {#language-extensions-sec}

如果实现支持，<dfn noexport>语言扩展</dfn>是自动可用的 [=extension=]。程序不必显式请求它。

[=语言扩展=] 包含了在任何WebGPU实现中都可以合理支持的功能。
如果该功能不是普遍可用，那是因为某些WebGPU实现尚未实现它。


注意：例如，do-while循环可以是一种语言扩展。

WebGPU对象的{{GPU/wgslLanguageFeatures}}成员列出了实现支持的一组[=语言扩展=]。


<dfn noexport>requires-directive</dfn>是一条[=指令=]，记录了程序对一个或多个[=语言扩展=]的使用。它不会改变实现所暴露的功能。如果实现不支持某个所需的扩展，那么会导致[=着色器创建错误=]。


WGSL模块可以使用[=requires-directive=]来表示可能的不可移植性，并且表示意图的最低可移植性要求。


注意：WebGPU实现之外的工具可以检查一个程序中使用的所有[=语言扩展=]是否都被程序中的[=requires-directive=]覆盖。

<pre class=include>
path: syntax/requires_directive.syntax.bs.include
</pre>
<pre class=include>
path: syntax/software_extension_list.syntax.bs.include
</pre>

与其他指示符一样，如果存在[=requires-directive=]，它必须出现在所有[=declarations=]和[[#const-assert-statement|const assertions]]之前。
扩展名不是[=identifiers=]：它们不能[=resolves|resolve=]为[=declarations=]。

<table class='data'>
  <caption>Language extensions</caption>
  <thead>
    <tr><th style="width:30%">WGSL language extension
        <th>Description
  </thead>
  <tr><td>readonly_and_readwrite_storage_textures
      <td>允许在类型/存储纹理中使用“访问/读取”和“访问/读写”访问模式。
          此外，还添加了“textureBarrier”内建函数。
</table>

注意：WGSL 的目的是随着时间的推移，定义包含当时常见的语言扩展的所有功能的语言扩展。
在一个 “requires-directive” 中，这些扩展作为一种简化方式，用于列出所有这些常见功能。
它们代表着逐步增加的功能集合，可以将其视为一种语言版本。

## 全局诊断过滤器 ## {#global-diagnostic-directive}

全局诊断筛选器是一个其受影响范围为整个WGSL模块的诊断筛选器。
它是一个指令，因此出现在任何模块范围声明之前。
它的拼写类似于属性形式，但没有前导的@（U+0040）代码点，并以分号结尾。

<pre class=include>
path: syntax/diagnostic_directive.syntax.bs.include
</pre>

# 声明和范围 # {#declaration-and-scope}

<dfn noexport>声明</dfn>将一个标识符与以下类型的对象之一关联起来：

* 一个类型
* 一个类型生成器
* 一个值声明
* 一个变量
* 一个函数
* 一个形式参数
* 一个枚举值

换句话说，声明为对象引入了一个名称。

如果声明出现在程序源代码中，但在任何其他声明的文本之外，则该声明处于模块范围内。


函数声明出现在模块范围内。
函数声明包含形式参数的声明（如果有的话），并且它可以在函数体内包含变量和值的声明。
因此，这些包含的声明不在模块范围内。


注意：唯一包含另一个声明的声明是函数声明。

WebGPU实现提供了某些对象，并将其视为在WGSL模块源代码开始之前声明过。我们称这样的对象为<dfn noexport>预声明</dfn>。例如，WGSL预声明了：

* 内置函数，
* 内置类型如i32和f32，
* 内置类型生成器如“array”、“ptr”和“texture_2d”，以及
* 枚举值如“access/read_write”、“interpolation type/perspective”和“texel format/rgba8unorm”。

声明的范围是指声明标识符可能指代其关联对象的程序源位置的集合。我们说标识符在这些源位置上是<dfn noexport>有效范围内</dfn>的（对于该声明）。

声明出现的位置决定了其范围：

* 预声明的对象和在模块范围内声明的对象在整个程序源代码中都是有效范围内的。
* 用户声明的函数的每个形式参数在相应的函数体中都是有效范围内的。详见[[#function-declaration-sec]]。
* 否则，范围是从声明的结束位置之后开始的一段文本。详见[[#var-and-value]]。

同一个WGSL源程序中的两个声明不能同时：

* 引入相同的标识符名称，并且
* 拥有相同的作用域结束位置。

注意：预声明的对象在WGSL源代码中没有声明。
因此，模块范围内或函数内的用户指定声明可以和预声明对象具有相同的名称。

标识符的使用方式如下，根据语法上下文进行区分：

* 与[=syntax/ident=]语法元素匹配的标记：
    * 用于声明中，作为正在声明的对象的名称，或
    * 作为名称使用，表示在其他地方声明的对象。这是常见情况。
* 与[=syntax/member_ident=]语法元素匹配的标记：
    * 用于结构类型声明中，作为成员的名称，或
    * 作为名称使用，表示结构值的成员，或表示对结构成员的引用。参见[[#struct-access-expr]]。

当一个[=syntax/ident=]标记作为表示在其他地方声明的对象的名称时，
它在某个声明中必须处于范围之内。
标识符标记所表示的对象由以下方式确定：

* 如果该标记在至少一个非模块范围声明的范围之内， 则该标记表示与最近的那个声明相关联的对象。

    注意：最近的这样的声明会出现在标识符标记之前。

* 否则，如果存在具有该名称的模块范围声明，则该标记 表示已声明的对象。

    注意：模块范围的声明可以出现在标识符标记之前或之后。

* 否则，如果存在具有该名称的预声明对象，则该标记表示该对象。

当上述算法用于将标识符映射到声明时，我们说该标识符解析到该声明。类似地，我们也说标识符解析到所声明的对象。

如果任何模块范围的声明是递归的，那么这是一个着色器创建错误。也就是说，声明之间不能存在循环：

> 考虑以下有向图：
> * 每个节点对应一个声明 D。
> * 当 D 的定义提到一个解析为 T 的标识符时，存在从声明 D 到声明 T 的边。
>
>       这个图不能有循环。

注意：函数体是函数声明的一部分，因此函数不能是递归的，无论是直接还是间接递归。

注意：非模块范围的标识符声明必须在文本中使用之前。

<div class='example wgsl' heading='Valid and invalid declarations'>
  <xmp>
    // Valid, user-defined variables can have the same name as a built-in function.
    var<private> modf: f32 = 0.0;

    // Valid, foo_1 is in scope for the entire program.
    var<private> foo: f32 = 0.0; // foo_1

    // Valid, bar_1 is in scope for the entire program.
    var<private> bar: u32 = 0u; // bar_1

    // Valid, my_func_1 is in scope for the entire program.
    // Valid, foo_2 is in scope until the end of the function.
    fn my_func(foo: f32) { // my_func_1, foo_2
      // Any reference to 'foo' resolves to the function parameter.

      // Invalid, modf resolves to the module-scope variable.
      let res = modf(foo);

      // Invalid, the scope of foo_2 ends at the of the function.
      var foo: f32; // foo_3

      // Valid, bar_2 is in scope until the end of the function.
      var bar: u32; // bar_2
      // References to 'bar' resolve to bar_2
      {
        // Valid, foo_4 is in scope until the end of the compound statement.
        var foo : f32; // foo_4

        // Valid, bar_3 is in scope until the end of the compound statement.
        var bar: u32; // bar_3
        // References to 'bar' resolve to bar_3

        // Invalid, bar_4 has the same end scope as bar_3.
        var bar: i32; // bar_4

        // Valid, i_1 is in scope until the end of the for loop
        for ( var i: i32 = 0; i < 10; i++ ) { // i_1
          // Invalid, i_2 has the same end scope as i_1.
          var i: i32 = 1; // i_2.
        }
      }

      // Invalid, bar_5 has the same end scope as bar_2.
      var bar: u32; // bar_5

      // Valid, later_def, a module scope declaration, is in scope for the entire program.
      var early_use : i32 = later_def;
    }

    // Invalid, bar_6 has the same scope as bar_1.
    var<private> bar: u32 = 1u; // bar_6

    // Invalid, my_func_2 has the same end scope as my_func_1.
    fn my_func() { } // my_func_2

    // Valid, my_foo_1 is in scope for the entire program.
    fn my_foo( //my_foo_1
      // Valid, my_foo_2 is in scope until the end of the function.
      my_foo: i32 // my_foo_2
    ) { }

    var<private> later_def : i32 = 1;
  </xmp>
</div>

<div class='example wgsl' heading='Shadowing predeclared objects'>
  <xmp>
     // This declaration hides the predeclared 'min' built-in function.
     // Since this declaration is at module-scope, it is in scope over the entire
     // source.  The built-in function is no longer accessible.
     fn min() -> u32 { return 0; }

     const rgba8unorm = 12; // This shadows the predeclared 'rgba8unorm' enumerant.
  </xmp>
</div>

# 类型 # {#types}

程序计算值。

在WGSL中，<dfn noexport>类型</dfn>是一组值，每个值都属于且只属于一个类型。
值的类型确定了可以对该值执行的操作的语法和语义。

例如，数学中的1在WGSL中对应于以下不同的值：

* 32位有符号整数值1i,
* 32位无符号整数值1u,
* 32位浮点值1.0f,
* 如果启用了[f16扩展|f16 extension]，则为16位浮点值1.0h,
* [=AbstractInt=]值1，以及
* [=AbstractFloat=]值1.0

WGSL将它们视为不同，因为它们的机器表示和操作不同。

类型要么是[=预定义=]的，要么是通过WGSL源代码中的[=声明=]创建的。

一些类型被表示为[=模板参数化=]。
<dfn noexport>类型生成器</dfn>是一个[=预定义=]对象，当用[=模板列表=]参数化时，表示一个类型。
例如，类型atomic<u32>将类型生成器atomic与模板列表<u32>组合起来。


我们区分类型的概念和WGSL中表示该类型的语法。
在许多情况下，此规范中类型的拼写与其在WGSL中的语法相同。
例如：

32位无符号整数值集合在此规范中拼写为u32，在WGSL模块中也是如此。
结构类型或包含结构的类型的拼写不同。

一些WGSL类型仅用于分析源程序和确定程序的运行时行为。
本规范将描述这些类型，但它们不会出现在WGSL源代码中。


注意：[=引用类型=]不会在WGSL模块中编写。参见[[#ref-ptr-types]]。

## 类型检查 ## {#type-checking-section}

计算WGSL值是通过评估表达式来实现的。
表达式是源文本的一部分，被解析为以“expression”结尾的WGSL语法规则之一。
表达式E可以包含子表达式，这些子表达式是外部表达式E中正确包含的表达式。
顶层表达式是一个不是自己的子表达式的表达式。
参见[[#expression-grammar]]。


表达式评估产生的特定值取决于：

* 静态上下文：表达式周围的源文本，以及
* 动态上下文：评估表达式的调用状态，以及调用所在的执行上下文。

通过评估特定表达式可能得到的值将始终属于特定的WGSL类型，即表达式的静态类型。
WGSL的规则设计使得表达式的静态类型仅取决于表达式的静态上下文。

类型断言是将某个WGSL源表达式映射到一个WGSL类型的操作。
表示为

> *e* : *T*

这个类型断言表示WGSL表达式e的静态类型为T。

注意：类型断言是关于程序文本的一个事实陈述，它不是运行时的检查。

语句通常使用表达式，并可能对这些表达式的静态类型有要求。
例如：
* if语句的条件表达式必须是bool类型。
* 在具有指定显示类型的let声明中，初始化表达式必须求值为该类型。

对成功解析的WGSL模块进行类型检查是将每个表达式映射到它的静态类型，并验证每个语句的类型要求是否满足的过程。
如果类型检查失败，将出现一种特殊情况下的着色器创建错误，称为类型错误。

类型检查可以通过递归地应用类型规则到句法短语来进行，其中句法短语可以是表达式或语句。
类型规则描述了句法短语的静态上下文如何确定该短语中包含的表达式的静态类型。

一个[= 类型规则 =] 有两个部分：
* 一个[= 类型规则结论 =]。
    * 如果短语是一个表达式，结论是该表达式的[= 类型断言 =]。
    * 如果短语是一个语句，结论是一组[= 类型断言 =]，每个断言对应语句的[= 顶层表达式 =]。
    * 在这两种情况下，使用斜体的名称来指定[= 句法短语 =]， 来表示子表达式或其他语法确定的参数。
* [= 类型规则前提条件 =]，包括：
    * 对于表达式：
        * 当它具有子表达式时，对子表达式的类型断言。 每个断言可以通过直接满足或通过[= 可行的自动转换 =]（在[[ #conversion-rank ]]中定义）满足。
        * 表达式在语句中的使用方式。
    * 对于语句：
        * 语句的句法形式以及
        * 语句中的[= 顶层表达式 =]的类型断言。
    * 其他示意参数的条件（如果有）。
    * 可选的其他静态上下文。

类型规则在其前提条件和结论中可以包含[= 类型参数 =]。
当类型规则的结论或前提条件包含类型参数时，
我们说它是[= 参数化的 =]。
当它们不包含类型参数时，我们说该规则是[= 完全展开的 =]。
我们可以通过为规则的每个类型参数替换类型，
并在规则中的所有相同参数出现处使用相同的类型，
从参数化的规则生成一个完全展开的类型规则。
给规则的类型参数分配类型被称为[= 替换 =]。

例如，这是逻辑取反的类型规则（形式为!|e|）：

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论
  </thead>
  <tr algorithm="example boolean negation"><td>|e|: |T|<br>
  |T| 为 bool 或 vec|N|&lt;bool&gt;
  <td>`!`|e|`:` |T|
</table>

这是一个带参数的规则，因为它包含类型参数|T|，可以代表四种类型之一[=bool=]、vec2<bool>、vec3<bool>或vec4<bool>。
应用将|T|映射到vec3<bool>的替换，得到完全详细的类型规则：

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论
  </thead>
  <tr algorithm="example2 boolean negation"><td>|e|`: vec3<bool>`<br>
  <td>`!`|e|`: vec3<bool>`
</table>

我们通过应用满足规则其他条件的一些替换来从参数化规则中产生的每个完全阐述的规则被称为参数化规则的<dfn noexport>重载</dfn>。例如，布尔取反规则有四个重载，因为有四种可能的方式来为其类型参数|T|分配类型。

注意：
换句话说，参数化类型规则为一组完全阐述的类型规则提供了模式，每个模式通过对参数化规则应用不同的替换而产生。

当一个规则的结论与一个[=语法短句=]的有效解析相匹配，并且规则的前提条件得到满足时，一个类型规则将适用于该语法短句。

如果存在一个[=替换=]产生一个[=完全阐述=]的适用于该表达式的类型规则，那么一个[=参数化=]类型规则将适用于该表达式。

考虑表达式 1u+2u。
它有两个[[#面值表达式|面值子表达式]]：1u 和 2u，都是类型 u32。
[=顶层表达式=] 是一个加法。
参考[[#算术表达式]]中的规则，加法的类型规则适用于该表达式，因为：

* 1u+2u 与 |e1|+|e2| 格式的解析相匹配，其中 |e1| 表示 1u，|e2| 表示 2u，并且
* |e1| 是类型 u32，而且
* |e2| 是类型 u32，而且
* 我们可以将 u32 替换类型参数 |T| 在类型规则中， 从而得到一个[=完全阐述=]的规则，适用于整个表达式。

在分析语法短语时，可能会出现三种情况：

* 表达式没有适用的类型规则。这会导致类型错误。
* 表达式只适用一个完全扩展的类型规则。 在这种情况下，规则的类型规则结论被断定，确定表达式的静态类型。
* 适用多个类型规则。也就是说，满足了多个重载的前提条件。 在这种情况下，使用[[#overload-resolution-section]]中描述的解决冲突的过程。
    * 如果重载解析成功，则确定一个适用于表达式的重载。 在该重载的类型规则结论中断言类型规则，并因此确定表达式或语法短语中的表达式的类型。
    * 如果重载解析失败，则会导致类型错误。

继续上面的例子，表达式1u+2u只适用一条类型规则，因此类型检查接受该类型规则的结论，即1u+2u的类型为u32。


当满足以下条件时，WGSL源程序被称为是“类型良好”的：

* 通过应用类型规则可以确定程序中每个表达式的静态类型。
* 满足每个语句的类型要求。

否则，存在类型错误，源程序不是有效的WGSL模块。

WGSL是一种“静态类型语言”，因为对WGSL模块进行类型检查要么成功，要么发现类型错误，而只需要检查程序源文本。

### 类型规则表 ### {#typing-tables-section}

表达式的WGSL[=类型规则=]按照<dfn noexport>类型规则表</dfn>进行组织，每个类型规则占据一行。


<dfn noexport>表达式的语义</dfn>是对该表达式进行评估的效果，主要是产生一个结果值。
适用于表达式的类型规则的描述列将指定表达式的语义。
语义通常取决于类型规则参数的值，包括任何子表达式的假定值。
有时，表达式的语义包括除产生结果值之外的其他影响，例如其子表达式的非结果值影响。

<div class='example' heading="Side-effect of an expression">
  <xmp>
    fn foo(p : ptr<function, i32>) -> i32 {
      let x = *p;
      *p += 1;
      return x;
    }

    fn bar() {
      var a: i32;
      let x = foo(&a); // the call to foo returns a value
                       // and updates the value of a
    }
  </xmp>
</div>

### 转化排名 ### {#conversion-rank}

当一个类型断言|e|:|T|被用作[=类型规则前提条件=]时，有以下情况时它被满足：

* |e|已经是类型|T|，或者
* |e|是类型|S|，并且类型|S|可以自动转换成类型|T|，如下所定义。

该规则由下表中定义的对类型对的<dfn>ConversionRank</dfn>函数所编码。
[=ConversionRank=]函数表达了自动转换一个类型(Src)到另一个类型(Dest)的偏好和可行性。
较低的rank更优先。

一个<dfn>可行的自动转换</dfn>将一个值从类型Src转换为类型Dest，并且当[=ConversionRank=]是有限的时允许进行。
这样的转换会保持值不变，但受到[[#floating-point-evaluation]]中描述的限制。

注意：自动转换只发生在两种情况下。
首先，当将一个[=const-expression=]转换为可以在GPU上使用的对应的类型化数值时。
其次，当从引用内存加载时，产生的值是存储在该内存中的值。

注意：无限rank的转换是不可行的，即不允许的。

注意：当没有进行转换时，转换rank为零。

<table class='data'>
  <caption>
    ConversionRank from one type to another
  </caption>
  <thead>
    <tr><th>Src
        <th>Dest
        <th>ConversionRank(Src,Dest)
        <th>Description
  </thead>
  <tr algorithm="conversion rank identity">
      <td>|T|
      <td>|T|
      <td>0
      <td>Identity. No conversion performed.
  <tr algorithm="conversion rank from reference via load rule">
      <td>ref&lt;|AS|,|T|,|AM|&gt;<br>for [=address space=] |AS|,
          and where [=access mode=] |AM| is [=access/read=] or [=access/read_write=].
      <td>|T|
      <td>0
      <td>Apply the [=Load Rule=] to load a value from a memory reference.
  <tr algorithm="conversion rank abstract float to f32">
      <td>[=AbstractFloat=]
      <td>f32
      <td>1
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract float to f16">
      <td>[=AbstractFloat=]
      <td>f16
      <td>2
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract int to i32">
      <td>[=AbstractInt=]
      <td>i32
      <td>3
      <td>Identity if the value is in [=i32=].
          Produces a [=shader-creation error=] otherwise.
  <tr algorithm="conversion rank abstract int to u32">
      <td>[=AbstractInt=]
      <td>u32
      <td>4
      <td>Identity if the value is in [=u32=].
          Produces a [=shader-creation error=] otherwise.
  <tr algorithm="conversion rank abstract int to abstract float">
      <td>[=AbstractInt=]
      <td>[=AbstractFloat=]
      <td>5
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract int to f32">
      <td>[=AbstractInt=]
      <td>f32
      <td>6
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f32
  <tr algorithm="conversion rank abstract int to f16">
      <td>[=AbstractInt=]
      <td>f16
      <td>7
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f16
  <tr algorithm="conversion rank abstract vector">
      <td>vec|N|&lt;|S|&gt;
      <td>vec|N|&lt;|T|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component type.
  <tr algorithm="conversion rank abstract matrix">
      <td>mat|C|x|R|&lt;|S|&gt;
      <td>mat|C|x|R|&lt;|T|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component type.
  <tr algorithm="conversion rank abstract array">
      <td>array&lt;|S|,|N|&gt;
      <td>array&lt;|T|,|N|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component type.
      Note: Only [=fixed-size arrays=] may have an [=type/abstract=] component type.
  <tr algorithm="conversion rank for frexp result">
      <td>__frexp_result_abstract
      <td>__frexp_result_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for frexp result f16">
      <td>__frexp_result_abstract
      <td>__frexp_result_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for frexp result vector">
      <td>__frexp_result_vecN_abstract
      <td>__frexp_result_vecN_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for frexp result vector f16">
      <td>__frexp_result_vecN_abstract
      <td>__frexp_result_vecN_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for modf result">
      <td>__modf_result_abstract
      <td>__modf_result_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for modf result f16">
      <td>__modf_result_abstract
      <td>__modf_result_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for modf result vector">
      <td>__modf_result_vecN_abstract
      <td>__modf_result_vecN_f32
      <td>1
      <td>
  <tr algorithm="conversion rank for modf result vector f16">
      <td>__modf_result_vecN_abstract
      <td>__modf_result_vecN_f16
      <td>2
      <td>
  <tr algorithm="conversion rank for non-convertible cases">
      <td><var ignore>S</var>
      <td><var ignore>T</var><br>where above cases don't apply
      <td>infinity
      <td>There are no automatic conversions between other types.
</table>

如果类型T是类型S的具体化，则满足以下条件：

* T是具体类型，且
* T不是引用类型，且
* ConversionRank(S, T)是有限的，且
* 对于任何其他非引用类型T2，有 ConversionRank(S, T2) > ConversionRank(S, T)

一个类型为T的值e的具体化是通过对e应用将T映射到具体化的可行转换得到的值。


备注：将类型转换为f32始终优先于f16，因此仅当模块中启用了f16扩展时，自动转换才会产生f16。

### 过载解析 ### {#overload-resolution-section}

当一个句法短语拥有多个类型规则适用时，需要使用一种决策过程来确定哪个规则生效。这个过程被称为重载解析（overload resolution），并假设类型检查已成功找到了句法短语的静态类型。

考虑一个句法短语P，以及适用于P的所有类型规则。重载解析算法将这些类型规则称为重载候选。对于每个候选：

* 它的前提条件已经直接或通过可行的自动转换得到满足。
* 它的结论具有：与P的有效解析匹配的句法形式，以及与P中每个顶级表达式相对应的类型断言。

对于P的重载解析的步骤如下，目标是找到一个最适合的重载候选：

1. 对于每个候选C，在句法短语中枚举子表达式的转换等级。候选的前提条件已经满足，因此对于P中的第i个子表达式：

    * 其静态类型已计算。
    * 存在一种从表达式的静态类型到前提条件中所需类型的可行自动转换。
        让C.R(i)是该转换的转换等级。

1. 消除任何其中一个子表达式在可行自动转换后解析为抽象类型，但候选的另一个子表达式不是常量表达式的情况。

    注：作为后果，如果短语中的任何子表达式不是常量表达式，则短语中的所有子表达式都必须具有具体类型。


1. 对候选进行排名：给定两个重载候选C1和C2，如果C1在C2之前执行，则C1优先于C2的定义如下：

    * 对于P中的每个表达式位置i，C1.R(i)≤C2.R(i)。
        * 即，将C1应用于P所需的每个表达式转换至少与将C2应用于P所需的相应表达式转换一样优先。
    * 至少存在一个表达式位置i，其中C1.R(i)<C2.R(i)。
        * 即，至少存在一个将C1应用所需的表达式转换比将C2应用所需的相应转换更优先的情况。

1. 如果存在一个候选C，它在所有其他候选之上都是最优的，则重载解析成功，得到候选类型规则C。否则，重载解析失败。

## 简单类型 ## {#plain-types-section}

[=Plain types=] 是用于机器表示的布尔值、数字、向量、矩阵或这些值的聚合的类型。

一个 <dfn>plain type</dfn> 可以是一个 [=scalar=] 类型，一个 [=atomic type|atomic=] 类型，或者一个 [=composite=] 类型。

注意：WGSL 中的 Plain types 类似于 C++ 中的 Plain-Old-Data types，但也包括原子类型和抽象数值类型。

### 抽象数字类型 ### {#abstract-types}

这些类型在WGSL源代码中不能被拼写出来，它们只用于类型检查。


某些表达式在着色器模块创建时进行求值，其数值范围和精度可能大于GPU直接实现的范围。


WGSL为这些求值定义了两个<dfn>抽象数值类型</dfn>：
* <dfn noexport>AbstractInt</dfn>类型是整数|i|的集合，满足-2<sup>63</sup> ≤ |i| < 2<sup>63</sup>。
* <dfn noexport>AbstractFloat</dfn>类型是可以表示在[[!IEEE-754|IEEE-754]] binary64（双精度）格式中的有限浮点数集。


在这些类型之一的表达式求值中，不能溢出或产生无限或NaN值。


如果一个类型是抽象数值类型或包含抽象数值类型，则该类型是<dfn dfn-for=“type” noexport>抽象的</dfn>。
如果一个类型不是抽象类型，则该类型是<dfn dfn-for=“type” noexport>具体的</dfn>。


没有后缀的[=numeric literal=]表示一个[=abstract numeric type=]中的值：
* 没有i或u后缀的[=integer literal=]表示[=AbstractInt=]值。
* 没有f或h后缀的[=floating point literal=]表示[=AbstractFloat=]值。


例子：表达式log2(32)的分析如下：


* log2(32)被解析为对具有操作数[=AbstractInt=]值32的内建函数log2的函数调用。
l* og2没有带有[=integer scalar=]形式参数的重载。
* 取而代之的是，进行[=overload resolution=]，考虑三个可能的重载和[=feasible automatic conversions=]：
  * [=AbstractInt=]转换为[=AbstractFloat=]。（转换秩为4）
  * [=AbstractInt=]转换为[=f32=]。（转换秩为5）
  * [=AbstractInt=]转换为[=f16=]。（转换秩为6）
  * 结果计算为[=AbstractFloat=]（例如log2(32.0)）。

例子：表达式1 + 2.5的分析如下：

* 1 + 2.5被解析为加法运算，其子表达式为[=AbstractInt=]值1和[=AbstractFloat=]值2.5。
* 没有整数类型和浮点类型的|===|运算重载。
* 但是，使用可行的自动转换，有三个潜在的重载：
    * 1被转换为[=AbstractFloat=]值1.0（秩为4）且2.5保持不变为[=AbstractFloat=]（秩为0）。
    * 1被转换为[=f32=]值1.0f（秩为5）且2.5被转换为[=f32=]值2.5f（秩为1）。
    * 1被转换为[=f16=]值1.0f（秩为6）且2.5被转换为[=f16=]值2.5h（秩为2）。
    * 第一个重载是[=preferable candidate=]，类型检查成功。
    * 结果计算为[=AbstractFloat=] 1.0 + 2.5。

例子：let x = 1 + 2.5;


这个例子与上面的例子类似，只是x不能解析为[=abstract numeric type=]。
因此，存在两个可行的重载候选：使用[=f32=]或[=f16=]进行加法运算。
[=preferable candidate=]使用[=f32=]。
声明的效果就像写作let x：f32 = 1.0 + 2.5f;一样。

例子：1u + 2.5会导致[=shader-creation error=]：
* 1u项是一个类型为[=u32=]的表达式。
* 2.5项是一个类型为[=AbstractFloat=]的表达式。
* 没有有效的重载候选：
    * 没有可行的自动将GPU实例化的[=integer scalar=]类型转换为浮点类型。
    * 没有类型规则能够匹配将e+f，其中e为[=integer scalar=]类型，f为浮点类型。

<div class='example literals' heading="Type inference for literals">
  <xmp>
    // Explicitly-typed unsigned integer literal.
    var u32_1 = 1u; // variable holds a u32

    // Explicitly-typed signed integer literal.
    var i32_1 = 1i; // variable holds a i32

    // Explicitly-typed floating point literal.
    var f32_1 = 1f; // variable holds a f32

    // Explicitly-typed unsigned integer literal cannot be negated.
    var u32_neg = -1u; // invalid: unary minus does not support u32

    // When a concrete type is required, but no part of the statement or
    // expression forces a particular concrete type, an integer literal is
    // interpreted as an i32 value:
    //   Initializer for a let-declaration must be constructible (or pointer).
    //   The most preferred automatic conversion from AbstractInt to a constructible type
    //   is AbstractInt to i32, with conversion rank 2.  So '1' is inferred as i32.
    let some_i32 = 1; // like let some_i32: i32 = 1i;

    // Inferred from declaration type.
    var i32_from_type : i32 = 1; // variable holds i32.  AbstractInt to i32, conversion rank 2
    var u32_from_type : u32 = 1; // variable holds u32.  AbstractInt to u32, conversion rank 3

    // Unsuffixed integer literal can convert to floating point when needed:
    //   Automatically convert AbstractInt to f32, with conversion rank 5.
    var f32_promotion : f32 = 1; // variable holds f32

    // Invalid: no feasible conversion from floating point to integer
    var i32_demotion : i32 = 1.0; // Invalid

    // Inferred from expression.
    var u32_from_expr = 1 + u32_1; // variable holds u32
    var i32_from_expr = 1 + i32_1; // variable holds i32

    // Values must be representable.
    let u32_too_large   : u32 = 1234567890123456890; // invalid, overflow
    let i32_too_large   : i32 = 1234567890123456890; // invalid, overflow
    let u32_large : u32 = 2147483649; // valid
    let i32_large : i32 = 2147483649; // invalid, overflow
    let f32_out_of_range1 = 0x1p500; // invalid, out of range
    let f32_hex_lost_bits = 0x1.0000000001p0; // invalid, not exactly representable in f32

    // Minimum integer: unary negation over AbstractInt, then infer i32.
    // Most preferred conversion from AbstractInt to a constructible type (with lowest
    // conversion rank) is AbstractInt to i32.
    let i32_min = -2147483648;  // has type i32

    // Invalid.  Select AbstractInt to i32 as above, but the value is out of
    // range, producing shader-creation error.
    let i32_too_large_2 = 2147483648; // Invalid.

    // Subexpressions can resolve to AbstractInt and AbstractFloat.
    // The following examples are all valid and the value of the variable is 6u.
    var u32_expr1 = (1 + (1 + (1 + (1 + 1)))) + 1u;
    var u32_expr2 = 1u + (1 + (1 + (1 + (1 + 1))));
    var u32_expr3 = (1 + (1 + (1 + (1u + 1)))) + 1;
    var u32_expr4 = 1 + (1 + (1 + (1 + (1u + 1))));

    // Inference based on built-in function parameters.

    // Most-preferred candidate is clamp(i32,i32,i32)->i32
    let i32_clamp = clamp(1, -5, 5);
    // Most preferred candidate is clamp(u32,u32,u32).
    // Literals use automatic conversion AbstractInt to u32.
    let u32_clamp = clamp(5, 0, u32_from_expr);
    // Most preferred candidate is clamp(f32,f32,f32)->f32
    // literals use automatic conversion AbstractInt to f32.
    let f32_clamp = clamp(0, f32_1, 1);

    // The following examples all promote to f32 with an initial value of 10f.
    let f32_promotion1 = 1.0 + 2 + 3 + 4;
    let f32_promotion2 = 2 + 1.0 + 3 + 4;
    let f32_promotion3 = 1f + ((2 + 3) + 4);
    let f32_promotion4 = ((2 + (3 + 1f)) + 4);

    // Type rule violations.

    // Invalid, the initializer can only resolve to f32:
    // No feasible automatic conversion from AbstractFloat to u32.
    let mismatch : u32 = 1.0;

    // Invalid. There is no overload of clamp that allows mixed sign parameters.
    let ambiguous_clamp = clamp(1u, 0, 1i);

    // Inference completes at the statement level.

    // Initializer for a let-declaration must be constructible (or pointer).
    // The most preferred automatic conversion from AbstractInt to a constructible type
    // is AbstractInt to i32, with conversion rank 2.  So '1' is inferred as i32.
    let some_i32 = 1; // like let some_i32: i32 = 1i;

    let some_f32 : f32 = some_i32; // Type error: i32 cannot be assigned to f32

    // Another overflow case
    let overflow_u32 = (1 -2) + 1u; // invalid, -1 is out of range of u32

    // Ideal value out of range of 32-bits, but brought back into range
    let out_and_in_again = (0x1ffffffff / 8);

    // Similar, but invalid
    let out_of_range = (0x1ffffffff / 8u); // requires computation is done in 32-bits,
                                           // making 0x1ffffffff out of range.

  </xmp>
</div>

### 布尔类型 ### {#bool-type}

<dfn noexport>bool</dfn> 类型包括值 `true` 和 `false`.

<table class='data'>
  <caption>Boolean literal type rules</caption>
  <thead>
    <tr><th>前提条件<th>结论<th>描述
  </thead>
  <tr><td><td>`true`: bool<td>The true value.
  <tr><td><td>`false`: bool<td>The false value.
</table>

### 整数类型 ### {#integer-types}

<dfn noexport>u32</dfn>类型是由32位无符号整数组成的集合。

<dfn noexport>i32</dfn>类型是由32位有符号整数组成的集合。它使用二进制补码表示，其中符号位位于最高有效位的位置。

<table class='data'>
  <caption>整数类型的极值</caption>
  <thead>
    <tr><th>Type<th>最小值<th>最大值
  </thead>
    <tr><td rowspan=2>i32<td>i32(-2147483648)<td>2147483647i
    <tr><td>i32(-0x80000000)<td>0x7fffffffi
    <tr><td rowspan=2>u32<td>0u<td>4294967295u
    <tr><td>0x0u<td>0xffffffffu
</table>

注意：[=AbstractInt=]也是一种整数类型。

### 浮点数类型 ### {#floating-point-types}

<f32>类型是[[!IEEE-754|IEEE-754]]二进制32位浮点格式（单精度）的32位浮点值集合。有关详细信息，请参见[[#floating-point-evaluation]]。


<f16>类型是[[!IEEE-754|IEEE-754]]二进制16位浮点格式（半精度）的16位浮点值集合。如果在程序中未包含enable f16;指令以启用[=extension/f16|f16扩展=]，则使用<f16>类型会引发[=shader-creation error=]。有关详细信息，请参见[[#floating-point-evaluation]]。


下表列出了浮点类型的某些极限值。每个值都有对应的负值。
<table class='data'>
  <caption>Extreme values for floating point types</caption>
  <thead>
    <tr><th>Type<th>Smallest positive denormal<th>Smallest positive normal<th>Largest positive finite<th>Largest finite power of 2
  </thead>
    <tr><td rowspan=2>f32<td>1.40129846432481707092e-45f<td>1.17549435082228750797e-38f<td>3.40282346638528859812e+38f<td rowspan=2>0x1p+127f
    <tr><td>0x1p-149f<td>0x1p-126f<td>0x1.fffffep+127f
    <tr><td rowspan=2>f16<td>5.9604644775390625e-8h<td>0.00006103515625h<td>65504.0h<td rowspan=2>0x1p+15h
    <tr><td>0x1p-24h<td>0x1p-14h<td>0x1.ffcp+15h
</table>

注意：[=AbstractFloat=]也是一种浮点类型。

### 标量类型 ### {#scalar-types}

<dfn noexport>标量</dfn>类型有bool、AbstractInt、AbstractFloat、i32、u32、f32和f16。


数值标量类型有AbstractInt、AbstractFloat、i32、u32、f32和f16。


整数标量类型有AbstractInt、i32和u32。

### 向量类型 ### {#vector-types}

<dfn noexport>向量</dfn>是由2、3或4个[=标量=]组成的序列。
components.

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr><td>vec*N*<*T*><td>类型为T的N个组件的向量。N必须取{2, 3, 4}之一，而T必须是标量类型之一。我们将T称为向量的<dfn noexport>组件类型</dfn>。
</table>

如果一个向量的组件类型是标量数值类型，那么它就是一个数值向量。


向量的主要用途包括：

* 表示方向和大小。
* 表示空间中的位置。
* 在某种颜色空间中表示颜色。 例如，各个分量可以表示红、绿、蓝的强度，而第四个分量可以表示 alpha（透明度）值。

向量上的许多操作都是组件逐个进行的，即通过独立地对每个分量进行操作来形成结果向量。

<div class='example wgsl type-scope' heading='Vector'>
  <xmp>
    vec2<f32>  // is a vector of two f32s.
  </xmp>
</div>

<div class='example wgsl function-scope component-wise addition' heading='Component-wise addition'>
  <xmp>
    let x : vec3<f32> = a + b; // a and b are vec3<f32>
    // x[0] = a[0] + b[0]
    // x[1] = a[1] + b[1]
    // x[2] = a[2] + b[2]
  </xmp>
</div>

WGSL还预声明了以下类型别名：

<table class='data'>
  <thead>
    <tr>
        <th>Predeclared alias
        <th>Original type
        <th>Restrictions
  </thead>
  <tr>
      <td><dfn noexport>vec2i</dfn>
      <td>vec2&lt;i32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec3i</dfn>
      <td>vec3&lt;i32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec4i</dfn>
      <td>vec4&lt;i32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec2u</dfn>
      <td>vec2&lt;u32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec3u</dfn>
      <td>vec3&lt;u32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec4u</dfn>
      <td>vec4&lt;u32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec2f</dfn>
      <td>vec2&lt;f32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec3f</dfn>
      <td>vec3&lt;f32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec4f</dfn>
      <td>vec4&lt;f32&gt;
      <td>
  <tr>
      <td><dfn noexport>vec2h</dfn>
      <td>vec2&lt;f16&gt;
      <td rowspan=3>Requires the [=extension/f16|f16 extension=].
  <tr>
      <td><dfn noexport>vec3h</dfn>
      <td>vec3&lt;f16&gt;
  <tr>
      <td><dfn noexport>vec4h</dfn>
      <td>vec4&lt;f16&gt;
</table>

### 矩阵类型 ### {#matrix-types}

一个矩阵是由2、3或4个浮点向量组成的分组序列。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="matrix type">
    <td>mat|C|x|R|&lt;|T|&gt;
    <td>类型为 |T| 的 |C| 列和 |R| 行的矩阵，其中 |C| 和 |R| 都在 {2, 3, 4} 中，而 |T| 必须为 [=f32=]、[=f16=] 或 [=AbstractFloat=]。
等价地，它可以被视为类型为 vec|R|<T> 的 |C| 列向量。
</table>

矩阵的关键用途是体现线性变换。
在这个解释中，矩阵的向量被视为列向量。

乘法运算符（*）被用于以下操作之一：

* 通过标量大小缩放变换。
* 对向量应用变换。
* 将变换与另一个矩阵结合。

参见[[#arithmetic-expr]]。

<div class='example wgsl type-scope' heading='Matrix'>
  <xmp>
    mat2x3<f32>  // This is a 2 column, 3 row matrix of 32-bit floats.
                 // Equivalently, it is 2 column vectors of type vec3<f32>.
  </xmp>
</div>

WGSL也[=指定预定义预定义=]以下[=类型别名=]：

<table class='data'>
  <thead>
    <tr>
        <th>Predeclared alias
        <th>Original type
        <th>Restrictions
  </thead>
  <tr> <td><dfn noexport>mat2x2f</dfn> <td>mat2x2&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat2x3f</dfn> <td>mat2x3&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat2x4f</dfn> <td>mat2x4&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat3x2f</dfn> <td>mat3x2&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat3x3f</dfn> <td>mat3x3&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat3x4f</dfn> <td>mat3x4&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat4x2f</dfn> <td>mat4x2&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat4x3f</dfn> <td>mat4x3&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat4x4f</dfn> <td>mat4x4&lt;f32&gt; <td>
  <tr> <td><dfn noexport>mat2x2h</dfn> <td>mat2x2&lt;f16&gt; <td rowspan=9>Requires the [=extension/f16|f16 extension=].
  <tr> <td><dfn noexport>mat2x3h</dfn> <td>mat2x3&lt;f16&gt;
  <tr> <td><dfn noexport>mat2x4h</dfn> <td>mat2x4&lt;f16&gt;
  <tr> <td><dfn noexport>mat3x2h</dfn> <td>mat3x2&lt;f16&gt;
  <tr> <td><dfn noexport>mat3x3h</dfn> <td>mat3x3&lt;f16&gt;
  <tr> <td><dfn noexport>mat3x4h</dfn> <td>mat3x4&lt;f16&gt;
  <tr> <td><dfn noexport>mat4x2h</dfn> <td>mat4x2&lt;f16&gt;
  <tr> <td><dfn noexport>mat4x3h</dfn> <td>mat4x3&lt;f16&gt;
  <tr> <td><dfn noexport>mat4x4h</dfn> <td>mat4x4&lt;f16&gt;
</table>

### 原子类型 ### {#atomic-types}

一个原子类型(encapsulates)封装了一个具体的整数标量类型，具体而言：

* 原子对象提供给并发观察者[[#memory-model|某些保证]]，
* 原子对象上唯一有效的操作是[[#atomic-builtin-functions|原子内置函数]]。

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr algorithm="atomic type"><td>atomic&lt;|T|&gt;
    <td>Atomic of type |T|. |T| [=shader-creation error|must=] be either [=u32=] or [=i32=].
</table>

表达式不得评估为原子类型。


原子类型只能由地址空间中的变量或具有读写访问模式的存储缓冲变量实例化。
对该类型的操作的内存范围由它实例化的地址空间确定。
地址空间中的原子类型具有“工作组”内存范围，而地址空间/存储中的原子类型具有“队列族”内存范围。


原子修改是对原子对象进行的任何操作，该操作设置对象的内容。
即使新值与对象的现有值相同，该操作也被视为修改。


在WGSL中，针对每个对象，原子修改是相互有序的。
也就是说，在着色器阶段执行期间，对于每个原子对象A，所有代理观察到对A应用的修改操作的相同顺序。
不同原子对象的排序可能没有任何关联；不暗示任何因果关系。
请注意，地址空间/工作组空间中的变量在计算着色器阶段/工作组内共享，但在不同工作组之间不共享。


### 数组类型 ### {#array-types}

一个<dfn noexport>数组</dfn>是一个可索引的元素值序列。

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr><td algorithm="fixed-size array type">array&lt;|E|,|N|&gt;
      <td>A <dfn>具有 |N| 个元素，类型为 |E| 的定长数组。<br> |N| 被称为数组的元素计数。
  <tr><td algorithm="runtime-sized array type">array&lt;|E|&gt;
      <td>A <dfn noexport>runtime-sized</dfn> 元素类型为|E|的数组。这些数组只能出现在特定的上下文中。
</table>

数组中的第一个元素位于索引0，每个后续元素位于下一个整数索引位置。
参见[[#array-access-expr]]。

一个表达式[=shader-creation error|不能=]求值为运行时大小的数组类型。

固定大小数组的元素计数表达式|N|受到以下约束：

* 它[=shader-creation error|必须=]是一个[=override-expression=]。
* 它[=shader-creation error|必须=]求值为[=type/concrete=]的[=integer scalar=]。
* 如果|N|不大于零，这是一个[=pipeline-creation error=]。

注意：元素计数的值在[=pipeline creation=]时完全确定。


注意：为了符合类型等效性，任何非const表达式的override表达式必须是一个identifier。
参见<a href=“#example-workgroup-variables-sized-by-override”>通过可重写常量确定尺寸的工作组变量</a>


运行时大小数组的元素数量由与相应的[=storage buffer=]变量相关联的缓冲绑定的大小确定。
参见[[#buffer-binding-determines-runtime-sized-array-element-count]]。

数组元素类型[=shader-creation error|必须=]是以下之一：

* [=scalar=]类型
* [=vector=]类型
* [=matrix=]类型
* [=atomic type|atomic=]类型
* 具有[=creation-fixed footprint=]的[=array=]类型
* 具有[=creation-fixed footprint=]的[=structure=]类型。

注意：元素类型必须是[=plain type=]。


当且仅当以下所有条件为真时，两个数组类型才相同：

* 它们具有相同的元素类型。
* 它们的元素计数规格匹配，即以下之一为真：
    * 它们都是运行时大小的。
    * 它们都是具有[=creation-fixed footprint=]的固定大小，且元素计数相等，即使其中一个是有符号的，另一个是无符号的。 (在这种情况下，有符号和无符号值是可比较的，因为元素计数始终为正数。)
    * 它们都是具有以标识符[=resolves|resolving=]到相同的[=pipeline-overridable=]常量声明的元素计数的固定大小。

<div class='example wgsl fixed-size array types' heading='Example fixed-size array types, non-overridable element count'>
  <xmp>
    // array<f32,8> and array<i32,8> are different types:
    // different element types
    var<private> a: array<f32,8>;
    var<private> b: array<i32,8>;
    var<private> c: array<i32,8u>;  // array<i32,8> and array<i32,8u> are the same type

    const width = 8;
    const height = 8;

    // array<i32,8>, array<i32,8u>, and array<i32,width> are the same type.
    // Their element counts evaluate to 8.
    var<private> d: array<i32,width>;

    // array<i32,height> and array<i32,width> are the same type.
    var<private> e: array<i32,width>;
    var<private> f: array<i32,height>;
  </xmp>
</div>

注意: 唯一有效的使用可受覆盖常量调整大小的数组类型是作为地址空间/工作组地址空间中的[内存视图]。
这包括工作组变量的存储类型。
请参见[[#var-and-value]]。

<div class='example wgsl global-scope'
   heading="Workgroup variables sized by overridable constants"
   id="example-workgroup-variables-sized-by-override">
  <xmp>
    override blockSize = 16;

    var<workgroup> odds: array<i32,blockSize>;
    var<workgroup> evens: array<i32,blockSize>; // Same type

    // None of the following have the same type as 'odds' and 'evens'.

    // Different type: Not the identifier 'blockSize'
    var<workgroup> evens_0: array<i32,16>;
    // Different type: Uses arithmetic to express the element count.
    var<workgroup> evens_1: array<i32,(blockSize * 2 / 2)>;
    // Different type: Uses parentheses, not just an identifier.
    var<workgroup> evens_2: array<i32,(blockSize)>;

    // An invalid example, because the overridable element count may only occur
    // at the outer level.
    // var<workgroup> both: array<array<i32,blockSize>,2>;

    // An invalid example, because the overridable element count is only
    // valid for workgroup variables.
    // var<private> bad_address_space: array<i32,blockSize>;
  </xmp>
</div>

### 结构类型 ### {#struct-types}

一个<dfn noexport>结构</dfn>是具有命名的<dfn noexport>成员</dfn>值的命名分组。

<table class='data'>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr algorithm="structure type">
      <td>`struct`&nbsp;|AStructName|&nbsp;{<br>
           &nbsp;&nbsp;<var ignore>M<sub>1</sub></var> : <var ignore>T<sub>1</sub></var>,<br>
           &nbsp;&nbsp;...<br>
           &nbsp;&nbsp;<var ignore>M<sub>N</sub></var> : <var ignore>T<sub>N</sub></var>,<br>
           }
      <td> 一个名为[=identifier=] |AStructName| 的结构类型的声明，
          该结构类型具有|N|个成员，
          其中成员<var ignore>i</var>的名称由标识符<var ignore>M<sub>|i|</sub></var>确定，
          并且是类型<var ignore>T<sub>|i|</sub></var>。


          |N| [=shader-creation error|必须=]至少为1。

          同一类型的两个成员[=shader-creation error|不能=]具有相同的名称。
</table>

结构类型在模块作用域下声明。
程序源代码中，结构类型由其标识符名称表示。
请参见[[#declaration-and-scope]]。

两个结构类型仅在它们具有相同的名称时才相同。

结构成员类型必须是以下之一：

* 标量类型
* 向量类型
* 矩阵类型
* 原子类型
* 具有固定大小的数组类型和固定的创建大小
* 但仅当它是结构的最后一个成员时，它可以是运行时大小数组类型
* 具有固定创建大小的结构类型

注意：所有用户声明的结构类型都是具体类型。


注意：每个成员类型必须是纯类型。


一些限制结构成员和数组元素类型的后果包括：

* 指针、纹理或采样器不能在数组或结构的嵌套级别中出现。
* 当运行时大小数组是较大类型的一部分时，它只能出现在结构的最后一个元素中，而结构本身不能是外部数组或结构的一部分。

<div class='example wgsl global-scope' heading="Structure">
  <xmp>
    // A structure with three members.
    struct Data {
      a: i32,
      b: vec2<f32>,
      c: array<i32,10>, // last comma is optional
    }

    // Declare a variable storing a value of type Data.
    var<private> some_data: Data;
  </xmp>
</div>

<pre class=include>
path: syntax/struct_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/struct_body_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/struct_member.syntax.bs.include
</pre>

可以应用以下属性到结构成员：

* [=attribute/align=]（对齐）
* [=attribute/builtin=]（内建）
* [=attribute/location=]（位置）
* [=attribute/interpolate=]（插值）
* [=attribute/invariant=]（不变性）
* [=attribute/size=]（大小）

属性[=attribute/builtin=]，[=attribute/location=]，[=attribute/interpolate=]和[=attribute/invariant=]是IO属性。
在结构体S的成员上使用IO属性仅在S用作形式参数或入口点的返回类型时生效。
参见[[#stage-inputs-outputs]]。


属性[=attribute/align=]和[=attribute/size=]是布局属性，
如果结构类型用来定义统一缓冲区或存储缓冲区，则可能需要这些属性。
参见[[#memory-layouts]]。

<div class='example wgsl global-scope' heading='Structure declaration'>
  <xmp>
    struct my_struct {
      a: f32,
      b: vec4<f32>
    }
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Structure used to declare a buffer'>
  <xmp>
    // Runtime Array
    alias RTArr = array<vec4<f32>>;
    struct S {
      a: f32,
      b: f32,
      data: RTArr
    }
    @group(0) @binding(0) var<storage> buffer: S;
  </xmp>
</div>

### 组合类型 ### {#composite-types}

如果一个类型有作为其他类型组合的内部结构，则它是复合类型。内部部分不重叠，并且被称为组件。复合值可以被分解为其组件。参见[[#composite-value-decomposition-expr]]。


复合类型包括：

* 向量类型
* 矩阵类型
* 数组类型
* 结构类型

对于一个复合类型|T|，其嵌套深度|T|的定义为：

* 向量类型的嵌套深度为1
* 矩阵类型的嵌套深度为2
* 数组类型（元素类型为|E|）的嵌套深度为1 + NestDepth(|E|)
* 结构类型（成员类型为M<sub>1</sub>，…，M<sub>N</sub>）的嵌套深度为1 + max(NestDepth(M<sub>1</sub>)，…，NestDepth(M<sub>N</sub>))


### 可构建类型 ### {#constructible-types}

许多种类的值可以被创建、加载、存储、传递到函数中，并从函数中返回。
我们将这些称为"可构造的"。


如果类型属于以下之一，则称其为"可构造的"：

* 标量类型
* 向量类型
* 矩阵类型
* 如果固定大小数组类型具有"已创建的固定占用空间"属性，并且其元素类型是可构造的，则此类型也属于可构造的。
* 如果结构类型的所有成员都是可构造的，则此类型也属于可构造的。

注：所有可构造类型都具有"已创建的固定占用空间"属性。


注：原子类型和运行时大小的数组类型不可构造。
不可构造包含原子和运行时大小数组的复合类型。

### 固定足迹类型 ### {#fixed-footprint-types}

变量的<dfn noexport>内存占用</dfn>是用于存储变量内容的内存空间的数量。
变量的内存占用取决于其存储类型，并在着色器生命周期的某个时刻确定。
大多数变量在着色器模块创建时就确定大小。
有些变量可能在管线创建时确定大小，而其他变量可能在着色器执行开始时确定大小。

如果某个类型的具体化大小在着色器模块创建时完全确定，那么它具有"creation-fixed footprint"。
如果某个类型的大小在管线创建时完全确定，那么它具有"fixed footprint"。

注意：所有具有"creation-fixed footprint"和"fixed footprint"的类型都是可存储的。

注意：管线的创建依赖于着色器的创建，因此具有"creation-fixed footprint"的类型也具有"fixed footprint"。


具有"creation-fixed footprint"的类型有：

* 标量类型
* 矢量类型
* 矩阵类型
* 原子类型
* 固定大小数组类型，满足以下条件：
* 其元素数量是一个常量表达式。
* 结构类型，如果其所有成员都具有"creation-fixed footprint"。

注意：可构造的类型具有"creation-fixed footprint"。

具有"fixed footprint"的纯类型包括：

* 具有"creation-fixed footprint"的类型
* 固定大小数组类型（不进一步约束其元素数量）

注意：固定大小数组的唯一有效用途是作为地址空间/工作组地址空间中的内存视图。
这包括工作组变量的存储类型。

注意：固定占用的类型可以直接或间接地包含原子类型，而可构造类型则不能。

注意：固定占用的类型不包括运行时大小的数组，以及包含运行时大小数组的任何结构。

## Enumeration Types ## {#enumeration-types}

<dfn noexport>枚举</dfn>类型是一组有限的命名值。
枚举用于区分特定概念的可能性集合，例如有效的[=纹理格式=]集合。


枚举值是枚举中的一个命名值。
每个枚举值与所有其他枚举值以及所有其他类型的值都是不同的。


在WGSL源代码中没有声明新的枚举值或新的枚举类型的机制。


注意：枚举值用作[=模板参数=]。


<div class=note>
  <span class=marker>注意：</span>无法复制枚举值或为其创建替代名称的方法：


  * [[#var-and-value|变量或值]]声明不能将枚举作为其[=存储类型=]或[=有效值类型=]。
  * 函数形式参数不能是枚举类型，部分原因是枚举不可构造。

</div>

### 预先声明的枚举值 ### {#predeclared-enumerants}

以下表格列出了WGSL中的枚举类型及其预定义的枚举元素。
这些枚举类型是存在的，但是在WGSL源码中无法表示。

<table class=data>
<caption>
  预先声明的枚举值
</caption>
<thead>
  <tr><th>枚举<br>(Cannot be spelled in WGSL)<th>预先声明的枚举值
</thead>
  <tr><td rowspan=3>[=access mode=]<td>[=access/read=]
  <tr><td>[=access/write=]
  <tr><td>[=access/read_write=]
  <tr><td rowspan=5>[=address space=]

      Note: The `handle` address space is never written in a WGSL source.
      <td>[=address spaces/function=]
  <tr><td>[=address spaces/private=]
  <tr><td>[=address spaces/workgroup=]
  <tr><td>[=address spaces/uniform=]
  <tr><td>[=address spaces/storage=]
  <tr><td rowspan=3>[=interpolation type=]
      <td>[=interpolation type/perspective=]
  <tr><td>[=interpolation type/linear=]
  <tr><td>[=interpolation type/flat=]
  <tr><td rowspan=3>[=interpolation sampling=]
      <td>[=interpolation sampling/center=]
  <tr><td>[=interpolation sampling/centroid=]
  <tr><td>[=interpolation sampling/sample=]
  <tr><td rowspan=12>[=built-in value=]
      <td>[=built-in values/vertex_index=]
  <tr><td>[=built-in values/instance_index=]
  <tr><td>[=built-in values/position=]
  <tr><td>[=built-in values/front_facing=]
  <tr><td>[=built-in values/frag_depth=]
  <tr><td>[=built-in values/local_invocation_id=]
  <tr><td>[=built-in values/local_invocation_index=]
  <tr><td>[=built-in values/global_invocation_id=]
  <tr><td>[=built-in values/workgroup_id=]
  <tr><td>[=built-in values/num_workgroups=]
  <tr><td>[=built-in values/sample_index=]
  <tr><td>[=built-in values/sample_mask=]
  <tr><td rowspan=17>[=texel format=]
      <td>[=texel format/rgba8unorm=]
  <tr><td>[=texel format/rgba8snorm=]
  <tr><td>[=texel format/rgba8uint=]
  <tr><td>[=texel format/rgba8sint=]
  <tr><td>[=texel format/rgba16uint=]
  <tr><td>[=texel format/rgba16sint=]
  <tr><td>[=texel format/rgba16float=]
  <tr><td>[=texel format/r32uint=]
  <tr><td>[=texel format/r32sint=]
  <tr><td>[=texel format/r32float=]
  <tr><td>[=texel format/rg32uint=]
  <tr><td>[=texel format/rg32sint=]
  <tr><td>[=texel format/rg32float=]
  <tr><td>[=texel format/rgba32uint=]
  <tr><td>[=texel format/rgba32sint=]
  <tr><td>[=texel format/rgba32float=]
  <tr><td>[=texel format/bgra8unorm=]
</table>

## 记忆视图 ## {#memory-views}

除了使用普通类型值进行计算外，WGSL程序还经常从[[#memory|memory]]中读取值或将值写入memory，通过内存访问操作进行。每个内存访问都是通过内存视图进行的。


一个内存视图包括：

* 特定地址空间中的一组内存位置，
* 一个[[#memory-model-reference|内存模型引用]]，
* 将这些位置的内容解释为WGSL类型的存储类型，称为<dfn noexport>store type</dfn>，
* 一个访问模式。

内存视图的访问模式[=shader-creation error|必须=]由地址空间支持。参见[[#var-and-value]]。

### 可存储类型 ### {#storable-types}

存储在变量中的值必须是可存储类型的值。
可存储类型可以通过WGSL来定义明确的表示，参见[[#internal-value-layout]]，
或者可以是不透明的，例如纹理资源和采样器资源。

如果一个类型同时满足以下条件，则被称为<dfn noexport>可存储</dfn>类型：

* 标量类型
* 向量类型
* 矩阵类型
* 原子类型
* 数组类型
* 结构体类型
* 纹理类型
* 采样器类型

注意：可存储类型包括标量类型、纹理类型和采样器类型。

### 可共享的主机类型 ### {#host-shareable-types}

可与主机共享的类型用于描述主机与GPU之间共享的缓冲区的内容，或在主机和GPU之间进行复制时不进行格式转换。在此目的下使用时，该类型还可以应用[=layout attributes=]，如[[#memory-layouts]]所述。如[[#var-decls]]所述，[=uniform buffer=]和[=storage buffer=]变量的[=store type=]必须可与主机共享。


如果类型既是[=type/concrete=]，又符合以下条件之一，该类型就是<dfn noexport>可与主机共享</dfn>的：

* [=numeric scalar=]类型
* [=numeric vector=]类型
* [=matrix=]类型
* [=atomic type|atomic=]类型
* [=fixed-size array=]类型，如果它具有[=creation-fixed footprint=]并且其元素类型可与主机共享
* [=runtime-sized=]数组类型，如果它的元素类型可与主机共享
* [=structure=]类型，如果其所有成员均可与主机共享

注：关于中间阶段输入和输出类型的限制，可以参考[[#stage-inputs-outputs]]和后续部分。这些类型也具有大小，但计数方式可能不同。


注：[[#texture-sampler-types|纹理和采样器]]也可以在主机和GPU之间共享，但它们的内容是不透明的。本节中的可与主机共享类型专门用于[=storage buffer|storage=]和[=uniform buffer|uniform=]缓冲区中的使用。

### 引用和指针类型 ### {#ref-ptr-types}

WGSL有两种类型来表示[内存视图]：[引用类型]和[指针类型]。

<table class='data'>
  <thead>
    <tr><th>限制<th>Type<th>描述
  </thead>
  <tr algorithm="memory reference type">
    <td style="width:25%">|AS| 是一个地址空间，
                          |T| 是一个可存储的类型，
                          |AM| 是一种访问模式。
    <td>ref&lt;|AS|,|T|,|AM|&gt;
    <td><dfn noexport>引用类型</dfn>被定义为一组在|AS|中存储着类型为|T|的值的内存视图，支持由模式|AM|描述的内存访问。
        在这里，|T|是[=存储类型=]。
        引用类型不会在WGSL源代码中直接出现；它们被用于分析WGSL模块。
  <tr algorithm="pointer type">
    <td>|AS| 是一个地址空间，
        |T| 是一个可存储类型，
        |AM| 是一个访问模式。
    <td>ptr&lt;|AS|,|T|,|AM|&gt;
    <td>指针类型指的是在AS中保存类型为T的值的内存位置的一组内存视图，支持由AM模式描述的内存访问。
        这里，T是存储类型。
        指针类型可以出现在WGSL源代码中。
</table>

只有当两个指针类型具有相同的地址空间、存储类型和访问模式时，它们才是相同的。


在分析 WGSL 模块时，引用和指针类型是由地址空间、可存储类型和访问模式完全参数化的。
在本规范中的代码示例中，注释显示了这种完全参数化的形式。


然而，在 WGSL 源文本中：

* 引用类型 [=shader-creation error|不能出现=]。
* 指针类型可以出现。
    * 指针类型的拼写方式为参数化：
        * [=地址空间=]，
        * [=存储类型=]，
        * 有时也由 [=访问模式=] 参数化，如 [[#address-space]] 中所指定的。
* 如果程序源代码中出现指针类型，则该类型的变量声明也要在程序的某个地方有效，包括 [=地址空间=]、[=存储类型=] 和 [=访问模式=]。

注意：此限制禁止了某些永远不会在运行时使用的 [=type aliases=] 和函数 [=formal parameters=] 的声明。 如果没有这个限制，声明指针类型的别名将是有效的，但永远不能创建该类型的指针值。 同样，声明一个带有指针形式参数的函数将是有效的，但永远不能调用该函数。

<div class='example wgsl' heading='Pointer type'>
  <xmp>
    fn my_function(
      /* 'ptr<function,i32,read_write>' is the type of a pointer value that references
         memory for keeping an 'i32' value, using memory locations in the 'function'
         address space.  Here 'i32' is the store type.
         The implied access mode is 'read_write'.
         See "Address Space" section for defaults. */
      ptr_int: ptr<function,i32>,

      // 'ptr<private,array<f32,50>,read_write>' is the type of a pointer value that
      // refers to memory for keeping an array of 50 elements of type 'f32', using
      // memory locations in the 'private' address space.
      // Here the store type is 'array<f32,50>'.
      // The implied access mode is 'read_write'.
      // See the "Address space section for defaults.
      ptr_array: ptr<private, array<f32, 50>>
    ) { }
  </xmp>
</div>

引用类型和指针类型都是一组内存视图：
特定的内存视图与唯一的引用值和唯一的指针值相关联：

<blockquote algorithm=“pointer reference correspondence”>
每个类型为ptr<|AS|,|T|,|AM|>的指针值|p|对应于类型为ref<|AS|,|T|,|AM|>的唯一引用值|r|，
反之亦然，
其中|p|和|r|描述相同的内存视图。
</blockquote>

### 有效和无效的内存引用 ### {#valid-invalid-memory-references}

一个引用类型的值可以是有效引用或无效内存引用。

引用的形成如详细描述在[[#forming-references-and-pointers]]中。
通常，一个有效引用可以通过以下方式形成：

* 命名一个变量，或
* 对一个有效指针应用间接（一元*）操作，或
* 一个以有效引用为基础的命名分量表达式，或
* 一个以有效引用为基础的索引表达式，并使用合法索引。

通常，一个无效内存引用可以通过以下方式形成：

* 对一个无效指针应用间接运算符，或
* 一个以无效内存引用为基础的命名分量表达式，或
* 一个以引用为基础的索引表达式，并且要么：
    * 基础为无效内存引用，或
    * 索引为越界索引。

一个合法指针是指对应于有效引用的指针。
一个无效指针是指对应于无效内存引用的指针。

### 起始变量 ### {#originating-variable-section}

<div algorithm="defining orginating variable">
对于参考值|R|，<dfn noexport>起源变量</dfn>的定义如下：

* 当|R|是一个变量时，它就是这个变量。
* 当|R|是指针值|P|的间接操作符（一元*）的应用时，它就是|P|的起源变量。
* 当|R|是一个[=named component expression=]或一个[=indexing expression=]时，它就是[=decomposition/base=]的起源变量。

</div>

一个指针值的初始变量被定义为对应引用值的初始变量。

注意：初始变量是一个动态概念。
函数的形式参数的初始变量取决于函数的调用点。
不同的调用点可能提供指向不同初始变量的指针。

一个有效的引用始终对应于某个变量的一个或多个内存位置的非空内存视图。

<div class=note>
<span class=marker>Note:</span> 一个引用可以对应于变量内部的内存位置，但仍然可能是无效的。
当索引超过被索引的类型的范围时，就会发生这种情况，但是被引用的位置却在后续的兄弟数据成员内。


在下面的例子中，引用 the_particle.position[i] 当且仅当 i 为0或1时是有效的。
当 i 是2时，引用将是一个无效的内存引用，但在其他情况下，它会对应于 the_particle.color_index 的内存位置。
<div class='example wgsl' heading='Invalid memory reference still inside a variable'>
<span id="example-invalid-ref"></span>
  <xmp>
    struct Particle {
       position: vec2f,
       velocity: vec2f,
       color_index: i32,
    }

    @group(0) @binding(0)
    var<storage,read_write> the_particle: Particle;

    fn particle_velocity_component(p: Particle, i: i32) -> f32 {
      return the_particle.velocity[i]; // A valid reference when i is 0 or 1.
    }
  </xmp>
</div>
</div>

### 越界访问 ### {#out-of-bounds-access-sec}

一个访问无效内存引用的操作被称为“越界访问”。


越界访问是程序中的一个缺陷，因为如果按照写下的方式执行，通常会出现以下情况：

* 读取或写入变量之外的内存位置
* 将这些位置的内容解释为错误的存储类型
* 导致意外的数据竞争

因此，实现不会按照写下的方式执行此访问。执行越界访问会生成动态错误。


注意：在前一节的示例中，出现了解释错误存储类型的示例。当i为2时，表达式the_particle.velocity[i]的类型为ref<storage,f32,read_write>，意味着它是一个以f32为存储类型的内存视图。然而，内存位置被分配给color_index成员，因此实际存储的值是i32类型。

<div class=note>
  <span class=marker>注意：</span>越界访问会导致动态错误，可能会出现多种可能的结果。


  这些结果包括但不限于以下情况：


  <dfn noexport>陷阱</dfn>：
  着色器调用立即终止，[=着色器阶段输出=]被设置为零值。


  <dfn noexport>无效的加载</dfn>：
  从无效引用中加载可能返回以下之一：
  * 当原始变量是一个统一缓冲区或存储缓冲区时，
  来自原始变量绑定的WebGPU {{GPUBuffer}}的任何[=内存位置|内存位置=]的值
  * 当原始变量不是统一缓冲区或存储缓冲区时，
  来自原始变量中的任何[=内存位置|内存位置=]的值
  * 引用的存储类型的[=零值=]
  * 如果加载的值是一个向量，则为值(0, 0, 0, x)，其中x是：
  * 对于整数分量，为0、1或最大正值
  * 对于浮点分量，为0.0或1.0


  <dfn noexport>无效的存储</dfn>：
  对无效引用的[=语句/赋值|存储=]行为可能是以下之一：
  * 当原始变量是一个存储缓冲区时，
  将值存储到绑定到原始变量的WebGPU {{GPUBuffer}}的任何[=内存位置|内存位置=]
  * 当原始变量不是存储缓冲区时，
  将值存储到原始变量中的任何[=内存位置|内存位置=]
  * 不执行


  如果将无效的加载或存储重定向到共享地址空间变量内部的不同位置，
  则可能发生数据竞争。
  例如，几个并发执行的调用的访问可能会被重定向到数组的第一个元素。
  如果至少有一个访问是写入的，并且它们没有被同步，
  则结果是数据竞争，因此也是动态错误。


  越界访问使得[[#uniformity|一致性分析]]的假设失效。
  例如，如果一个调用由于越界访问而提前终止，那么它将无法参与集合操作。
  特别是，对[[#sync-builtin-functions|workgroupBarrier]]的调用可能会导致着色器挂起，而导数可能会产生无效的结果。
</div>

### 参考和指针的用途 ### {#ref-ptr-use-cases}

参考和指针的区别在于它们的用法：
* 变量的类型是引用类型。
* 取地址操作（一元运算符&）将引用值转换为其相应的指针值。
* 解引用操作（一元运算符*）将指针值转换为其相应的引用值。
* let声明可以是指针类型，但不能是引用类型。
* 形式参数可以是指针类型，但不能是引用类型。
* 简单赋值语句通过引用执行写访问操作来更新内存的内容，其中：
* 赋值语句的左侧必须是引用类型，并具有访问模式为access/write或access/read_write。
* 赋值语句的右侧必须求值为左侧的存储类型。
* 载入规则：在函数内部，引用会自动解引用（读取）以满足类型规则：
* 在函数中，当使用具有存储类型为T的引用表达式|r|的语句或表达式时，其中
* |r|的访问模式为access/read或access/read_write，并且
* 唯一可能匹配的类型规则要求|r|具有类型为T的值，则
* 认为已满足该类型规则要求，并且
* 在该上下文中评估|r|的结果是存储在|r|引用的内存位置上的值（类型为T）。 即，执行读访问以产生结果值。

以这种方式定义引用使得变量的使用变得简单而惯用。

<div class='example wgsl' heading='Reference types enable simple use of variables'>
  <xmp>
    @compute @workgroup_size(1)
    fn main() {
      // 'i' has reference type ref<function,i32,read_write>
      // The memory locations for 'i' store the i32 value 0.
      var i: i32 = 0;

      // 'i + 1' can only match a type rule where the 'i' subexpression is of type i32.
      // So the expression 'i + 1' has type i32, and at evaluation, the 'i' subexpression
      // evaluates to the i32 value stored in the memory locations for 'i' at the time
      // of evaluation.
      let one: i32 = i + 1;

      // Update the value in the locations referenced by 'i' so they hold the value 2.
      i = one + 1;

      // Update the value in the locations referenced by 'i' so they hold the value 5.
      // The evaluation of the right-hand-side occurs before the assignment takes effect.
      i = i + 3;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Returning a reference returns the value loaded via the reference'>
  <xmp>
    var<private> age: i32;
    fn get_age() -> i32 {
      // The type of the expression in the return statement must be 'i32' since it
      // must match the declared return type of the function.
      // The 'age' expression is of type ref<private,i32,read_write>.
      // Apply the Load Rule, since the store type of the reference matches the
      // required type of the expression, and no other type rule applies.
      // The evaluation of 'age' in this context is the i32 value loaded from the
      // memory locations referenced by 'age' at the time the return statement is
      // executed.
      return age;
    }

    fn caller() {
      age = 21;
      // The copy_age constant will get the i32 value 21.
      let copy_age: i32 = get_age();
    }
  </xmp>
</div>

以这种方式定义指针可以实现两个关键应用场景：
* 使用具有指针类型的let声明，以形成变量内容的一部分的简短名称。
* 使用函数的形式参数来引用对调用函数可访问的变量的内存。
      * 对于这样的函数调用，必须为该操作数提供指针值。 这通常需要使用地址运算符（一元&）来获取变量内容的指针。

<div class='example wgsl' heading='Using a pointer as a short name for part of a variable'>
  <xmp>
    struct Particle {
      position: vec3<f32>,
      velocity: vec3<f32>
    }
    struct System {
      active_index: i32,
      timestep: f32,
      particles: array<Particle,100>
    }
    @group(0) @binding(0) var<storage,read_write> system: System;

    @compute @workgroup_size(1)
    fn main() {
      // Form a pointer to a specific Particle in storage memory.
      let active_particle: ptr<storage,Particle> =
          &system.particles[system.active_index];

      let delta_position: vec3<f32> = (*active_particle).velocity * system.timestep;
      let current_position: vec3<f32>  = (*active_particle).position;
      (*active_particle).position = delta_position + current_position;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Using a pointer as a formal parameter'>
  <xmp>
    fn add_one(x: ptr<function,i32>) {
      /* Update the locations for 'x' to contain the next higher integer value,
         (or to wrap around to the largest negative i32 value).
         On the left-hand side, unary '*' converts the pointer to a reference that
         can then be assigned to. It has a read_write access mode, by default.
         /* On the right-hand side:
            - Unary '*' converts the pointer to a reference, with a read_write
              access mode.
            - The only matching type rule is for addition (+) and requires '*x' to
              have type i32, which is the store type for '*x'.  So the Load Rule
              applies and '*x' evaluates to the value stored in the memory for '*x'
              at the time of evaluation, which is the i32 value for 0.
            - Add 1 to 0, to produce a final value of 1 for the right-hand side. */
         Store 1 into the memory for '*x'. */
      *x = *x + 1;
    }

    @compute @workgroup_size(1)
    fn main() {
      var i: i32 = 0;

      // Modify the contents of 'i' so it will contain 1.
      // Use unary '&' to get a pointer value for 'i'.
      // This is a clear signal that the called function has access to the memory
      // for 'i', and may modify it.
      add_one(&i);
      let one: i32 = i;  // 'one' has value 1.
    }
  </xmp>
</div>

### 形成引用和指针值 ### {#forming-references-and-pointers}

引用值可以通过以下方式之一形成：

* [=标识符=] 通过解析为在作用域内的变量 v 的引用值来指示 v 的内存。
* 在指针上使用间接操作（一元 *）。
* 在对复合引用上使用命名成分表达式：
    * 给定一个带有向量存储类型的引用，添加一个单字母向量访问短语将导致指向向量的命名成分的引用。
    * 给定一个带有结构存储类型的引用，添加一个成员访问短语将导致指向结构的命名成员的引用。
* 在对复合引用上使用索引表达式：
    * 给定一个带有向量存储类型的引用，添加一个数组索引访问短语将导致指向向量的索引成分的引用。
    * 给定一个带有矩阵存储类型的引用，添加一个数组索引访问短语将导致指向矩阵的索引列向量的引用。
    * 给定一个带有数组存储类型的引用，添加一个数组索引访问短语将导致指向数组的索引元素的引用。

在所有情况下，结果的访问模式与原始引用的访问模式相同。

<div class='example wgsl' heading='Component reference from a composite reference'>
  <xmp>
    struct S {
        age: i32,
        weight: f32
    }
    var<private> person: S;
    // Elsewhere, 'person' denotes the reference to the memory underlying the variable,
    // and will have type ref<private,S,read_write>.

    fn f() {
        var uv: vec2<f32>;
        // For the remainder of this function body, 'uv' denotes the reference
        // to the memory underlying the variable, and will have type
        // ref<function,vec2<f32>,read_write>.

        // Evaluate the left-hand side of the assignment:
        //   Evaluate 'uv.x' to yield a reference:
        //   1. First evaluate 'uv', yielding a reference to the memory for
        //      the 'uv' variable. The result has type ref<function,vec2<f32>,read_write>.
        //   2. Then apply the '.x' vector access phrase, yielding a reference to
        //      the memory for the first component of the vector pointed at by the
        //      reference value from the previous step.
        //      The result has type ref<function,f32,read_write>.
        // Evaluating the right-hand side of the assignment yields the f32 value 1.0.
        // Store the f32 value 1.0 into the storage memory locations referenced by uv.x.
        uv.x = 1.0;

        // Evaluate the left-hand side of the assignment:
        //   Evaluate 'uv[1]' to yield a reference:
        //   1. First evaluate 'uv', yielding a reference to the memory for
        //      the 'uv' variable. The result has type ref<function,vec2<f32>,read_write>.
        //   2. Then apply the '[1]' array index phrase, yielding a reference to
        //      the memory for second component of the vector referenced from
        //      the previous step.  The result has type ref<function,f32,read_write>.
        // Evaluating the right-hand side of the assignment yields the f32 value 2.0.
        // Store the f32 value 2.0 into the storage memory locations referenced by uv[1].
        uv[1] = 2.0;

        var m: mat3x2<f32>;
        // When evaluating 'm[2]':
        // 1. First evaluate 'm', yielding a reference to the memory for
        //    the 'm' variable. The result has type ref<function,mat3x2<f32>,read_write>.
        // 2. Then apply the '[2]' array index phrase, yielding a reference to
        //    the memory for the third column vector pointed at by the reference
        //    value from the previous step.
        //    Therefore the 'm[2]' expression has type ref<function,vec2<f32>,read_write>.
        // The 'let' declaration is for type vec2<f32>, so the declaration
        // statement requires the initializer to be of type vec2<f32>.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the vec2<f32> value loaded
        // from the memory locations referenced by 'm[2]' at the time the declaration
        // is executed.
        let p_m_col2: vec2<f32> = m[2];

        var A: array<i32,5>;
        // When evaluating 'A[4]'
        // 1. First evaluate 'A', yielding a reference to the memory for
        //    the 'A' variable. The result has type ref<function,array<i32,5>,read_write>.
        // 2. Then apply the '[4]' array index phrase, yielding a reference to
        //    the memory for the fifth element of the array referenced by
        //    the reference value from the previous step.
        //    The result value has type ref<function,i32,read_write>.
        // The let-declaration requires the right-hand-side to be of type i32.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the i32 value loaded from
        // the memory locations referenced by 'A[4]' at the time the declaration
        // is executed.
        let A_4_value: i32 = A[4];

        // When evaluating 'person.weight'
        // 1. First evaluate 'person', yielding a reference to the memory for
        //    the 'person' variable declared at module scope.
        //    The result has type ref<private,S,read_write>.
        // 2. Then apply the '.weight' member access phrase, yielding a reference to
        //    the memory for the second member of the memory referenced by
        //    the reference value from the previous step.
        //    The result has type ref<private,f32,read_write>.
        // The let-declaration requires the right-hand-side to be of type f32.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the f32 value loaded from
        // the memory locations referenced by 'person.weight' at the time the
        // declaration is executed.
        let person_weight: f32 = person.weight;
    }
  </xmp>
</div>

指针值可以通过以下方式之一形成：

* 在引用上使用[=取地址=]（一元&）操作符。
    * 只有当原始引用是[=有效引用=]时，结果才是[=有效指针=]。
    * 有效结果的[=原始变量=]被定义为引用的原始变量。
* 如果一个函数[=形式参数=]具有指针类型，则在运行时调用函数时，形式参数的使用表示传递给调用函数中相应操作数的指针值。
    * 形式参数在运行时表示的值只有在调用点的指针值是[=有效指针=]时才是[=有效指针=]。
    * 有效指针形式参数在运行时的[=原始变量=]被定义为调用点处指针操作数的原始变量。

在所有情况下，结果的[=访问模式=]与原始指针的访问模式相同。

<div class='example wgsl' heading='Pointer from a variable'>
  <xmp>
    // Declare a variable in the private address space, for storing an f32 value.
    var<private> x: f32;

    fn f() {
        // Declare a variable in the function address space, for storing an i32 value.
        var y: i32;

        // The name 'x' resolves to the module-scope variable 'x',
        // and has reference type ref<private,f32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode is the same as the access mode of the original variable, so
        // the fully specified type is ptr<private,f32,read_write>.  But read_write
        // is the default access mode for function address space, so read_write does not
        // have to be spelled in this case
        let x_ptr: ptr<private,f32> = &x;

        // The name 'y' resolves to the function-scope variable 'y',
        // and has reference type ref<private,i32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode defaults to 'read_write'.
        let y_ptr: ptr<function,i32> = &y;

        // A new variable, distinct from the variable declared at module scope.
        var x: u32;

        // Here, the name 'x' resolves to the function-scope variable 'x' declared in
        // the previous statement, and has type ref<function,u32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode defaults to 'read_write'.
        let inner_x_ptr: ptr<function,u32> = &x;
    }
  </xmp>
</div>

### 与其他语言中的引用和指针的比较 ### {#pointers-other-languages}

本节是信息性的，而不是规范性的。


在WGSL中，引用和指针的限制比其他语言更严格。具体而言：
* 在WGSL中，引用不能直接声明为对另一个引用或变量的别名，无论是作为变量还是作为形式参数。
* 在WGSL中，指针和引用不能存储。也就是说，WGSL的变量声明的内容不能包含指针或引用。
* 在WGSL中，函数着色器不能返回指针或引用。
* 在WGSL中，没有办法在整数值和指针值之间进行转换。
* 在WGSL中，没有办法强制将指针值的类型更改为另一种指针类型。
    * 复合组件引用表达式是不同的： 它获取对复合值的引用，并产生对复合值内部的一个组件或元素的引用。 在WGSL中，尽管它们在更低级别的实现抽象中可能具有相同的机器地址，但它们被认为是不同的引用。
* 在WGSL中，没有办法强制将引用值的类型更改为另一种引用类型。
* 在WGSL中，没有办法更改指针或引用的访问模式。
    * 相比之下，C++会自动将非const指针转换为const指针，并使用const_cast将const值转换为非const值。
* 在WGSL中，没有办法从"堆"中分配新的内存。
* 在WGSL中，没有办法显式销毁变量。只有当变量超出作用域时，WGSL变量的内存才变得不可访问。

注意：根据上述规则，无法形成"悬空"指针，即不引用"活动"源变量的指针。[=memory view=]可能是一个[=invalid memory reference=]，但它[=behavioral requirement|绝不会=]访问与[=originating variable=]或缓冲区无关的[=memory locations=]。

## 纹理类型和采样器类型 ## {#texture-sampler-types}

<dfn noexport>纹素</dfn>是指作为纹理中最小独立可访问元素的标量或矢量。纹素是纹素元素的缩写。

<dfn noexport>纹理</dfn>是一组支持用于渲染的特殊操作的纹素集合。在WGSL中，这些操作通过纹理内置函数调用。请参阅[[#texture-builtin-functions]]获取完整列表。

WGSL纹理对应WebGPU的{{GPUTexture}}。

纹理具有以下特征：

: [=纹理格式=]
::每个纹素的数据表示。参见[[#纹素格式]]。
: <dfn dfn-for=texture noexport>维度性</dfn>：网格坐标的维度数量以及坐标的解释方式。
:: 维度数量可以是1、2或3。
: 大多数纹理使用笛卡尔坐标。
::立方体纹理具有六个正方形面，并且通过从原点指向以原点为中心的立方体的三维坐标进行采样解释为方向向量。 详见{{GPUTextureViewDimension}}。
: 尺寸：沿每个维度的网格坐标的范围。这是一个与mip等级有关的函数。
:: <dfn dfn-for=texture noexport>mip等级数量</dfn>
  对于采样纹理和深度纹理，mip等级数量至少为1，对于存储纹理等级数量等于1。
  mip等级0包含纹理的全尺寸版本。
  每个后续的mip等级包含前一个mip等级的一半大小（舍入）的滤波版本。 在对纹理进行采样时，使用显式或隐式计算的细节级别来选择从中读取纹素数据的mip等级，然后通过滤波组合生成采样值。
: <dfn dfn-for=texture noexport>是否是数组纹理</dfn>
:: 非数组纹理是纹素的网格。
    * 数组纹理是纹素网格的一致数组。
: <dfn dfn-for=texture noexport>数组大小/dfn>
:: 如果纹理是数组纹理，则是一致网格的数量。
: <dfn dfn-for=texture noexport>采样次数</dfn>
:: 如果纹理是多重采样的，是采样数量。

纹理中的每个像素与一个唯一的“逻辑纹素地址”相关联，这是一个整数元组，具有以下特征：
* 一个[=mip level=]在[0, [=texture/mip level count=]]的范围内。
* 一定数量的分量，由[=texture/dimensionality=]控制，每个分量的值在[0, S<sub>i</sub>)的范围内，其中S<sub>i</sub>是第i个分量的[=texture/size=]。
* 如果纹理是[=texture/arrayed=]，则有一个在[0, [=texture/array size=]]的范围内的数组索引。请注意，[=texture/size=]是[=mip level=]的一个函数。
* 如果纹理是[[#multisampled-texture-type|multisampled]]，则有一个在[0, [=texture/sample count=]]的范围内的样本索引。

纹理的物理组织通常针对渲染操作进行了优化。为了实现这一点，很多细节对程序员来说是隐藏的，包括数据布局、数据类型以及不能直接在着色器语言中表达的内部操作。

因此，着色器不能直接访问[=texture resource|texture variable=]中的纹素内存。相反，访问是通过一个不透明的句柄进行的。

* 在着色器内部：
    * 声明一个模块作用域变量，其中[=存储类型=]是后面章节中描述的纹理类型之一。该变量存储底层纹理内存的不透明句柄，并自动放置在[=地址空间/句柄=]地址空间中。
    * 在函数内部，调用其中一个纹理内建函数，并将纹理变量或函数参数作为纹理内建函数的第一个参数提供。

* 构建WebGPU管道时，纹理变量的存储类型和绑定须与相应的绑定组布局条目兼容。


通过这种方式，纹理类型的支持操作集由具有该纹理类型[=形式参数=]的[[#纹理内建函数|纹理内建函数]]的可用性决定。


注意：纹理变量存储的句柄不能由着色器改变。也就是说，该变量是只读的，即使它提供访问的底层纹理可能是可变的（例如，写入仅[=类型/存储纹理=]）。


<dfn>纹理类型</dfn>是在以下定义的一组类型：
* [[#采样纹理类型]]
* [[#多重采样纹理类型]]
* [[#外部纹理类型]]
* [[#纹理存储]]
* [[#纹理深度]]

采样器是一个不透明的句柄，用于控制从采样纹理或深度纹理中访问像素。

WGSL采样器映射到WebGPU的{{GPUSampler}}。

通过采样器的几个属性来控制像素的访问方式：

: 寻址模式
:: 控制如何解决纹理边界和越界坐标的问题。
: 每个纹理维度的寻址模式可以独立设置。
:: 详见WebGPU的{{GPUAddressMode}}。
: 过滤模式
:: 控制访问哪些像素以生成最终结果。
  过滤可以使用最近的像素或在多个像素之间进行插值。
  可以独立设置多个过滤模式。
  详见WebGPU的{{GPUFilterMode}}。
: LOD（Level of Detail）夹持
:: 控制访问的最小和最大细节级别。
: 比较
:: 控制用于比较采样器的类型。
    详见WebGPU的{{GPUCompareFunction}}。
: 最大各向异性
:: 控制采样器使用的最大各向异性值。

在WGSL模块中无法创建采样器，并且它们的状态（例如上述列出的属性）在着色器内部是不可变的，只能通过WebGPU API进行设置。

如果使用具有非可过滤格式的纹理与使用插值过滤的采样器（即任何采样器）一起使用，则会出现[=pipeline-creation error=]。

注意：着色器无法更改采样器变量存储的句柄。

### 纹理格式 ### {#texel-formats}

在WGSL中，某些纹理类型由纹素格式进行参数化。


<dfn noexport>纹素格式</dfn>具有以下特征：


: <dfn noexport>通道</dfn>
:: 每个通道包含一个标量。
纹素格式最多有四个通道：r、g、b和a，通常对应于红色、绿色、蓝色和透明度通道的概念。
: <dfn noexport>通道格式</dfn>
:: 通道中位数的数量以及如何解释这些位数。


WGSL中的每种纹素格式都对应于具有相同名称的WebGPU {{GPUTextureFormat}}。


只有某些纹素格式在WGSL源代码中使用。
用于定义这些纹素格式的通道格式列在 <dfn dfn>通道格式</dfn> 表中。
最后一列指定了从存储的通道位到着色器中使用的值之间的转换。
这也被称为<dfn noexport>通道传输函数</dfn>或CTF。


注意：8unorm的通道传输函数将{0，…，255}映射到浮点数范围[0.0，1.0]。


注意：8snorm的通道传输函数将{-128，…，127}映射到浮点数范围[-1.0，1.0]。

<table class='data'>
  <caption>Channel Formats</caption>
  <thead>
    <tr><th>Channel format
        <th>Number of stored bits
        <th>Interpretation of stored bits
        <th>Shader type<td style="width:25%">Shader value
(Channel Transfer Function)
  </thead>
  <tr><td>8unorm<td>8<td>unsigned integer |v| &isinv; {0,...,255}<td>f32<td> |v| &div; 255
  <tr><td>8snorm<td>8<td>signed integer |v| &isinv; {-128,...,127}<td>f32<td> max(-1, |v| &div; 127)
  <tr><td>8uint<td>8<td>unsigned integer |v| &isinv; {0,...,255}<td>u32<td> |v|
  <tr><td>8sint<td>8<td>signed integer |v| &isinv; {-128,...,127}<td>i32<td> |v|
  <tr><td>16uint<td>16<td>unsigned integer |v| &isinv; {0,...,65535}<td>u32<td> |v|
  <tr><td>16sint<td>16<td>signed integer |v| &isinv; {-32768,...,32767}<td>i32<td> |v|
  <tr><td>16float<td>16<td>[[!IEEE-754|IEEE-754]] binary16 16-bit floating point value |v|, with 1 sign bit, 5 exponent bits, 10 mantissa bits<td>f32<td>|v|
  <tr><td>32uint<td>32<td>32-bit unsigned integer value |v|<td>u32<td>|v|
  <tr><td>32sint<td>32<td>32-bit signed integer value |v|<td>i32<td>|v|
  <tr><td>32float<td>32<td>[[!IEEE-754|IEEE-754]] binary32 32-bit floating point value |v|<td>f32<td>|v|
</table>

存储纹理的像素格式在“存储纹理的Texel格式”表中列出，对应支持WebGPU纯色格式的WebGPU GPUTextureUsage/STORAGE_BINDING使用。这些像素格式用于参数化在texture-storage中定义的类型/存储纹理类型。


当像素格式不具有四个通道时：

* 在读取像素时：
* 如果像素格式没有绿色通道，则着色器值的第二个分量为0。
* 如果像素格式没有蓝色通道，则着色器值的第三个分量为0。
* 如果像素格式没有alpha通道，则着色器值的第四个分量为1。
* 在写入像素时，将忽略缺失通道的着色器值分量。

下表中的最后一列使用了来自通道格式表的特定格式的通道转换函数。

<table class='data'>
  <caption>Texel Formats for Storage Textures</caption>
  <thead>
    <tr><th>Texel format
        <th>Channel format
        <th>Channels in memory order
        <th style="width:50%">Corresponding shader value
  </thead>
  <tr><td><dfn for="texel format">rgba8unorm</dfn><td>8unorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba8snorm</dfn><td>8snorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba8uint</dfn><td>8uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba8sint</dfn><td>8sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba16uint</dfn><td>16uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba16sint</dfn><td>16sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba16float</dfn><td>16float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">r32uint</dfn><td>32uint<td>r<td>vec4&lt;u32&gt;(CTF(r), 0u, 0u, 1u)
  <tr><td><dfn for="texel format">r32sint</dfn><td>32sint<td>r<td>vec4&lt;i32&gt;(CTF(r), 0, 0, 1)
  <tr><td><dfn for="texel format">r32float</dfn><td>32float<td>r<td>vec4&lt;f32&gt;(CTF(r), 0.0, 0.0, 1.0)
  <tr><td><dfn for="texel format">rg32uint</dfn><td>32uint<td>r, g<td>vec4&lt;u32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td><dfn for="texel format">rg32sint</dfn><td>32sint<td>r, g<td>vec4&lt;i32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td><dfn for="texel format">rg32float</dfn><td>32float<td>r, g<td>vec4&lt;f32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td><dfn for="texel format">rgba32uint</dfn><td>32uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba32sint</dfn><td>32sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">rgba32float</dfn><td>32float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td><dfn for="texel format">bgra8unorm</dfn><td>8unorm<td>b, g, r, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
</table>

WGSL为表中的每种纹理格式[=predeclared|predeclares=]一个[=enumerant=]。

### 采样纹理类型 ### {#sampled-texture-type}

一个“采样纹理”可以与“采样器类型”一起被访问。它也可以在不使用采样器的情况下被访问。采样纹理只允许读访问。


“纹素格式”是绑定到纹理变量的“GPUTexture”的“format”属性。WebGPU会在纹理、绑定组布局的“GPUTextureBindingLayout/sampleType”以及纹理变量的“采样类型”之间进行验证以确保兼容性。


纹理由一个“采样类型”参数化，且必须是“f32”、“i32”或“u32”。

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_1d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"1d"|1D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_2d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_2d_array</dfn><*T*>
      <td>{{GPUTextureViewDimension/"2d-array"|2D}}
      <td>Yes
  <tr><td><dfn noexport dfn-for='type'>texture_3d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"3d"|3D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_cube</dfn><*T*>
      <td>{{GPUTextureViewDimension/"cube"|Cube}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_cube_array</dfn><*T*>
      <td>{{GPUTextureViewDimension/"cube-array"|Cube}}
      <td>Yes
</table>

* T 是[=采样类型=]。
* 图像的参数化类型是从采样转换后的类型。 例如，您可以有一个具有8位非规范化分量的纹素图像，但是当您对它们进行采样时，您会得到一个32位浮点数结果（或者f32向量）。

### 多重采样纹理类型 ### {#multisampled-texture-type}

一个多样本纹理具有一个或多个纹理采样点。
尽管名字是这样，但它不能与采样器一起使用。
如果忽略采样索引，它有效地按每个逻辑纹素地址存储多个像素值的数据。


纹素格式是绑定到纹理变量的GPUTexture的format属性。
WebGPU通过验证纹理、绑定组布局的GPUTextureBindingLayout/sampleType以及纹理变量的采样类型之间的兼容性。


纹理由采样类型参数化，必须是f32、i32或u32。

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_multisampled_2d</dfn><*T*>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_depth_multisampled_2d</dfn>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
</table>

T 是被抽样的类型。

### 外部采样纹理类型 ### {#external-texture-type}

一个<dfn noexport dfn-for=‘type’>外部纹理</dfn>是一个不透明的二维浮点数-[=type/sampled texture=]类型，类似于texture_2d<f32>，但可能具有不同的表示形式。
可以使用[[#textureload|textureLoad]]或[[#textureSampleBaseClampToEdge|textureSampleBaseClampToEdge]]内置函数来读取它们，这些函数可以处理这些不同的表示形式。

见 [[WebGPU#gpuexternaltexture]].

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_external</dfn>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
</table>

### 存储纹理类型 ### {#texture-storage}

一种存储纹理支持无需使用采样器即可访问单个纹素值。

* 一个只写的存储纹理支持写入单个纹素，将着色器值自动转换为存储的纹素值。
* 一个只读的存储纹理支持读取单个纹素，将存储的纹素值自动转换为着色器纹素值。
* 一个读写的存储纹理支持读取和写入单个纹素，着色器纹素值和存储纹素值之间自动进行转换。

存储纹理类型必须通过[存储纹素格式]之一进行参数化。纹素格式决定了转换函数，如[[#纹素格式]]中所述。


在向存储纹理写入纹素时，使用与转换函数相反的函数将着色器值转换为存储的纹素。


<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_storage_1d</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"1d"|1D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_storage_2d</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_storage_2d_array</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"2d-array"|2D}}
      <td>Yes
  <tr><td><dfn noexport dfn-for='type'>texture_storage_3d</dfn><*Format*, *Access*>
      <td>{{GPUTextureViewDimension/"3d"|3D}}
      <td>No
</table>

* Format 必须是存储纹理的像素格式之一
* Access 必须是访问模式中的一个枚举值。

### 深度纹理类型 ### {#texture-depth}

一个深度纹理（depth texture）可以与类型/采样器比较结合使用，可以被访问。它也可以在不使用采样器的情况下被访问。深度纹理仅允许读取访问。


纹理的像素格式在GPUTextureBindingLayout中被定义。

<table class='data'>
  <thead>
    <tr><th>Type<th>[=texture/Dimensionality=]<th>[=texture/Arrayed=]
  </thead>
  <tr><td><dfn noexport dfn-for='type'>texture_depth_2d</dfn>
      <td>{{GPUTextureViewDimension/"2d"|2D}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_depth_2d_array</dfn>
      <td>{{GPUTextureViewDimension/"2d-array"|2D}}
      <td>Yes
  <tr><td><dfn noexport dfn-for='type'>texture_depth_cube</dfn>
      <td>{{GPUTextureViewDimension/"cube"|Cube}}
      <td>No
  <tr><td><dfn noexport dfn-for='type'>texture_depth_cube_array</dfn>
      <td>{{GPUTextureViewDimension/"cube-array"|Cube}}
      <td>Yes
</table>

### 采样器类型 ### {#sampler-type}

一个<dfn>采样器（sampler）</dfn>通过执行以下操作来调节对于[=type/sampled texture=]或[=type/depth texture=]的访问：
* 坐标变换。
* 可选地修改mip级别的选择。
* 对于[=type/sampled texture=]，可选地对检索到的纹素值进行滤波。
* 对于[=type/depth texture=]，确定要应用于检索到的纹素的比较函数。

<dfn noexport>采样器类型（sampler types）</dfn>有：
* [=type/sampler=]
* [=type/sampler_comparison=]

<table class=‘data’>
  <thead>
    <tr><th>类型<th>描述
  </thead>
  <tr algorithm=“sampler type”>
  <td><dfn dfn-for=“type”>sampler</dfn>
  <td>采样器。调节对于[=type/sampled texture=]的访问。</td>
  <tr algorithm=“comparison sampler type”>
  <td><dfn dfn-for=“type”>sampler_comparison</dfn>
  <td>比较采样器。调节对于[=type/depth texture=]的访问。</td>
</table>


采样器在WebGPU API中创建时进行参数化。
它们不能由WGSL模块修改。

采样器只能被[[#texture-builtin-functions|纹理内置函数]]使用。

<pre class='def'>
sampler
sampler_comparison
</pre>

## 所有类型 类型 ## {#alltypes-type}

<dfn noexport>AllTypes</dfn>类型是所有WGSL类型的集合。


在WGSL源代码中无法直接编写AllTypes类型。


请参阅[[#predeclared-types]]以获取所有预定义类型和类型生成器的列表。


<div class=note>
<span class=marker>注意：</span>类型在一般意义上不是一个值。
它不是在运行时由着色器操作的数据。


<p>
相反，AllTypes类型存在是为了使类型检查规则适用于可能包含一般值的任何短语。
WGSL通过将类型定义为一种值的类型，并允许表达式表示一个类型来使规则保持一致。


<p>
动机案例是一个“模板参数”，在各种上下文中可以表示多种事物，包括一个“类型”、一个“枚举值”或一个“基本类型值”。
特别是，“syntax/template_arg_expression”语法规则会展开为“syntax/expression”语法非终结符。
</div>

## 类型别名 ## {#type-aliases}

一个<dfn noexport>类型别名</dfn>为现有类型声明了一个新名称。
声明必须出现在模块范围内，并且其作用域为整个程序。


当类型T被定义为结构类型S的一个类型别名时，
S的成员的所有属性，包括特性，都会传递给T的成员。

<pre class=include>
path: syntax/type_alias_decl.syntax.bs.include
</pre>

<div class='example wgsl global-scope' heading='Type Alias'>
  <xmp>
    alias Arr = array<i32, 5>;

    alias RTArr = array<vec4<f32>>;

    alias single = f32;     // Declare an alias for f32
    const pi_approx: single = 3.1415;
    fn two_pi() -> single {
      return single(2) * pi_approx;
    }
  </xmp>
</div>

## 类型指示语法 ## {#type-specifiers}

请参见[[#type-expr]]。


<pre class=include>
路径：syntax/type_specifier.syntax.bs.include
</pre>


<pre class=include>
路径：syntax/template_elaborated_ident.syntax.bs.include
</pre>


注意：通过展开的方式，[=expression=]也可以表示一种类型，通过扩展语法/primary_expression=]的语法规则到[syntax/template_elaborated_ident=]，以及通过[[#parenthesized-expressions|parenthesization]]的方式。

## 预声明类型和类型生成器总结 ## {#predeclared-types}

在WGSL源代码中可以拼写的预定义类型包括：
* [=bool=]
* [=f16=]
* [=f32=]
* [=i32=]
* [=type/sampler=]
* [=type/sampler_comparison=]
* [=type/texture_depth_2d=]
* [=type/texture_depth_2d_array=]
* [=type/texture_depth_cube=]
* [=type/texture_depth_cube_array=]
* [=type/texture_depth_multisampled_2d=]
* [=type/texture_external=]
* [=u32=]

WGSL还预先声明了[[#frexp-builtin|frexp]]、[[#modf-builtin|modf]]和[[#atomic-rmw|atomicCompareExchangeWeak]]内建函数的返回类型。
然而，这些类型在WGSL源代码中不能拼写。


以下表格列出了预声明的类型生成器：
<table class=data>
<caption>
  Predeclared type generators
</caption>
<thead>
  <tr><th>Predeclared type-generator<th>Cross-reference
</thead>
  <tr><td>array<td>See [[#array-types]]
  <tr><td>atomic<td>See [[#atomic-types]]
  <tr><td>mat2x2<td rowspan=9>See [[#matrix-types]], which also lists
     predeclared [=type aliases|aliases=] for matrix types.

     Note: These are also used in [=value constructor=] expressions
     to create matrices.
  <tr><td>mat2x3
  <tr><td>mat2x4
  <tr><td>mat3x2
  <tr><td>mat3x3
  <tr><td>mat3x4
  <tr><td>mat4x2
  <tr><td>mat4x3
  <tr><td>mat4x4
  <tr><td>ptr<td>See [[#ref-ptr-types]]
  <tr><td>texture_1d<td rowspan=6>See [[#sampled-texture-type]]
  <tr><td>texture_2d
  <tr><td>texture_2d_array
  <tr><td>texture_3d
  <tr><td>texture_cube
  <tr><td>texture_cube_array
  <tr><td>texture_multisampled_2d<td>See [[#multisampled-texture-type]]
  <tr><td>texture_storage_1d<td rowspan=4>See [[#texture-storage]]
  <tr><td>texture_storage_2d
  <tr><td>texture_storage_2d_array
  <tr><td>texture_storage_3d
  <tr><td>vec2<td rowspan=3>See [[#vector-types]], which also lists
     predeclared [=type aliases|aliases=] for vector types.

     Note: These are also used in [=value constructor=] expressions
     to create vectors.
  <tr><td>vec3
  <tr><td>vec4
</table>

# 变量和值的声明 # {#var-and-value}

[=变量声明|变量=]和[=值声明|值=]声明为数据值提供了名称。


<dfn noexport>值声明</dfn>创建一个值的名称，一旦声明，该值就是不可变的。
值声明有四种种类：const、override、let和形式参数声明，下面会进一步描述（见[[#value-decls]]）。


<dfn noexport>变量声明</dfn>为[=内存位置=]创建一个名称，用于存储值；如果变量具有[=访问/读写=]访问模式，那么存储在该位置的值可以被更新。
变量声明只有一种类型，即var，但可以在各种组合中选择[=地址空间=]和[=访问模式=]的选项，下面会进行描述（见[[#var-decls]]）。


注意：值声明没有关联的内存位置。例如，WGSL表达式无法形成指向该值的指针。


在任何函数定义之外出现的声明位于[=模块作用域=]中。它的名称在整个程序中[=在作用域内=]。


在函数定义中出现的声明位于<dfn noexport>函数作用域</dfn>中。
该名称在声明之后的语句中立即可用，直到声明所包含的大括号列表的结束。
函数作用域声明是一个[=动态上下文=]。


变量和值声明具有相似的总体语法：
<xmp>
  // Specific value declarations.
               const    name [: type]  = initializer ;
  [attribute]* override name [: type] [= initializer];
               let      name [: type]  = initializer ;

  // General variable form.
  [attribute]* var[<address_space[, access_mode]>] name [: type] [= initializer];

  // Specific variable declarations.
  // Function scope.
               var[<function>] name [: type] [= initializer];

  // Module scope.
               var<private>    name [: type] [= initializer];
               var<workgroup>  name : type;
  [attribute]+ var<uniform>    name : type;
  [attribute]+ var             name : texture_type;
  [attribute]+ var             name : sampler_type;
  [attribute]+ var<storage[, access_mode]> name : type;
</xmp>

每个这样的声明都必须具有显式指定的类型或初始化器。
可以同时指定类型和初始化器。
每个这样的声明确定与其关联的数据值的类型，被称为该声明的有效值类型。
该声明的有效值类型为：

* 如果显式指定了类型，则为声明的类型。
* 否则，如果初始化器表达式的类型为 T：
    * 对于 const 声明，有效值类型为 T 本身。
    * 对于 override、let 或 var 声明，有效值类型为 T 的具体化。

如果存在的话，每种值或变量声明方式可以对初始化器表达式的形式和有效值类型施加额外的约束。

<table class='data'>
<caption>
  Variable and Value Declaration Feature Summary.
</caption>
<thead>
  <tr><th>Declaration
      <th>Mutability
      <th>Scope
      <th>[=Effective-value-type=]<sup>1</sup>
      <th>Initializer Support
      <th>Initializer Expression<sup>2</sup>
      <th>Part of Resource Interface
</thead>
<tr><td>[=const-declaration|const=]
    <td>Immutable
    <td>[=module scope|Module=] or [=function scope|function=]
    <td>[=Constructible=] ([=type/concrete|Concrete=] or [=type/abstract|abstract=])
    <td>Required
    <td>[=const-expression=]
    <td>No

<tr><td>[=override-declaration|override=]
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=scalar=]
    <td>Optional<sup>3</sup>
    <td>[=const-expression=] or [=override-expression=]
    <td>No<sup>4</sup>

<tr><td>[=let-declaration|let=]
    <td>Immutable
    <td>[=function scope|Function=]
    <td>[=type/concrete|Concrete=] [=constructible=] or [=pointer type=]
    <td>Required
    <td>[=const-expression=], [=override-expression=], or [=runtime expression=]
    <td>No

<tr><td class="nowrap">
        [=variable|var=]&lt;[=address spaces/storage=], read&gt;<br>
        [=variable|var=]&lt;[=address spaces/storage=]&gt;
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=host-shareable=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=storage buffer=]

<tr><td class="nowrap">
        [=variable|var=]&lt;[=address spaces/storage=], read_write&gt;<sup>5,6</sup>
    <td>Mutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=host-shareable=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=storage buffer=]

<tr><td>[=variable|var=]&lt;[=address spaces/uniform=]&gt;
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=constructible=] [=host-shareable=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=uniform buffer=]

<tr><td>[=variable|var=]<sup>6</sup>
    <td>Immutable<sup>7</sup>
    <td>[=module scope|Module=]
    <td>[=texture type|Texture=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=texture resource=]

<tr><td>[=variable|var=]
    <td>Immutable
    <td>[=module scope|Module=]
    <td>[=sampler type|Sampler=]
    <td>Disallowed
    <td>
    <td>Yes.<br>[=sampler resource=]

<tr><td>[=variable|var=]&lt;[=address spaces/workgroup=]&gt;<sup>6,8</sup>
    <td>Mutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=plain type=] with a [=fixed footprint=]<sup>9</sup>
    <td>Disallowed<sup>10</sup>
    <td>
    <td>No

<tr><td>[=variable|var=]&lt;[=address spaces/private=]&gt;
    <td>Mutable
    <td>[=module scope|Module=]
    <td>[=type/concrete|Concrete=] [=constructible=]
    <td>Optional<sup>10</sup>
    <td>[=const-expression=] or [=override-expression=]
    <td>No

<tr><td>[=variable|var=]&lt;[=address spaces/function=]&gt;<br>
        [=variable|var=]
    <td>Mutable
    <td>[=function scope|Function=]
    <td>[=type/concrete|Concrete=] [=constructible=]
    <td>Optional<sup>10</sup>
    <td>[=const-expression=], [=override-expression=], or [=runtime expression=]
    <td>No

</table>
1. 只有 [=const-declarations=] 可以是 [=type/abstract=] 类型，而且只有在类型没有明确指定的情况下。
1. 表达式的类型必须能够 [=可行自动转换|可行转换=] 为 [=effective-value-type=]。
1. 如果没有指定初始化器，则必须在 [=pipeline creation|pipeline-creation time=] 提供一个值。
1. [=Override-declarations=] 是着色器接口的一部分，但不是绑定的资源。
1. 具有与 [=access/read=] 不同的访问模式的 [=storage buffers=] 和 [=type/storage textures=] 不能在 [=vertex shader stage=] 中被 [=静态访问=]。
1. 参见 WebGPU {{GPUDevice/createBindGroupLayout()}}。
1. [=Atomic types=] 只能出现在可变的存储缓冲区或工作组变量中。
1. 具有 [=access/write=] 或 [=access/read_write=] [=access mode=] 的 [[#texture-storage|storage textures]] 中的数据是可变的，但只能通过 [[#texturestore|textureStore]] 内置函数来修改。
1. 变量本身不能被修改。
1. [=address spaces/workgroup=] 地址空间中的变量只能在 [=compute shader stage=] 中被 [=静态访问=]。
1. 最外层的 [=array=] 的 [=element count=] 可以是一个 [=override-expression=]。
1. 如果没有初始化器，则变量被 [=default initial value|default initialized=]。

## 变量与值 ## {#var-vs-value}

【变量声明】是WGSL模块中唯一可变的数据。【值声明】始终是不可变的。
变量可以作为【引用类型】和【指针类型】值的基础，因为变量有关联的【内存位置】，而值声明不能作为指针或引用值的基础。


使用变量通常比使用值声明更昂贵，因为使用变量需要额外的操作来读取或写入与变量关联的【内存位置】。


一般来说，作者应该优先使用以下声明方式，按照首选选项列出：
* 【const声明】
* 【override声明】
* 【let声明】
* 【变量声明】

这通常会导致着色器的整体性能最佳。

## 值声明 ## {#value-decls}

当[=标识符=]解析为[=值声明=]时，该标识符表示该值。


WGSL提供多种类型的值声明。
每种声明的值在[[#shader-lifecycle|着色器生命周期]]的不同点固定。
不同种类的值声明以及其值的固定时间是：
* [=常量声明=]，在[=着色器模块创建|创建着色器时=]
* [=覆盖声明=]，在[=管线创建|创建管线时=]
* [=局部声明=]，当它们被执行时
* [=形式参数=]声明，在关联的[=函数调用=]参数被执行时

注意：[=形式参数=]的描述在[[#functions]]中。

### `const` Declarations ### {#const-decls}

A <dfn noexport>const-declaration</dfn> specifies a name for a data value that
is fixed at [=shader module creation|shader-creation time=].
Each const-declaration requires an initializer.
A const-declaration can be declared in [=module scope|module=] or [=function
scope|function=] scope.
The initializer expression [=shader-creation error|must=] be a
[=const-expression=].
The type of a const-declaration must be a [=type/concrete=] or
[=type/abstract=] [=constructible=] type.
const-declarations are the only declarations where the [=effective-value-type=]
may be [=type/abstract=].

Note: Since [=abstract numeric types=] cannot be spelled in WGSL, they can only
be used via type inference.

<div class='example wgsl global-scope' heading='const-declarations at module scope'>
  <xmp>
    const a = 4;                  // AbstractInt with a value of 4.
    const b : i32 = 4;            // i32 with a value of 4.
    const c : u32 = 4;            // u32 with a value of 4.
    const d : f32 = 4;            // f32 with a value of 4.
    const e = vec3(a, a, a);      // vec3 of AbstractInt with a value of (4, 4, 4).
    const f = 2.0;                // AbstractFloat with a value of 2.
    const g = mat2x2(a, f, a, f); // mat2x2 of AbstractFloat with a value of:
                                  // ((4.0, 2.0), (4.0, 2.0)).
                                  // The AbstractInt a converts to AbstractFloat.
                                  // An AbstractFloat cannot convert to AbstractInt.
    const h = array(a, f, a, f);  // array of AbstractFloat with 4 components:
                                  // (4.0, 2.0, 4.0, 2.0).
  </xmp>
</div>

### `override` Declarations ### {#override-decls}

An <dfn noexport>override-declaration</dfn> specifies a name for a
[=pipeline-overridable=] constant value.
The value of a <dfn noexport>pipeline-overridable</dfn> constant is fixed at
[=pipeline creation|pipeline-creation time=].
The value is one provided by the WebGPU pipeline-creation method, if
specified, and otherwise is the value of its [=concretization of a
value|concretized=] initializer expression.
The [=effective-value-type=] of an override-declaration must be a [=type/concrete=]
[=scalar=] type.

An initializer expression is optional.
If present, it must be an [=override-expression=] and represents the <dfn
noexport>pipeline-overridable constant default value</dfn>.
If no initializer is specified, it is a [=pipeline-creation error=] if a value
is not provided at pipeline-creation time.

If the declaration has an [=attribute/id=] attribute applied, the literal
operand is known as the <dfn noexport>pipeline constant ID</dfn>, and must be a
unique integer between 0 and 65535 inclusive.
That is, two override-declarations must not use the same pipeline constant ID.

The application can specify its own value for an override-declaration at
[=pipeline creation|pipeline-creation time=].
The pipeline creation API accepts a mapping from overridable constants to a
value of the constant’s type.
The constant is identified by a <dfn noexport>pipeline-overridable constant
identifier string</dfn>, which is the base-10 representation of the [=pipeline
constant ID=] if specified, and otherwise the declared [=name=] of the constant.

<div class='example wgsl global-scope' heading='Module constants, pipeline-overrideable'>
  <xmp>
    @id(0)    override has_point_light: bool = true;  // Algorithmic control
    @id(1200) override specular_param: f32 = 2.3;     // Numeric control
    @id(1300) override gain: f32;                     // Must be overridden
              override width: f32 = 0.0;              // Specified at the API level using
                                                      // the name "width".
              override depth: f32;                    // Specified at the API level using
                                                      // the name "depth".
                                                      // Must be overridden.
              override height = 2 * depth;            // The default value
                                                      // (if not set at the API level),
                                                      // depends on another
                                                      // overridable constant.

  </xmp>
</div>


### `let` Declarations ### {#let-decls}

A <dfn noexport>let-declaration</dfn> specifies a name for a value that is
fixed each time the statement is executed at runtime.
A let-declaration must only be declared in [=function scope=], and as such, is
a [=dynamic context=].
A let-declaration must have an initializer expression.
The value is the [=concretization of a value|concretized=] value of the initializer.
The [=effective-value-type=] of a let-declaration must be either a [=type/concrete=]
[=constructible=] type or a [=pointer type=].

<div class='example wgsl let-declaration at function-scope' heading='let-declared constants at function scope'>
  <xmp>
    // 'blockSize' denotes the i32 value 1024.
    let blockSize: i32 = 1024;

    // 'row_size' denotes the u32 value 16u.  The type is inferred.
    let row_size = 16u;
  </xmp>
</div>

## `var` Declarations ## {#var-decls}

A <dfn>variable</dfn> is a named reference to memory that can contain a value
of a particular [=storable=] type.

Two types are associated with a variable: its [=store type=] (the type of value
that may be placed in the referenced memory) and its [=reference type=] (the type
of the variable itself).
If a variable has store type `T`, [=address space=] `AS`, and [=access mode=]
`AM`, then its reference type is `ref<AS,T,AM>`.
The store type of a variable is always [=type/concrete=].

A variable declaration:
* Specifies the variable’s [=name=].
* Determines the variable’s [=address space=], [=store type=], and [=access mode=].
    Together these comprise the variable’s [=reference type=].
    * The store type is the [=effective-value-type=] of the variable’s declaration.
* Ensures the execution environment allocates memory for a value of the store
    type, in the specified address space, supporting the given access mode, for
    the [=lifetime=] of the variable.
* Optionally has an initializer expression if the variable is in the [=address
    spaces/private=] or [=address spaces/function=] address spaces.
    If present, the initializer must evaluate to the variable’s store type.
    If present, the initializer for a [=address spaces/private=] variable must
    be a [=const-expression=] or an [=override-expression=].
    Variables in address spaces other than [=address spaces/function=] or
    [=address spaces/private=] [=shader-creation error|must not=] have an
    initializer.

When an [=identifier=] [=resolves=] to a variable declaration, the identifier
is an expression denoting the reference [=memory view=] for the variable’s memory,
and its type is the variable’s [=reference type=].
See [[#var-identifier-expr]].

If the [=address space=] or [=access mode=] for a variable declaration are specified
in program source, they are written as a [=template list=] after the `var` keyword:
* The [=address space=] is specified first, as one of the [=predeclared=] address space [=enumerants=].
* The [=access mode=] is specified second, if present, as one of the [=predeclared=] address mode [=enumerants=].
    * The address space must be specified if the access mode is specified.

Variables in the [=address spaces/private=], [=address spaces/storage=],
[=address spaces/uniform=], [=address spaces/workgroup=], and [=address
spaces/handle=] address spaces must only be declared in [=module scope=], while
variables in the [=address spaces/function=] address space must only be
declared in [=function scope=].
The address space [=shader-creation error|must=] be specified for all address
spaces except handle and function.
The handle address space [=shader-creation error|must not=] be specified.
Specifying the function address space is optional.

The [=access mode=] always has a default value, and except for variables in the
[=address spaces/storage=] address space, [=shader-creation error|must not=] be
specified in the WGSL source.
See [[#address-space]].

A variable in the [=address spaces/uniform=] address space is a <dfn
noexport>uniform buffer</dfn> variable.
Its [=store type=] must be a [=host-shareable=] [=constructible=] type, and
must satisfy the [[#address-space-layout-constraints|address space layout
constraints]].

A variable in the [=address spaces/storage=] address space is a <dfn
noexport>storage buffer</dfn> variable.
Its [=store type=] must be a [=host-shareable=] type and must satisfy the
[[#address-space-layout-constraints|address space layout constraints]].
The variable may be declared with a [=access/read=] or [=access/read_write=]
access mode; the default is read.

A <dfn>texture resource</dfn> is a variable whose [=effective-value-type=] is a [=texture type=].
It is declared at [=module scope=].
It holds an opaque handle which is used to access the underlying grid of [=texels=] in a [=texture=].
The handle itself is in the [=address spaces/handle=] address space and is always read-only.
In many cases the underlying texels are read-only, and we say the texture variable immutable.
For [=type/write-only storage textures=] and [=type/read-write storage textures=], the underlying texels are mutable, and by convention
we say the texture variable is mutable.

A <dfn>sampler resource</dfn> is a variable whose [=effective-value-type=] is a [=sampler type=].
It is declared at [=module scope=], exists in the [=address spaces/handle=] address space,
and is immutable.

As described in [[#resource-interface]], uniform buffers, storage buffers,
textures, and samplers form the [=resource interface of a shader=].

The <dfn noexport>lifetime</dfn> of a variable is the period during shader
execution for which the [=memory locations=] are associated with the variable.
The lifetime of a [=module scope=] variable is the entire execution of the
shader stage.
There is an independent version of a variable in the [=address spaces/private=]
and [=address spaces/function=] address spaces for each invocation.
[=function scope|Function-scope=] variables are a [=dynamic context=].
The lifetime of a function-scope variable is determined by its scope:
* It starts when control enters the variable’s declaration.
* It ends when the name is no longer [=in scope=] of any part of the [=dynamic context=].
    That is, the lifetime includes any functions [=function call|called=] while
    the name is in scope.

Two [=resource=] variables may have [=overlap|overlapping memory=] locations,
but it is a [=dynamic error=] if either of those variables is mutable.
Other variables with overlapping lifetimes [=behavioral requirement|will=] not
have overlapping memory locations.
When a variable’s lifetime ends, its memory may be used for another variable.

Note: WGSL ensures the contents of a variable are only observable during the
variable’s lifetime.

When a variable in the [=address spaces/private=], [=address spaces/function=],
or [=address spaces/workgroup=] address spaces is created, it [=behavioral
requirement|will=] have an initial value.
If no initializer is specified the initial value is the <dfn noexport>default
initial value</dfn>.
The initial values are computed as follows:
* For variables in the function address space:
    * The [=zero value=] of the [=store type=], if the variable declaration did
        not specify an initializer.
    * Otherwise it is the result of evaluating the
        [=concretization of a value|concretized=] initializer expression at
        that point in program execution.
* For variables in the private address space:
    * The [=zero value=] of the [=store type=], if the variable declaration did
        not specify an initializer.
    * Otherwise it is the result of evaluating the [=concretization of a
        value|concretized=] initializer expression.
        The initializer must be an [=override-expression=], and so its value is
        fixed no later than [=pipeline creation|pipeline-creation time=].
* For variables in the workgroup address space:
    * When the [=store type=] is [=constructible=], the [=zero value=] for the
        store type.
    * If the [=store type=] is an [=atomic type=], the [=zero value=] is that
        of the underlying type ([=type/concrete=] [=integer scalar=]).
    * Otherwise, if the [=store type=] is not [=constructible=], the [=zero
        value=] is determined by recursively applying these rules to each
        [=component=] of the [=composite=] until a [=constructible=] type is
        encountered.
        * Note: This commonly occurs when using an [=array=] with a
            [=pipeline-overridable=] [=element count=] or a [=composite=] that
            contains an [=atomic type=].

Variables in other address spaces are [=resources=] set by bindings in the
[=draw command=] or [=dispatch command=].

Consider the following snippet of WGSL:
<div class='example wgsl function-scope' heading='Variable initial values'>
  <xmp>
    var i: i32;         // Initial value is 0.  Not recommended style.
    loop {
      var twice: i32 = 2 * i;   // Re-evaluated each iteration.
      i++;
      if i == 5 { break; }
    }
  </xmp>
</div>
The loop body will execute six times.
Variable `i` will take on values 0, 1, 2, 3, 4, 5, and variable `twice` will take on values 0, 2, 4, 6, and 8.

Consider the following snippet of WGSL:
<div class='example wgsl function-scope' heading='Reading a variable multiple times'>
  <xmp>
    var x: f32 = 1.0;
    let y = x * x + x + 1;
  </xmp>
</div>
Because `x` is a variable, all accesses to it turn into load and store operations.
However, it is expected that either the browser or the driver optimizes this intermediate representation
such that the redundant loads are eliminated.

<div class='example wgsl global-scope' heading="Module scope variable declarations">
  <xmp>
    var<private> decibels: f32;
    var<workgroup> worklist: array<i32,10>;

    struct Params {
      specular: f32,
      count: i32
    }

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    @group(0) @binding(2)
    var<uniform> param: Params;    // A uniform buffer

    // A storage buffer, for reading and writing
    @group(0) @binding(0)
    var<storage,read_write> pbuf: array<vec2<f32>>;

    // Textures and samplers are always in "handle" space.
    @group(0) @binding(1)
    var filter_params: sampler;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Access modes for buffers'>
  <xmp>
    // Storage buffers
    @group(0) @binding(0)
    var<storage,read> buf1: Buffer;       // Can read, cannot write.
    @group(0) @binding(0)
    var<storage> buf2: Buffer;            // Can read, cannot write.
    @group(0) @binding(1)
    var<storage,read_write> buf3: Buffer; // Can both read and write.

    struct ParamsTable {weight: f32}

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    @group(0) @binding(2)
    var<uniform> params: ParamsTable;     // Can read, cannot write.
  </xmp>
</div>

<div class='example wgsl global-scope' heading="Function scope variables and constants">
  <xmp>
    fn f() {
       var<function> count: u32;  // A variable in function address space.
       var delta: i32;            // Another variable in the function address space.
       var sum: f32 = 0.0;        // A function address space variable with initializer.
       var pi = 3.14159;          // Infer the f32 store type from the initializer.
    }
  </xmp>
</div>

## Variable and Value Declaration Grammar Summary ## {#var-and-value-decl-grammar}

<pre class=include>
path: syntax/variable_or_value_statement.syntax.bs.include
</pre>
<pre class=include>
path: syntax/variable_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/optionally_typed_ident.syntax.bs.include
</pre>
<pre class=include>
path: syntax/global_variable_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/global_value_decl.syntax.bs.include
</pre>

# Expressions # {#expressions}

[=Expressions=] specify how values are computed.

The different kinds of value expressions provide a tradeoff between when they
are evaluated and how expressive they can be.
The sooner the evaluation, the more constrained the operations, but also the
more places the value can be used.  This tradeoff leads to different
flexibility with each kind of value declaration.
[=const-expressions=] and [=override-expressions=] are evaluated prior to
execution on the GPU, so only the result of the computation of the expression
is necessary in the final GPU code.
Additionally, because [=const-expressions=] are evaluated at [=shader module
creation|shader-creation time=] they can be used in more situations than
[=override-expressions=], for example, to size [=arrays=] in [=function scope=]
[=variable declaration|variables=].
A <dfn noexport>runtime expression</dfn> is an expression that is neither a
[=const-expression=] nor an [=override-expression=].
A runtime expression is computed on the GPU during shader execution.
While runtime expressions can be used by fewer grammar elements, they can be
computed from a larger class of expressions, for example, other runtime values.

## Early Evaluation Expressions ## {#early-eval-exprs}

WGSL defines two types of expressions that can be evaluated before runtime:
* [=const-expressions=], at [=shader module creation|shader-creation time=]
* [=override-expressions=], at [=pipeline creation|pipeline-creation time=]

### `const` Expressions ### {#const-expr}

Expressions that can be evaluated at [=shader module creation|shader-creation
time=] are called <dfn noexport>const-expressions</dfn>.
An expression is a const-expression if all its [=identifiers=] [=resolve=] to:
* [=const-declarations=], or
* [=const-functions=], or
* [=type aliases=], or
* [=structure=] names.

The type of a `const` expression [=shader-creation error|must=] [=type rules|resolve=] to a type with a
[=creation-fixed footprint=].

Note: [=type/abstract|Abstract types=] can be the inferred type of a const-expression.

A const-expression |E| [=behavioral requirement|will=] be evaluated if and only if:
* |E| is [=top-level expression=], or
* |E| is a [=subexpression=] of an expression |OuterE|, and |OuterE|
    [=behavioral requirement|will=] be evaluated, and evaluation of |OuterE|
    requires |E| to be evaluated.

Note: The evaluation rule implies that short-circuiting operators `&&` and `||` guard evaluation of their right-hand
side subexpressions.

A const-expression may be evaluated by the CPU implementing the WebGPU API methods.
Therefore accuracy requirements for operations on [=AbstractFloat=] values are *no more strict* than
required for common WebGPU runtime environments, such as WebAssembly [[WASM-CORE-2]] and ECMAScript [[ECMASCRIPT]].
Accuracy requirements for [=type/concrete=] floating point types (such as f32) are specified in [[#concrete-float-accuracy]].

Example:  `(42)` is analyzed as follows:
* The term `42` is the [=AbstractInt=] value 42.
* Surrounding that term with parentheses produces a new expression `(42)` that is
    of type [=AbstractInt=] with value 42.

Example:  `-5` is analyzed as follows:
* The term `5` is the [=AbstractInt=] value 5.
* Preceding that term with '`-`' produces a new expression `-5` that is
    of type [=AbstractInt=] with value -5.

Example:  `-2147483648` is analyzed as follows:
* The term `2147483648` is the [=AbstractInt=] value 2147483648.
    Note that this value does **not** fit in a 32-bit signed integer.
* Preceding that term with '`-`' produces a new expression `-2147483648` that is
    of type [=AbstractInt=] with value -2147483648.

Example:  `const minint = -2147483648;` is analyzed as follows:
* As above, `-2147483648` evaluates to a [=AbstractInt=] value -2147483648.
* A [=const-declaration=] allows the initializer to be an [=abstract numeric type=].
* The result is that `minint` is declared to be the [=AbstractInt=] value -2147483648.

Example:  `let minint = -2147483648;` is analyzed as follows:
* As above, `-2147483648` evaluates to a [=AbstractInt=] value -2147483648.
* A [=let-declaration=] requires the initializer to be a [=type/concrete=] [=constructible=] type or a pointer type.
* The let-declaration does not have an explicit type, so [=overload resolution=] is used.
    The overload candidates that apply use [=feasible automatic conversions=] from [=AbstractInt=] to either [=i32=], [=u32=], or [=f32=].
    The one of lowest rank is to [=i32=], and so
    [=AbstractInt=] -2147483648 value is converted to the [=i32=] value -2147483648.
* The result is that `minint` is declared to be the i32 value -2147483648.

Example:  `false && (10i < i32(5 * 1000 * 1000 * 1000))` is analyzed as follows:
* The entire expression is a const-expression.
* However, the short-circuiting rules of the `&&` operator apply:
    the left-hand side evaluates to `false`, and so the right-hand side is *not evaluated*.
* Evaluation of i32(5 * 1000 * 1000 * 1000) would have caused a [=shader-creation error=]
    because the [=AbstractInt=] value 5000000000 overflows the [=i32=] type.

### `override` Expressions ### {#override-expr}

Expressions that can be evaluated at [=pipeline creation=] time are called <dfn
noexport>override-expressions</dfn>.
An expression is an override-expression if all its [=identifiers=] [=resolve=] to:
* [=override-declarations=], or
* [=const-declarations=], or
* [=const-functions=], or
* [=type aliases=], or
* [=structure=] names.

Note: All [=const-expressions=] are also override-expressions.

An override-expression |E| [=behavioral requirement|will=] be evaluated if and only if:
* |E| is [=top-level expression=], or
* |E| is a [=subexpression=] of an expression |OuterE|, and |OuterE|
    [=behavioral requirement|will=] be evaluated, and evaluation of |OuterE|
    requires |E| to be evaluated.

Note: Not all override-expressions may be usable as the initializer for an
[=override-declaration=], because such initializers must [=type rules|resolve=]
to a [=type/concrete=] [=scalar=] type.

Example: `override x = 42;` is analyzed as follows:
* The term `42` is the [=AbstractInt=] value 42.
* An [=override-declaration=] requires a [=type/concrete=] [=scalar=] type.
* `42` is converted to [=i32=] via a [=feasible automatic conversion=].

Example: `let y = x + 1;` is analyzed as follows:
* From above, `x` has a type of [=i32=].
* The expression `x + 1` is an override-expression because it is composed of an
    [=override-declaration=] and an [=integer literal=].
* The expression has a type of [=i32=] and is evaluated at [=pipeline
    creation=] time.
    Its value depends on whether or not `x` is overridden at pipeline creation
    time.

Example: `vec3(x,x,x)` is analyzed as follows:
* From above, `x` is an [=override-declaration=] with the type [=i32=].
* `vec3(x,x,x)` is an override-expression because the only identifiers
    [=resolve=] to override-declarations.
* The type of the expression is a [=vector=] of 3 components
    of [=i32=] (`vec3<i32>`).

## Indeterminate values ## {#indeterminate-values}

In limited cases, an evaluation of a [=runtime expression=] can occur
using unsupported values for its [=subexpressions=].

In such a case, the result of that evaluation is
an <dfn>indeterminate value</dfn> of the expression's [=static type=],
meaning some arbitrary implementation-chosen value of the static type.

A distinct value may be produced for each unique [=dynamic context=] in which the expression is evaluated.
For example, if the evaluation occurs once per iteration of a loop, a distinct
value may be computed for each loop iteration.

Note: If the type is a floating point type and the implementation supports NaN values, then
the indeterminate value produced at runtime may be a NaN value.

<div class='example wgsl global-scope' heading="Indeterminate value example">
  <xmp>
    fn fun() {
       var extracted_values: array<i32,2>;
       const v = vec2<i32>(0,1);

       for (var i: i32 = 0; i < 2 ; i++) {
          // A runtime-expression used to index a vector, but outside the
          // indexing bounds of the vector, produces an indeterminate value
          // of the vector component type.
          let extract = v[i+5];

          // Now 'extract' is any value of type i32.

          // Save it for later.
          extracted_values[i] = extract;

          if extract == extract {
             // This is always executed
          }
          if extract < 2 {
             // This might be executed, but might not be executed.
             // Even though the original vector components are 0 and 1,
             // the extracted value might not be either of those values.
          }
       }
       if extracted_values[0] == extracted_values[1] {
          // This might be executed, but might not be executed.
       }
    }

    fn float_fun(runtime_index: u32) {
       const v = vec2<f32>(0,1); // A vector of floating point values

       // As in the previous example, 'float_extract' is an indeterminate value.
       // Since it is a floating point type, it may be a NaN.
       let float_extract: f32 = v[runtime_index+5];

       if float_extract == float_extract {
          // This *might not* be executed, because:
          //  -  'float_extract' may be NaN, and
          //  -  a NaN is never equal to any other floating point number,
          //     even another NaN.
       }
    }
  </xmp>
</div>


## Literal Value Expressions ## {#literal-expressions}

<table class='data'>
  <caption>Scalar literal type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr><td>
      <td>`true`: bool
      <td>`true` boolean value.
  <tr><td>
      <td>`false`: bool
      <td>`false` boolean value.
  <tr><td>|e| is an [=integer literal=] with no suffix
      <td>|e|: AbstractInt
      <td>Abstract integer literal value.
  <tr><td>|e| is a [=floating point literal=] with no suffix
      <td>|e|: AbstractFloat
      <td>Abstract float literal value.
  <tr><td>|e| is an [=integer literal=] with `i` suffix
      <td>|e|: i32
      <td>32-bit signed integer literal value.
  <tr><td>|e| is an [=integer literal=] with `u` suffix
      <td>|e|: u32
      <td>32-bit unsigned integer literal value.
  <tr><td>|e| is an [=floating point literal=] with `f` suffix
      <td>|e|: f32
      <td>32-bit floating point literal value.
  <tr><td>|e| is an [=floating point literal=] with `h` suffix
      <td>|e|: f16
      <td>16-bit floating point literal value.
</table>

## Parenthesized Expressions ## {#parenthesized-expressions}

<table class='data'>
  <caption>Parenthesized expression type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="parenthesized expression">
      <td>|e| : |T|
      <td>`(` |e| `)` : |T|
      <td>Evaluates to |e|.<br>
          Use parentheses to isolate an expression from the surrounding text.
</table>

## Composite Value Decomposition Expressions ## {#composite-value-decomposition-expr}

This section describes expressions for getting a [=component=] of a [=composite=] value,
and for getting a [=reference type|reference=] to a [=component=] from a reference to the containing composite value.
For this discussion, the composite value, or the reference to composite value,
is known as the <dfn dfn-for=decomposition noexport>base</dfn>.

There are two ways of doing so:
: <dfn noexport>named component expression</dfn>
:: The expression for the [=decomposition/base=] *B* is followed by a period `'.'` (U+002D), and then the name of the component.
    * This is supported when *B* is of [=vector=] or [=structure=] type, or a reference to a vector or structure type.
    * The valid names depend on *B*'s type.
: <dfn noexport>indexing expression</dfn>
:: The expression for the base is followed by `'['` (U+005B), then the expression for an index then `']'` (U+005D).
    * The base may be a [=vector=], [=matrix=], or [=fixed-size array=] type, or
        or a reference to a vector, matrix, fixed-size array, or [=runtime-sized=] array type.
    * The index expression [=shader-creation error|must=] be of [=integer scalar=] type.

Syntactically, these two forms are embodied by uses of the [=syntax/component_or_swizzle_specifier=] grammar rule.

<div algorithm="out of bounds index">
The index value |i| of an [=indexing expression=] is an <dfn noexport>in-bounds index</dfn> if 0 &le; |i| &lt; |N|, where |N| is the number of components (elements) of the composite type:
    * |N| is the number of components of the [=vector=] type, when the base is a vector or a [=reference type|reference=] to a vector.
    * |N| is the number of columns of the [=matrix=] type, when the base is a matrix or a reference to a matrix.
    * |N| is the [=element count=] of the [=fixed-size array=] type, when the base is a fixed-size array or a reference to a fixed-size array.
    * |N| is [=NRuntime=] for the base, when the base is a reference to a [=runtime-sized=] array.

The index value is an <dfn noexport>out-of-bounds index</dfn> when it is not an [=in-bounds index=].
An out-of-bounds index is often a programming defect, and will often cause a [[#errors|error]].
See below for details.
</div>

Additionally, vector types support a [=swizzle|swizzling=] syntax for creating a new vector value from the components of another vector.

### Vector Access Expression ### {#vector-access-expr}

Accessing components of a vector can be done either:
* Using array subscripting (e.g. `v[2]`), or
* Using a <dfn noexport>swizzle</dfn> name, a [=context-dependent name=] written as a sequence of convenience names, each mapping to a component of the source vector.
    * The color set of convenience names: `r`, `g`, `b`, `a` for vector components 0, 1, 2, and 3 respectively.
    * The dimensional set of convenience names: `x`, `y`, `z`, `w` for vector components 0, 1, 2, and 3, respectively.

The convenience names are accessed using the `.` notation. (e.g. `color.bgra`).

The convenience letterings [=shader-creation error|must not=] be mixed. For example, you cannot use `.rybw`.

A convenience letter [=shader-creation error|must not=] access a component past the end of the vector.

The convenience letterings can be applied in any order, including duplicating letters as needed.
The provided number of letters [=shader-creation error|must=] be between 1 and 4.
That is, using convenience letters can only produce a valid vector type.

The result type depends on the number of letters provided. Assuming a `vec4<f32>`
<table>
  <thead>
    <tr><th>Accessor<th>Result type
  </thead>
  <tr><td>r<td>`f32`
  <tr><td>rg<td>`vec2<f32>`
  <tr><td>rgb<td>`vec3<f32>`
  <tr><td>rgba<td>`vec4<f32>`
</table>

<div class='example wgsl function-scope'>
  <xmp>
    var a: vec3<f32> = vec3<f32>(1., 2., 3.);
    var b: f32 = a.y;          // b = 2.0
    var c: vec2<f32> = a.bb;   // c = (3.0, 3.0)
    var d: vec3<f32> = a.zyx;  // d = (3.0, 2.0, 1.0)
    var e: f32 = a[1];         // e = 2.0
  </xmp>
</div>

#### Vector Single Component Selection #### {#vector-single-component}

<table class='data'>
  <caption>Vector decomposition: single component selection</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.x`: |T|<br>
           |e|`.r`: |T|
       <td>Select the first component of |e|
  <tr algorithm="second vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.y`: |T|<br>
           |e|`.g`: |T|
       <td>Select the second component of |e|
  <tr algorithm="third vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
          |N| is 3 or 4
       <td class="nowrap">
           |e|`.z`: |T|<br>
           |e|`.b`: |T|
       <td>Select the third component of |e|
  <tr algorithm="fourth vector component selection"><td>|e|: vec4&lt;|T|&gt;
       <td class="nowrap">
           |e|`.w`: |T|<br>
           |e|`.a`: |T|
       <td>Select the fourth component of |e|

  <tr algorithm="vector indexed component selection concrete">
       <td>|e|: vec|N|&lt;|T|&gt;<br>
           |i|: [INT]<br>
           |T| is [=type/concrete=]
       <td class="nowrap">
           |e|[|i|]: |T|
       <td>Select the |i|'<sup>th</sup> component of vector<br>
           The first component is at index |i|=0.

           If |i| is outside the range [0,|N|-1]:<br>
           * It is a [=shader-creation error=] if |i| is a [=const-expression=].
           * It is a [=pipeline-creation error=] if |i| is an [=override-expression=].
           * Otherwise an [=indeterminate value=] for |T| may be returned.

  <tr algorithm="vector indexed component selection abstract">
       <td>|e|: vec|N|&lt;|T|&gt;<br>
           |i|: [INT]<br>
           |T| is [=type/abstract=]<br>
           |i| is a [=const-expression=]
       <td class="nowrap">
           |e|[|i|]: |T|
       <td>Select the |i|'<sup>th</sup> component of vector<br>
           The first component is at index |i|=0.

           It is a [=shader-creation error=] if |i| is outside the range [0,|N|-1].

           Note: When an abstract vector value |e| is indexed by an expression that
           is not a [=const-expression=], then the vector is
           [=concretization of a value|concretized=] before the index is applied.
</table>

#### Vector Multiple Component Selection #### {#vector-multi-component}

<table class='data'>
  <caption>Vector decomposition: multiple component selection
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="two component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `x`, `y`, `z`, or `w`<br>
          |J| is the letter `x`, `y`, `z`, or `w`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>Computes the two-component vector with first component |e|.|I|, and second component |e|.|J|.<br>
           Letter `z` is valid only when |N| is 3 or 4.<br>
           Letter `w` is valid only when |N| is 4.
  <tr algorithm="two component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `r`, `g`, `b`, or `a`<br>
          |J| is the letter `r`, `g`, `b`, or `a`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>Computes the two-component vector with first component |e|.|I|, and second component |e|.|J|.<br>
           Letter `b` is valid only when |N| is 3 or 4.<br>
           Letter `a` is valid only when |N| is 4.
  <tr algorithm="three component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `x`, `y`, `z`, or `w`<br>
          |J| is the letter `x`, `y`, `z`, or `w`<br>
          |K| is the letter `x`, `y`, `z`, or `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>Computes the three-component vector with first component |e|.|I|, second component |e|.|J|, and third component |e|.|K|.<br>
           Letter `z` is valid only when |N| is 3 or 4.<br>
           Letter `w` is valid only when |N| is 4.
  <tr algorithm="three component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `r`, `g`, `b`, or `a`<br>
          |J| is the letter `r`, `g`, `b`, or `a`<br>
          |K| is the letter `r`, `g`, `b`, or `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>Computes the three-component vector with first component |e|.|I|, second component |e|.|J|, and third component |e|.|K|.<br>
           Letter `b` is only valid when |N| is 3 or 4.<br>
           Letter `a` is only valid when |N| is 4.
  <tr algorithm="four component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `x`, `y`, `z`, or `w`<br>
          |J| is the letter `x`, `y`, `z`, or `w`<br>
          |K| is the letter `x`, `y`, `z`, or `w`<br>
          |L| is the letter `x`, `y`, `z`, or `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>Computes the four-component vector with first component |e|.|I|, second component |e|.|J|, third component |e|.|K|, and fourth component |e|.|L|.<br>
           Letter `z` is valid only when |N| is 3 or 4.<br>
           Letter `w` is valid only when |N| is 4.
  <tr algorithm="four component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `r`, `g`, `b`, or `a`<br>
          |J| is the letter `r`, `g`, `b`, or `a`<br>
          |K| is the letter `r`, `g`, `b`, or `a`<br>
          |L| is the letter `r`, `g`, `b`, or `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>Computes the four-component vector with first component |e|.|I|, second component |e|.|J|, third component |e|.|K|, and fourth component |e|.|L|.<br>
           Letter `b` is only valid when |N| is 3 or 4.<br>
           Letter `a` is only valid when |N| is 4.
</table>

#### Component Reference from Vector Reference #### {#component-reference-from-vector-reference}

A [=write access=] to component of a vector **may** access all of the [=memory
location|memory locations=] associated with that vector.

Note: This means accesses to different components of a vector by different
invocations must be synchronized if at least one access is a [=write access=].
See [[#sync-builtin-functions]].

<table class='data'>
  <caption>Getting a reference to a component from a reference to a vector</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component reference selection">
       <td>|r|: ref&lt;|AS|,vec|N|&lt;|T|&gt;,|AM|&gt;<br>
       <td class="nowrap">
           |r|`.x`: ref&lt;|AS|,|T|,|AM|&gt;<br>
           |r|`.r`: ref&lt;|AS|,|T|,|AM|&gt;<br>
       <td>Compute a reference to the first component of the vector referenced by the reference |r|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="second vector component reference selection">
       <td>|r|: ref&lt;|AS|,vec|N|&lt;|T|&gt;,|AM|&gt;<br>
       <td class="nowrap">
           |r|`.y`: ref&lt;|AS|,|T|,|AM|&gt;<br>
           |r|`.g`: ref&lt;|AS|,|T|,|AM|&gt;<br>
       <td>Compute a reference to the second component of the vector referenced by the reference |r|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="third vector component reference selection">
       <td>|r|: ref&lt;|AS|,vec|N|&lt;|T|&gt;,|AM|&gt;<br>
           |N| is 3 or 4
       <td class="nowrap">
           |r|`.z`: ref&lt;|AS|,|T|,|AM|&gt;<br>
           |r|`.b`: ref&lt;|AS|,|T|,|AM|&gt;<br>
       <td>Compute a reference to the third component of the vector referenced by the reference |r|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="fourth vector component reference selection">
       <td>|r|: ref&lt;|AS|,vec4&lt;|T|&gt;,|AM|&gt;<br>
       <td class="nowrap">
           |r|`.w`: ref&lt;|AS|,|T|,|AM|&gt;<br>
           |r|`.a`: ref&lt;|AS|,|T|,|AM|&gt;<br>
       <td>Compute a reference to the fourth component of the vector referenced by the reference |r|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="vector indexed component reference selection">
       <td>|r|: ref&lt;|AS|,vec|N|&lt;|T|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,|T|,|AM|&gt;
       <td>Compute a reference to the |i|'<sup>th</sup> component of the vector
           referenced by the reference |r|.

           If |i| is outside the range [0,|N|-1]:<br>
           * It is a [=shader-creation error=] if |i| is a [=const-expression=].
           * It is a [=pipeline-creation error=] if |i| is an [=override-expression=].
           * Otherwise, the expression evaluates to an [=invalid memory reference=].

           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
</table>

### Matrix Access Expression ### {#matrix-access-expr}

<table class='data'>
  <caption>Column vector extraction</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector selection concrete">
       <td class="nowrap">
          |e|: mat|C|x|R|&lt;|T|&gt;<br>
          |i|: [INT]<br>
          |T| is [=type/concrete=]
       <td class="nowrap">
           |e|[|i|]: vec|R|&lt;|T|&gt;
       <td>The result is the |i|'<sup>th</sup> column vector of |e|.

           If |i| is outside the range [0,|C|-1]:<br>
           * It is a [=shader-creation error=] if |i| is a [=const-expression=].
           * It is a [=pipeline-creation error=] if |i| is an [=override-expression=].
           * Otherwise, an [=indeterminate value=] for vec|R|&lt;|T|&gt; may be returned.

  <tr algorithm="matrix indexed column vector selection abstract">
       <td class="nowrap">
          |e|: mat|C|x|R|&lt;|T|&gt;<br>
          |i|: [INT]<br>
          |T| is [=type/abstract=]<br>
          |i| is a [=const-expression=]
       <td class="nowrap">
           |e|[|i|]: vec|R|&lt;|T|&gt;
       <td>The result is the |i|'<sup>th</sup> column vector of |e|.

           It is a [=shader-creation error=] if |i| is outside the range [0,|C|-1].

           Note: When an abstract matrix value |e| is indexed by an expression that
           is not a [=const-expression=], then the matrix is
           [=concretization of a value|concretized=] before the index is applied.
</table>

<table class='data'>
  <caption>Getting a reference to a column vector from a reference to a matrix</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector reference selection">
       <td class="nowrap">
          |r|: ref&lt;|AS|,mat|C|x|R|&lt;|T|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,vec|R|&lt;|T|&gt;,|AM|&gt;
       <td>Compute a reference to the |i|'<sup>th</sup> column vector of the
           matrix referenced by the reference |r|.

           If |i| is outside the range [0,|C|-1]:<br>
           * It is a [=shader-creation error=] if |i| is a [=const-expression=].
           * It is a [=pipeline-creation error=] if |i| is an [=override-expression=].
           * Otherwise, the expression evaluates to an [=invalid memory reference=].

           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
</table>

### Array Access Expression ### {#array-access-expr}

<table class='data'>
  <caption>Array element extraction</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed element selection concrete">
       <td class="nowrap">
          |e|: array&lt;|T|,|N|&gt;<br>
          |i|: [INT]<br>
          |T| is [=type/concrete=]
       <td class="nowrap">
           |e|[|i|] : |T|
       <td>The result is the value of the |i|'<sup>th</sup> element of the array value |e|.

           If |i| is outside the range [0,|N|-1]:<br>
           * It is a [=shader-creation error=] if |i| is a [=const-expression=].
           * It is a [=pipeline-creation error=] if |i| is an [=override-expression=].
           * Otherwise, an [=indeterminate value=] for |T| may be returned.
  <tr algorithm="fixed-size array indexed element selection abstract">
       <td class="nowrap">
          |e|: array&lt;|T|,|N|&gt;<br>
          |i|: [INT]<br>
          |T| is [=type/abstract=]<br>
          |i| is a [=const-expression=]
       <td class="nowrap">
           |e|[|i|] : |T|
       <td>The result is the value of the |i|'<sup>th</sup> element of the array value |e|.

           It is a [=shader-creation error=] if |i| is outside the range [0,|N|-1].

           Note: When an abstract array value |e| is indexed by an expression that
           is not a [=const-expression=], then the array is
           [=concretization of a value|concretized=] before the index is applied.
</table>

<table class='data'>
  <caption>Getting a reference to an array element from a reference to an array</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed reference selection">
       <td class="nowrap">
          |r|: ref&lt;|AS|,array&lt;|T|,|N|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,|T|,|AM|&gt;
       <td>Compute a reference to the |i|'<sup>th</sup> element of the array
           referenced by the reference |r|.

           If |i| is outside the range [0,|N|-1]:<br>
           * It is a [=shader-creation error=] if |i| is a [=const-expression=].
           * It is a [=pipeline-creation error=] if |i| is an [=override-expression=].
           * Otherwise, the expression evaluates to an [=invalid memory reference=].

           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="array indexed reference selection">
       <td>|r|: ref&lt;|AS|,array&lt;|T|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,|T|,|AM|&gt;
       <td>Compute a reference to the |i|'<sup>th</sup> element of the
           runtime-sized array referenced by the reference |r|.

           If at runtime the array has |N| elements, and |i| is outside the range
           [0,|N|-1], then the expression evaluates to an [=invalid memory
           reference=].

           If |i| is a signed integer, and |i| is less than 0:<br>
           * It is a [=shader-creation error=] if |i| is a [=const-expression=].
           * It is a [=pipeline-creation error=] if |i| is an [=override-expression=].

           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
</table>


### Structure Access Expression ### {#struct-access-expr}

<table class='data'>
  <caption>Structure member extraction</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member extraction">
       <td class="nowrap">
          |S| is a structure type<br>
          |M| is the identifier name of a member of |S|, having type |T|<br>
          |e|: |S|<br>
       <td class="nowrap">
           |e|.|M|: |T|
       <td>The result is the value of the member with name |M| from the structure value |e|.
</table>

<table class='data'>
  <caption>Getting a reference to a structure member from a reference to a structure</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member reference selection">
       <td class="nowrap">
          |S| is a structure type<br>
          |M| is the identifier name of a member of |S|, having type |T|<br>
          |r|: ref&lt;|AS|,|S|,|AM|&gt;<br>
       <td class="nowrap">
           |r|.|M|: ref&lt;|AS|,|T|,|AM|&gt;
       <td>Given a reference to a structure, the result is a reference to the structure member with identifier name |M|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
</table>

## Logical Expressions ## {#logical-expr}
<table class='data'>
  <caption>Unary logical operations</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="boolean negation"><td>|e|: T<br>|T| is bool or vec|N|&lt;bool&gt;
  <td>`!`|e|: |T|
  <td>Logical negation.
  The result is `true` when |e| is `false` and `false` when |e| is `true`.
  [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <caption>Binary logical expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="short-circuiting or"><td>|e1|: bool<br>|e2|: bool<td>|e1| `||` |e2|`: bool`
  <td>Short-circuiting "or". Yields `true` if either |e1| or |e2| are true;
  evaluates |e2| only if |e1| is false.

  <tr algorithm="short-circuiting and"><td>|e1|: bool<br>|e2|: bool
  <td>|e1| `&&` |e2|`: bool`
  <td>Short-circuiting "and". Yields `true` if both |e1| and |e2| are true;
  evaluates |e2| only if |e1| is true.

  <tr algorithm="logical or"><td>|e1|: |T|<br>|e2|: |T|<br>|T| is bool or vec|N|&lt;bool&gt;
  <td>|e1| `|` |e2|`:` |T|
  <td>Logical "or". [=Component-wise=] when |T| is a vector. Evaluates both |e1| and |e2|.

  <tr algorithm="logical and"><td>|e1|: |T|<br>|e2|: |T|<br>|T| is bool or vec|N|&lt;bool&gt;
  <td>|e1| `&` |e2|`:` |T|
  <td>Logical "and". [=Component-wise=] when |T| is a vector. Evaluates both |e1| and |e2|.
</table>


## Arithmetic Expressions ## {#arithmetic-expr}

<table class='data'>
  <caption>Unary arithmetic expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="negation"><td>|e|: |T|<br>
  |T| is AbstractInt, AbstractFloat, i32, f32, f16, vec|N|&lt;AbstractInt&gt;,
  vec|N|&lt;AbstractFloat&gt;, vec|N|&lt;i32&gt;, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
  <td>`-`|e|`:` |T|
  <td>Negation. [=Component-wise=] when |T| is a vector.
  If |T| is an [=integer scalar=] type and |e| evaluates to the largest negative value, then the result is |e|.
</table>

<table class='data'>
  <caption>Binary arithmetic expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>

  <tr algorithm="addition">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `+` |e2| : |T|
    <td>Addition. [=Component-wise=] when |T| is a vector.
    If |T| is a [=type/concrete=] [=integer scalar=] type, then the result is modulo 2<sup>32</sup>.

  <tr algorithm="subtraction">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `-` |e2| : |T|
    <td>Subtraction [=Component-wise=] when |T| is a vector.
    If |T| is a [=type/concrete=] [=integer scalar=] type, then the result is modulo 2<sup>32</sup>.

  <tr algorithm="multiplication">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `*` |e2| : |T|
    <td>Multiplication. [=Component-wise=] when |T| is a vector.
    If |T| is a [=type/concrete=] [=integer scalar=] type, then the result is modulo 2<sup>32</sup>.

  <tr algorithm="division">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `/` |e2| : |T|
    <td>Division. [=Component-wise=] when |T| is a vector.

        If |T| is a signed [=integer scalar=] type, evaluates to:
        * If |e2| is zero:
            * It is a [=shader-creation error=] if |e2| is a [=const-expression=].
            * It is a [=pipeline-creation error=] if |e2| is an [=override-expression=].
            * Otherwise, |e1|.
        * If |e1| is most negative value in |T|, and |e2| is -1:
            * It is a [=shader-creation error=] if |e1| and |e2| are [=const-expressions=].
            * It is a [=pipeline-creation error=] if |e1| and |e2| are [=override-expressions=].
            * Otherwise, |e1|.
        * [=truncate=](|x|) otherwise, where |x| is the
            real-valued quotient |e1|&nbsp;&div;&nbsp;|e2|.

        Note:
        The need to ensure truncation behavior may require an implementation
        to perform more operations than when computing an unsigned division.
        Use unsigned division when both operands are known to have the same sign.

        <!--
               where MINIT = most negative value in |T|
               where Divisor = select(e2, 1, (e2==0) | ((e1 == MININT) & (e2 == -1)))
               result is truncate(e1/Divisor)
        -->

        If |T| is an unsigned [=integer scalar=] type, evaluates to:
        * If |e2| is zero:
            * It is a [=shader-creation error=] if |e2| is a [=const-expression=].
            * It is a [=pipeline-creation error=] if |e2| is an [=override-expression=].
            * Otherwise, |e1|.
        * Otherwise, the integer |q| such that
            |e1|&nbsp;=&nbsp;|q|&nbsp;&times;&nbsp;|e2|&nbsp;+&nbsp;|r|,
            where 0 &le; |r| &lt; |e2|.

  <tr algorithm="Remainder">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `%` |e2| : |T|
    <td>Remainder. [=Component-wise=] when |T| is a vector.

       If |T| is a signed [=integer scalar=] type, evaluates |e1| and |e2| once, and evaluates to:
       * if |e2| is zero:
          * It is a [=shader-creation error=] if |e2| is a [=const-expression=].
          * It is a [=pipeline-creation error=] if |e2| is an [=override-expression=].
          * Otherwise, 0.
       * If |e1| is the most negative value in |T|, and |e2| is -1:
          * It is a [=shader-creation error=] if |e1| and |e2| are [=const-expressions=].
          * It is a [=pipeline-creation error=] if |e1| and |e2| are [=override-expressions=].
          * Otherwise, 0.
       * Otherwise, |e1|&nbsp;-&nbsp;[=truncate=](|e1|&nbsp;&div;&nbsp;|e2|)&nbsp;&times;&nbsp;|e2|
           where the quotient is computed as a real value.

       Note:
       When non-zero, the result has the same sign as |e1|.

       Note:
       The need to ensure consistent behavior may require an implementation
       to perform more operations than when computing an unsigned remainder.

       <!--
              where MINIT = most negative value in |T|
              where Divisor = select(e2, 1, (e2==0) | ((e1 == MININT) & (e2 == -1)))
              result is e1 - truncate(e1/Divisor) * Divisor
       -->

       If |T| is an unsigned [=integer scalar=] type, evaluates to:
       * if |e2| is zero:
          * It is a [=shader-creation error=] if |e2| is a [=const-expression=].
          * It is a [=pipeline-creation error=] if |e2| is an [=override-expression=].
          * Otherwise, 0.
       * Otherwise, the integer |r| such that
           |e1|&nbsp;=&nbsp;|q|&nbsp;&times;&nbsp;|e2|&nbsp;+&nbsp;|r|,
           where |q| is an integer and 0 &le; |r| &lt; |e2|.

       If |T| is a floating point type, the result is equal to:<br> |e1| - |e2| * trunc(|e1| / |e2|)

</table>

<table class='data'>
  <caption>Binary arithmetic expressions with mixed scalar and vector operands</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
  <tr algorithm="vector-scalar arithmetic, any scalar type">
    <td rowspan="10">|S| is one of AbstractInt, AbstractFloat, f32, f16, i32, u32<br>
        |V| is vec|N|&lt;|S|&gt<br>
        |es|: |S|<br>
        |ev|: |V|
    <td>|ev| `+` |es|: |V|
    <td>|ev| `+` |V|(|es|)
  <tr>
    <td>|es| `+` |ev|: |V|
    <td>|V|(|es|) `+` |ev|
  <tr>
    <td>|ev| `-` |es|: |V|
    <td>|ev| `-` |V|(|es|)
  <tr>
    <td>|es| `-` |ev|: |V|
    <td>|V|(|es|) `-` |ev|
  <tr>
    <td>|ev| `*` |es|: |V|
    <td>|ev| `*` |V|(|es|)
  <tr>
    <td>|es| `*` |ev|: |V|
    <td>|V|(|es|) `*` |ev|
  <tr>
    <td>|ev| `/` |es|: |V|
    <td>|ev| `/` |V|(|es|)
  <tr>
    <td>|es| `/` |ev|: |V|
    <td>|V|(|es|) `/` |ev|
  <tr>
    <td>|ev| `%` |es|: |V|
    <td>|ev| `%` |V|(|es|)
  <tr>
    <td>|es| `%` |ev|: |V|
    <td>|V|(|es|) `%` |ev|
</table>

<table class='data'>
  <caption>Matrix arithmetic</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
  <tr algorithm="matrix addition">
    <td rowspan=2>|e1|, |e2|: mat|C|x|R|&lt;|T|&gt<br>
        |T| is AbstractFloat, f32, or f16
    <td>|e1| `+` |e2|: mat|C|x|R|&lt;|T|&gt<br>
    <td>Matrix addition: column |i| of the result is |e1|[i] + |e2|[i]
  <tr algorithm="matrix subtraction">
    <td>|e1| `-` |e2|: mat|C|x|R|&lt;|T|&gt
    <td>Matrix subtraction: column |i| of the result is |e1|[|i|] - |e2|[|i|]
  <tr algorithm="matrix-scalar multiply">
    <td rowspan=2>|m|: mat|C|x|R|&lt;|T|&gt<br>
        |s|: |T|<br>
        |T| is AbstractFloat, f32, or f16
    <td>|m| `*` |s|:  mat|C|x|R|&lt;|T|&gt<br>
    <td>Component-wise scaling: (|m| `*` |s|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="scalar-matrix multiply">
    <td>|s| `*` |m|:  mat|C|x|R|&lt;|T|&gt<br>
    <td>Component-wise scaling: (|s| `*` |m|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="matrix-column-vector multiply">
    <td>|m|: mat|C|x|R|&lt;|T|&gt<br>
        |v|: vec|C|&lt;|T|&gt<br>
        |T| is AbstractFloat, f32, or f16
    <td>|m| `*` |v|:  vec|R|&lt;|T|&gt<br>
    <td>Linear algebra matrix-column-vector product:
        Component |i| of the result is `dot`(transpose(|m|)[|i|],|v|)
  <tr algorithm="matrix-row-vector multiply">
    <td>
        |m|: mat|C|x|R|&lt;|T|&gt<br>
        |v|: vec|R|&lt;|T|&gt<br>
        |T| is AbstractFloat, f32, or f16
    <td>|v| `*` |m|:  vec|C|&lt;|T|&gt<br>
    <td>Linear algebra row-vector-matrix product:<br>
        [=transpose=](transpose(|m|) `*` transpose(|v|))
  <tr algorithm="matrix-matrix multiply">
    <td>|e1|: mat|K|x|R|&lt;|T|&gt<br>
        |e2|: mat|C|x|K|&lt;|T|&gt<br>
        |T| is AbstractFloat, f32, or f16
    <td>|e1| `*` |e2|:  mat|C|x|R|&lt;|T|&gt<br>
    <td>Linear algebra matrix product.

</table>

## Comparison Expressions ## {#comparison-expr}

<table class='data'>
  <caption>Comparisons</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>

  <tr algorithm="equality">
    <td>|e1|: |T|<br>|e2|: |T|<br>
    |S| is AbstractInt, AbstractFloat, bool, i32, u32, f32, or f16<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TB| is vec|N|&lt;bool&gt; if |T| is a vector,<br>
    otherwise |TB| is bool
    <td class="nowrap">|e1| `==` |e2|`:` |TB|
    <td>Equality. [=Component-wise=] when |T| is a vector.
  <tr algorithm="inequality">
    <td>|e1|: |T|<br>|e2|: |T|<br>
    |S| is AbstractInt, AbstractFloat, bool, i32, u32, f32, or f16<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TB| is vec|N|&lt;bool&gt; if |T| is a vector,<br>
    otherwise |TB| is bool
    <td class="nowrap">|e1| `!=` |e2|`:` |TB|
    <td>Inequality. [=Component-wise=] when |T| is a vector.
  <tr algorithm="less than">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is vec|N|&lt;bool&gt; if |T| is a vector,<br>
    otherwise |TB| is bool
    <td class="nowrap">|e1| `<` |e2|`:` |TB|
    <td>Less than. [=Component-wise=] when |T| is a vector.
  <tr algorithm="less than equal">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is vec|N|&lt;bool&gt; if |T| is a vector,<br>
    otherwise |TB| is bool
    <td class="nowrap">|e1| `<=` |e2|`:` |TB|
    <td>Less than or equal. [=Component-wise=] when |T| is a vector.
  <tr algorithm="greater than">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is vec|N|&lt;bool&gt; if |T| is a vector,<br>
    otherwise |TB| is bool
    <td class="nowrap">|e1| `>` |e2|`:` |TB|
    <td>Greater than. [=Component-wise=] when |T| is a vector.
  <tr algorithm="greater than equal">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is vec|N|&lt;bool&gt; if |T| is a vector,<br>
    otherwise |TB| is bool
    <td class="nowrap">|e1| `>=` |e2|`:` |TB|
    <td>Greater than or equal. [=Component-wise=] when |T| is a vector.

</table>

## Bit Expressions ## {#bit-expr}

<table class='data'>
  <caption>Unary bitwise operations</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="complement">
    <td>|e|: |T|<br>
    [ALLINTEGRALDECL]
    <td class="nowrap">`~`|e| : |T|
    <td>Bitwise complement on |e|.
    Each bit in the result is the opposite of the corresponding bit in |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <caption>Binary bitwise operations</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="bitwise or">
    <td>|e1|: |T|<br>
       |e2|: |T|<br>
       [ALLINTEGRALDECL]
    <td class="nowrap">|e1| `|` |e2|: |T|
    <td>Bitwise-or. [=Component-wise=] when |T| is a vector.
  <tr algorithm="bitwise and">
    <td>|e1|: |T|<br>
       |e2|: |T|<br>
       [ALLINTEGRALDECL]
    <td class="nowrap">|e1| `&` |e2|: |T|
    <td>Bitwise-and. [=Component-wise=] when |T| is a vector.
  <tr algorithm="bitwise exclusive or">
    <td>|e1|: |T|<br>
       |e2|: |T|<br>
       [ALLINTEGRALDECL]
    <td class="nowrap">|e1| `^` |e2|: |T|
    <td>Bitwise-exclusive-or. [=Component-wise=] when |T| is a vector.
</table>


<table class='data'>
  <caption>Bit shift expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>

  <tr algorithm="concrete shift left">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |S| is [INT]<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TS| is u32 when |T| is |S|, otherwise |TS| is vec|N|&lt;u32&gt;
    <td class="nowrap">|e1| `<<` |e2|: |T|
    <td>Shift left (shifted value is concrete):

        Shift |e1| left, inserting zero bits at the least significant positions,
        and discarding the most significant bits.

        The number of bits to shift is the value of |e2|, modulo the bit width of |e1|.<br>
        If |e2| is greater than or equal to the bit width of |e1|, then:
        * It is a [=shader-creation error=] if |e2| is a [=const-expression=].
        * It is a [=pipeline-creation error=] if |e2| is an [=override-expression=].

        When both |e1| and |e2| are known before [=shader execution start=],
        the result must not overflow:
        * If |T| is a signed integer type,
            and the |e2|+1 most significant bits of |e1| do not have the same bit value, then:
            * It is a [=shader-creation error=] if |e1| and |e2| are [=const-expressions=].
            * It is a [=pipeline-creation error=] if |e1| and |e2| are [=override-expressions=].
        * If |T| is an unsigned integer type, and any of the |e2| most significant bits of |e1| are 1, then:
            * It is a [=shader-creation error=] if |e1| and |e2| are [=const-expressions=].
            * It is a [=pipeline-creation error=] if |e1| and |e2| are [=override-expressions=].

        [=Component-wise=] when |T| is a vector.

  <tr algorithm="abstract shift left">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |T| is AbstractInt or vec|N|&lt;AbstractInt&gt;<br>
    |TS| is u32 when |T| is AbstractInt, otherwise |TS| is vec|N|&lt;u32&gt;
    <td class="nowrap">|e1| `<<` |e2|: |T|
    <td>Shift left (shifted value abstract):

        Shift |e1| left, inserting zero bits at the least significant positions,
        and discarding the most significant bits.

        The number of bits to shift is the value of |e2|.

        The |e2|+1 most significant bits of |e1| [=shader-creation error|must=] have the same bit value.
        Otherwise overflow would occur.

        Note: This condition means all the discarded bits must be the same as the sign bit of the original value,
        and the same as the sign bit of the final value.

        [=Component-wise=] when |T| is a vector.

  <tr algorithm="concrete shift right">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |S| is [INT]<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TS| is u32 when |T| is |S|, otherwise |TS| is vec|N|&lt;u32&gt;
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>Shift right (shifted value is concrete).

        Shift |e1| right, discarding the least significant bits.

        If |S| is an unsigned type, insert zero bits at the most significant positions.

        If |S| is a signed type:
        * If |e1| is negative, each inserted bit is 1, and so the result is also negative.
        * Otherwise, each inserted bit is 0.

        The number of bits to shift is the value of |e2|, modulo the bit width of |e1|.

        If |e2| is greater than or equal to the bit width or |e1|, then:
        * It is a [=shader-creation error=] if |e2| is a [=const-expression=].
        * It is a [=pipeline-creation error=] if |e2| is an [=override-expression=].

        [=Component-wise=] when |T| is a vector.

  <tr algorithm="abstract shift right">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |T| is AbstractInt or vec|N|&lt;AbstractInt&gt;<br>
    |TS| is u32 when |T| is AbstractInt, otherwise |TS| is vec|N|&lt;u32&gt;
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>Shift right (abstract).

        Shift |e1| right, discarding the least significant bits.

        If |e1| is negative, each inserted bit is 1, and so the result is also negative.
        Otherwise, each inserted bit is 0.

        The number of bits to shift is the value of |e2|.

        [=Component-wise=] when |T| is a vector.
</table>

## Function Call Expression ## {#function-call-expr}

A function call expression executes a [=function call=] where the called
function has a [=return type=].
If the called function does not return a value, a function call statement
should be used instead.
See [[#function-call-statement]].

## Variable Identifier Expression ## {#var-identifier-expr}

<table class='data'>
  <caption>Getting a reference from a variable name</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="variable reference">
       <td>
          |v| is an [=identifier=] [=resolves|resolving=] to
          an [=in scope|in-scope=] variable declared in [=address space=] |AS|
          with [=store type=] |T| and [=access mode=] |AM|
       <td class="nowrap">
          |v|: ref&lt;|AS|,|T|,|AM|&gt;
       <td>Result is a reference to the memory for the named variable |v|.
</table>

## Formal Parameter Expression  ## {#formal-parameter-expr}

<table class='data'>
  <caption>Getting the value of an identifier declared as a formal parameter to a function</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="formal parameter value">
       <td>
          |a| is an [=identifier=] [=resolves|resolving=] to
          an [=in scope|in-scope=] formal parameter declaration with type |T|
       <td class="nowrap">
          |a|: |T|
       <td>Result is the value supplied for the corresponding function call operand at the [=call site=]
           invoking this instance of the function.
</table>

## Address-Of Expression  ## {#address-of-expr}

The <dfn noexport>address-of</dfn> operator converts a reference to its corresponding pointer.

<table class='data'>
  <caption>Getting a pointer from a reference</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="address-of expression">
       <td>
          |r|: ref&lt;|AS|,|T|,|AM|&gt;
       <td class="nowrap">
          `&`|r|: ptr&lt;|AS|,|T|,|AM|&gt;
       <td>Result is the pointer value corresponding to the
           same [=memory view=] as the reference value |r|.

           If |r| is an [=invalid memory reference=], then the resulting
           pointer is also an invalid memory reference.

           It is a [=shader-creation error=] if |AS| is the [=address spaces/handle=] address space.

           It is a [=shader-creation error=] if |r| is a
           [[#component-reference-from-vector-reference|reference to a vector component]].

</table>

## Indirection Expression  ## {#indirection-expr}

The <dfn noexport>indirection</dfn> operator converts a pointer to its corresponding reference.

<table class='data'>
  <caption>Getting a reference from a pointer</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="indirection expression">
       <td>
          |p|: ptr&lt;|AS|,|T|,|AM|&gt;
       <td class="nowrap">
          `*`|p|: ref&lt;|AS|,|T|,|AM|&gt;
       <td>Result is the reference value corresponding to the
           same [=memory view=] as the pointer value |p|.

           If |p| is an [=invalid memory reference=], then the resulting
           reference is also an invalid memory reference.

</table>

## Identifier Expressions for Value Declarations  ## {#value-identifier-expr}

<table class='data'>
  <caption>Getting the value of a `const`-, `override`-, or `let`-declared identifiers</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="const-declared value">
       <td>
          |c| is an [=identifier=] [=resolves|resolving=] to
          an [=in scope|in-scope=] [=const-declaration=] with type |T|
       <td class="nowrap">
          |c|: |T|
       <td>Result is the value computed for the initializer expression.
           The expression is a [=const-expression=], and is evaluated at [=shader module creation|shader-creation=] time.

  <tr algorithm="pipeline-overridable constant value">
       <td>
          |c| is an [=identifier=] [=resolves|resolving=] to
          an [=in scope|in-scope=] [=override-declaration=] with type |T|
       <td class="nowrap">
          |c|: |T|
       <td>If pipeline creation specified a value for the [=pipeline constant ID|constant ID=],
           then the result is that value.
           This value may be different for different pipeline instances.

           Otherwise, the result is the value computed for the initializer expression.
           Pipeline-overridable constants appear at module-scope, so evaluation occurs
           before the shader begins execution.

           Note: Pipeline creation fails if no initial value was specified in the API call
           and the `let`-declaration has no initializer expression.
  <tr algorithm="let-declared value">
       <td>
          |c| is an [=identifier=] [=resolves|resolving=] to
          an [=in scope|in-scope=] [=let-declaration=] with type |T|
       <td class="nowrap">
          |c|: |T|
       <td>Result is the value computed for the initializer expression.
           A [=let-declaration=] appears inside a function body, and its initializer
           is evaluated each time control flow reaches the declaration.<br>
</table>

## Enumeration Expressions ## {#enum-expr}

<table class='data'>
  <caption>Enumeration expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
    <tr algorithm="enumerant expression">
        <td>|e| is an [=identifier=] [=resolves|resolving=] to a [=predeclared=] [=enumerant=]
            belonging to [=enumeration=] type |E|
        <td>|e| : |E|
        <td>See [[#predeclared-enumerants]]
</table>

## Type Expressions ## {#type-expr}

<table class='data'>
  <caption>Type expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
    <tr algorithm="predeclared type expression">
        <td>|t| is an [=identifier=] [=resolves|resolving=] to a [=predeclared=] [=type=]
        <td>|t| : [=AllTypes=]
        <td>See [[#predeclared-types]]
    <tr algorithm="type alias expression">
        <td>|a| is an [=identifier=] [=resolves|resolving=] to a [=type alias=].
        <td>|a| : [=AllTypes=]
        <td>Additionally, |a| denotes the type to which it is aliased.
    <tr algorithm="structure type expression">
        <td>|s| is an [=identifier=] [=resolves|resolving=] to the declaration of a [=structure=] type.
        <td>|s| : [=AllTypes=]
        <td>Additionally, |s| denotes the structure type.
    <tr algorithm="predeclared type generator expression no trailing comma">
        <td rowspan=2>|tg| is an [=identifier=] [=resolves|resolving=] to a [=type-generator=]

            |e1|: |T1|<br>
              ...<br>
            |eN|: <var ignore>TN</var>
        <td>|tg| [=syntax_sym/_template_args_start=]<br>|e1|,<br>...,<br>|eN|<br> [=syntax_sym/_template_args_end=]<br>: [=AllTypes=]
        <td rowspan=2>Each [=type-generator=] has its own requirements on the template parameters it requires and accepts,
            and defines how the template paramters help determine the resulting type.

            The expressions |e1| through |eN| are the [=template parameters=] for the type-generator.

            For example, the type expression `vec2<f32>` is the [=vector=] of two [=f32=] elements.

            See [[#predeclared-types]] for the list of predeclared type-generators.

            Note: The two variants here differ only in whether they have a trailing comma after |eN|.
    <tr algorithm="predeclared type generator expression trailing comma">
        <td><var ignore>tg</var> [=syntax_sym/_template_args_start=]<br>|e1|,<br>...,<br>|eN|,<br> [=syntax_sym/_template_args_end=]<br>: [=AllTypes=]
</table>

## Expression Grammar Summary ## {#expression-grammar}

When an [=identifier=] is the first [=token=] in a [=syntax/call_phrase=], it is one of:
* The name of a [=user-defined function=] or [=built-in function=],
    as part of a [=function call=].
* The name of a [=type=], [[#type-aliases|type alias]], or [=type-generator=],
    as part of a [=value constructor=] expression.

[[#declaration-and-scope|Declaration and scope]] rules ensure those names are always distinct.

<pre class=include>
path: syntax/primary_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/call_expression.syntax.bs.include
</pre>
Note: The [=syntax/call_expression=] rule exists to ensure [=type checking=] applies to the call expression.
<pre class=include>
path: syntax/call_phrase.syntax.bs.include
</pre>

<pre class=include>
path: syntax/paren_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/argument_expression_list.syntax.bs.include
</pre>
<pre class=include>
path: syntax/expression_comma_list.syntax.bs.include
</pre>
<pre class=include>
path: syntax/component_or_swizzle_specifier.syntax.bs.include
</pre>
<pre class=include>
path: syntax/unary_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/singular_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/lhs_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/core_lhs_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/multiplicative_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/multiplicative_operator.syntax.bs.include
</pre>
<pre class=include>
path: syntax/additive_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/additive_operator.syntax.bs.include
</pre>
<pre class=include>
path: syntax/shift_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/relational_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/short_circuit_and_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/short_circuit_or_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/binary_or_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/binary_and_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/binary_xor_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/bitwise_expression.syntax.bs.include
</pre>
<pre class=include>
path: syntax/expression.syntax.bs.include
</pre>

## Operator Precedence and Associativity ## {#operator-precedence-associativity}

This entire subsection is non-normative.

Operator precedence and associativity in [=syntax/expression|right-hand side WGSL expressions=]
emerge from their grammar in summary. Right-hand expressions group operators to organize them,
as illustrated by the following diagram:

<div class=operators1>
  <figure>
    <figcaption>Operator precedence and associativity graph</figcaption>
    <object type="image/svg+xml" data="img/operators_1.mmd.svg"></object>
  </figure>
</div>

To promote readability through verbosity, the following groups do not associate with other groups:

* [=syntax/short_circuit_or_expression|Short-circuit OR=]
    (can associate with [=syntax/short_circuit_or_expression|self=] and [=syntax/relational_expression|relational=] weakly),
* [=syntax/short_circuit_and_expression|Short-circuit AND=]
    (can associate with [=syntax/short_circuit_and_expression|self=] and [=syntax/relational_expression|relational=] weakly),
* [=syntax/binary_or_expression|Binary OR=]
    (can associate with [=syntax/binary_or_expression|self=] and [=syntax/unary_expression|unary=] weakly),
* [=syntax/binary_and_expression|Binary AND=]
    (can associate with [=syntax/binary_and_expression|self=] and [=syntax/unary_expression|unary=] weakly),
* [=syntax/binary_xor_expression|Binary XOR=]
    (can associate with [=syntax/binary_xor_expression|self=] and [=syntax/unary_expression|unary=] weakly).

And the following groups do not associate with themselves:

* [=syntax/shift_expression|Shift=]
    (can associate with [=syntax/unary_expression|unary=] weakly),
* [=syntax/relational_expression|Relational=]
    (can associate with [=syntax/additive_expression|additive=] and [=syntax/shift_expression|shift=] weakly).

Associating both group sections above requires parentheses to set the relationship explicitly.
The following exemplifies where these rules render expressions invalid in comments:

<div class='example wgsl function-scope' heading='Operator precedence corner cases'>
  <xmp>
    let a = x & (y ^ (z | w)); // Invalid: x & y ^ z | w
    let b = (x + y) << (z >= w); // Invalid: x + y << z >= w
    let c = x < (y > z); // Invalid: x < y > z
    let d = x && (y || z); // Invalid: x && y || z
  </xmp>
</div>

Emergent precedence controls the implicit parentheses of an expression, where the stronger
binding operator will act as if it is surrounded by parentheses when together with operators
of weaker precedence. For example, stronger binding multiplicative operators than additive will
infer `(a + (b * c))` from `a + b * c` expression. Similarly, the emergent associativity controls
the direction of these implicit parentheses. For example, a left-to-right association will
infer `((a + b) + c)` from `a + b + c` expression, whereas a right-to-left association
will infer `(* (* a))` from `* * a` expression.

The following table summarizes operator precedence, associativity, and binding, sorting
by starting with strongest to weakest. The binding column contains the stronger expression
of the given operator, meaning, for example, if "All above" is the value, then this operator
can include any of the stronger expressions. But, for example, if "Unary" is the value,
then anything weaker than unary but stronger than the operator at row would require parentheses
to bind with this operator. This column is necessary for linearly listing operators.

<table class='data'>
  <caption>
    Operator precedence, associativity, and binding for right-hand side expressions, sorted from strong to weak<br>
  </caption>
  <thead>
    <tr><th>Name
        <th>Operators
        <th>Associativity
        <th>Binding
  </thead>
  <tr><td>[=syntax/paren_expression|Parenthesized=]
      <td>`(...)`
      <td>
      <td>
  <tr><td>[=syntax/primary_expression|Primary=]
      <td>`a()`, `a[]`, `a.b`
      <td>Left-to-right
      <td>
  <tr><td>[=syntax/unary_expression|Unary=]
      <td>`-a`, `!a`, `~a`, `*a`, `&a`
      <td>Right-to-left
      <td>All above
  <tr><td>[=syntax/multiplicative_expression|Multiplicative=]
      <td>`a*b`, `a/b`, `a%b`
      <td>Left-to-right
      <td>All above
  <tr><td>[=syntax/additive_expression|Additive=]
      <td>`a+b`, `a-b`
      <td>Left-to-right
      <td>All above
  <tr><td>[=syntax/shift_expression|Shift=]
      <td>`a<<b`, `a>>b`
      <td>Requires parentheses
      <td>Unary
  <tr><td>[=syntax/relational_expression|Relational=]
      <td>`a<b`, `a>b`, `a<=b`, `a>=b`, `a==b`, `a!=b`
      <td>Requires parentheses
      <td>All above
  <tr><td>[=syntax/binary_and_expression|Binary AND=]
      <td>`a&b`
      <td>Left-to-right
      <td>Unary
  <tr><td>[=syntax/binary_xor_expression|Binary XOR=]
      <td>`a^b`
      <td>Left-to-right
      <td>Unary
  <tr><td>[=syntax/binary_or_expression|Binary OR=]
      <td>`a|b`
      <td>Left-to-right
      <td>Unary
  <tr><td>[=syntax/short_circuit_and_expression|Short-circuit AND=]
      <td>`a&&b`
      <td>Left-to-right
      <td>Relational
  <tr><td>[=syntax/short_circuit_or_expression|Short-circuit OR=]
      <td>`a||b`
      <td>Left-to-right
      <td>Relational
</table>


# Statements # {#statements}

A <dfn>statement</dfn> is a program fragment that controls execution.
Statements are generally executed in sequential order; however,
[[#control-flow|control flow statements]] may cause a program to execute in
non-sequential order.

## Compound Statement ## {#compound-statement-section}

A <dfn>compound statement</dfn> is a brace-enclosed sequence of zero or more statements.
When a [=declaration=] is one of those statements, its [=identifier=] is [=in scope=]
from the start of the next statement until the end of the compound statement.

<pre class=include>
path: syntax/compound_statement.syntax.bs.include
</pre>

The [=syntax/continuing_compound_statement=] is a special form of compound
statement that forms the body of a [[#continuing-statement|continuing]]
statement, and allows an optional [[#break-if-statement|break-if]] statement at
the end.

## Assignment Statement ## {#assignment}

An <dfn noexport dfn-for="statement">assignment</dfn> evaluates an expression,
and optionally stores it in memory (thus updating the contents of a variable).


<pre class=include>
path: syntax/assignment_statement.syntax.bs.include
</pre>


The text to the left of the operator token is the <dfn noexport>left-hand side</dfn>,
and the
expression to the right of the operator token is the <dfn noexport>right-hand side</dfn>.

### Simple Assignment ### {#simple-assignment-section}

An [=statement/assignment=] is a <dfn noexport>simple assignment</dfn> when the
[=left-hand side=] is an expression, and the operator is the equal (<a for=syntax_sym lt=equal>`'='`</a>) token.
In this case the value of the [=right-hand side=] is written to the memory referenced by the left-hand side.

<table class='data'>
  <thead>
    <tr><th style="width:40%">Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="updating assignment">
    <td>|e|: |T|,<br>
        |T| is a [=type/concrete=] [=constructible=] type,<br>
        |r|: ref<|AS|,|T|,|AM|>,<br>
        |AS| is a writable [=address space=],<br>
        [=access mode=] |AM| is [=access/write=] or [=access/read_write=]<br>
    <td class="nowrap">|r| = |e|
    <td>Evaluates |r|, then evaluates |e|, then writes the value computed for |e| into
        the [=memory locations=] referenced by |r|.

        Note: If the reference is an [=invalid memory reference=], the write
        may not execute, or may write to a different memory location than
        expected.
</table>

In the simplest case, the left hand side is the name of a variable.
See [[#forming-references-and-pointers]] for other cases.

    <div class='example wgsl' heading='Assignments'>
      <xmp>
        struct S {
            age: i32,
            weight: f32
        }
        var<private> person: S;

        fn f() {
            var a: i32 = 20;
            a = 30;           // Replace the contents of 'a' with 30.

            person.age = 31;  // Write 31 into the age field of the person variable.

            var uv: vec2<f32>;
            uv.y = 1.25;      // Place 1.25 into the second component of uv.

            let uv_x_ptr: ptr<function,f32> = &uv.x;
            *uv_x_ptr = 2.5;  // Place 2.5 into the first component of uv.

            var sibling: S;
            // Copy the contents of the 'person' variable into the 'sibling' variable.
            sibling = person;
        }
      </xmp>
    </div>

### Phony Assignment ### {#phony-assignment-section}

An [=statement/assignment=] is a <dfn noexport>phony assignment</dfn> when the
[=left-hand side=] is the underscore (<a for=syntax_sym lt=equal>`'_'`</a>) token.
In this case the [=right-hand side=] is evaluated, and then ignored.

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="phony-assignment">
    <td>|e|: |T|,<br>
        |T| is [=constructible=], a [=pointer type=], a [=texture=] type, or a [=sampler=] type
    <td class="nowrap">_ = |e|
    <td>Evaluates |e|.

        Note: The resulting value is not stored.
        The `_` token is not an identifier, and therefore cannot be used in an expression.
</table>

A phony-assignment is useful for:
* Calling a function that returns a value, but clearly expressing that the resulting value
    is not needed.
* [=statically accessed|Statically accessing=] a variable, thus establishing it as a part of
    the [=resource interface of a shader|shader's resource interface=].

    Note: A buffer variable's store type may not be constructible, e.g. it contains an atomic type, or a runtime-sized array.
    In these cases, use a pointer to the variable's contents instead.

<div class='example wgsl global-scope' heading='Using phony-assignment to throw away an un-needed function result'>
  <xmp>
    var<private> counter: i32;

    fn increment_and_yield_previous() -> i32 {
      let previous = counter;
      counter = counter + 1;
      return previous;
    }

    fn user() {
      // Increment the counter, but don't use the result.
      _ = increment_and_yield_previous();
    }
  </xmp>
</div>


<div class='example wgsl global-scope' heading='Using phony-assignment to occupy bindings without using them'>
  <xmp>
    struct BufferContents {
        counter: atomic<u32>,
        data: array<vec4<f32>>
    }
    @group(0) @binding(0) var<storage> buf: BufferContents;
    @group(0) @binding(1) var t: texture_2d<f32>;
    @group(0) @binding(2) var s: sampler;

    @fragment
    fn shade_it() -> @location(0) vec4<f32> {
      // Declare that buf, t, and s are part of the shader interface, without
      // using them for anything.
      _ = &buf;
      _ = t;
      _ = s;
      return vec4<f32>();
    }
  </xmp>
</div>

### Compound Assignment ### {#compound-assignment-sec}

An [=statement/assignment=] is a <dfn noexport>compound assignment</dfn> when the
[=left-hand side=] is an expression, and the operator is one of the [=syntax/compound_assignment_operators=].

<pre class=include>
path: syntax/compound_assignment_operator.syntax.bs.include
</pre>

The type requirements, semantics, and behavior of each statement is defined as if
the compound assignment expands as in the following table, except that:
* the reference expression |e1| is evaluated only once, and
* the [=reference type=] for |e1| [=shader-creation error|must=] have a [=access/read_write=] [=access mode=].

<table class='data'>
  <thead>
    <tr><th>Statement<th>Expansion
  </thead>
<tr algorithm="add-assign">
    <td class="nowrap">|e1| += |e2|
    <td>|e1| = |e1| + (|e2|)
<tr algorithm="subtract-assign">
    <td class="nowrap">|e1| -= |e2|
    <td>|e1| = |e1| - (|e2|)
<tr algorithm="multiply-assign">
    <td class="nowrap">|e1| *= |e2|
    <td>|e1| = |e1| * (|e2|)
<tr algorithm="divide-assign">
    <td class="nowrap">|e1| /= |e2|
    <td>|e1| = |e1| / (|e2|)
<tr algorithm="modulus-assign">
    <td class="nowrap">|e1| %= |e2|
    <td>|e1| = |e1| % (|e2|)
<tr algorithm="bitwise-and-assign">
    <td class="nowrap">|e1| &= |e2|
    <td>|e1| = |e1| & (|e2|)
<tr algorithm="bitwise-or-assign">
    <td class="nowrap">|e1| |= |e2|
    <td>|e1| = |e1| | (|e2|)
<tr algorithm="bitwise-xor-assign">
    <td class="nowrap">|e1| ^= |e2|
    <td>|e1| = |e1| ^ (|e2|)
<tr algorithm="bitwise-shiftright-assign">
    <td class="nowrap">|e1| >>= |e2|
    <td>|e1| = |e1| >> (|e2|)
<tr algorithm="bitwise-shiftleft-assign">
    <td class="nowrap">|e1| <<= |e2|
    <td>|e1| = |e1| << (|e2|)
</table>

Note: The syntax does not allow a [=compound assignment=] to also be a [=phony assignment=].

Note: Even though the reference |e1| is evaluated once, its underlying memory is accessed twice:
first a [=read access=] gets the old value, and then a [=write access=] stores the updated value.

<div class='example wgsl global-scope' heading="Compound assignment">
  <xmp>
    var<private> next_item: i32 = 0;

    fn advance_item() -> i32 {
       next_item += 1;   // Adds 1 to next_item.
       return next_item - 1;
    }

    fn bump_item() {
      var data: array<f32,10>;
      next_item = 0;
      // Adds 5.0 to data[0], calling advance_item() only once.
      data[advance_item()] += 5.0;
      // next_item will be 1 here.
    }

    fn precedence_example() {
      var value = 1;
      // The right-hand side of a compound assignment is its own expression.
      value *= 2 + 3; // Same as value = value * (2 + 3);
      // 'value' now holds 5.
    }
  </xmp>
</div>

<div class=note><span class=marker>Note:</span>
A compound assignment can rewritten as different WGSL code that uses a [=simple assignment=] instead.
The idea is to use a pointer to hold the result of evaluating the reference once.

<p algorithm="translation compound assignment not vector component">For example,
when |e1| is *not* a reference to a component inside a vector, then
<blockquote>
|e1|` += `|e2|;
</blockquote>
can be rewritten as
<blockquote>
`{ let p = &(`|e1|`); *p = *p + (`|e2|`); }`
</blockquote>
where the identifier `p` is chosen to be different from all other identifiers in the program.
</p>

<p algorithm="translation compound assignment vector component">When
|e1| is a reference to a component inside a vector, the above technique
needs to be modified because WGSL does not allow [[#address-of-expr|taking the address]] in that case.
For example, if <var ignore>ev</var> is a reference to a vector, the statement
<blockquote>
|ev|`[`|c|`] += ` |e2|;
</blockquote>
can be rewritten as
<blockquote>
`{ let p = &(`|ev|`); let c0 = ` |c|`; (*p)[c0] = (*p)[c0] + (`|e2|`); }`
</blockquote>
where identifiers `c0` and `p` are chosen to be different from all other identifiers in the program.
</div>
</div>

## Increment and Decrement Statements ## {#increment-decrement}

An <dfn noexport>increment statement</dfn> adds 1 to the contents of a variable.
A <dfn noexport>decrement statement</dfn> subtracts 1 from the contents of a variable.

<pre class=include>
path: syntax/increment_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/decrement_statement.syntax.bs.include
</pre>

The expression [=shader-creation error|must=] evaluate to a reference with a [=type/concrete=] [=integer scalar=] [=store type=] and [=access/read_write=] [=access mode=].

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="increment statement">
    <td class="nowrap">|r| : ref&lt;|AS|,|T|,[=access/read_write=]&gt;,<br>
        |T| is a [=type/concrete=] [=integer scalar=]<br>
    <td class="nowrap">|r|`++`
    <td>Adds 1 to the contents of memory referenced by |r|.
        <br>Same as |r| += |T|(1)
  <tr algorithm="decrement statement">
    <td class="nowrap">|r| : ref&lt;|AS|,|T|,[=access/read_write=]&gt;,<br>
        |T| is a [=type/concrete=] [=integer scalar=]<br>
    <td class="nowrap">|r|`--`
    <td>Subtracts 1 from the contents of memory referenced by |r|.
        <br>Same as |r| -= |T|(1)
</table>

    <div class='example wgsl' heading='Increment and decrement'>
      <xmp>
        fn f() {
            var a: i32 = 20;
            a++;
            // Now a contains 21
            a--;
            // Now a contains 20
        }
      </xmp>
    </div>

## Control Flow ## {#control-flow}

Control flow statements may cause the program to execute in non-sequential order.

### If Statement ### {#if-statement}

An <dfn noexport dfn-for="statement">if</dfn> statement conditionally executes at most one [=compound statement=] based on
the evaluation of condition expressions.

An `if` statement has an `if` clause, followed by zero or more `else if` clauses, followed by an optional `else` clause.

<pre class=include>
path: syntax/if_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/if_clause.syntax.bs.include
</pre>

<pre class=include>
path: syntax/else_if_clause.syntax.bs.include
</pre>

<pre class=include>
path: syntax/else_clause.syntax.bs.include
</pre>

[=Type rule precondition=]:
The expression in each `if` and `else if` clause [=shader-creation error|must=] be of [=bool=] type.

An `if` statement is executed as follows:
* The condition associated with the `if` clause is evaluated.
    If the result is `true`,
    control transfers to the first compound statement (immediately after the condition expression).
* Otherwise, the condition of the next `else if` clause in textual order (if one exists) is evaluated
     and, if the result is `true`, control transfers to the associated compound statement.
     * This behavior is repeated for all `else if` clauses until one of the conditions evaluates to `true`.
* If no condition evaluates to `true`, then control transfers to the compound statement
    associated with the `else` clause (if it exists).

### Switch Statement ### {#switch-statement}

A <dfn noexport dfn-for="statement">switch</dfn> statement transfers control to one of a set of [=case clauses=], or to the [=default clause=],
depending on the evaluation of a selector expression.

<pre class=include>
path: syntax/switch_statement.syntax.bs.include
</pre>
<pre class=include>
path: syntax/switch_body.syntax.bs.include
</pre>
<pre class=include>
path: syntax/switch_clause.syntax.bs.include
</pre>
<pre class=include>
path: syntax/case_clause.syntax.bs.include
</pre>
<pre class=include>
path: syntax/default_alone_clause.syntax.bs.include
</pre>
<pre class=include>
path: syntax/case_selectors.syntax.bs.include
</pre>
<pre class=include>
path: syntax/case_selector.syntax.bs.include
</pre>

A <dfn noexport>case clause</dfn> is the <a for=syntax_kw lt=case>`'case'`</a> token followed by a comma-separated list of [=syntax/case_selector|case selectors=] and a
body in the form of a [=compound statement=].

A <dfn noexport>default-alone clause</dfn> is the <a for=syntax_kw lt=default>`'default'`</a> token followed by a body in the form of a [=compound statement=].

A <dfn noexport>default clause</dfn> is either:
* a [=case clause=] where <a for=syntax_kw lt=default>`'default'`</a> appears as one of its selectors, or
* a [=default-alone clause=].

Each switch statement [=shader-creation error|must=] have exactly one [=default clause=].

The <a for=syntax_kw lt=default>`'default'`</a> token [=shader-creation error|must=] not appear more than once in a single [=syntax/case_selector=] list.

[=Type rule precondition=]:
For a single switch statement, the selector expression and all case selector expressions [=shader-creation error|must=] be of the same [=type/concrete=] [=integer scalar=] type.

The expressions in the [=syntax/case_selectors=] [=shader-creation error|must=]
be [=const-expressions=].

Two different case selector expressions in the same switch statement [=shader-creation error|must not=] have the same value.

If the selector value equals the value of an expression in a [=syntax/case_selector=] list,
then control is transferred to the body of that [=case clause=].
If the selector value does not equal any of the case selector values, then control is
transferred to the body of the [=default clause=].

When control reaches the end of the body of a clause, control transfers to the first statement after the switch statement.

When one of the statements in the body of a clause is a [=declaration=],
it follows the normal [=scope=] and [=lifetime=] rules of a declaration in a [=compound statement=].
That is, the body is a sequence of statements, and if one of those is a declaration
then the scope of that declaration extends from the start of the next statement in the sequence
until the end of the body.
The declaration executes when it is reached,
creating a new instance of the [=variable declaration|variable=] or [=value declaration|value=], and initializes it.

<div class='example wgsl function-scope' heading='WGSL Switch'>
  <xmp>
    var a : i32;
    let x : i32 = generateValue();
    switch x {
      case 0: {      // The colon is optional
        a = 1;
      }
      default {      // The default need not appear last
        a = 2;
      }
      case 1, 2, {   // Multiple selector values can be used
        a = 3;
      }
      case 3, {      // The trailing comma is optional
        a = 4;
      }
      case 4 {
        a = 5;
      }
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading='WGSL Switch with default combined'>
  <xmp>
    const c = 2;
    var a : i32;
    let x : i32 = generateValue();
    switch x {
      case 0: {
        a = 1;
      }
      case 1, c {       // Const-expression can be used in case selectors
        a = 3;
      }
      case 3, default { // The default keyword can be used with other clauses
        a = 4;
      }
    }
  </xmp>
</div>

### Loop Statement ### {#loop-statement}

<pre class=include>
path: syntax/loop_statement.syntax.bs.include
</pre>

A <dfn noexport dfn-for="statement">loop</dfn> statement repeatedly executes a <dfn noexport>loop body</dfn>;
the loop body is specified as a [=compound statement=].
Each execution of the loop body is called an <dfn noexport>iteration</dfn>.

This repetition can be interrupted by a [=statement/break=], or
[=statement/return=] statement.

Optionally, the last statement in the loop body may be a
[=statement/continuing=] statement.

When one of the statements in the loop body is a [=declaration=],
it follows the normal [=scope=] and [=lifetime=] rules of a declaration in a [=compound statement=].
That is, the loop body is a sequence of statements, and if one of those is a declaration
then the scope of that declaration extends from the start of the next statement in the sequence
until the end of the loop body.
The declaration executes each time it is reached, so each new iteration
creates a new instance of the [=variable declaration|variable=] or [=value declaration|value=], and re-initializes it.

Note: The loop statement is one of the biggest differences from other shader
languages.

This design directly expresses loop idioms commonly found in compiled code.
In particular, placing the loop update statements at the end of the loop body
allows them to naturally use values defined in the loop body.

<div class='example glsl' heading='GLSL Loop'>
  <xmp>
    int a = 2;
    for (int i = 0; i < 4; i++) {
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;      // <1>
    loop {
      if i >= 4 { break; }

      a = a * 2;

      i++;
    }
  </xmp>
</div>
* <1> The initialization is listed before the loop.

<div class='example glsl' heading='GLSL Loop with continue'>
  <xmp>
    int a = 2;
    int step = 1;
    for (int i = 0; i < 4; i += step) {
      if (i % 2 == 0) continue;
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }

      let step: i32 = 1;

      i = i + step;
      if i % 2 == 0 { continue; }

      a = a * 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue and continuing">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }

      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {   // <2>
        i = i + step;
      }
    }
  </xmp>
</div>
* <2> The continue construct is placed at the end of the `loop`

### For Statement ### {#for-statement}

<pre class=include>
path: syntax/for_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/for_header.syntax.bs.include
</pre>

<pre class=include>
path: syntax/for_init.syntax.bs.include
</pre>
<pre class=include>
path: syntax/for_update.syntax.bs.include
</pre>

The <dfn dfn-for="statement">for</dfn> statement takes the form
`for (initializer; condition; update_part) { body }` and is syntactic sugar on top of a [=statement/loop=] statement with the same `body`.
Additionally:
* If `initializer` is non-empty, it is executed inside an additional [=scope=] before the first [=iteration=].
    The scope of a declaration in the initializer extends to the end of the loop body.
* [=Type rule precondition=]: If the condition is non-empty, it [=shader-creation error|must=] be an expression of [=bool=] type.
    * If present, the condition is evaluated immediately before executing the loop body.
        If the condition is false, then a [[#break-statement]] is executed, finishing execution of the loop.
        This check is performed at the start of each loop iteration.
* If `update_part` is non-empty, it becomes a [=statement/continuing=] statement at the end of the loop body.

The `initializer` of a for loop is executed once prior to executing the loop.
When a [=declaration=] appears in the initializer, its [=identifier=] is [=in scope=] until the end of the `body`.
Unlike declarations in the `body`, the declaration is not re-initialized each iteration.

The `condition`, `body` and `update_part` execute in that order to form a loop [=iteration=].
The `body` is a special form of [=compound statement=].
The identifier of a declaration in the `body` is [=in scope=] from the start of
the next statement until the end of the `body`.
The declaration is executed each time it is reached, so each new iteration
creates a new instance of the variable or constant, and re-initializes it.

<div class='example wgsl function-scope' heading="For to Loop transformation: before">
  <xmp>
    var a: i32 = 2;
    for (var i: i32 = 0; i < 4; i++) {
      if a == 0 {
        continue;
      }
      a = a + 2;
    }
  </xmp>
</div>

Converts to:

<div class='example wgsl function-scope' heading="For to Loop transformation: after">
  <xmp>
    var a: i32 = 2;
    { // Introduce new scope for loop variable i
      var i: i32 = 0;
      loop {
        if !(i < 4) {
          break;
        }

        if a == 0 {
          continue;
        }
        a = a + 2;

        continuing {
          i++;
        }
      }
    }
  </xmp>
</div>

### While Statement ### {#while-statement}

<pre class=include>
path: syntax/while_statement.syntax.bs.include
</pre>

The <dfn noexport dfn-for="statement">while</dfn> statement is a kind of loop parameterized by a condition.
At the start of each loop [=iteration=], a boolean condition is evaluated.
If the condition is false, the while loop ends execution.
Otherwise, the rest of the iteration is executed.

[=Type rule precondition=]: The condition [=shader-creation error|must=] be of [=bool=] type.

A while loop can be viewed as syntactic sugar over either a [=statement/loop=] or [=statement/for=] statement.
The following statement forms are equivalent:
* `while`  *condition*  `{` *body_statements* `}`
* `loop { if !` *condition* `{break;}` *body_statements* `}`
* `for (;`  *condition* `;) {` *body_statements*  `}`

### Break Statement ### {#break-statement}

<pre class=include>
path: syntax/break_statement.syntax.bs.include
</pre>

A <dfn noexport dfn-for="statement">break</dfn> statement transfers control to immediately
after the body of the nearest-enclosing loop
or [=statement/switch=] statement, thus ending execution of the loop or switch statement.

A `break` statement [=shader-creation error|must=] only be used within [=statement/loop=], [=statement/for=], [=statement/while=], and [=statement/switch=] statements.

A `break` statement [=shader-creation error|must not=] be placed such that it would exit from a loop's [[#continuing-statement|continuing]] statement.
Use a [[#break-if-statement|break-if]] statement instead.

<div class='example wgsl function-scope' heading="WGSL Invalid loop break from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        if i >= 4 { break; } // Invalid.  Use break-if instead.
      }
    }
  </xmp>
</div>

### Break-If Statement ### {#break-if-statement}

<pre class=include>
path: syntax/break_if_statement.syntax.bs.include
</pre>

A <dfn noexport dfn-for="statement">break-if</dfn> statement evaluates a boolean condition;
If the condition is true, control is transferred to immediately after the body of the nearest-enclosing [=statement/loop=]
statement, ending execution of that loop.

[=Type rule precondition=]: The condition [=shader-creation error|must=] be of [=bool=] type.

Note: A break-if statement may only appear as the last statement in the body of a [[#continuing-statement|continuing]]
statement.

<div class='example wgsl function-scope' heading="WGSL Valid loop break-if from a continuing clause">
  <xmp>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        break if i >= 4;
      }
    }
  </xmp>
</div>

### Continue Statement ### {#continue-statement}

<pre class=include>
path: syntax/continue_statement.syntax.bs.include
</pre>

A <dfn noexport dfn-for="statement">continue</dfn> statement transfers control in the nearest-enclosing [=statement/loop=]:

*  forward to the [=statement/continuing=] statement at the end of the body of that loop, if it exists.
*  otherwise backward to the first statement in the loop body, starting the next [=iteration=].

A `continue` statement [=shader-creation error|must=] only be used in a [=statement/loop=], [=statement/for=] or [=statement/while=] statement.
A `continue` statement [=shader-creation error|must not=] be placed such that it would transfer
control to an enclosing [=statement/continuing=] statement.
(It is a *forward* branch when branching to a `continuing` statement.)

A `continue` statement [=shader-creation error|must not=] be placed such that it would transfer
control past a declaration used in the targeted [=statement/continuing=] statement.

Note: A `continue` can only be used in a `continuing` statement if it is used for transferring control
flow within another loop nested in the `continuing` statement. That is, a `continue`
cannot be used to transfer control to the start of the currently executing `continuing` statement.

<div class='example wgsl function-scope expect-error' heading="Invalid continue bypasses declaration">
  <xmp>
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }
      if i % 2 == 0 { continue; } // <3>

      let step: i32 = 2;

      continuing {
        i = i + step;
      }
    }
  </xmp>
</div>
* <3> The `continue` is invalid because it bypasses the declaration of `step` used in the `continuing` construct

### Continuing Statement ### {#continuing-statement}

<pre class=include>
path: syntax/continuing_statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/continuing_compound_statement.syntax.bs.include
</pre>

A <dfn dfn-for="statement">continuing</dfn> statement specifies a [=compound statement=] to be executed at the end of a loop [=iteration=].
The construct is optional.

The compound statement [=shader-creation error|must not=] contain a [=statement/return=] at any compound statement nesting level.

### Return Statement ### {#return-statement}

<pre class=include>
path: syntax/return_statement.syntax.bs.include
</pre>

A <dfn noexport dfn-for="statement">return</dfn> statement ends execution of the current function.
If the function is an [=entry point=], then the current shader invocation
is terminated.
Otherwise, evaluation continues with the next expression or statement after
the evaluation of the [=call site=] of the current function invocation.

If the function does not have a [=return type=], then the [=statement/return=] statement is
optional. If the return statement is provided for such a function, it [=shader-creation error|must not=]
supply a value.
Otherwise the expression [=shader-creation error|must=] be present, and is called the <dfn>return value</dfn>.
In this case the call site of this function invocation evaluates to the return value.
The type of the return value [=shader-creation error|must=] match the return type of the function.

### Discard Statement ### {#discard-statement}

A <dfn dfn-for="statement">discard</dfn> statement converts the invocation into
a [=helper invocation=] and throws away the fragment.
The `discard` statement [=shader-creation error|must=] only be used in a [=fragment=] shader stage.

More precisely, executing a `discard` statement [=behavioral requirement|will=]:

* convert the current invocation into a [=helper invocation=], and
* prevent the current fragment from being processed downstream in the [=GPURenderPipeline=].

Only statements executed prior to the `discard` statement [=behavioral
requirement|will=] have observable effects.

Note: A `discard` statement may be executed by any
[=functions in a shader stage|function in a fragment stage=] and the effect is the same:
the fragment will be thrown away.

<div class='example wgsl' heading='Using the discard statement to throw away a fragment'>
  <xmp>
  @group(0) @binding(0)
  var<storage, read_write> will_emit_color : u32;

  fn discard_if_shallow(pos: vec4<f32>) {
    if pos.z < 0.001 {
      // If this is executed, then the will_emit_color variable will
      // never be set to 1 because helper invocations will not write
      // to shared memory.
      discard;
    }
    will_emit_color = 1;
  }

  @fragment
  fn main(@builtin(position) coord_in: vec4<f32>)
    -> @location(0) vec4<f32>
  {
    discard_if_shallow(coord_in);

    // Set the value to 1 and emit red, but only if the helper function
    // did not execute the discard statement.
    will_emit_color = 1;
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
  }
  </xmp>
</div>

## Function Call Statement ## {#function-call-statement}

<pre class=include>
path: syntax/func_call_statement.syntax.bs.include
</pre>

A function call statement executes a [=function call=].

A [=shader-creation error=] results if the called function has the [=attribute/must_use=] attribute.

Note: If the function [=return value|returns a value=],
and the function does not have the [=attribute/must_use=] attribute,
that value is ignored.

## Const Assertion Statement ## {#const-assert-statement}

A const assertion statement produces a [=shader-creation error=] if the
expression evaluates to `false`.
The expression [=shader-creation error|must=] be a [=const-expression=].
The statement can satisfy [=statically accessed|static access=] conditions in
a shader, but otherwise has no effect on the compiled shader.
This statement can be used at [=module scope=] and within [=function scope|functions=].

[=Type rule precondition=]:
The expression [=shader-creation error|must=] be of [=bool=] type.

<pre class=include>
path: syntax/const_assert_statement.syntax.bs.include
</pre>

<div class='example wgsl global-scope' heading="Static assertion examples">
  <xmp>
    const x = 1;
    const y = 2;
    const_assert x < y; // valid at module-scope.
    const_assert(y != 0); // parentheses are optional.

    fn foo() {
      const z = x + y - 2;
      const_assert z > 0; // valid in functions.
      let a  = 3;
      const_assert a != 0; // invalid, the expresion must be a const-expression.
    }
  </xmp>
</div>

## Statements Grammar Summary ## {#statements-summary}

The [=syntax/statement=] rule matches statements that can be used in most places inside a function body.

<pre class=include>
path: syntax/statement.syntax.bs.include
</pre>

<pre class=include>
path: syntax/variable_updating_statement.syntax.bs.include
</pre>

Additionally, certain statements may only be used in very specific contexts:
* [=syntax/break_if_statement=]
* [=syntax/continuing_compound_statement=]

## Statements Behavior Analysis ## {#behaviors}

### Rules ### {#behaviors-rules}

Some statements affecting control-flow are only valid in some contexts.
For example, [=statement/continue=] is invalid outside of a [=statement/loop=],
[=statement/for=], or [=statement/while=].
Additionally, the uniformity analysis (see [[#uniformity]]) needs to know when control flow can exit a statement in multiple different ways.

Both goals are achieved by a system for summarizing execution behaviors of statements. Behavior analysis maps each statement to the set of possible ways execution proceeds after evaluation of the statement completes.
As with type analysis for values and expressions, behavior analysis proceeds bottom up: first determine behaviors for certain basic statements, and then determine behavior for higher level constructs by applying combining rules.

A <dfn export>behavior</dfn> is a set, whose elements may be:
- Return
- Break
- Continue
- Next

Each of those correspond to a way to exit a compound statement: either through a keyword, or by falling to the next statement ("Next").

We note "*s*: *B*" to say that *s* respects the rules regarding behaviors, and has [=behavior=] *B*.

For each function:
- Its body [=shader-creation error|must=] be a valid statement by these rules.
- If the function has a return type, the [=behavior=] of its body [=shader-creation error|must=] be {Return}.
- Otherwise, the [=behavior=] of its body [=shader-creation error|must=] be a subset of {Next, Return}.

We assign a [=behavior=] to each function: it is its body's [=behavior=] (treating the body as a regular statement), with any "Return" replaced by "Next".
As a consequence of the rules above, a function behavior is always one of {}, or {Next}.

Behavior analysis [=shader-creation error|must=] be able to determine a
non-empty [=behavior=] for each statement, and function.

<table class='data'>
  <caption>Rules for analyzing and validating the behaviors of statements</caption>
  <thead>
    <tr><th>Statement<th>Preconditions<th>Resulting behavior
  </thead>
  <tr>
    <td class="nowrap">*empty statement*
    <td>
    <td class="nowrap">{Next}
  <tr algorithm="braced statement behavior">
    <td class="nowrap">{|s|}
    <td>|s|: |B|
    <td class="nowrap">|B|
  <tr algorithm="statement sequence behavior with next">
    <td class="nowrap" rowspan=2>|s1| |s2|

        Note: |s1| often ends in a semicolon.

    <td class="nowrap">|s1|: |B1|<br>
        Next in |B1|<br>
        |s2|: |B2|
    <td class="nowrap">(|B1|&#x2216;{Next}) &cup; |B2|
  <tr algorithm="statement sequence behavior without next">
    <td class="nowrap">|s1|: |B1|<br>
        Next not in |B1|<br>
        |s2|: <var ignore>B2</var>
    <td class="nowrap">|B1|
  <tr algorithm="variable declaration behavior">
    <td class="nowrap">var x:T;
    <td>
    <td>{Next}
  <tr algorithm="let-declaration behavior">
    <td class="nowrap">let x = |e|;
    <td>
    <td>{Next}
  <tr algorithm="initialized variable declaration behavior">
    <td class="nowrap">var x = |e|;
    <td>
    <td>{Next}
  <tr algorithm="assignment behavior">
    <td class="nowrap">x = |e|;
    <td>
    <td>{Next}
  <tr algorithm="phony assignment behavior">
    <td class="nowrap">_ = |e|;
    <td>
    <td>{Next}
  <tr algorithm="function call statement behavior">
    <td class="nowrap">|f|(|e1|, ..., |en|);
    <td class="nowrap">|f| has behavior |B|
    <td class="nowrap">|B|
  <tr algorithm="return behavior">
    <td>return;
    <td>
    <td>{Return}
  <tr algorithm="return value behavior">
    <td class="nowrap">return |e|;
    <td>
    <td>{Return}
  <tr algorithm="discard behavior">
    <td class="nowrap">discard;
    <td>
    <td>{Next}
  <tr algorithm="break behavior">
    <td>break;
    <td>
    <td>{Break}
  <tr algorithm="break if behavior">
    <td>break if |e|;
    <td>
    <td>{Break, Next}
  <tr algorithm="continue behavior">
    <td>continue;
    <td>
    <td>{Continue}
  <tr algorithm="if statement behavior">
    <td class="nowrap">if |e| |s1| else |s2|
    <td class="nowrap">
        |s1|: |B1|<br>
        |s2|: |B2|
    <td class="nowrap">|B1| &cup; |B2|
  <tr algorithm="loop with continuing without break behavior">
    <td class="nowrap" rowspan=2>loop {|s1| continuing {|s2|}}
    <td class="nowrap">
        |s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return} are in |B2|<br>
        Break is not in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1| &cup; |B2|)&#x2216;{Continue, Next}
  <tr algorithm="loop with continuing with break behavior">
    <td class="nowrap">
        |s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return} are in |B2|<br/>
        Break is in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1| &cup; |B2| &cup; {Next})&#x2216;{Break, Continue}
  <tr algorithm="switch behavior">
    <td class="nowrap" rowspan=2>switch |e|  {case <var ignore>c1</var>: |s1| ... case <var ignore>cn</var>: |sn|}
    <td class="nowrap">
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Break is not in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">|B1| &cup; ... &cup; |Bn|
  <tr algorithm="switch with break behavior">
    <td class="nowrap">
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Break is in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">(|B1| &cup; ... &cup; |Bn| &cup; {Next})&#x2216;Break
</table>

Note: &cup; is a set union operation and &#x2216; is a set difference operation.

Note: The empty statement case occurs when a `loop` has an empty body, or when a `for` loop lacks an initialization or update statement.

For the purpose of this analysis:
- `for` loops get desugared (see [[#for-statement]])
- `while` loops get desugared (see [[#while-statement]])
- `loop {s}` is treated as `loop {s continuing {}}`
- `if` statements without an `else` branch are treated as if they had an empty else branch (which adds Next to their [=behavior=])
- `if` statements with `else if` branches are treated as if they were nested simple `if/else` statements
- a [=syntax/switch_clause=] starting with `default` behaves just like a [=syntax/switch_clause=] starting with `case _:`

Each [=built-in function=] has a [=behavior=] of {Next}.
And each operator application not listed in the table above has the same [=behavior=] as if it were a function call with the same operands and with a function's [=behavior=] of {Next}.

The behavior of a function [=shader-creation error|must=] satisfy the rules given above.

Note: It is unnecessary to analyze the behavior of expressions because they
will always be {Next} or a previously analyzed function will have produced
a error.

### Notes ### {#behaviors-notes}

This section is informative, non-normative.

Behavior analysis can cause a program to be rejected in the following ways
(restating requirements from above):
- The body of a function (treated as a regular statement) has a behavior not included in {Next, Return}.
- The body of a function with a return type has a behavior which is not {Return}.
- The behavior of a continuing block contains any of Continue, or Return.
- Some obviously infinite loops have an empty behavior set, and are therefore invalid.

This analysis can be run in linear time, by analyzing the call-graph bottom-up (since the behavior of a function call can depend on the function's code).

### Examples ### {#behaviors-examples}

Here are some examples showing this analysis in action:
<div class='example wgsl expect-error' heading='Trivially dead code is allowed'>
   <xmp>
    fn simple() -> i32 {
      var a: i32;
      return 0;  // Behavior: {Return}
      a = 1;     // Valid, statically unreachable code.
                 //   Statement behavior: {Next}
                 //   Overall behavior (due to sequential statements): {Return}
      return 2;  // Valid, statically unreachable code. Behavior: {Return}
    } // Function behavior: {Return}
   </xmp>
</div>

<div class='example wgsl expect-error' heading='Compound statements are supported'>
   <xmp>
    fn nested() -> i32 {
      var a: i32;
      {             // The start of a compound statement.
        a = 2;      // Behavior: {Next}
        return 1;   // Behavior: {Return}
      }             // The compound statement as a whole has behavior {Return}
      a = 1;        // Valid, statically unreachable code.
                    //   Statement behavior: {Next}
                    //   Overall behavior (due to sequential statements): {Return}
      return 2;     // Valid, statically unreachable code. Behavior: {Return}
    }
   </xmp>
</div>

<div class='example wgsl' heading='if/then behaves as if there is an empty else'>
   <xmp>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        }             // Behavior of the whole if compound statement: {Break, Next},
                      //   as the if has an implicit empty else
        a = a + 1;    // Valid, as the previous statement had "Next" in its behavior
      }
    }
   </xmp>
</div>

<div class='example wgsl expect-error' heading='if/then/else has the behavior of both sides'>
   <xmp>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        } else {
          continue;   // Behavior: {Continue}
        }             // Behavior of the whole if compound statement: {Break, Continue}
        a = a + 1;    // Valid, statically unreachable code.
                      //   Statement behavior: {Next}
                      //   Overall behavior: {Break, Continue}
      }
    }
   </xmp>
</div>

<div class='example wgsl' heading='if/else if/else behaves like a nested if/else'>
   <xmp>
    fn if_example() {
      var a: i32 = 0;
      loop {
        // if e1 s1 else if e2 s2 else s3
        // is identical to
        // if e1 else { if e2 s2 else s3 }
        if a == 5 {
          break;      // Behavior: {Break}
        } else if a == 42 {
          continue;   // Behavior: {Continue}
        } else {
          return;     // Behavior {Return}
        }             // Behavior of the whole if compound statement:
                      //   {Break, Continue, Return}
      }               // Behavior of the whole loop compound statement {Next, Return}
    }                 // Behavior of the whole function {Next}
   </xmp>
</div>

<div class='example wgsl' heading='Break in switch becomes Next'>
   <xmp>
    fn switch_example() {
      var a: i32 = 0;
      switch a {
        default: {
          break;   // Behavior: {Break}
        }
      }            // Behavior: {Next}, as switch replaces Break by Next
      a = 5;       // Valid, as the previous statement had Next in its behavior
    }
   </xmp>
</div>

<div class='example wgsl' heading='Obviously infinite loops'>
   <xmp>
    fn invalid_infinite_loop() {
      loop { }     // Behavior: { }.  Invalid because it's empty.
    }
   </xmp>
</div>

<div class='example wgsl' heading='Discard will not terminate a loop'>
  <xmp>
    fn invalid_infinite_loop() {
      loop {
        discard; // Behavior { Next }.
      }          // Invalid, behavior of the whole loop is { }.
    }
  </xmp>
</div>

<div class='example wgsl' heading='A conditional continue with continuing statement'>
   <xmp>
    fn conditional_continue() {
      var a: i32;
      loop {
        if a == 5 { break; } // Behavior: {Break, Next}
        if a % 2 == 1 {      // Valid, as the previous statement has Next in its behavior
          continue;          // Behavior: {Continue}
        }                    // Behavior: {Continue, Next}
        a = a * 2;           // Valid, as the previous statement has Next in its behavior
        continuing {         // Valid as the continuing statement has behavior {Next}
                             //  which does not include any of:
                             //  {Break, Continue, Return}
          a = a + 1;
        }
      }                      // The loop as a whole has behavior {Next},
                             //  as it absorbs "Continue" and "Next",
                             //  then replaces "Break" with "Next"
    }
   </xmp>
</div>

<div class='example wgsl' heading='A redundant continue with continuing statement'>
   <xmp>
    fn redundant_continue_with_continuing() {
      var a: i32;
      loop {
        if a == 5 { break; }
        continue;   // Valid. This is redundant, branching to the next statement.
        continuing {
          a = a + 1;
        }
      }
    }
   </xmp>
</div>

<div class='example wgsl' heading='A continue at the end of a loop body'>
   <xmp>
    fn continue_end_of_loop_body() {
      for (var i: i32 = 0; i < 5; i++ ) {
        continue;   // Valid. This is redundant,
                    //   branching to the end of the loop body.
      }             // Behavior: {Next},
                    //   as loops absorb "Continue",
                    //   and "for" loops always add "Next"
    }
   </xmp>
</div>
`for` loops desugar to `loop` with a conditional break. As shown in a previous example, the conditional break has [=behavior=] {Break, Next}, which leads to adding "Next" to the loop's [=behavior=].

<div class='example wgsl expect-error' heading='return required in functions that have a return type'>
   <xmp>
    fn missing_return () -> i32 {
      var a: i32 = 0;
      if a == 42 {
        return a;       // Behavior: {Return}
      }                 // Behavior: {Next, Return}
    }                   // Error: Next is invalid in the body of a
                        //   function with a return type
   </xmp>
</div>

<div class='example wgsl expect-error' heading='continue must be in a loop'>
   <xmp>
    fn continue_out_of_loop () {
      var a: i32 = 0;
      if a > 0  {
        continue;       // Behavior: {Continue}
      }                 // Behavior: {Next, Continue}
    }                   // Error: Continue is invalid in the body of a function
   </xmp>
</div>
The same example would also be invalid for the same reason if `continue` was replaced by `break`.

# Functions # {#functions}

A <dfn dfn-for="function" noexport>function</dfn> performs computational work when invoked.

A function is invoked in one of the following ways:
* By evaluating a function call expression. See [[#function-call-expr]].
* By executing a function call statement. See [[#function-call-statement]].
* An [=entry point=] function is invoked by the WebGPU implementation to perform
    the work of a [=shader stage=] in a [=pipeline=]. See [[#entry-points]]

There are two kinds of functions:
* A [=built-in function=] is provided by the WGSL implementation,
    and is always available to a WGSL module.
    See [[#builtin-functions]].
* A [=user-defined function=] is declared in a WGSL module.

## Declaring a User-defined Function ## {#function-declaration-sec}

A <dfn noexport>function declaration</dfn> creates a <dfn noexport>user-defined function</dfn>, by specifying:
* An optional set of [=attributes=].
* The name of the function.
* The formal parameter list: an ordered sequence of zero
    or more [=formal parameter=] declarations,
    which may have attributes applied,
    separated by commas, and
    surrounded by parentheses.
* An optional <dfn noexport>return type</dfn>, which may have attributes applied.
* The <dfn noexport>function body</dfn>.
    This is the set of statements to be executed when the function is [=function call|called=].

A function declaration [=shader-creation error|must=] only occur at [=module scope=].
A function name is [=in scope=] for the entire program.

Note: Each [=user-defined function=] only has one [=overload=].

A <dfn noexport>formal parameter</dfn> [=declaration=] specifies an [=identifier=] name and a type for a value that [=shader-creation error|must=] be
provided when invoking the function.
A formal parameter may have attributes.
See [[#function-calls]].
The [=scope=] of the identifier is the [=function body=].
Two formal parameters for a given function [=shader-creation error|must not=] have the same name.

Note: Some built-in functions may allow parameters to be [=abstract numeric types=];
however, this functionality is not currently supported for user-declared
functions.

The [=return type=], if specified, [=shader-creation error|must=] be [=constructible=].

WGSL defines the following attributes that can be applied to function declarations:
 * the [=shader stage attributes=]: [=attribute/vertex=], [=attribute/fragment=], and [=attribute/compute=]
 * [=attribute/workgroup_size=]

WGSL defines the following attributes that can be applied to function
parameters and return types:
 * [=attribute/builtin=]
 * [=attribute/location=]
 * [=attribute/interpolate=]
 * [=attribute/invariant=]

<pre class=include>
path: syntax/function_decl.syntax.bs.include
</pre>
<pre class=include>
path: syntax/function_header.syntax.bs.include
</pre>
<pre class=include>
path: syntax/param_list.syntax.bs.include
</pre>
<pre class=include>
path: syntax/param.syntax.bs.include
</pre>

<div class='example wgsl' heading='Simple functions'>
  <xmp>
    // Declare the add_two function.
    // It has two formal parameters, i and b.
    // It has a return type of i32.
    // It has a body with a return statement.
    fn add_two(i: i32, b: f32) -> i32 {
      return i + 2;  // A formal parameter is available for use in the body.
    }

    // A compute shader entry point function, 'main'.
    // It has no specified return type.
    // It invokes the add_two function, and captures
    // the resulting value in the named value 'six'.
    @compute @workgroup_size(1)
    fn main() {
       let six: i32 = add_two(4, 5.0);
    }
  </xmp>
</div>

## Function Calls ## {#function-calls}

A <dfn noexport>function call</dfn> is a statement or expression which invokes a function.

The function containing the function call is the <dfn>calling function</dfn>, or <dfn noexport>caller</dfn>.
The function being invoked is the <dfn>called function</dfn>, or <dfn noexport>callee</dfn>.

The function call:
* Names the [=called function=], and
* Provides a parenthesized, comma-separated list of argument value expressions.

The function call [=shader-creation error|must=] supply the same number of argument values as there are
[=formal parameter|formal parameters=] in the [=called function=].
Each argument value [=shader-creation error|must=] evaluate to the same type as the corresponding formal
parameter, by position.

In summary, when calling a function:
1. Execution of the [=calling function=] is suspended.
2. The [=called function=] executes until it [=returns=].
3. Execution of the [=calling function=] resumes.

A called function <dfn>returns</dfn> as follows:
* A [=built-in function=] returns when its work has completed.
* A [=user-defined function=] with a [=return type=] returns when it executes a [=statement/return=] statement.
* A [=user-defined function=] with no [=return type=] returns when it executes a [=statement/return=] statement,
    or when execution reaches the end of its [=function body=].

In detail, when a function call is executed the following steps occur:
1. Function call argument values are evaluated.
    The relative order of evaluation is left-to-right.
2. Execution of the [=calling function=] is suspended.
    All [=function scope=] variables and constants maintain their current values.
3. If the called function is [=user-defined function|user-defined=],
    memory is allocated for each function scope variable in the called function.
    * Initialization occurs as described in [[#var-decls]].
4. Values for the formal parameters of the called function are determined
    by matching the function call argument values by position.
    For example, the first formal parameter of the called function will have
    the value of the first argument at the [=call site=].
5. Control is transferred to the called function.
    If the called function is [=user-defined function|user-defined=], execution
    proceeds starting from the first statement in the [=function body|body=].
6. The called function is executed, until it [=returns=].
7. Control is transferred back to the calling function, and the called function's execution is
    unsuspended.
    If the called function [=return value|returns a value=], that value is supplied for the
    value of the function call expression.

The location of a function call is referred to as a <dfn noexport>call site</dfn>, specifically
the location of the first [=token=] in the parsed instance of the [=syntax/call_phrase=] grammar rule.
Call sites are a [=dynamic context=].
As such, the same textual location may represent multiple call sites.

Note: It is possible that a function call in a [=fragment=] shader never
returns if all of the invocations in a [=quad=] are [=statement/discard|discarded=].
In such a case, control will not be tranferred back to the calling function.

## `const` Functions ## {#const-funcs}

A function declared with a [=attribute/const=] attribute can be
evaluated at [=shader module creation|shader-creation time=].
These functions are called <dfn noexport>const-functions</dfn>.
Calls to these functions can part of [=const-expressions=].

It is a [=shader-creation error=] if the function contains any expressions that
are not [=const-expressions=], or any declarations that are not
[=const-declarations=].

Note: The [=attribute/const=] attribute cannot be applied to user-declared functions.

<div class='example wgsl' heading='const-functions'>
  <xmp>
    const first_one = firstLeadingBit(1234 + 4567); // Evaluates to 12
                                                    // first_one has the type i32, because
                                                    // firstLeadingBit cannot operate on
                                                    // AbstractInt

    @id(1) override x : i32;
    override y = firstLeadingBit(x); // const-expressions can be
                                     // used in override-expressions.
                                     // firstLeadingBit(x) is not a
                                     // const-expression in this context.

    fn foo() {
      var a : array<i32, firstLeadingBit(257)>; // const-functions can be used in
                                                // const-expressions if all their
                                                // parameters are const-expressions.
    }
  </xmp>
</div>

## Restrictions on Functions ## {#function-restriction}

* A [=vertex=] shader [=shader-creation error|must=] return the [=built-in values/position=] [=built-in output value=].
* An entry point [=shader-creation error|must=] never be the target of a [=function call=].
* If a function has a return type, it [=shader-creation error|must=] be a [=constructible=] type.
* A [=formal parameter|function parameter=] [=shader-creation error|must=] one the following types:
    * a constructible type
    * a pointer type
    * a texture type
    * a sampler type
* Each function call argument [=shader-creation error|must=] evaluate to the type of the corresponding
    function parameter.
    * In particular, an argument that is a pointer [=shader-creation error|must=] agree with the formal parameter
        on [=address space=], [=store type=], and [=access mode=].
* For [=user-defined functions=], a parameter of pointer type [=shader-creation error|must=] be in one of
    the following address spaces:
    * [=address spaces/function=]
    * [=address spaces/private=]
* For [=built-in functions=], a parameter of pointer type [=shader-creation error|must=] be in one of
    the following address spaces:
    * [=address spaces/function=]
    * [=address spaces/private=]
    * [=address spaces/workgroup=]
    * [=address spaces/storage=]
* Each argument of pointer type to a [=user-defined function=]
    [=shader-creation error|must=] have the same [=memory view=] as its [=root
    identifier=].
    * Note: This means no [[#vector-access-expr|vector]],
        [[#matrix-access-expr|matrix]], [[#array-access-expr|array]], or
        [[#struct-access-expr|struct]] access expressions can be applied to
        produce a [=memory view=] into the root identifier when traced from the
        argument back through all the [=let-declarations=].

Note: Recursion is disallowed because cycles are not permitted among any kinds
of declarations.

<div class='example wgsl' heading='Valid and invalid pointer arguments'>
  <xmp>
    fn bar(p : ptr<function, f32>) {
    }

    fn baz(p : ptr<private, i32>) {
    }

    fn bar2(p : ptr<function, f32>) {
      let a = &*&*(p);

      bar(p); // Valid
      bar(a); // Valid
    }

    struct S {
      x : i32
    }

    var usable_priv : i32;
    var unusable_priv : array<i32, 4>;
    fn foo() {
      var usable_func : f32;
      var unusable_func : S;

      let a_priv = &usable_priv;
      let b_priv = a_priv;
      let c_priv = &*&usable_priv;
      let d_priv = &(unusable_priv.x);
      let e_priv = d_priv;

      let a_func = &usable_func;
      let b_func = &unusable_func;
      let c_func = &(*b_func)[0];
      let d_func = c_func;
      let e_func = &*a_func;

      baz(&usable_priv); // Valid, address-of a variable.
      baz(a_priv);       // Valid, effectively address-of a variable.
      baz(b_priv);       // Valid, effectively address-of a variable.
      baz(c_priv);       // Valid, effectively address-of a variable.
      baz(d_priv);       // Invalid, memory view has changed.
      baz(e_priv);       // Invalid, memory view has changed.

      bar(&usable_func); // Valid, address-of a variable.
      bar(c_func);       // Invalid, memory view has changed.
      bar(d_func);       // Invalid, memory view has changed.
      bar(e_func);       // Valid, effectively address-of a variable.
    }
  </xmp>
</div>

### Alias Analysis ### {#alias-analysis}

#### Root Identifier #### {#root-ident-sec}

[=Memory locations=] can be accessed during the execution of a function using [=memory views=].
Within a function, each [=memory view=] has a particular <dfn>root identifier</dfn>, which names
the variable or formal parameter that first provides access to that memory in that function.

Locally derived expressions of [=reference type|reference=] or
[=pointer type|pointer=] type may introduce new names for a particular root identifier,
but each expression has a statically determinable root identifier.

<p algorithm="finding a root identifier">
Given an expression |E| of [=pointer type|pointer=] or [=reference type=], the
[=root identifier=] is the [=originating variable=] or [=formal parameter=] of [=pointer type=]
found as follows:
* If |E| is an identifier [=resolves|resolving=] to a variable, then the root identifier is that variable.
* If |E| is an identifier [=resolves|resolving=] to a formal parameter of pointer type, then the root identifier is that formal parameter.
* If |E| is an identifier [=resolves|resolving=] to a [=let-declaration=] with initializer |E2|, then the root identifier is the root identifier of |E2|.
* If |E| is of the form `(`|E2|`)`, `&`|E2|, `*`|E2|, or |E2|`[`<var ignore>Ei</var>`]` then the root identifier is the root identifier of |E2|.
* If |E| is a [[#vector-access-expr|vector access expression]] of the form |E2|.|swiz|, where |swiz| is a [=swizzle=] name, then the root identifer is the root identifier of |E2|.
* If |E| is a [[#struct-access-expr|structure access expression]] of the form |E2|.<var ignore>member_name</var>, then the root identifer is the root identifier of |E2|.
    <p>

#### Aliasing #### {#aliasing}

While the [=originating variable=] of a [=root identifier=] is a dynamic concept that
depends on the [=call sites=] for the function, WGSL modules can be
statically analyzed to determine the set of all possible [=originating
variables=] for each root identifier.

Two [=root identifiers=] <dfn noexport>alias</dfn> when they have the same
[=originating variable=].
Execution of a WGSL function [=shader-creation error|must not=] potentially
access memory through aliased root identifiers, where one access is a write and
the other is a read or a write.
This is determined by analyzing the program from the leaves of the callgraph
upwards (i.e. topological order).
For each function the analysis records the following sets:
* [=module scope|Module-scope=] variables that are [=write access|written=].
    This includes any module-scope variables that are written in functions called from this function.
* [=module scope|Module-scope=] variables that are [=read access|read=].
    This includes any module-scope variables that are read in functions called from this function.
* Pointer parameters used as root identifiers of memory views that are [=write access|written=] in this function or in called functions.
* Pointer parameters used as root identifiers of memory views that are [=read
    access|read=] in this function or in called functions.

At each [=call site=] of a function, it is a [=shader-creation error=] if any
of the following occur:
* Two arguments of pointer type have the same root identifier and either
    corresponding parameter is in the written parameter set.
* An argument of pointer type whose root identifier is a module-scope variable where:
    * the corresponding pointer parameter is in the set of written pointer parameters, and
    * the module-scope variable is in the read set for the called function.
* An argument of pointer type whose root identifier is a module-scope variable where:
    * the corresponding pointer parameter is in the set of written pointer parameters, and
    * the module-scope variable is in the written set for the called function.
* An argument of pointer type whose root identifier is a module-scope variable where:
    * the corresponding pointer parameter is in the set of read pointer parameters, and
    * the module-scope variable is in the written set for the called function.

<div class='example wgsl' heading='Alias analysis'>
  <xmp>
    var<private> x : i32 = 0;

    fn f1(p1 : ptr<function, i32>, p2 : ptr<function, i32>) {
      *p1 = *p2;
    }

    fn f2(p1 : ptr<function, i32>, p2 : ptr<function, i32>) {
      f1(p1, p2);
    }

    fn f3() {
      var a : i32 = 0;
      f2(&a, &a);  // Invalid. Cannot pass two pointer parameters
                   // with the same root identifier when one or
                   // more are written (even by a subfunction).
    }

    fn f4(p1 : ptr<function, i32>, p2 : ptr<function, i32>) -> i32 {
      return *p1 + *p2;
    }

    fn f5() {
      var a : i32 = 0;
      let b = f4(&a, &a); // Valid. p1 and p2 in f4 are both only read.
    }

    fn f6(p : ptr<private, i32>) {
      x = *p;
    }

    fn f7(p : ptr<private, i32>) -> i32 {
      return x + *p;
    }

    fn f8() {
      let a = f6(&x); // Invalid. x is written as a global variable and
                      // read as a parameter.
      let b = f7(&x); // Valid. x is only read as both a parameter and
                      // a variable.
    }
  </xmp>
</div>

# Attributes # {#attributes}

An <dfn noexport>attribute</dfn> modifies an object.
WGSL provides a unified syntax for applying attributes.
Attributes are used for a variety of purposes such as specifying the interface with the API.

Generally speaking, from the language's point-of-view, attributes can be
ignored for the purposes of type and semantic checking.
Additionally, the attribute name is a [=context-dependent name=], and
some attribute parameters are also context-dependent names.

Unless explicitly permitted below, an attribute [=shader-creation error|must not=] be specified more than once per object or type.

<table class='data'>
  <caption>Attributes defined in WGSL</caption>
  <thead>
    <tr><th>Attribute<th>Valid Values<th>Description
  </thead>

  <tr><td><dfn noexport dfn-for="attribute">`align`</dfn>
    <td>[=shader-creation error|Must=] be a [=const-expression=] that [=type rules|resolves=] to an [=i32=] or [=u32=].<br>
        [=shader-creation error|Must=] be positive.
    <td>[=shader-creation error|Must=] only be applied to a member of a [=structure=] type.

    [=shader-creation error|Must=] be a power of 2.

    Note: This attribute influences how a value of the enclosing structure type can appear in memory:
    at which byte addresses the structure itself and its component members can appear.
    In particular, the rules in [[#memory-layouts]] combine to imply the following constraint:

    <p class="note" algorithm="implied constraint on align attribute">
    If `align(`|n|`)` is applied to a member of |S|
    with type |T|, and |S| is the [=store type=]
    or contained in the store type for a variable in address space |C|,
    then |n| [=shader-creation error|must=] satisfy:
    |n|&nbsp;=&nbsp;|k|&nbsp;&times;&nbsp;[=RequiredAlignOf=](|T|,|C|)
    for some positive integer |k|.
    </p>

  <tr><td><dfn noexport dfn-for="attribute">`binding`</dfn>
    <td>[=shader-creation error|Must=] be a [=const-expression=] that [=type rules|resolves=] to an [=i32=] or [=u32=].<br>
        [=shader-creation error|Must=] be non-negative.
    <td>[=shader-creation error|Must=] only be applied to a [=resource=] variable.

    Specifies the binding number of the resource in a bind [=attribute/group=].
    See [[#resource-interface]].

  <tr><td><dfn noexport dfn-for="attribute">`builtin`</dfn>
    <td>[=shader-creation error|Must=] be an [=enumerant=] for a [=built-in value=].
    <td>[=shader-creation error|Must=] only be applied to an entry point
    function parameter, entry point return type, or member of a [=structure=].

    Specifies that the associated object is a built-in value, as denoted by the specified [=enumerant=].
    See [[#builtin-inputs-outputs]].

  <tr><td><dfn noexport dfn-for="attribute">`const`</dfn>
    <td>*None*
    <td>Must only be applied to function declarations.

    Specifies that the function can be used as a [=const-function=].
    This attribute [=shader-creation error|must not=] be applied to a
    user-defined function.

    Note: This attribute is used as a notational convention to describe which
    built-in functions can be used in [=const-expressions=].

  <tr><td><dfn noexport dfn-for="attribute">`diagnostic`</dfn>
    <td>Two parameters.

        The first parameter is a [=syntax/severity_control_name=].

        The second parameter is a [=syntax/diagnostic_rule_name=] token
        specifying a [=diagnostic/triggering rule=].

    <td>Specifies a [=range diagnostic filter=].  See [[#diagnostics]].

        More than one [=attribute/diagnostic=] attribute may be specified on a syntactic form,
        but they [=shader-creation error|must=] specify different [=diagnostic/triggering rules=].

  <tr><td><dfn noexport dfn-for="attribute">`group`</dfn>
    <td>[=shader-creation error|Must=] be a [=const-expression=] that [=type rules|resolves=] to an [=i32=] or [=u32=].<br>
        [=shader-creation error|Must=] be non-negative.
    <td>[=shader-creation error|Must=] only be applied to a [=resource=] variable.

    Specifies the binding group of the resource.
    See [[#resource-interface]].

  <tr><td><dfn noexport dfn-for="attribute">`id`</dfn>
    <td>[=shader-creation error|Must=] be a [=const-expression=] that [=type rules|resolves=] to an [=i32=] or [=u32=].<br>
        [=shader-creation error|Must=] be non-negative.
    <td>[=shader-creation error|Must=] only be applied to an [=override-declaration=] of [=scalar=] type.

    Specifies a numeric identifier as an alternate name for a
    [=pipeline-overridable=] constant.

  <tr><td><dfn noexport dfn-for="attribute">`interpolate`</dfn>
    <td>One or two parameters.

    The first parameter [=shader-creation error|must=] be an [=enumerant=] for an [=interpolation type=].

    The second parameter, if present, [=shader-creation error|must=] be
    an [=enumerant=] for the [=interpolation sampling=].

    <td>[=shader-creation error|Must=] only be applied to a declaration that
    has a [=attribute/location=] attribute applied.

    Specifies how the user-defined IO [=shader-creation error|must=] be interpolated.
    The attribute is only significant on user-defined [=vertex=] outputs
    and [=fragment=] inputs.
    See [[#interpolation]].

  <tr><td><dfn noexport dfn-for="attribute">`invariant`</dfn>
    <td>*None*
    <td>[=shader-creation error|Must=] only be applied to the [=built-in values/position=] built-in value.

    When applied to the [=built-in values/position=] [=built-in output value=] of a vertex
    shader, the computation of the result is invariant across different
    programs and different invocations of the same entry point.
    That is, if the data and control flow match for two `position` outputs in
    different entry points, then the result values are guaranteed to be the
    same.
    There is no affect on a `position` [=built-in input value=].

    Note: This attribute maps to the `precise` qualifier in HLSL, and the
    `invariant` qualifier in GLSL.

  <tr><td><dfn noexport dfn-for="attribute">`location`</dfn>
    <td>[=shader-creation error|Must=] be a [=const-expression=] that [=type rules|resolves=] to an [=i32=] or [=u32=].<br>
        [=shader-creation error|Must=] be non-negative.
    <td>[=shader-creation error|Must=] only be applied to an entry point function parameter, entry point
    return type, or member of a [=structure=] type.
    [=shader-creation error|Must=] only be applied to declarations of objects with [=numeric scalar=]
    or [=numeric vector=] type.
    [=shader-creation error|Must not=] be used with the [=compute=] shader stage.

    Specifies a part of the user-defined IO of an entry point.
    See [[#input-output-locations]].

  <tr><td><dfn noexport dfn-for="attribute">`must_use`</dfn>
    <td>*None*
    <td>[=shader-creation error|Must=] only be applied to the declaration of a [=function/function=] with a [=return type=].

        Specifies that a [=function call|call=] to this function [=shader-creation error|must=] be used as an [=expression=].
        That is, a call to this function [=shader-creation error|must=] not be the entirety of a [[#function-call-statement|function call statement]].

        Note: Many functions return a value and do not have side effects.
        It is often a programming defect to call such a function as the only thing in a function call statement.
        Built-in functions with these properties are declared as `@must_use`.
        User-defined functions can also have the `@must_use` attribute.

        Note: To deliberately work around the `@must_use` rule, use a [=phony assignment=]
        or [=value declaration|declare a value=] using the function call as the initializer.

  <tr><td><dfn noexport dfn-for="attribute">`size`</dfn>
    <td>[=shader-creation error|Must=] be a [=const-expression=] that [=type rules|resolves=] to an [=i32=] or [=u32=].<br>
        [=shader-creation error|Must=] be positive.
    <td>[=shader-creation error|Must=] only be applied to a member of a [=structure=] type.
    The member type [=shader-creation error|must=] have [=creation-fixed footprint=].

    The number of bytes reserved in the struct for this member.

    This number [=shader-creation error|must=] be at least the [=byte-size=] of the type of the member:
    <p algorithm="byte-size constraint">
    If `size(`|n|`)` is applied to a member with type |T|, then [=SizeOf=](|T|)&nbsp;&leq;&nbsp;|n|.
    </p>

    See [[#memory-layouts]]

  <tr><td><dfn noexport dfn-for="attribute">`workgroup_size`</dfn>
    <td>One, two or three parameters.

    Each parameter [=shader-creation error|must=] be a [=const-expression=] or an [=override-expression=].
    All parameters [=shader-creation error|must=] be the same type, either [=i32=] or [=u32=].

    A [=shader-creation error=] results if any specified parameter is a
    [=const-expression=] that evaluates to a non-positive value.

    A [=pipeline-creation error=] results if any specified parameter evaluates
    to a non-positive value or exceeds an upper bound specified by the WebGPU
    API, or if the product of the parameter values exceeds the upper bound
    specified by the WebGPU API (see [[WebGPU#limits]]).
    <td>[=shader-creation error|Must=] be applied to a [=compute shader stage|compute shader=] entry point function.
    [=shader-creation error|Must not=] be applied to any other object.

    Specifies the x, y, and z dimensions of the [=workgroup grid=] for the compute shader.

    The first parameter specifies the x dimension.
    The second parameter, if provided, specifies the y dimension, otherwise is assumed to be 1.
    The third parameter, if provided, specifies the z dimension, otherwise is assumed to be 1.

</table>

The <dfn noexport>shader stage attributes</dfn> below
designate a function as an [=entry point=] for a particular [=shader stage=].
These attributes [=shader-creation error|must=] only be applied to [=function declarations=],
and at most one may be present on a given function.
They take no parameters.

<table class='data'>
  <caption>Shader Stage Attributes</caption>
  <thead>
    <tr><th>Attribute<th>Description
  </thead>

  <tr><td><dfn noexport dfn-for="attribute">`vertex`</dfn><br>
    <td>Declares the function to be an [=entry point=] for the [=vertex shader stage=]
    of a [=GPURenderPipeline|render pipeline=].

  <tr><td><dfn noexport dfn-for="attribute">`fragment`</dfn><br>
    <td>Declares the function to be an [=entry point=] for the [=fragment shader stage=]
    of a [=GPURenderPipeline|render pipeline=].

  <tr><td><dfn noexport dfn-for="attribute">`compute`</dfn><br>
    <td>Declares the function to be an [=entry point=] for the [=compute shader stage=]
    of a [=GPUComputePipeline|compute pipeline=].

</table>

<pre class=include>
path: syntax/attribute.syntax.bs.include
</pre>
<pre class=include>
path: syntax/attrib_end.syntax.bs.include
</pre>
<pre class=include>
path: syntax/diagnostic_control.syntax.bs.include
</pre>

# Entry Points # {#entry-points}

An <dfn noexport>entry point</dfn> is a [=user-defined function=] that performs
the work for a particular [=shader stage=].

## Shader Stages ## {#shader-stages-sec}

WebGPU issues work to the GPU in the form of [=draw command|draw=] or [=dispatch commands=].
These commands execute a pipeline in the context of a set of shader stage
[=shader stage input|inputs=], [=shader stage output|outputs=], and attached
[=resources=].

A <dfn noexport>pipeline</dfn> describes the work to be performed on the GPU, as a sequence
of stages, some of which are programmable.
In WebGPU, a pipeline is created before scheduling a draw or dispatch command for execution.
There are two kinds of pipelines: GPUComputePipeline, and GPURenderPipeline.

A [=dispatch command=] uses a <dfn noexport>GPUComputePipeline</dfn> to run a
<dfn noexport>compute shader stage</dfn> over a logical
grid of points with a controllable amount of parallelism,
while reading and possibly updating buffer and image resources.

A [=draw command=] uses a <dfn noexport>GPURenderPipeline</dfn> to run a multi-stage process with
two programmable stages among other fixed-function stages:

* A <dfn noexport>vertex shader stage</dfn> maps input attributes for a single vertex into
    output attributes for the vertex.
* Fixed-function stages map vertices into graphic primitives (such as triangles)
    which are then rasterized to produce fragments.
* A <dfn noexport>fragment shader stage</dfn> processes each fragment,
    possibly producing a fragment output.
* Fixed-function stages consume a fragment output, possibly updating external state
    such as color attachments and depth and stencil buffers.

The WebGPU specification describes pipelines in greater detail.

WGSL defines three <dfn noexport>shader stages</dfn>, corresponding to the
programmable parts of pipelines:

* <dfn noexport>compute</dfn>
* <dfn noexport>vertex</dfn>
* <dfn noexport>fragment</dfn>

Each shader stage has its own set of features and constraints, described elsewhere.

## Entry Point Declaration ## {#entry-point-decl}

To create an [=entry point=], declare a [=user-defined function=] with a [=shader stage attribute=].

When configuring a [=pipeline=] in the WebGPU API,
the entry point's function name maps to the `entryPoint` attribute of the
WebGPU {{GPUProgrammableStage}} object.

The entry point's [=formal parameters=] denote the stage's [=shader stage inputs=].
The entry point's [=return value=], if specified, denotes the stage's [=shader stage outputs=].

The type of each formal parameter, and the entry point's return type, [=shader-creation error|must=] be one of:
* [=bool=]
* a [=numeric scalar=]
* a [=numeric vector=]
* a [=structure=] whose member types are any of [=bool=], [=numeric scalar=], or [=numeric vector=].

A structure type can be used to group [=user-defined input datum|user-defined inputs=] with each other and optionally with [=built-in input value|built-in inputs=].
A structure type can be used as the [=return type=] to group [=user-defined output datum|user-defined outputs=] with each other and optionally with [=built-in output value|built-in outputs=].

Note: The [=bool=] case is forbidden for user-defined inputs and outputs.
It is only permitted for the [=built-in values|front_facing builtin value=].

Note: [=Compute=] entry points never have a return type.

<div class='example wgsl global-scope' heading='Entry Point'>
  <xmp>
    @vertex
    fn vert_main() -> @builtin(position) vec4<f32> {
      return vec4<f32>(0.0, 0.0, 0.0, 1.0);
    }

    @fragment
    fn frag_main(@builtin(position) coord_in: vec4<f32>) -> @location(0) vec4<f32> {
      return vec4<f32>(coord_in.x, coord_in.y, 0.0, 1.0);
    }

    @compute @workgroup_size(1)
    fn comp_main() { }
  </xmp>
</div>

The set of <dfn noexport>functions in a shader stage</dfn> is the union of:

* The entry point function for the stage.
* The targets of function calls from within the body of a function
    in the shader stage, whether or not that call is executed.

The union is applied repeatedly until it stabilizes.
It will stabilize in a finite number of steps.

### Function Attributes for Entry Points ### {#entry-point-attributes}

WGSL defines the following attributes that can be applied to entry point declarations:
 * the [=shader stage attributes=]: [=attribute/vertex=], [=attribute/fragment=], and [=attribute/compute=]
 * [=attribute/workgroup_size=]

<div class='example wgsl global-scope' heading='workgroup_size Attribute'>
  <xmp>
    @compute @workgroup_size(8,4,1)
    fn sorter() { }

    @compute @workgroup_size(8u)
    fn reverser() { }

    // Using an pipeline-overridable constant.
    @id(42) override block_width = 12u;
    @compute @workgroup_size(block_width)
    fn shuffler() { }

    // Error: workgroup_size must be specified on compute shader
    @compute
    fn bad_shader() { }
  </xmp>
</div>

## Shader Interface ## {#shader-interface}

The shader interface is the set of objects
through which the shader accesses data external to the [=shader stage=],
either for reading or writing, and the [=pipeline-overridable=] constants used to configure the shader.
The interface includes:

* [=Shader stage inputs=]
* [=Shader stage outputs=]
* [=Override-declarations=]
* Attached [=resources=], which include:
    * [=Uniform buffers=]
    * [=Storage buffers=]
    * [=Texture resources=]
    * [=Sampler resources=]

A declaration *D* is <dfn>statically accessed</dfn> by a shader when:
* An identifier [=resolves|resolving=] to *D* appears in the [=function declaration|declaration=]
    of any of the [=functions in a shader stage|functions in the shader stage=].
* An identifier [=resolves|resolving=] to *D* is used to define a type for a [=statically accessed=] declaration.
* An identifier [=resolves|resolving=] to *D* is used in the initializer for a [=statically accessed=] declaration.
* An identifier [=resolves|resolving=] to *D* is used by an attribute used by a [=statically accessed=] declaration.

<div class="note"><span class=marker>Note:</span>Static access is recursively defined, taking into account the following:
* All the parts of a [=function declaration=] including attributes, formal parameters, return type, and function body.
* Any type needed to define the above, including following [=type aliases=].
* As a particular case of helping to define a type,
    any [=override-declaration=] used in an [=override-expression=] that is the [=element count=]
    of an [=array=] type for a variable in the [=address spaces/workgroup=] address space,
    when that variable itself is statically accessed.
* Any override declarations used to support the evaluation of override-expressions in any of the above.
* Any attributes on any of the above.
    </div>

We can now precisely define the <dfn noexport>interface of a shader</dfn> as consisting of:
  - The [=formal parameters=] of the [=entry point=].
     These denote the shader stage inputs.
  - The [=return value=] of the entry point.
     This denotes the shader stage outputs.
  - The [=uniform buffer=], [=storage buffer=], [=texture resource=], and [=sampler resource=] variables
        [=statically accessed=] by the shader.
  - The [=override-declarations=]
        [=statically accessed=] by the shader.

### Inter-stage Input and Output Interface ### {#stage-inputs-outputs}

A <dfn>shader stage input</dfn> is a datum provided to the shader stage from upstream in the pipeline.
Each datum is either a [=built-in input value=], or a [=user-defined input datum|user-defined input=].

A <dfn>shader stage output</dfn> is a datum the shader provides for further processing downstream in the pipeline.
Each datum is either a [=built-in output value=], or a [=user-defined output datum|user-defined output=].

[=IO attributes=] are used to establish an object as a [=shader stage input=] or a [=shader stage output=],
or to further describe the properties of an input or output.
The <dfn noexport>IO attributes</dfn> are:
* [=attribute/builtin=]
* [=attribute/location=]
* [=attribute/interpolate=]
* [=attribute/invariant=]

#### Built-in Inputs and Outputs #### {#builtin-inputs-outputs}

A <dfn noexport>built-in input value</dfn> provides access to system-generated control information.
An entry point [=shader-creation error|must=] not contain duplicated built-in inputs.

A built-in input for stage *S* with name *X* and type *T*<sub>*X*</sub> is accessed via a
[=formal parameter=] to an [=entry point=] for [=shader stage=] *S*, in one of two ways:

1. The parameter has attribute `builtin(`*X*`)` and is of type *T*<sub>*X*</sub>.
2. The parameter has structure type, where one of the structure members has attribute `builtin(`*X*`)` and is of type *T*<sub>*X*</sub>.

Conversely, when a parameter or member of a parameter for an entry point has a [=attribute/builtin=] attribute,
the corresponding builtin [=shader-creation error|must=] be an input for the entry point's shader stage.

A <dfn noexport>built-in output value</dfn> is used by the shader to convey
control information to later processing steps in the pipeline.
An entry point [=shader-creation error|must=] not contain duplicated built-in outputs.

A built-in output for stage *S* with name *Y* and type *T*<sub>*Y*</sub> is set via the [=return value=] for an
[=entry point=] for [=shader stage=] *S*, in one of two ways:

1. The entry point [=return type=] has attribute `builtin(`*Y*`)` and is of type *T*<sub>*Y*</sub>.
2. The entry point [=return type=] has structure type, where one of the structure members has attribute `builtin(`*Y*`)` and is of type *T*<sub>*Y*</sub>.

Conversely, when the return type or member of a return type for an entry point has a [=attribute/builtin=] attribute,
the corresponding builtin [=shader-creation error|must=] be an output for the entry point's shader stage.

Note: The [=built-in values/position=] built-in is both an output of a vertex shader, and an input to the fragment shader.

Collectively, built-in input and built-in output values are known as <dfn noexport>built-in values</dfn>.

The following table summarizes the available built-in values.
Each is a [=predeclared=] [=enumerant=].
Each is described in detail in subsequent sections.

<table class='data'>
  <caption>Built-in input and output values</caption>
  <thead>
    <tr><th>Predeclared Name<th>Stage<th>Direction<th>Type
  </thead>

  <tr><td>[=built-in values/vertex_index=]
      <td>vertex
      <td>input
      <td>u32

  <tr><td>[=built-in values/instance_index=]
      <td>vertex
      <td>input
      <td>u32

  <tr><td rowspan=2>[=built-in values/position=]
      <td>vertex
      <td>output
      <td>vec4&lt;f32&gt;

  <tr>
      <td>fragment
      <td>input
      <td>vec4&lt;f32&gt;

  <tr><td>[=built-in values/front_facing=]
      <td>fragment
      <td>input
      <td>bool

  <tr><td>[=built-in values/frag_depth=]
      <td>fragment
      <td>output
      <td>f32

  <tr><td>[=built-in values/sample_index=]
      <td>fragment
      <td>input
      <td>u32

  <tr><td rowspan=2>[=built-in values/sample_mask=]
      <td>fragment
      <td>input
      <td>u32

  <tr>
      <td>fragment
      <td>output
      <td>u32

  <tr><td>[=built-in values/local_invocation_id=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;

  <tr><td>[=built-in values/local_invocation_index=]
      <td>compute
      <td>input
      <td>u32

  <tr><td>[=built-in values/global_invocation_id=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;

  <tr><td>[=built-in values/workgroup_id=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;

  <tr><td>[=built-in values/num_workgroups=]
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
</table>

<div class='example wgsl global-scope' heading="Declaring built-in values">
  <xmp>
    struct VertexOutput {
      @builtin(position) my_pos: vec4<f32>
    }

    @vertex
    fn vs_main(
      @builtin(vertex_index) my_index: u32,
      @builtin(instance_index) my_inst_index: u32,
    ) -> VertexOutput {}

    struct FragmentOutput {
      @builtin(frag_depth) depth: f32,
      @builtin(sample_mask) mask_out: u32
    }

    @fragment
    fn fs_main(
      @builtin(front_facing) is_front: bool,
      @builtin(position) coord: vec4<f32>,
      @builtin(sample_index) my_sample_index: u32,
      @builtin(sample_mask) mask_in: u32,
    ) -> FragmentOutput {}

    @compute @workgroup_size(64)
    fn cs_main(
      @builtin(local_invocation_id) local_id: vec3<u32>,
      @builtin(local_invocation_index) local_index: u32,
      @builtin(global_invocation_id) global_id: vec3<u32>,
   ) {}
  </xmp>
</div>

##### `frag_depth` ##### {#frag-depth-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">frag_depth</dfn>
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>f32
  <tr><td style="width:10%">Direction
      <td>Output
  <tr><td style="width:10%">Description
      <td>
      Updated depth of the fragment, in the viewport depth range.

      See [[WebGPU#coordinate-systems]].
</table>

##### `front_facing` ##### {#front-facing-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">front_facing</dfn>
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>bool
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      True when the current fragment is on a [=front-facing=] primitive.
      False otherwise.
</table>

##### `global_invocation_id` ##### {#global-invocation-id-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">global_invocation_id</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>vec3&lt;u32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The current invocation's [=global invocation ID=], i.e. its position in
      the [=compute shader grid=]. The value of [=built-in values/global_invocation_id=]
      is equal to [=built-in values/workgroup_id=] * [=attribute/workgroup_size=] +
      [=built-in values/local_invocation_id=].

</table>

##### `instance_index` ##### {#instance-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">instance_index</dfn>
  <tr><td style="width:10%">Stage
      <td>[=vertex shader stage|vertex=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      Instance index of the current vertex within the current API-level draw command.

      The first instance has an index equal to the `firstInstance` argument of the draw,
      whether provided directly or indirectly.
      The index is incremented by one for each additional instance in the draw.
</table>

##### `local_invocation_id` ##### {#local-invocation-id-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">local_invocation_id</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>vec3&lt;u32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The current invocation's [=local invocation ID=], i.e. its position in
      the [=workgroup grid=].
</table>

##### `local_invocation_index` ##### {#local-invocation-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">local_invocation_index</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The current invocation's [=local invocation index=], a linearized index of
      the invocation's position within the [=workgroup grid=].
</table>

##### `num_workgroups` ##### {#num-workgroups-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">num_workgroups</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>vec3&lt;u32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The [=dispatch size=], `vec3<u32>(group_count_x, group_count_y,
      group_count_z)`, of the compute shader
      [[WebGPU#compute-pass-encoder-dispatch|dispatched]] by the API.
</table>

##### `position` ##### {#position-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">position</dfn>
  <tr><td style="width:10%">Stage
      <td>[=vertex shader stage|vertex=]
  <tr><td style="width:10%">Type
      <td>vec4&lt;f32&gt;
  <tr><td style="width:10%">Direction
      <td>Output
  <tr><td style="width:10%">Description
      <td>
      The [=clip position=] of the current vertex,
      in [=clip space coordinates=].

      An output value (*x*,*y*,*z*,*w*)
      [=behavioral requirement|will=] map to (*x*/*w*, *y*/*w*, *z*/*w*) in
      WebGPU [=normalized device coordinates=].

      See [[WebGPU#coordinate-systems]] and [[WebGPU#primitive-clipping]].
</table>

<table class='data'>
  <tr><td style="width:10%">Name
      <td>position
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>vec4&lt;f32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      <div algorithm="fragment position calculation">
      Input position of the current fragment.

      Let |fp| be the input position of the fragment.<br>
      Let |rp| be the [=RasterizationPoint=] for the fragment.<br>
      Let |vp| be the {{RenderState/[[viewport]]}} in effect for the draw command.

      Then schematically:
      <blockquote>
      |fp|.xy = |rp|.[=rasterizationpoint-destination|destination=].[=fragmentdestination-position|position=]<br>
      |fp|.z = |rp|.[=rasterizationpoint-depth|depth=]<br>
      |fp|.w = |rp|.[=rasterizationpoint-perspectivedivisor|perspectiveDivisor=]
      </blockquote>

      In more detail:
      *  |fp|.x and |fp|.y are the interpolated x and y coordinates of the
          position the current fragment in
          the [=framebuffer=].

          The framebuffer is a two-dimensional grid of pixels with the top-left at (0.0,0.0)
          and the bottom right at (|vp|.width, |vp|.height).
          Each pixel has an extent of 1.0 unit in each of the x and y dimensions,
          and pixel centers are at (0.5,0.5) offset from integer coordinates.

      * |fp|.z is the interpolated depth of the current fragment.
          For example:
          * depth 0 in [=normalized device coordinates=] maps to |fp|.z = |vp|.minDepth,
          * depth 1 in normalized device coordinates maps to |fp|.z = |vp|.maxDepth.

      * |fp|.w is the perspective divisor for the fragment,
          which is the interpolation of 1.0 &divide; |vertex_w|,
          where |vertex_w| is the w component
          of the [=built-in values/position=] output of the vertex shader.

      See [[WebGPU#coordinate-systems]] and [[WebGPU#rasterization]].
      </div>
</table>

##### `sample_index` ##### {#sample-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">sample_index</dfn>
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      Sample index for the current fragment.  The value is least 0 and at most
      `sampleCount`-1, where `sampleCount` is the MSAA sample
      {{GPUMultisampleState/count}} specified for the GPU render pipeline.

      See [[WebGPU#gpurenderpipeline]].
</table>

##### `sample_mask` ##### {#sample-mask-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">sample_mask</dfn>
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      Sample coverage mask for the current fragment.  It contains a bitmask
      indicating which samples in this fragment are covered by the primitive
      being rendered.

      See [[WebGPU#sample-masking]].
</table>

<table class='data'>
  <tr><td style="width:10%">Name
      <td>sample_mask
  <tr><td style="width:10%">Stage
      <td>[=fragment shader stage|fragment=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Output
  <tr><td style="width:10%">Description
      <td>
      Sample coverage mask control for the current fragment.  The last value
      written to this variable becomes the [=shader-output mask=].  Zero bits
      in the written value will cause corresponding samples in the color
      attachments to be discarded.

      See [[WebGPU#sample-masking]].
</table>

##### `vertex_index` ##### {#vertex-index-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">vertex_index</dfn>
  <tr><td style="width:10%">Stage
      <td>[=vertex shader stage|vertex=]
  <tr><td style="width:10%">Type
      <td>u32
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      Index of the current vertex within the current API-level draw command,
      independent of draw instancing.

      For a non-indexed draw, the first vertex has an index equal to the `firstVertex` argument
      of the draw, whether provided directly or indirectly.
      The index is incremented by one for each additional vertex in the draw instance.

      For an indexed draw, the index is equal to the index buffer entry for the
      vertex, plus the `baseVertex` argument of the draw, whether provided directly or indirectly.
</table>

##### `workgroup_id` ##### {#workgroup-id-builtin-value}

<table class='data'>
  <tr><td style="width:10%">Name
      <td><dfn noexport dfn-for="built-in values">workgroup_id</dfn>
  <tr><td style="width:10%">Stage
      <td>[=compute shader stage|compute=]
  <tr><td style="width:10%">Type
      <td>vec3&lt;u32&gt;
  <tr><td style="width:10%">Direction
      <td>Input
  <tr><td style="width:10%">Description
      <td>
      The current invocation's [=workgroup ID=], i.e. the position of the
      workgroup in overall [=compute shader grid=].

      All invocations in the same workgroup have the same workgroup ID.

      Workgroup IDs span from (0,0,0) to ([=group_count_x=] - 1,
      [=group_count_y=] - 1, [=group_count_z=] - 1).
</table>

#### User-defined Inputs and Outputs #### {#user-defined-inputs-outputs}

User-defined data can be passed as input to the start of a pipeline, passed
between stages of a pipeline or output from the end of a pipeline.

Each <dfn noexport>user-defined input datum</dfn> and
<dfn noexport>user-defined output datum</abbrev></dfn> [=shader-creation error|must=]:
* be of [=numeric scalar=] type or [=numeric vector=] type.
* be assigned an IO location. See [[#input-output-locations]].


A [=compute=] shader [=shader-creation error|must not=] have user-defined inputs or outputs.

#### Input-output Locations #### {#input-output-locations}

Each input-output location can store a value up to 16 bytes in size.
The byte size of a type is defined using the *SizeOf* column in [[#alignment-and-size]].
For example, a four-component vector of floating-point values occupies a single location.

IO locations are specified via the [=attribute/location=] attribute.

Each user-defined [=user-defined input datum|input=] and [=user-defined output datum|output=] [=shader-creation error|must=] have an explicitly specified IO location.
Each structure member in the entry point IO [=shader-creation error|must=] be one of either a built-in value
(see [[#builtin-inputs-outputs]]), or assigned a location.

Locations [=shader-creation error|must not=] overlap within each of the following sets:
* Members within a structure type.
    This applies to any structure, not just those used in shader stage inputs or outputs.
* An entry point's shader stage inputs,
    i.e. locations for its formal parameters, or for the members of its formal parameters of structure type.

Note: Location numbering is distinct between inputs and outputs:
Location numbers for an entry point's shader stage inputs do not conflict with location numbers for the entry point's shader stage outputs.

Note: No additional rule is required to prevent location overlap within an entry point's outputs.
When the output is a structure, the first rule above prevents overlap.
Otherwise, the output is a scalar or a vector, and can have only a single location assigned to it.

Note: The number of available locations for an entry point is defined by the WebGPU API.

<div class='example wgsl applying location attribute' heading='Applying location attributes'>
  <xmp>
    struct A {
      @location(0) x: f32,
      // Despite locations being 16-bytes, x and y cannot share a location
      @location(1) y: f32
    }

    // in1 occupies locations 0 and 1.
    // in2 occupies location 2.
    // The return value occupies location 0.
    @fragment
    fn fragShader(in1: A, @location(2) in2: f32) -> @location(0) vec4<f32> {
     // ...
    }
  </xmp>
</div>

User-defined IO can be mixed with built-in values in the same structure. For example,

<div class='example wgsl mixing builtins and user-defined IO' heading='Mixing builtins and user-defined IO'>
  <xmp>
    // Mixed builtins and user-defined inputs.
    struct MyInputs {
      @location(0) x: vec4<f32>,
      @builtin(front_facing) y: bool,
      @location(1) @interpolate(flat) z: u32
    }

    struct MyOutputs {
      @builtin(frag_depth) x: f32,
      @location(0) y: vec4<f32>
    }

    @fragment
    fn fragShader(in1: MyInputs) -> MyOutputs {
      // ...
    }
  </xmp>
</div>

<div class='example wgsl invalid locations' heading='Invalid location assignments'>
  <xmp>
    struct A {
      @location(0) x: f32,
      // Invalid, x and y cannot share a location.
      @location(0) y: f32
    }

    struct B {
      @location(0) x: f32
    }

    struct C {
      // Invalid, structures with user-defined IO cannot be nested.
      b: B
    }

    struct D {
      x: vec4<f32>
    }

    @fragment
    // Invalid, location cannot be applied to a structure type.
    fn fragShader1(@location(0) in1: D) {
      // ...
    }

    @fragment
    // Invalid, in1 and in2 cannot share a location.
    fn fragShader2(@location(0) in1: f32, @location(0) in2: f32) {
      // ...
    }

    @fragment
    // Invalid, location cannot be applied to a structure.
    fn fragShader3(@location(0) in1: vec4<f32>) -> @location(0) D {
      // ...
    }
  </xmp>
</div>

#### Interpolation #### {#interpolation}

Authors can control how user-defined IO data is interpolated through the use of
the [=attribute/interpolate=] attribute.
WGSL offers two aspects of interpolation to control: the type of
interpolation, and the sampling of the interpolation.

The <dfn noexport>interpolation type</dfn> [=shader-creation error|must=] be one of the following [=predeclared=] [=enumerants=]:
: <dfn for="interpolation type">perspective</dfn>
:: Values are interpolated in a perspective correct manner.
: <dfn for="interpolation type">linear</dfn>
:: Values are interpolated in a linear, non-perspective correct manner.
: <dfn for="interpolation type">flat</dfn>
:: Values are not interpolated.
    Interpolation sampling is not used with `flat` interpolation.

The <dfn noexport>interpolation sampling</dfn> [=shader-creation error|must=] be one of the following [=predeclared=] [=enumerants=]:
: <dfn for="interpolation sampling">center</dfn>
:: Interpolation is performed at the center of the pixel.
: <dfn for="interpolation sampling">centroid</dfn>
:: Interpolation is performed at a point that lies within all the
    samples covered by the fragment within the current primitive.
    This value is the same for all samples in the primitive.
: <dfn for="interpolation sampling">sample</dfn>
:: Interpolation is performed per sample.
    The [=fragment=] shader is invoked once per sample when this attribute is
    applied.

For user-defined IO of scalar or vector floating-point type:
* If the interpolation attribute is not specified, then `@interpolate(perspective, center)` is assumed.
* If the interpolation attribute is specified with an interpolation type:
    * If the interpolation type is `flat`, then interpolation sampling [=shader-creation error|must not=] be specified.
    * If the interpolation type is `perspective` or `linear`, then:
         * Any interpolation sampling is valid.
         * If interpolation sampling is not specified, `center` is assumed.

User-defined [=vertex=] outputs and [=fragment=] inputs of scalar or vector
integer type [=shader-creation error|must=] always be specified as
`@interpolate(flat)`.

Interpolation attributes [=shader-creation error|must=] match between [=vertex=] outputs and [=fragment=]
inputs with the same [=attribute/location=] assignment within the same [=pipeline=].


### Resource Interface ### {#resource-interface}

A <dfn noexport>resource</dfn> is an object which provides access to data external to a [=shader stage=],
and which is not an [=override-declaration=] and not a [[#stage-inputs-outputs|shader stage input or output]].
Resources are shared by all invocations of the shader.

There are four kinds of resources:

* [=Uniform buffers=]
* [=Storage buffers=]
* [=Texture resources=]
* [=Sampler resources=]

The <dfn noexport>resource interface of a shader</dfn> is the set of module-scope
resource variables [=statically accessed=] by
[=functions in a shader stage|functions in the shader stage=].

Each resource variable [=shader-creation error|must=] be declared with both [=attribute/group=] and [=attribute/binding=]
attributes.
Together with the shader's stage, these identify the binding address
of the resource on the shader's pipeline.
See [[WebGPU#gpupipelinelayout]].

Two different resource variables in a [=shader=] [=shader-creation error|must
not=] have the same [=attribute/group=] and [=attribute/binding=] values, when
considered as a pair.

### Resource Layout Compatibility ### {#resource-layout-compatibility}

WebGPU requires that a shader's resource interface match the [[WebGPU#gpupipelinelayout|layout of the pipeline]]
using the shader.

It is a [=pipeline-creation error=] if a WGSL variable in a resource interface is bound to an incompatible WebGPU
[=binding resource type=] or [=binding type=],
where compatibility is defined by the following table.
<table class='data'>
  <caption>WebGPU binding type compatibility</caption>
  <thead>
    <tr><th>WGSL resource
        <th>WebGPU<br>[=binding resource type|resource type=]
        <th>WebGPU [=binding member=]
        <th colspan=2>WebGPU [=binding type=]
  </thead>
  <tr><td>[=uniform buffer=]
      <td rowspan=3>{{GPUBufferBinding}}
      <td rowspan=3>{{GPUBindGroupLayoutEntry/buffer}}
      <td rowspan=3>GPUBufferBindingType
      <td>{{GPUBufferBindingType/"uniform"}}
  <tr><td>[=storage buffer=] with [=access/read_write=] access
      <td>{{GPUBufferBindingType/"storage"}}
  <tr><td>[=storage buffer=] with [=access/read=] access
      <td>{{GPUBufferBindingType/"read-only-storage"}}
  <tr><td rowspan=2>[=type/sampler=]
      <td rowspan=3>{{GPUSampler}}
      <td rowspan=3>{{GPUBindGroupLayoutEntry/sampler}}
      <td rowspan=3>GPUSamplerBindingType
      <td>{{GPUSamplerBindingType/"filtering"}}
  <tr>
      <td>{{GPUSamplerBindingType/"non-filtering"}}
  <tr><td>[=type/sampler_comparison=]
      <td>{{GPUSamplerBindingType/"comparison"}}
  <tr><td rowspan=5>[=type/sampled texture=],
                    [=type/depth texture=], or
                    [=type/multisampled texture=]
      <td rowspan=5>{{GPUTextureView}}
      <td rowspan=5>{{GPUBindGroupLayoutEntry/texture}}
      <td rowspan=5>GPUTextureSampleType
      <td>{{GPUTextureSampleType/"float"}}
  <tr>
      <td>{{GPUTextureSampleType/"unfilterable-float"}}
  <tr>
      <td>{{GPUTextureSampleType/"sint"}}
  <tr>
      <td>{{GPUTextureSampleType/"uint"}}
  <tr>
      <td>{{GPUTextureSampleType/"depth"}}
  <tr><td>[=type/write-only storage texture=]
      <td rowspan=3>{{GPUTextureView}}
      <td rowspan=3>{{GPUBindGroupLayoutEntry/storageTexture}}
      <td rowspan=3>{{GPUStorageTextureAccess}}
      <td>{{GPUStorageTextureAccess/"write-only"}}
  <tr><td>[=type/read-write storage texture=]
      <td>{{GPUStorageTextureAccess/"read-write"}}
  <tr><td>[=type/read-only storage texture=]
      <td>{{GPUStorageTextureAccess/"read-only"}}
  <tr><td>[=type/external texture=]
      <td>{{GPUExternalTexture}}
      <td>{{GPUBindGroupLayoutEntry/externalTexture}}
      <td colspan=2>(not applicable)
</table>

See the [$validating GPUProgrammableStage|WebGPU API$]
specification for interface validation requirements.

### Buffer Binding Determines Runtime-Sized Array Element Count ### {#buffer-binding-determines-runtime-sized-array-element-count}

When a [=storage buffer=] variable contains a [=runtime-sized=] array, then the number of elements in that array
is determined from the size of the corresponding {{GPUBufferBinding}}:

<blockquote algorithm="element count of runtime-sized array">
* Let |T| be the [=store type=] for a [=storage buffer=] variable,
    where |T| is a [=runtime-sized=] array type or contains a runtime-sized array type.
* Let |EBS| be the
    [=effective buffer binding size=]
    for the {{GPUBufferBinding}} bound to the pipeline binding address corresponding to the storage buffer variable.
* Then <dfn noexport>NRuntime</sub></dfn>, i.e.
    the number of elements in the runtime-sized array,
    is the largest integer such that [=SizeOf=](|T|) &le; |EBS|.

</blockquote>

In more detail, the [=NRuntime=] for a runtime-size array of type *RAT* is:
<blockquote algorithm="element count of runtime-sized array, expanded">
[=truncate=]((EBBS &minus; *array_offset*) &divide; *array_stride*), where:
* EBBS is the [=effective buffer binding size=] associated with the variable,
* *array_offset* is the byte offset of the runtime-sized array within the store type of the variable.
    * It is zero if the store type is |RAT|, the runtime-sized array type itself.
    * Otherwise the store type is a structure, and its last member is the runtime-sized array.
        In this case *array_offset* is the [=OffsetOfMember|byte offset of that member=] within the structure.
* *array_stride* is the stride of the array type, i.e. [=StrideOf=](|RAT|).

</blockquote>

A shader can compute [=NRuntime=] via the [[#arrayLength-builtin|arrayLength]] builtin function.

<div class=note>
<span class=marker>Note:</span>
This algorithm is unambiguous:
When a runtime-sized array is part of a larger type, it may only appear as the last element of a structure,
which itself cannot be part of an enclosing array or structure.

[=NRuntime=] is determined by the size of the corresponding buffer binding, and that can be different for each [=draw command|draw=]
or [=dispatch command=].

WebGPU validation rules ensure that 1 &le; [=NRuntime=].

</div>


<div class=note>
In the following code sample:
* The `weights` variable is a [=storage buffer=].
* Its store type is the runtime-sized arry type `array<f32>`.
* The array offset is 0.
* The array stride is [=StrideOf=](array&lt;f32&gt;), which is 4.

<div class='example wgsl' heading='number of elements in a simple runtime sized array'>
  <xmp>
@group(0) @binding(1) var<storage> weights: array<f32>;
  </xmp>
</div>

The following table shows examples of [=NRuntime=] for the `weights` variable, based on
the corresponding effective buffer binding size.

<table class='data'>
  <caption>Example number of elements for simple runtime-sized array</caption>
  <thead>
    <tr><th style="width:15%">Effective buffer binding size<th>NRuntime for `weights` variable<td>Calculation
  </thead>
  <tr><td>1024<td>256<td>[=truncate=]( 1024 &divide; 4 )
  <tr><td>1025<td>256<td>[=truncate=]( 1025 &divide; 4 )
  <tr><td>1026<td>256<td>[=truncate=]( 1026 &divide; 4 )
  <tr><td>1027<td>256<td>[=truncate=]( 1027 &divide; 4 )
  <tr><td>1028<td>257<td>[=truncate=]( 1028 &divide; 4 )
</table>
</div>

<div class=note>
In the following code sample:
* The `lights` variable is a [=storage buffer=].
* Its store type is `LightStorage`.
* The `point` member of `LightStorage` is a runtime-sized array of type `array<PointLight>`.
    * The member is at byte offset 16 in the variable's storage.
    * The array stride is [=StrideOf=](array&lt;`PointLight`&gt;) = [=roundUp=]([=AlignOf=](`PointLight`),[=SizeOf=](`PointLight`)) = [=roundUp=](16,32) = 32

<div class='example wgsl' heading='number of elements in a complex runtime sized array'>
  <xmp>
struct PointLight {                          //             align(16) size(32)
  position : vec3f,                          // offset(0)   align(16) size(12)
  // -- implicit member alignment padding -- // offset(12)            size(4)
  color : vec3f,                             // offset(16)  align(16) size(12)
  // -- implicit struct size padding --      // offset(28)            size(4)
}

struct LightStorage {                        //             align(16)
  pointCount : u32,                          // offset(0)   align(4)  size(4)
  // -- implicit member alignment padding -- // offset(4)             size(12)
  point : array<PointLight>,                 // offset(16)  align(16) elementsize(32)
}

@group(0) @binding(1) var<storage> lights : LightStorage;
  </xmp>
</div>

The following table shows examples of [=NRuntime=] for the `point` member of the `lights` variable.

<table class='data'>
  <caption>Example number of elements for complex runtime-sized array</caption>
  <thead>
    <tr><th style="width:15%">Effective buffer binding size<th>NRuntime for `point` member of `lights` variable<td>Calculation
  </thead>
  <tr><td>1024<td>31<td>[=truncate=]( ( 1024 - 16 ) &divide; 32) )
  <tr><td>1025<td>31<td>[=truncate=]( ( 1025 - 16 ) &divide; 32) )
  <tr><td>1039<td>31<td>[=truncate=]( ( 1039 - 16 ) &divide; 32) )
  <tr><td>1040<td>32<td>[=truncate=]( ( 1040 - 16 ) &divide; 32) )
  </thead>
</table>
</div>

# Memory # {#memory}

In WGSL, a value of [=storable=] type may be stored in memory, for later retrieval.
This section describes the structure of memory, and the semantics of operations accessing memory.
See [[#memory-views]] for the types of values that can be placed in memory, and the types used to perform memory accesses.

## Memory Locations ## {#memory-locations-section}

Memory consists of a set of distinct <dfn noexport>memory locations</dfn>.
Each memory location is 8-bits in size.
An operation affecting memory interacts with a set of one or more memory locations.
Memory operations on [=composites=] [=behavioral requirement|will not=]
access padding memory locations.
Therefore, the set of memory locations accessed by an operation may not be contiguous.

Two sets of memory locations <dfn noexport>overlap</dfn> if the intersection of
their sets of memory locations is non-empty.

## Memory Access Mode ## {#memory-access-mode}

A <dfn noexport>memory access</dfn> is an operation that acts on [=memory locations=].

* A <dfn noexport>read access</dfn> observes the contents of memory locations.
* A <dfn noexport>write access</dfn> sets the contents of memory locations.

A single operation can read, write, or both read and write.

Particular memory locations may support only certain kinds of accesses, expressed
as the memory's <dfn noexport>access mode</dfn>.

<table class='data'>
  <caption>Access Modes</caption>
  <thead>
    <tr><th>Access mode
        <th>Supported accesses
  </thead>
  <tr><td><dfn noexport dfn-for="access">read</dfn>
      <td>Supports read accesses, but not writes.
  <tr><td><dfn noexport dfn-for="access">write</dfn>
      <td>Supports write accesses, but not reads.
  <tr><td><dfn noexport dfn-for="access">read_write</dfn>
      <td>Supports both read and write accesses.
</table>

WGSL [=predeclared|predeclares=] the [=enumerants=] `read`, `write`, and `read_write`.

## Address Spaces ## {#address-space}

Memory locations are partitioned into <dfn noexport>address spaces</dfn>.
Each address space has unique properties determining
mutability, visibility, the values it may contain,
and how to use variables with it.
See [[#var-and-value]] for more details.

The access mode of a given [=memory view=] is often determined by context:

The [=address spaces/storage=] address spaces supports both [=access/read=] and
[=access/read_write=] access modes.
Each other address space supports only one access mode.
The default access mode for each address space is described in the following
table.

<table class='data'>
  <caption>Address Spaces</caption>
  <thead>
    <tr><th>Address space
        <th>Sharing among invocations
        <th>Default access mode
        <th>Notes
  </thead>
  <tr><td><dfn noexport dfn-for="address spaces">function</dfn>
      <td>Same invocation only
      <td>[=access/read_write=]
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">private</dfn>
      <td>Same invocation only
      <td>[=access/read_write=]
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">workgroup</dfn>
      <td>Invocations in the same [=compute shader stage|compute shader=] [=compute shader stage/workgroup=]
      <td>[=access/read_write=]
      <td>The [=element count=] of an outermost array may be a [=pipeline-overridable=] constant.
  <tr><td><dfn noexport dfn-for="address spaces">uniform</dfn>
      <td>Invocations in the same [=shader stage=]
      <td>[=access/read=]
      <td>For [=uniform buffer=] variables
  <tr><td><dfn noexport dfn-for="address spaces">storage</dfn>
      <td>Invocations in the same [=shader stage=]
      <td>[=access/read=]
      <td>For [=storage buffer=] variables
  <tr><td><dfn noexport dfn-for="address spaces">handle</dfn>
      <td>Invocations in the same shader stage
      <td>[=access/read=]
      <td>For [=sampler resource|sampler=] and [=texture resource|texture=] variables.<br>
</table>

WGSL [=predeclared|predeclares=] an [=enumerant=] for each address space, except for the `handle` address space.

[=Variables=] in the [=address spaces/workgroup=] address space
[=shader-creation error|must=] only be [=statically accessed=] in a [=compute
shader stage=].

[=Variables=] in the [=address spaces/storage=] address space ([=storage
buffers=]) can only be [=statically accessed=] by a [=vertex shader stage=] if the access mode is [=access/read=]. 
Variables whose [=store type=] is a [=type/storage texture=] with a
[=access/write=] or [=access/read_write=] [=access mode=] cannot be
[=statically accessed=] by a [=vertex shader stage=].
See WebGPU {{GPUDevice/createBindGroupLayout()}}.

Note: Each address space may have different performance characteristics.

When writing a [=variable declaration=] or a [=pointer type=] in WGSL source:
* For the [=address spaces/storage=] address space, the access mode is optional, and defaults to [=access/read=].
* For other address spaces, the access mode [=shader-creation error|must not=] be written.

## Memory Layout ## {#memory-layouts}

The layout of types in WGSL is independent of [=address space=].
Strictly speaking, however, that layout can only be observed by host-shareable
buffers.
[=Uniform buffer=] and [=storage buffer=] variables are used to share
bulk data organized as a sequence of bytes in memory.
Buffers are shared between the CPU and the GPU, or between different shader stages
in a pipeline, or between different pipelines.

Because buffer data are shared without reformatting or translation, it is a
[=dynamic error=] if buffer producers and consumers do not agree on the <dfn
noexport>memory layout</dfn>, which is the description of how the bytes in a
buffer are organized into typed WGSL values.
These bytes are [=memory locations=] of a value relative to a common base
location.

The [=store type=] of a buffer variable [=shader-creation error|must=] be
[=host-shareable=], with fully elaborated memory layout, as described below.

Each buffer variable [=shader-creation error|must=] be declared in either the
[=address spaces/uniform=] or [=address spaces/storage=] address spaces.

The memory layout of a type is significant only when evaluating an expression with:
* a variable in the [=address spaces/uniform=] or [=address spaces/storage=] address space, or
* a pointer into the [=address spaces/uniform=] or [=address spaces/storage=] address space.

An 8-bit byte is the most basic unit of [=host-shareable=] memory.
The terms defined in this section express counts of 8-bit bytes.

We will use the following notation:
* <dfn noexport>AlignOf</dfn>(|T|) is the [=alignment=] of host-shareable type |T|.
* <dfn noexport>AlignOfMember</dfn>(|S|, |i|) is the alignment of the |i|'th member of the host-shareable structure |S|.
* <dfn noexport>SizeOf</dfn>(|T|) is the [=byte-size=] of host-shareable type |T|.
* <dfn noexport>SizeOfMember</dfn>(|S|, |i|) is the size of the |i|'th member of the host-shareable structure |S|.
* <dfn noexport>OffsetOfMember</dfn>(|S|, |i|) is the offset of the |i|'th member from the start of the host-shareable structure |S|.
* <dfn noexport>StrideOf</dfn>(|A|) is the <dfn>element stride</dfn> of host-shareable array type |A|, defined
    as the number of bytes from the start of one array element to the start of the next element.
    It equals the size of the array's element type, rounded up to the alignment of the element type:
        <p algorithm="array element stride">
          [=StrideOf=](array<|E|, |N|>) = [=roundUp=]([=AlignOf=](E), [=SizeOf=](E))<br>
          [=StrideOf=](array<|E|>) = [=roundUp=]([=AlignOf=](E), [=SizeOf=](E))
        </p>

### Alignment and Size ###  {#alignment-and-size}

Each [=host-shareable=] or [=fixed footprint=] data type |T| has an alignment and size.

The <dfn>alignment</dfn> of a type is a constraint on where values of that type
may be placed in memory, expressed as an integer:
a type's alignment [=shader-creation error|must=] evenly divide
the byte address of the starting [=memory location=] of a value of that type.
Alignments enable use of more efficient hardware instructions for accessing the values,
or satisfy more restrictive hardware requirements on certain
address spaces. (See [address space layout constraints](#address-space-layout-constraints)).

Note: Each alignment value is always a power of two, by construction.

The <dfn>byte-size</dfn> of a type or structure member is the number of contiguous bytes
reserved in host-shareable memory for the purpose of storing a value of the type
or structure member.
The size may include non-addressable padding at the end of the type.
Consequently, loads and stores of a value might access fewer memory locations
than the value's size.

Alignment and size of [=host-shareable=] types are defined recursively in the
following table:

<table class='data'>
  <caption>
    Alignment and size for host-shareable types<br>
  </caption>
  <thead>
    <tr><th>Host-shareable type |T|
        <th>[=AlignOf=](|T|)
        <th>[=SizeOf=](|T|)
  </thead>
  <tr><td>[=i32=], [=u32=], or [=f32=]
      <td>4
      <td>4
  <tr><td>[=f16=]
      <td>2
      <td>2
  <tr><td>[=atomic type|atomic&lt;|T|&gt;=]
      <td>4
      <td>4
  <tr><td>[=vector|vec=]2&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>8
      <td>8
  <tr><td>vec2&lt;f16&gt;
      <td>4
      <td>4
  <tr><td>vec3&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>12
  <tr><td>vec3&lt;f16&gt;
      <td>8
      <td>6
  <tr><td>vec4&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>16
  <tr><td>vec4&lt;f16&gt;
      <td>8
      <td>8
  <tr><td>[=matrix|mat=]|C|x|R| (col-major)<br>
      <p class="small">(General form)</p>
      <td>[=AlignOf=](vec|R|)
      <td>[=SizeOf=](array&lt;vec|R|, |C|&gt;)
  <tr><td>mat2x2&lt;f32&gt;
      <td>8
      <td>16
  <tr><td>mat2x2&lt;f16&gt;
      <td>4
      <td>8
  <tr><td>mat3x2&lt;f32&gt;
      <td>8
      <td>24
  <tr><td>mat3x2&lt;f16&gt;
      <td>4
      <td>12
  <tr><td>mat4x2&lt;f32&gt;
      <td>8
      <td>32
  <tr><td>mat4x2&lt;f16&gt;
      <td>4
      <td>16
  <tr><td>mat2x3&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x3&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x3&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x3&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x3&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x3&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>mat2x4&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x4&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x4&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x4&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x4&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x4&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>[=structure|struct=] |S| with members M<sub>1</sub>...M<sub>N</sub>
      <td>max([=AlignOfMember=](S,1), ... , [=AlignOfMember=](S,N))<br>
      <td>[=roundUp=]([=AlignOf=](|S|), justPastLastMember)<br><br>
          where justPastLastMember = [=OffsetOfMember=](|S|,N) + [=SizeOfMember=](|S|,N)
  <tr><td>[=array=]<|E|, |N|><br>
      <td>[=AlignOf=](|E|)
      <td>|N| &times; [=roundUp=]([=AlignOf=](|E|), [=SizeOf=](|E|))
  <tr><td>array<|E|><br>
      <td>[=AlignOf=](|E|)
      <td>[=NRuntime=] &times; [=roundUp=]([=AlignOf=](|E|),[=SizeOf=](|E|))<br><br>
          where NRuntime is the runtime-determined number of elements of |T|
</table>

### Structure Member Layout ###  {#structure-member-layout}

The internal layout of a [=structure=] is computed from the sizes and alignments of its members.
By default, the members are arranged tightly, in order, without overlap, while satisfying member alignment
requirements.

This default internal layout can be overriden by using <dfn noexport>layout attributes</dfn>, which are:

* [=attribute/size=]
* [=attribute/align=]

The |i|'th member of structure type |S| has a size and alignment, denoted
by [=SizeOfMember=](|S|, |i|) and [=AlignOfMember=](|S|, |i|), respectively.
The member sizes and alignments are used to calculate each member's byte offset from the start of the structure,
as described in [[#internal-value-layout]].

<p algorithm="structure member size">
  [=SizeOfMember=](|S|, |i|) is |k| if the |i|'th member of |S| has attribute [=attribute/size=](|k|).
  Otherwise, it is [=SizeOf=](|T|) where |T| is the type of the member.
</p>

<p algorithm="structure member alignment">
  [=AlignOfMember=](|S|, |i|) is |k| if the |i|'th member of |S| has attribute [=attribute/align=](|k|).
  Otherwise, it is [=AlignOf=](|T|) where |T| is the type of the member.
</p>

If a structure member has the [=attribute/size=] attribute applied, the
value [=shader-creation error|must=] be at least as large as the size of the
member's type:

<p algorithm="member size constraint">
  [=SizeOfMember=](|S|, |i|) &ge; [=SizeOf=](T)<br>
  Where |T| is the type of the |i|'th member of |S|.
</p>

The first structure member always has a zero byte offset from the start of the
structure:
<p algorithm="offset of first structure member">
  [=OffsetOfMember=](<var ignore>S</var>, 1) = 0
</p>

Each subsequent member is placed at the lowest offset that satisfies the member type alignment,
and which avoids overlap with the previous member.
For each member index |i| > 1:
<p algorithm="structure member offset">
  [=OffsetOfMember=](|S|, |i|) = [=roundUp=]([=AlignOfMember=](|S|, |i| ), [=OffsetOfMember=](|S|, |i|-1) + [=SizeOfMember=](|S|, |i|-1))<br>
</p>

<div class='example wgsl' heading='Layout of structures using implicit member sizes and alignments'>
  <xmp>
    struct A {                                     //             align(8)  size(24)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        x: f32                                     // offset(16)  align(4)  size(4)
        // -- implicit struct size padding --      // offset(20)            size(4)
    }

    struct B {                                     //             align(16) size(160)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(4)
        e: A,                                      // offset(40)  align(8)  size(24)
        f: vec3<f32>,                              // offset(64)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(76)            size(4)
        g: array<A, 3>,    // element stride 24       offset(80)  align(8)  size(72)
        h: i32                                     // offset(152) align(4)  size(4)
        // -- implicit struct size padding --      // offset(156)           size(4)
    }

    @group(0) @binding(0)
    var<storage,read_write> storage_buffer: B;
  </xmp>
</div>

<div class='example wgsl' heading='Layout of structures with explicit member sizes and alignments'>
  <xmp>
    struct A {                                     //             align(8)  size(32)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        @size(16) x: f32                           // offset(16)  align(4)  size(16)
    }

    struct B {                                     //             align(16) size(208)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(12)
        @align(16) e: A,                           // offset(48)  align(16) size(32)
        f: vec3<f32>,                              // offset(80)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(92)            size(4)
        g: array<A, 3>,    // element stride 32       offset(96)  align(8)  size(96)
        h: i32                                     // offset(192) align(4)  size(4)
        // -- implicit struct size padding --      // offset(196)           size(12)
    }

    @group(0) @binding(0)
    var<uniform> uniform_buffer: B;
  </xmp>
</div>

### Array Layout Examples ###  {#array-layout-examples}

<div class='example wgsl function-scope' heading='Fixed-size array layout examples'>
  <xmp>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = roundUp(4,4)
    //   - size is 32 = stride * number_of_elements = 4 * 8
    var small_stride: array<f32, 8>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    //   - size is 128 = stride * number_of_elements = 16 * 8
    var bigger_stride: array<vec3<f32>, 8>;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Runtime-sized array layout examples'>
  <xmp>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = 4
    // If B is the effective buffer binding size for the binding on the
    // draw or dispatch command, the number of elements is:
    //   N_runtime = floor(B / element stride) = floor(B / 4)
    @group(0) @binding(0)
    var<storage> weights: array<f32>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    // If B is the effective buffer binding size for the binding on the
    // draw or dispatch command, the number of elements is:
    //   N_runtime = floor(B / element stride) = floor(B / 16)
    var<storage> directions: array<vec3<f32>>;
  </xmp>
</div>

### Internal Layout of Values ###  {#internal-value-layout}

This section describes how the internals of a value are placed in the byte locations
of a buffer, given an assumed placement of the overall value.
These layouts depend on the value's type,
and the [=attribute/align=] and [=attribute/size=] attributes on structure members.

The buffer byte offset at which a value is placed [=shader-creation
error|must=] satisfy the type alignment requirement: If a value of type |T| is
placed at buffer offset |k|, then |k| = |c| &times; [=AlignOf=](|T|), for some
non-negative integer |c|.

The data [=behavioral requirement|will=] appear identically regardless of the address space.

When a value |V| of type [=u32=] or [=i32=] is placed at byte offset |k| of a
host-shared buffer, then:
   * Byte |k| contains bits 0 through 7 of |V|
   * Byte |k|+1 contains bits 8 through 15 of |V|
   * Byte |k|+2 contains bits 16 through 23 of |V|
   * Byte |k|+3 contains bits 24 through 31 of |V|

Note: Recall that [=i32=] uses twos-complement representation, so the sign bit
is in bit position 31.

A value |V| of type [=f32=] is represented in [[!IEEE-754|IEEE-754]] binary32 format.
It has one sign bit, 8 exponent bits, and 23 fraction bits.
When |V| is placed at byte offset |k| of host-shared buffer, then:
   * Byte |k| contains bits 0 through 7 of the fraction.
   * Byte |k|+1 contains bits 8 through 15 of the fraction.
   * Bits 0 through 6 of byte |k|+2 contain bits 16 through 22 of the fraction.
   * Bit 7 of byte |k|+2 contains bit 0 of the exponent.
   * Bits 0 through 6 of byte |k|+3 contain bits 1 through 7 of the exponent.
   * Bit 7 of byte |k|+3 contains the sign bit.

A value |V| of type [=f16=] is represented in [[!IEEE-754|IEEE-754]] binary16 format.
It has one sign bit, 5 exponent bits, and 10 fraction bits.
When |V| is placed at byte offset |k| of host-shared buffer, then:
   * Byte |k| contains bits 0 through 7 of the fraction.
   * Bits 0 through 1 of byte |k|+1 contain bits 8 through 9 of the fraction.
   * Bits 2 through 6 of byte |k|+1 contain bits 0 through 4 of the exponent.
   * Bit 7 of byte |k|+1 contains the sign bit.

Note: The above rules imply that numeric values in host-shared buffers
are stored in little-endian format.

When a value |V| of [=atomic type=] `atomic`&lt;|T|&gt; is placed in a host-shared buffer,
it has the same internal layout as a value of the underlying type |T|.

When a value |V| of [=vector|vector type=] vec|N|&lt;|T|&gt; is placed at
byte offset |k| of a host-shared buffer, then:
   * |V|.x is placed at byte offset |k|
   * |V|.y is placed at byte offset |k| + [=SizeOf=](|T|)
   * If |N| &ge; 3, then |V|.z is placed at byte offset |k| + 2 &times; [=SizeOf=](|T|)
   * If |N| &ge; 4, then |V|.w is placed at byte offset |k| + 3 &times; [=SizeOf=](|T|)

When a value |V| of [=matrix|matrix type=] mat|C|x|R|&lt;|T|&gt; is placed at
byte offset |k| of a host-shared buffer, then:
  * Column vector |i| of |V| is placed at byte offset |k| + |i| &times; [=AlignOf=](vec|R|&lt;|T|&gt;)

When a value of [=array|array type=] |A| is placed at byte offset |k| of a host-shared memory buffer,
then:
   * Element |i| of the array is placed at byte offset |k| + |i| &times; [=StrideOf=](|A|)

When a value of [=structure|structure type=] |S| is placed at byte offset |k| of a host-shared memory buffer,
then:
   * The |i|'<sup>th</sup> member of the structure value is placed at byte offset |k| + [=OffsetOfMember=](|S|,|i|).
    See [[#structure-member-layout]].

### Address Space Layout Constraints ###  {#address-space-layout-constraints}

The [=address spaces/storage=] and [=address spaces/uniform=] address spaces
have different buffer layout constraints which are described in this section.

Note: All [=address spaces=] except [=address spaces/uniform=] have the same
constraints as the [=address spaces/storage=] address space.

All structure and array types directly or indirectly referenced by a variable
[=shader-creation error|must=] obey the constraints of the variable's address space.
Violations of an address space constraint results in a [=shader-creation error=].

In this section we define <dfn noexport>RequiredAlignOf</dfn>(|S|, |C|) as the
byte offset [=alignment=] requirement of values of host-shareable type |S| when
used in address space |C|.

<table class='data'>
  <caption>
    Alignment requirements of a host-shareable type for
    [=address spaces/storage=] and [=address spaces/uniform=] address spaces
  </caption>
  <thead>
    <tr><th>Host-shareable type |S|
        <th>[=RequiredAlignOf=](|S|, [=address spaces/storage=])
        <th>[=RequiredAlignOf=](|S|, [=address spaces/uniform=])
  </thead>
  <tr><td>[=i32=], [=u32=], [=f32=], or [=f16=]
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=atomic types|atomic=]&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=vector|vec=]N&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of a matrix with C columns and R rows">
      <td>[=matrix|mat=]CxR&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of an array">
      <td>[=array=]&lt;T, N&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of an runtime-sized array">
      <td>array&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of a structure">
      <td>[=structure|struct=] |S|
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))<br>
</table>

Structure members of type |T| [=shader-creation error|must=] have a byte offset
from the start of the structure that is a multiple of the [=RequiredAlignOf=](|T|, |C|)
for the address space |C|:

<p algorithm="structure member minimum alignment">
    [=OffsetOfMember=](|S|, |M|) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    Where |k| is a positive integer and |M| is a member of structure |S| with type |T|
</p>

Arrays of element type |T| [=shader-creation error|must=] have an [=element stride=] that is a
multiple of the [=RequiredAlignOf=](|T|, |C|) for the address space |C|:

<p algorithm="array element minimum alignment">
    [=StrideOf=](array<|T|, |N|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    [=StrideOf=](array<|T|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    Where |k| is a positive integer
</p>

Note: [=RequiredAlignOf=](|T|, |C|) does not impose any additional restrictions
on the values permitted for an [=attribute/align=] attribute, nor does it affect the rules
of [=AlignOf=](|T|). Data is laid out with the rules defined in previous
sections and then the resulting layout is validated against the
[=RequiredAlignOf=](|T|, |C|) rules.

The [=address spaces/uniform=] address space also requires that:
* Array elements are aligned to 16 byte boundaries.
    That is, [=StrideOf=](array&lt;|T|,|N|&gt;) = 16 &times; |k|' for some positive integer |k|'.
* If a structure member itself has a structure type `S`, then the number of
    bytes between the start of that member and the start of any following member
    [=shader-creation error|must=] be at least [=roundUp=](16, [=SizeOf=](S)).

Note: The following examples show how to use [=attribute/align=] and [=attribute/size=] attributes
on structure members to satisfy layout requirements for uniform buffers.
In particular, these techniques can be used mechanically transform a GLSL buffer with std140 layout
to WGSL.

<div class='example wgsl global-scope' heading='Satisfying offset requirements for uniform address space'>
  <xmp>
    struct S {
      x: f32
    }
    struct Invalid {
      a: S,
      b: f32 // invalid: offset between a and b is 4 bytes, but must be at least 16
    }
    @group(0) @binding(0) var<uniform> invalid: Invalid;

    struct Valid {
      a: S,
      @align(16) b: f32 // valid: offset between a and b is 16 bytes
    }
    @group(0) @binding(1) var<uniform> valid: Valid;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Satisfying stride requirements for uniform address space'>
  <xmp>
    struct small_stride {
      a: array<f32,8> // stride 4
    }
    // Invalid, stride must be a multiple of 16
    @group(0) @binding(0) var<uniform> invalid: small_stride;

    struct wrapped_f32 {
      @size(16) elem: f32
    }
    struct big_stride {
      a: array<wrapped_f32,8> // stride 16
    }
    @group(0) @binding(1) var<uniform> valid: big_stride;     // Valid
  </xmp>
</div>

## Memory Model ## {#memory-model}

In general, WGSL follows the [[!VulkanMemoryModel|Vulkan Memory Model]].
The remainder of this section describes how WGSL programs map to the
Vulkan Memory Model.

Note: The Vulkan Memory Model is a textual version of a [formal Alloy
model](https://github.com/KhronosGroup/Vulkan-MemoryModel/blob/master/alloy/spirv.als).

### Memory Operation ### {#memory-operation}

In WGSL, a [=read access=] is equivalent to a memory read operation in
the Vulkan Memory Model.
In WGSL, a [=write access=] is equivalent to a memory write operation in
the Vulkan Memory Model.

A [=read access=] occurs when an invocation executes one of the following:
* An evaluation of the [=Load Rule=]
* Any [[#texture-builtin-functions|texture builtin function]] except:
    * [[#texturedimensions|textureDimensions]]
    * [[#texturestore|textureStore]]
    * [[#texturenumlayers|textureNumLayers]]
    * [[#texturenumlevels|textureNumLevels]]
    * [[#texturenumsamples|textureNumSamples]]
* Any atomic built-in function except [[#atomic-store|atomicStore]]
* A [[#workgroupUniformLoad-builtin|workgroupUniformLoad]] built-in function
* A [=compound assignment=] statement (for the [=left-hand side=] expression)

A [=write access=] occurs when an invocation executes one of the following:
* An [=statement/assignment=] statement ([=simple assignment|simple=] or
    [=compound assignment|compound=] for the [=left-hand side=] expression)
* A [[#texturestore|textureStore]] built-in function
* Any atomic built-in function except [[#atomic-load|atomicLoad]]
    * [[#atomic-rmw|atomicCompareExchangeWeak]] only performs a write if the
        `exchanged` member of the returned result is `true`

[[#atomic-rmw|Atomic read-modify-write]] built-in functions perform a single
memory operation that is both a [=read access=] and a [=write access=].

Read and write accesses do not occur under any other circumstances.
Read and write accesses are collectively known as [=memory model memory
operation|memory operations=] in the Vulkan Memory Model.

A memory operation accesses exactly the set of [=memory location|locations=]
associated with the particular [=memory view=] used in the operation.  For
example, a memory read that accesses a [=u32=] from a struct containing
multiple members, only reads the memory locations associated with that u32
member.

Note: A write access to a component of a vector **may** access all memory locations
associated with that vector.

<div class='example wgsl memory locations accessed' heading="Accessing memory locations">
  <xmp>
    struct S {
      a : f32,
      b : u32,
      c : f32
    }

    @group(0) @binding(0)
    var<storage> v : S;

    fn foo() {
      let x = v.b; // Does not access memory locations for v.a or v.c.
    }
  </xmp>
</div>

### Memory Model Reference ### {#memory-model-reference}

Each module-scope [=resource=] variable forms a [=memory model reference=] for
the unique [=attribute/group=] and [=attribute/binding=] pair.
Each other variable (i.e. variables in the [=address spaces/function=],
[=address spaces/private=], and [=address spaces/workgroup=] address spaces)
forms a unique [=memory model reference=] for the lifetime of the variable.

### Scoped Operations ### {#scoped-operations}

When an invocation performs a scoped operation, it will affect one or two sets
of invocations.
These sets are the memory scope and the execution scope.  The <dfn
noexport>memory scope</dfn> specifies the set of invocations that will see any
updates to memory contents affected by the operation.
For [[#sync-builtin-functions|synchronization built-in functions]], this also
means that all affected memory operations program ordered before the function
are visible to affected operations program ordered after the function.
The <dfn noexport>execution scope</dfn> specifies the set of invocations which
may participate in an operation (see [[#collective-operations]]).

[[#atomic-builtin-functions|Atomic built-in functions]] map to [=memory model atomic
operation|atomic operations=] whose memory [=memory model scope|scope=] is:
* `Workgroup` if the atomic pointer is in the [=address spaces/workgroup=]
    address space
* `QueueFamily` if the atomic pointer is in the [=address spaces/storage=]
    address space

[[#sync-builtin-functions|Synchronization built-in functions]] map to control
barriers whose execution and memory [=memory model scope|scopes=] are
`Workgroup`.

Implicit and explicit [[#derivatives|derivatives]] have an implicit [=quad=]
execution scope.

Note: If the Vulkan memory model is not enabled in generated shaders, `Device`
scope should be used instead of `QueueFamily`.

### Memory Semantics ### {#memory-semantics}

All [[#atomic-builtin-functions|Atomic built-in functions]] use `Relaxed`
[=memory model memory semantics|memory semantics=] and, thus, no storage class
semantics.

Note: Address space in WGSL is equivalent to storage class in SPIR-V.

[[#sync-builtin-functions|workgroupBarrier]] uses `AcquireRelease` [=memory
model memory semantics|memory semantics=] and `WorkgroupMemory` semantics.
[[#sync-builtin-functions|storageBarrier]] uses `AcquireRelease` [=memory model
memory semantics|memory semantics=] and `UniformMemory` semantics.
[[#sync-builtin-functions|textureBarrier]] uses `AcquireRelease` [=memory model
memory semantics|memory semantics=] and `ImageMemory` semantics.

Note: A combined `workgroupBarrier` and `storageBarrier` uses `AcquireRelease`
ordering semantics and both `WorkgroupMemory` and `UniformMemory` memory
semantics.

Note: No atomic or synchronization built-in functions use `MakeAvailable` or
`MakeVisible` semantics.

### Private vs Non-private ### {#private-vs-non-private}

All non-atomic [=read accesses=] in the [=address spaces/storage=] or
[=address spaces/workgroup=] address spaces are considered
[=memory model non-private|non-private=] and correspond to read operations with
`NonPrivatePointer | MakePointerVisible` memory operands with the `Workgroup`
scope.

All non-atomic [=write accesses=] in the [=address spaces/storage=] or
[=address spaces/workgroup=] address spaces are considered
[=memory model non-private|non-private=] and correspond to write operations
with `NonPrivatePointer | MakePointerAvailable` memory operands with the
`Workgroup` scope.

# Execution # {#execution}

[[#overview]] describes how a shader is invoked and partitioned into [=invocations=].
This section describes further constraints on how invocations execute,
individually and collectively.

## Program Order Within an Invocation ## {#program-order}

Each statement in a WGSL module may be executed zero or more times during
execution.
For a given invocation, each execution of a given statement represents a unique
<dfn noexport>dynamic statement instance</dfn>.

When a statement includes an expression, the statement’s semantics determines:
* Whether the expression is evaluated as part of statement execution.
* The relative ordering of evaluation between independent expressions in the statement.

Expression nesting defines data dependencies which must be satisfied to
complete evaluation.
That is, a nested expression must be evaluated before the enclosing expression
can be evaluated.
The order of evaluation for operands of an expression is left-to-right in
WGSL.
For example, `foo() + bar()` must evaluate `foo()` before `bar()`.
See [[#expressions]].

Statements in a WGSL module are executed in control flow order.
See [[#statements]] and [[#function-calls]].

## Uniformity ## {#uniformity}

A [[#collective-operations|collective operation]]
(e.g. barrier, derivative, or a texture operation relying on an implicitly computed derivative)
requires coordination among different invocations running concurrently on the GPU.
The operation executes correctly and portably
when all invocations execute it concurrently, i.e. in [=uniform control flow=].

Conversely, incorrect or non-portable behavior occurs when a strict subset of invocations
execute the operation, i.e. in non-uniform control flow.
Informally, some invocations reach the collective operation, but others do not,
or not at the same time, as a result of non-uniform control dependencies.
Non-uniform control dependencies arise from [[#control-flow|control flow]]
statements whose behavior depends on [=uniform value|non-uniform values=].

> For example, a non-uniform control dependency arises when different invocations compute
    different values for the condition of an
    [=statement/if=], [=statement/break-if=], [=statement/while=], or [=statement/for=],
    different values for the selector of a [=statement/switch=],
    or the left-hand operand of a short-circuiting binary operator (`&&` or `||`).

These non-uniform values can often be traced back to certain sources that are not
statically proven to be uniform.
These sources include, but are not limited to:
* Mutable [=module scope|module-scope=] [=variables=]
* Most [=built-in values=], except [=built-in values/num_workgroups=] and [=built-in values/workgroup_id=]
* [=user-defined input datum|User-defined inputs=]
* Certain [=built-in functions=] (see [[#uniformity-function-calls]])

To ensure correct and portable behavior, a WGSL implementation [=behavioral requirement|will=]
perform a static <dfn>uniformity analysis</dfn>, attempting to prove that each collective operation
executes in [=uniform control flow=].
Subsequent subsections describe the analysis.

A <dfn noexport>uniformity failure</dfn> [=behavioral requirement|will=] be triggered
when [=uniformity analysis=] cannot prove that a particular [[#collective-operations|collective operation]] executes in [=uniform control flow=].
* If a uniformity failure is triggered for a
    [=builtin functions that compute a derivative|builtin function that computes a derivative=], then
    a [=trigger/derivative_uniformity=] [=diagnostic=] is [=triggered=].
    * The diagnostic's [=diagnostic/triggering location=] is the location of the [=call site=] of that builtin.
    * The diagnostic's [=diagnostic/severity=] defaults to an [=severity/error=] but can be controlled with a [=diagnostic filter=].
* If a uniformity failure is triggered for a [[#sync-builtin-functions|synchronization builtin]],
    an [=severity/error=] [=diagnostic=] is [=triggered=],
    which results in a [=shader-creation error=].

### Terminology and Concepts ### {#uniformity-concepts}

The following definitions are merely informative, trying to give an intuition for what the analysis in the next subsection is computing.
The analysis is what actually defines these concepts, and when a program is valid or breaks the uniformity rules.

For a given group of invocations:
- If all invocations in a given scope execute as if they are executing in lockstep at a given
    point in the program, that point is said to have <dfn noexport>uniform control flow</dfn>.
    - For a [=compute shader stage=], the scope of uniform control flow is all invocations
        in the same [=compute shader stage/workgroup=].
    - For other shader stages, the scope of uniform control flow is all invocations for that
        [=entry point=] in the same [=draw command=].
- If an expression is executed in uniform control flow, and all invocations compute the
    same value, it is said to be a <dfn noexport>uniform value</dfn>.
- If invocations hold the same value for a local variable at every point where it is live,
    it is said to be a <dfn noexport>uniform variable</dfn>.

### Uniformity Analysis Overview ### {#uniformity-overview}

The remaining subsections specify a static analysis that verifies that
[[#collective-operations|collective operations]] are only executed in [=uniform
control flow=].

The analysis assumes [=dynamic errors=] do not occur.
A shader stage with a [=dynamic error=] is already non-portable, no matter the outcome
of uniformity analysis.

<div class="note"><span class=marker>Note:</span>This analysis has the following desirable properties:
      - Sound, meaning that a [=uniformity failure=] [=behavioral requirement|will=] be triggered for a program that would break the uniformity requirements of builtins.
      - Linear time complexity, in the number of tokens in the program.
      - Refactoring a piece of code into a function, or inlining a function, cannot make a shader invalid if it was valid before the transformation.
      - If the analysis refuses a program, it provides a straightforward chain of implications that can be used by the user agent to craft a good error message.
</div>

Each function is analyzed, trying to ensure two things:
    * Uniformity requirements are satisfied when it calls other functions, and
    * Uniformity requirements are satisfied whenever it is called.
A [=uniformity failure=] is triggered if either of these two checks fail.

As part of this work, the analysis computes metadata about the function to help analyze its callers in turn.
This means that the call graph must first be built, and functions must be analyzed from the leaves upwards, i.e. from functions that call no function outside the standard library toward the entry point.
This way, whenever a function is analyzed, the metadata for all of its callees has already been computed.
There is no risk of being trapped in a cycle, as recurrence is forbidden in the language.

Note: Another way of saying the same thing is that we do a topological sort of functions ordered by the "is a (possibly indirect) callee of" partial order, and analyze them in that order.

Additionally, for each function call, the analysis computes and propagates
the set of [=diagnostic/triggering rules=], if any, that would be triggered if that call cannot be proven to be in uniform control flow.
We call this the <dfn noexport>potential-trigger-set</dfn> for the call.
The elements of this set are drawn from two possibilites:
* [=trigger/derivative_uniformity=], for functions relying on computing a derivative, or
* an unnamed triggering rule, for the uniformity requirements that cannot be filtered.
    * This is used for compute shader functions relying on [[#sync-builtin-functions|synchronization functions]].

### Analyzing the Uniformity Requirements of a Function ### {#uniformity-function}

Each function is analyzed in two phases.

The first phase walks over the syntax of the function, building a directed graph along the way based on the rules in the following subsections.
The second phase explores that graph, computing the constraints on calling this function,
and potentially triggering a [=uniformity failure=].

<div class="note"><span class=marker>Note:</span>Apart from four special nodes
    [=RequiredToBeUniform.error=],
    [=RequiredToBeUniform.warning=],
    [=RequiredToBeUniform.info=], and [=MayBeNonUniform=], each node can be understood as capturing the truth-value one of the following statements:
        - A specific point of the program must be executed in [=uniform control flow=].
        - An expression must be a [=uniform value=].
        - A variable must be a [=uniform variable=].
        - A value stored in memory, that could be loaded via a pointer, must be a [=uniform value=].

        An edge can be understood as an implication from the statement corresponding to its source node to the statement corresponding to its target node.

        For example, one uniformity requirement is that the `workgroupBarrier` builtin function must only be called within uniform control flow.
        To express this, we add an edge from [=RequiredToBeUniform.error=] to the node corresponding to the `workgroupBarrier` [=call site=].
        One way to understand this is that [=RequiredToBeUniform.error=] corresponds to the proposition True,
        so that [=RequiredToBeUniform.error=] -> X is the same as saying that X is true.

        Reciprocally, to express that we cannot ensure the uniformity of something (e.g. a variable which holds the thread id), we add an edge from the corresponding node to [=MayBeNonUniform=].
        One way to understand this, is that [=MayBeNonUniform=] corresponds to the proposition False, so that X -> [=MayBeNonUniform=] is the same as saying that X is false.

        A consequence of this interpretation is that every node reachable from [=RequiredToBeUniform.error=] corresponds to
        something which is required to be uniform for the program to be valid, and every node from which
        [=MayBeNonUniform=] is reachable corresponds to something whose uniformity we cannot guarantee.
        It follows that we have a uniformity violation, triggering a [=uniformity failure=], if there is any
        path from [=RequiredToBeUniform.error=] to [=MayBeNonUniform=].

        The nodes [=RequiredToBeUniform.warning=] and [=RequiredToBeUniform.info=] are used in a similar way,
        but instead help determine when [=severity/warning=] or [=severity/info=] [=diagnostics=] should be triggered:
        *   If there is a path from [=RequiredToBeUniform.warning=] to [=MayBeNonUniform=], then a [=severity/warning=]
            [=diagnostic=] will be triggered.
        *   If there is a path from [=RequiredToBeUniform.info=] to [=MayBeNonUniform=], then an [=severity/info=]
            [=diagnostic=] will be triggered.

        As described in [[#diagnostics]], lower severity diagnostics may be discarded if higher severity diagnostics have also been generated.
</div>

For each function, two tags are computed:
  * A <dfn noexport>call site tag</dfn> describing the control flow uniformity requirements on the [=call sites=] of the function, and
  * A <dfn noexport>function tag</dfn> describing the function's effects on uniformity.

For each [=formal parameter=] of a function, one or two tags are computed:
  * A <dfn noexport>parameter tag</dfn> describes the uniformity requirement of the parameter value.
  * A <dfn noexport>parameter return tag</dfn> describes how the uniformity of the parameter influences that of the function's [=return value=].
  * A <dfn noexport>pointer parameter tag</dfn>, when the parameter type is a pointer into the  [=address spaces/function=] address space.
      The tag describes whether the value in the memory pointed to by the parameter may become
      [=uniform value|non-uniform=] during the execution of the function call.

<table class='data'>
  <caption>[=Call site tag=] values</caption>
  <thead>
    <tr><th>Call Site Tag<th>Description
  </thead>
  <tr algorithm="CallSiteRequiredToBeUniform tag">
      <td><dfn noexport>CallSiteRequiredToBeUniform.S</dfn>,<br>
          where |S| is one of the severities: [=severity/error=], [=severity/warning=], or [=severity/info=].
      <td>The function must only be called from [=uniform control flow=].
          Otherwise a diagnostic with severity |S| will be triggered.

          Associated with a [=potential-trigger-set=].
  <tr><td><dfn noexport>CallSiteNoRestriction</dfn>
      <td>The function may be called from [=uniform control flow|non-uniform control flow=].
</table>

<table class='data'>
  <caption>[=Function tag=] values</caption>
  <thead>
    <tr><th>Function Tag<th>Description
  </thead>
  <tr><td><dfn noexport>ReturnValueMayBeNonUniform</dfn>
      <td>The [=return value=] of the function may be non-uniform.
  <tr><td><dfn noexport>NoRestriction</dfn>
      <td>The function does not introduce non-uniformity.
</table>

<table class='data'>
  <caption>[=Parameter tag=] values</caption>
  <thead>
    <tr><th>Parameter Tag<th>Description
  </thead>
  <tr algorithm="ParameterRequiredToBeUniformValue tag">
      <td><dfn noexport>ParameterRequiredToBeUniform.S</dfn>,<br>
          where |S| is one of the severities: [=severity/error=], [=severity/warning=], or [=severity/info=].
      <td>The parameter must be a [=uniform value=].
          If the parameter type is a pointer, the memory view, but not
          necessarily its contents, must be uniform.
          Otherwise a diagnostic with severity |S| will be triggered.

          Associated with a [=potential-trigger-set=].
  <tr algorithm="ParameterContentsRequiredToBeUniform tag">
      <td><dfn noexport>ParameterContentsRequiredToBeUniform.S</dfn>,<br>
          where |S| is one of the severities: [=severity/error=], [=severity/warning=], or [=severity/info=].
      <td>The value stored in the memory pointed to by the pointer parameter must be a [=uniform value=].
          Otherwise a diagnostic with severity |S| will be triggered.

          Associated with a [=potential-trigger-set=].
  <tr><td><dfn noexport>ParameterNoRestriction</dfn>
      <td>The parameter value has no uniformity requirement.
</table>

<table class='data'>
  <caption>[=Parameter return tag=] values</caption>
  <thead>
    <tr><th>Parameter Return Tag<th>Description
  </thead>
  <tr><td><dfn noexport>ParameterReturnContentsRequiredToBeUniform</dfn>
      <td>The parameter [=shader-creation error|must=] be a [=uniform value=] in order for the [=return value=] to be a uniform value.
      If the parameter is a pointer, then the values stored in the memory pointed to by the pointer must also be [=uniform value|uniform=].
  <tr><td><dfn noexport>ParameterReturnNoRestriction</dfn>
      <td>The parameter value has no uniformity requirement.
</table>

<table class='data'>
  <caption>[=Pointer parameter tag=] values</caption>
  <thead>
    <tr><th>Pointer Parameter Tag<th>Description
  </thead>
  <tr><td><dfn noexport>PointerParameterMayBeNonUniform</dfn>
      <td>The value stored in the memory pointed to by the pointer parameter may be [=uniform value|non-uniform=] after the function call.
  <tr><td><dfn noexport>PointerParameterNoRestriction</dfn>
      <td>The uniformity of the value stored in the memory pointed to by the pointer parameter is unaffected by the function call.
</table>

The following algorithm describes how to compute these tags for a given function:

* Create the following nodes:
    * <dfn noexport>RequiredToBeUniform.error</dfn>, <dfn noexport>RequiredToBeUniform.warning</dfn>, and <dfn noexport>RequiredToBeUniform.info</dfn>.
        Collectively these are called the <dfn noexport>RequiredToBeUniform.S</dfn> nodes.
        * Each such node is associated with a [=potential-trigger-set=], which is initially empty.
    * <dfn noexport>MayBeNonUniform</dfn>
    * <dfn noexport>CF_start</dfn>, representing the uniformity requirement for control flow when the function begins executing.
    * <dfn noexport>param_i</dfn>, where *i* ranges over the function's [=formal parameters=].
    * If the function has a [=return type=], create a node called <dfn noexport>Value_return</dfn>.
* Desugar pointers as described in [[#pointer-desugar]].
    * For each formal parameter that is a pointer in the [=address spaces/function=] address space,
        create the following nodes:
        * <dfn noexport>param_i_contents</dfn>: this represents the uniformity of the contents of the memory view.
        * <dfn noexport>Value_return_i_contents</dfn>: this represents the function's effects on the uniformity of the contents of the memory view.
* Walk over the syntax of the function, adding nodes and edges to the graph following the rules of the next sections ([[#func-var-value-analysis]], [[#uniformity-statements]], [[#uniformity-function-calls]], [[#uniformity-expressions]]), using [=CF_start=] as the starting control-flow for the function's body.
    * The nodes added in this step are called <dfn noexport>interior nodes</dfn>.
* Initialize as follows:
    * The [=function tag=] is initialized to [=NoRestriction=].
    * The [=call site tag=] is initialized to [=CallSiteNoRestriction=].
    * The [=parameter tag=] for each [=param_i=] is initialized to [=ParameterNoRestriction=].
    * The [=parameter return tag=] for each [=param_i=] is initialized to [=ParameterReturnNoRestriction=].
    * The [=pointer parameter tag=] for each [=param_i=], if it exists, is initialized to [=PointerParameterNoRestriction=].
* For each severity *S* in the order {[=severity/error=], [=severity/warning=], [=severity/info=]}, perform the following:
    * Let *R.S* be the set of unvisited nodes reachable from [=RequiredToBeUniform.S=].
    * Mark the [=interior nodes=] in *R.S* as visited.
    * Let *PTS* be the [=potential-trigger-set=] associated with [=RequiredToBeUniform.S=].
    * If *R.S* includes the node [=MayBeNonUniform=], then trigger a [=uniformity failure=]:
         * [=triggered|Trigger=] a diagnostic with severity *S* and triggering rule *t*, for each *t* in *PTS*.
    * Otherwise:
        * If *R.S* includes [=CF_start=], and the [=call site tag=] has not been updated since initialization, then
             set the [=call site tag=] to [=CallSiteRequiredToBeUniform.S=], and set its [=potential-trigger-set=] to *PTS*.
        * For each [=param_i=] in *R.S*, if its corresponding [=parameter tag=] has not been updated since initialization, then
             set that tag to [=ParameterRequiredToBeUniform.S=], and set its [=potential-trigger-set=] to *PTS*.
        * For each [=param_i_contents=] in *R.S*, if its corresponding [=parameter tag=] has not been updated since initialization, then
             set that tag to [=ParameterContentsRequiredToBeUniform.S=], and set its [=potential-trigger-set=] to *PTS*.
* Mark all the [=interior nodes=] as unvisited.
* If [=Value_return=] exists, let *VR* be the set of nodes reachable from [=Value_return=].
    * If *VR* includes [=MayBeNonUniform=], then set the [=function tag=] to [=ReturnValueMayBeNonUniform=].
    * For each [=param_i=] in *VR*, set the corresponding [=parameter return tag=] to [=ParameterReturnContentsRequiredToBeUniform=].
* For each [=Value_return_i_contents=] node, let *VRi* be the set of nodes reachable from [=Value_return_i_contents=].
    * If *VRi* includes [=MayBeNonUniform=], set the corresponding [=pointer parameter tag=] to [=PointerParameterMayBeNonUniform=].

Note: The entire graph can be destroyed at this point. The tags described above are all that we need to remember to analyze callers of this function.
However, the graph contains information that can be used to provide more informative diagnostics.
For example a value in a one function may not be provably [=uniform value|uniform=],
which then contributes to triggering a uniformity failure in another function.
An informative diagnostic would describe the non-uniform value, as well as the function call at the diagnostic's
[=diagnostic/triggering location|triggered location=].

### Pointer Desugaring ### {#pointer-desugar}

Each [=formal parameter|parameter=] of [=pointer type=] in the [=address
spaces/function=] address space is desugared as a local variable declaration
whose initial value is equivalent to dereferencing the parameter.
That is, function address space pointers are viewed as aliases to a local
variable declaration.
The initial value assignment produces an edge to [=param_i_contents=] for
*i*<sup>th</sup> parameter (i.e. *V(e)* is [=param_i_contents=]).

Each [=let-declaration=], *L*, with an [=effective-value-type=] that is a [=pointer type=] is desugared as follows:
* Visit each subexpression, *SE*, of the initializer expression of *L* in a postorder depth-first traversal:
    * If  *SE* invokes the [=load rule=] during [=type checking=] and the [=root identifier=]
        is a mutable variable then:
        * Create a new let-declaration, *LSE*, immediately prior to *L* initialized with *SE*.
        * Replace *SE* in *L* with a [[#value-identifier-expr|value identifier expression]]
            composed of *LSE*.
* Record the, possibly updated, initializer expression of *L*.
* Substitute each [=identifier=] that [=resolves=] to *L* with the recorded
    initializer expression (wrapped in a [[#parenthesized-expressions|parenthesized expression]]).

This desugaring simplifies the subsequent analyses by exposing the [=root identifier=]
of the pointer directly at each of its uses.

Note: For the purposes of uniformity analysis [=type checking=] is described to
occur both before and after this desugaring has occurred.

<div class='example wgsl' heading='pointers in the uniformity analysis'>
  <xmp>
    fn foo(p : ptr<function, array<f32, 4>>, i : i32) -> f32 {
      let p1 = p;
      var x = i;
      let p2 = &((*p1)[x]);
      x = 0;
      *p2 = 5;
      return (*p1)[x];
    }

    // This is the equivalent version of foo for the analysis.
    fn foo_for_analysis(p : ptr<function, array<f32, 4>>, i : i32) -> f32 {
      var p_var = *p;            // Introduce variable for p.
      let p1 = &p_var;           // Use the variable for p1
      var x = i;
      let x_tmp1 = x;            // Capture value of x
      let p2 = &(p_var[x_tmp1]); // Substitute p1's initializer
      x = 0;
      *(&(p_var[x_tmp1])) = 5;   // Substitute p2's initializer
      return (*(&p_var))[x];     // Substitute p1's initializer
    }
  </xmp>
</div>

### Function-scope Variable Value Analysis ### {#func-var-value-analysis}

The value of each [=function scope|function-scope=] [=variable=] at a
particular statement can be analyzed in terms of the assignments that reach it
and, potentially, its initial value.

An assignment is a <dfn noexport>full assignment</dfn> if:
* The variable's [=effective-value-type=] is a [=scalar=] type, or
* the variable's [=effective-value-type=] is a [=composite=] type and each
    [=component=] of the composite is assigned a value.

Otherwise, an assignment is a <dfn noexport>partial assignment</dfn>.

A <dfn>full reference</dfn> is an expression of [=reference type=] that is one of:
* an identifier *x* that [=resolves=] to a variable, or
* `(`*r*`)` where *r* is a [=full reference=], or
* `*`*p* where *p* is a [=full pointer=].

A <dfn>full pointer</dfn> is an expression of [=pointer type=] that is one of:
* `&`*r* where *r* is a [=full reference=], or
* an identifier *p* that [=resolves=] to a [=let-declaration=] initialized to a [=full pointer=], or
* `(`*p*`)` where *p* is a [=full pointer=].

Note: For the purposes of this analysis, we don't need the case where
a formal parameter of pointer type may be a full pointer.

A [=full reference=], and similarly a [=full pointer=], is a [=memory view=]
for *all* the memory locations for the corresponding [=originating variable=] *x*.

A reference that is not a [=full reference=] is a <dfn noexport>partial reference</dfn>.
As such, a partial reference is either:
* a memory view for a strict subset of the memory locations
    for the corresponding [=originating variable=], or
* a memory view the with same set of locations as the corresponding
    originating variable, but with a different [=store type=].

<div class="note">
<span class=marker>Note:</span> A [=partial reference=] can still cover all the same memory locations
as a full reference, i.e. all the locations used by a variable declaration.
This can occur when the store type is a structure type having only one member,
or when the store type is an array type with one element.

Consider a structure type with a single member, and a variable storing that type:

```
     struct S { member: i32; }
     fn foo () {
        var v: S;
     }
```

Then `v` is a full reference and `v.member` is a partial reference.
Their memory views cover the same memory
locations, but the store type for `v` is `S` and the store type of `v.s` is `i32`.

A similar situation occurs with arrays having a single element:

```
     fn foo () {
        var arr: array<i32,1>;
     }
```

Then `arr` is a full reference and `arr[0]` is a partial reference.
Their memory views cover the same memory
locations, but the store type for `arr` is `array<i32,1>` and the store type of `arr[0]` is `i32`.

To simplify analysis, an assignment via *any* kind of [=partial reference=] is treated as if
it does *not* modify every memory location in the associated [=originating variable=].
This causes the analysis to be conservative, potentially triggering a [=uniformity failure=] for
more programs than strictly necessary.
</div>

An assignment through a [=full reference=] is a [=full assignment=].

An assignment through a [=partial reference=] is a [=partial assignment=].

When the uniformity rules in subsequent sections refer to the value for a
function-scope variable used as an [=RHSValue=], it means the value of the variable
prior to evaluation of the RHSValue expression.
When the uniformity rules in subsequent sections refer to the value for a
function-scope variable used as an [=LHSValue=], it means the value of the variable
after execution of the statement the expression appears in.

Multiple assignments to a variable might reach a use of that variable due to
[[#control-flow|control-flow statements]] or partial assignments.
The analysis joins multiple assignments reaching out of control-flow statements
by unioning the set of assignments that reach each control-flow exit.

The following table describes the rules for joining assignments.
In the uniformity graph, each join is an edge from the result node to node
representing the source of the value.
It is written in terms of an arbitrary variable `x`. It uses the following
notations:
* *Vin*(*S*) is the value of `x` prior the execution of the statement *S*.
* *Vout*(*S*) is the value of `x` after the execution of the statement *S*.
* *Vout*(*prev*) is the value of `x` prior to the execution of the current statement.
* *Vin*(*next*) is the value of `x` prior to the execution of the next statement.
* *V*(*e*) is a value node for an expression as in the subsequent sections.
* *V*(*0*) is the zero value of `x`'s [=effective-value-type=].

<table class='data'>
  <caption>Rules for joining multiple assignments to a function-scope variable.
  <thead>
    <tr><th>Statement
        <th>Result
        <th>Edges from the Result
  </thead>
  <tr><td>
          var *x*;
      <td>*Vin*(*next*)
      <td>*V*(*0*)
  <tr><td>
          var *x* = *e*;<br>
      <td rowspan=3>*Vin*(*next*)
      <td rowspan=3>*V*(*e*)

          Note: This is a [=full assignment=] to *x*.
  <tr><td>
          *x* = *e*;<br>
  <tr><td>
          *r* = *e*;<br>
          where *r* is a [=full reference=] to variable *x*
  <tr><td>
          *r* = *e*;<br>
          where *r* is a [=partial reference=] to variable *x*
      <td>*Vout*(*S*)
      <td>*V*(*e*), *V*(*prev*)

          Note: This is a [=partial assignment=] to *x*.

          Note: Partial assignments include the previous value.
          The assignment either writes only a subset of the stored components,
          or the type of the written value differs from the [=store type=]
          of the [=originating=] variable.
  <tr><td>*s1* *s2*<br>
          where *Next* is in behavior of *s1*.

          Note: *s1* often ends in a semicolon.
      <td>*Vin*(*s2*)
      <td>*Vout*(*s1*)
  <tr><td>
          if *e* *s1* else *s2*<br>
          where *Next* is in the behaviors of both *s1* and *s2*
      <td>*Vin*(*next*)
      <td>*Vout*(*s1*), *Vout*(*s2*)
  <tr><td>
          if *e* *s1* else *s2*<br>
          where *Next* is in the behavior of *s1*, but not *s2*
      <td>*Vin*(*next*)
      <td>*Vout*(*s1*)
  <tr><td>
          if *e* *s1* else *s2*<br>
          where *Next* is in the behavior of *s2*, but not *s1*
      <td>*Vin*(*next*)
      <td>*Vout*(*s2*)
  <tr><td>loop { *s1* continuing { *s2* } }
      <td>*Vin*(*s1*)
      <td>*Vout*(*prev*), *Vout*(*s2*)
  <tr><td>loop { *s1* continuing { *s2* } }
      <td>*Vin*(*s2*)
      <td>*Vout*(*s1*),<br>
          *Vout*(*s*<sub>i</sub>)<br>
          for all *s*<sub>i</sub> in *s1* whose behavior is {*Continue*} and transfer control to *s2*
  <tr><td>loop { *s1* continuing { *s2* } }
      <td>*Vin*(*next*)
      <td>*Vout*(*s2*),<br>
          *Vout*(*s*<sub>i</sub>)<br>
          for all *s*<sub>i</sub> in *s1* whose behavior is {*Break*} and transfer control to *next*
  <tr><td>switch *e* {<br>
            case _: *s1*<br>
            case _: *s2*<br>
            ...<br>
            case _: *s3*<br>
          }<br>
      <td>*Vin*(*s*<sub>i</sub>)
      <td>*Vout*(*prev*)
  <tr><td>switch *e* {<br>
            case _: *s1*<br>
            case _: *s2*<br>
            ...<br>
            case _: *s3*<br>
          }<br>
      <td>*Vin*(*next*)
      <td>*Vout*(*s*<sub>i</sub>),<br>
          for all *s*<sub>i</sub> whose behavior includes *Next* or *Break*, and<br>
          *Vout*(*s*<sub>j</sub>)<br>
          for all statements inside *s*<sub>j</sub> whose behavior is {*Break*} and trasfer control to *next*
</table>

For all other statements (except function calls), *Vin*(*next*) is equivalent
to *Vout*(*prev*).

Note: The same desugarings apply as in [[#behaviors|statement behavior analysis]].

### Uniformity Rules for Statements ### {#uniformity-statements}

The rules for analyzing statements take as argument both the statement itself and the node corresponding to control flow at the beginning of it (which we'll note "CF" below) and return both of the following:

* A node corresponding to control flow at the exit of it
* A set of new nodes and edges to add to the graph

In the table below, `(CF1, S) => CF2` means "run the analysis on S starting
with control flow CF1, apply the required changes to the graph, and name the
resulting control flow CF2".
Similarly, `(CF1, E) => (CF2, V)` means "run the analysis on expression E,
starting with control flow CF1, apply the required changes to the graph, and
name the resulting control flow node CF2 and the resulting value node V" (see
next section for the analysis of expressions).
This evaluation of expressions is used for any expression that is not part of
the [=left-hand side=] of an [=statement/assignment=] and is called an <dfn
noexport>RHSValue</dfn>.

There is a similar set of rules for expressions that are part of the
[=left-hand side=] of an [=statement/assignment=], the <dfn noexport>LHSValue</dfn>,
that we denote by `LHSValue: (CF, E) => (CF, L)`. Instead of computing the node
which corresponds to the uniformity of the value, it computes the node which
corresponds to the uniformity of the variable we are addressing.

Note: [=LHSValues=] include expressions in [=increment statement|increment=] and
[=decrement statement|decrement=] statements.

Note: [=RHSValues=] include expression that are part of the [=right-hand side=] of
an [=statement/assignment=] statement or expressions that are not part of an
assignment, [=increment statement|increment=], or [=decrement statement|decrement=] statement.

When several edges have to be created we use `X -> {Y, Z}` as a short-hand for `X -> Y, X -> Z`.

<table class='data'>
  <caption>Uniformity rules for statements</caption>
  <thead>
    <tr><th>Statement<th>New nodes<th>Recursive analyses<th>Resulting control flow node<th>New edges
  </thead>
  <tr><td class="nowrap">{*s*}
      <td>
      <td class="nowrap">(*CF*, *s*) => *CF'*
      <td>*CF'*
      <td>
  <tr><td class="nowrap">*s1* *s2*,<br>
        with Next in behavior of *s1*

        Note: *s1* often ends in a semicolon.

      <td>
      <td class="nowrap">(*CF*, *s1*) => *CF1*<br>
          (*CF1*, *s2*) => *CF2*
      <td>*CF2*
      <td>
  <tr><td class="nowrap">*s1* *s2*,<br>
        without Next in behavior of *s1*

        Note: *s1* often ends in a semicolon.

      <td>
      <td>(*CF*, *s1*) => *CF1*<br>

      Note: *s2* is statically unreachable and not recursively analyzed.
      *s2* does not contribute to the uniformity analysis.
      <td>*CF1*
      <td>
  <tr><td class="nowrap">if *e* *s1* else *s2*<br> with behavior {Next}
      <td>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)<br>
          (*V*, *s1*) => *CF1*<br>
          (*V*, *s2*) => *CF2*
      <td>*CF*
      <td>
  <tr><td class="nowrap">if *e* *s1* else *s2*<br> with another behavior
      <td>*CFend*
      <td>*CFend*
      <td class="nowrap">*CFend* -> {*CF1*, *CF2*}
  <tr><td class="nowrap">loop {*s1* continuing {*s2*}}<br> with behavior {Next}
      <td rowspan=2>*CF'*
      <td rowspan=2 class="nowrap">(*CF'*, *s1*) => *CF1*<br>
          (*CF1*, *s2*) => *CF2*
      <td>*CF*
      <td rowspan=2 class="nowrap">*CF'* -> {*CF2*, *CF*}
  <tr><td class="nowrap">loop {*s1* continuing {*s2*}}<br> with another behavior
      <td>*CF'*
  <tr><td class="nowrap">loop {*s1*}<br> with behavior {Next}
      <td rowspan=2>*CF'*
      <td rowspan=2 class="nowrap">(*CF'*, *s1*) => *CF1*
      <td>*CF*
      <td rowspan=2 class="nowrap">*CF'* -> {*CF1*, *CF*}
  <tr><td class="nowrap">loop {*s1*}<br> with another behavior
      <td>*CF'*
  <tr><td class="nowrap">switch *e* case _: *s_1* .. case _: *s_n*<br> with behavior {Next}
      <td>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)<br>
        (*V*, *s_1*) => *CF_1*<br>
        ...<br>
        (*V*, *s_n*) => *CF_n*
      <td>*CF*
      <td>
  <tr><td class="nowrap">switch *e* case _: *s_1* .. case _: *s_n*<br> with another behavior
      <td>*CFend*
      <td>*CFend*
      <td class="nowrap">*CFend* -> {*CF_1*, ..., *CF_n*}
  <tr><td class="nowrap">var x: T;
      <td rowspan=3>
      <td rowspan=3>
      <td rowspan=3>*CF*
      <td rowspan=3>
      Note: If x is a [=address spaces/function=] address space variable, *CF*
      is used as the zero value initializer in the
      [[#func-var-value-analysis|value analysis]].
  <tr><td class="nowrap">break;
  <tr><td class="nowrap">continue;
  <tr><td class="nowrap">break if *e*;
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>
  <tr><td class="nowrap">return;
      <td>
      <td>
      <td>*CF*
      <td>
      For each [=address spaces/function=] address space pointer parameter *i*,
      [=Value_return_i_contents=] -> *Vin*(*prev*) (see [[#func-var-value-analysis]])
  <tr><td class="nowrap">return *e*;
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>[=Value_return=] -> *V*

      For each [=address spaces/function=] address space pointer parameter *i*,
      [=Value_return_i_contents=] -> *Vin*(*prev*) (see [[#func-var-value-analysis]])
  <tr><td class="nowrap">*e1* = *e2*;
      <td>
      <td class="nowrap">[=LHSValue=]: (*CF*, *e1*) => (*CF1*, *LV*)<br>
          (*CF1*, *e2*) => (*CF2*, *RV*)
      <td>*CF2*
      <td>*LV* -> *RV*

      Note: *LV* is the result value from the [[#func-var-value-analysis|value analysis]].
  <tr><td class="nowrap">_ = *e*
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>
  <tr><td class="nowrap">let x = *e*;
      <td>
      <td>(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>
  <tr><td class="nowrap">var x = *e*;
      <td>
      <td>(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>Note: If x is a [=address spaces/function=] address space variable,
      *V* is used as the result value in the [[#func-var-value-analysis|value analysis]].
</table>

Analysis of [[#for-statement|for]] and [[#while-statement|while]] loops follows
from their respective desugaring translations to [[#loop-statement|loop]] statements.

In [[#switch-statement|switch]], a [=default-alone clause=] block is treated exactly like a [=case clause=] with regards to uniformity.

To maximize performance, implementations often try to minimize the amount of
[=uniform control flow|non-uniform control flow=].
However, the points at which invocations can be said to be uniform varies
depending on a number of factors.  WGSL's static analysis conservatively
assumes a return to uniform control flow occuring at the end of
[=statement/if=], [=statement/switch=], and [=statement/loop=] statements if
the [[#behaviors|behavior]] for the statement is {Next}.
This is modeled in the preceding table as the resulting control flow node
being the same as input control flow node.

### Uniformity Rules for Function Calls ### {#uniformity-function-calls}

The most complex rule is for function calls:
- For each argument, apply the corresponding expression rule, with the control flow at the exit of the previous argument (using the control flow at the beginning of the function call for the first argument). Name the corresponding value nodes <dfn noexport>arg_i</dfn> and the corresponding control flow nodes <dfn noexport>CF_i</dfn>
- Create two new nodes, named <dfn noexport>Result</dfn> and <dfn noexport>CF_after</dfn>
- If the [=call site tag=] of the function is [=CallSiteRequiredToBeUniform.S=], then:
    - Add an edge from [=RequiredToBeUniform.S=] to the last [=CF_i=].
    - Add the members of the [=potential-trigger-set=] of the [=call site tag=] to the potential-trigger-set associated with [=RequiredToBeUniform.S=].
- Add an edge from [=CF_after=] to the last [=CF_i=]
- If the [=function tag=] is [=ReturnValueMayBeNonUniform=], then add an edge from [=Result=] to [=MayBeNonUniform=]
- Add an edge from [=Result=] to [=CF_after=]
- For each argument *i*:
    - If the corresponding [=parameter tag=] is [=ParameterRequiredToBeUniform.S=], then:
        - Add an edge from [=RequiredToBeUniform.S=] to [=arg_i=].
        - Add the members of the [=potential-trigger-set=] of the [=parameter tag=] to the potential-trigger-set associated with [=RequiredToBeUniform.S=].
    - If the [=parameter return tag=] is [=ParameterReturnContentsRequiredToBeUniform=], then add an edge from [=Result=] to [=arg_i=]
    - If the corresponding parameter has a [=pointer parameter tag=] of [=PointerParameterMayBeNonUniform=], then add an edge from *Vout*(*call*) to [=MayBeNonUniform=]
    - If the parameter is a pointer in the [=address spaces/function=] address space, add an edge from *Vout*(*call*) to each corresponding [=arg_i=] for the reachable parameters recorded previously
        - If the [=parameter tag=] is [=ParameterContentsRequiredToBeUniform.S=], add an edge from [=RequiredToBeUniform.S=] to *Vout*(*call*)

Note: Refer to [[#func-var-value-analysis]] for the definition of *Vout*(*call*).

Most built-in functions have tags of:
- A [=call site tag=] of [=CallSiteNoRestriction=].
- A [=function tag=] of [=NoRestriction=].
- For each parameter:
    - a [=parameter tag=] of [=ParameterNoRestriction=].
    - a [=parameter return tag=] of [=ParameterReturnContentsRequiredToBeUniform=].

Here is the list of exceptions:
- A call to a function in [[#sync-builtin-functions]]:
    - Has a [=function tag=] of [=NoRestriction=].
    - Has a [=call site tag=] of [=CallSiteRequiredToBeUniform.S|CallSiteRequiredToBeUniform.error=], with [=potential-trigger-set=]
        consisting of an unnamed [=diagnostic/triggering rule=].
        - Note: The triggering rule has no name, and so it cannot be filtered.
    - Additionally for the case of a call to [[#workgroupUniformLoad-builtin|workgroupUniformLoad]],
        the parameter `p` has a [=parameter tag=] of [=ParameterRequiredToBeUniform.S|ParameterRequiredToBeUniform.error=],
        with [=potential-trigger-set=] consisting of an unnamed [=diagnostic/triggering rule=].
- A call to a function in
    [[#derivative-builtin-functions]], [[#texturesample]], [[#texturesamplebias]], and [[#texturesamplecompare]]:
    - Has a [=function tag=] of [=ReturnValueMayBeNonUniform=].
    - Has a [=call site tag=] as follows:
        - Let *DF* be the [=nearest enclosing diagnostic filter=] for the call site location and triggering rule [=trigger/derivative_uniformity=]
        - If *DF* exists, then let *S* be the *DF*'s new severity parameter.
            - If *S* is the severity [=severity/off=], the call site tag is [=CallSiteNoRestriction=].
            - Otherwise the call site tag is [=CallSiteRequiredToBeUniform.S=], with [=potential-trigger-set=]
                consisting of a [=trigger/derivative_uniformity=] element.
        - If there is no such *DF*,
            the call site tag is [=CallSiteRequiredToBeUniform.S|CallSiteRequiredToBeUniform.error=], with [=potential-trigger-set=]
            consisting of a [=trigger/derivative_uniformity=] element.
- A call to [[#textureload]]:
    - Has a [=call site tag=] of [=CallSiteNoRestriction=]
    - Has a [=function tag=] as follows:
        - [=ReturnValueMayBeNonUniform=] if the argument corresponding to the `t` parameter
            is a [=type/read-write storage texture=]
        - [=NoRestriction=] otherwise


Note: A WGSL implementation will ensure that if control flow prior to a
function call is [=uniform control flow|uniform=], it will also be uniform
after the function call.

### Uniformity Rules for Expressions ### {#uniformity-expressions}

The rules for analyzing expressions take as argument both the expression itself and the node corresponding to control flow at the beginning of it (which we'll note "CF" below) and return the following:

* A node corresponding to control flow at the exit of it
* A node corresponding to its value
* A set of new nodes and edges to add to the graph

<table class='data'>
  <caption>Uniformity rules for [=RHSValue=] expressions</caption>
  <thead>
    <tr><th>Expression<th>New nodes<th>Recursive analyses<th>Resulting control flow node, value node<th>New edges
  </thead>
  <tr><td class="nowrap">*e1* || *e2*
      <td rowspan=2>
      <td rowspan=2 class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          (*V1*, *e2*) => (*CF2*, *V2*)
      <td rowspan=2 class="nowrap">*CF*, *V2*
      <td rowspan=2>
  <tr><td class="nowrap">*e1* && *e2*
  <tr><td class="nowrap">Literal
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td>identifier [=resolves|resolving=] to function-scope variable "x",
      where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is invoked on *MVE* during
      [=type checking=]
      <td>*Result*
      <td class>*X* is the node corresponding to the value of "x" at the input to the statement containing this expression
      <td class="nowrap">*CF*, *Result*
      <td class>*Result* -> {*CF*, *X*}

      Note: *X* is equivalent to *Vout*(*prev*) for "x"<br>
      (see [[#func-var-value-analysis]])
   <tr><td>identifier [=resolves|resolving=] to function-scope variable "x",
      where "x" is the desugared pointer parameter *i*, and
      where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is not invoked on *MVE* during
      [=type checking=]
      <td>
      <td class>
      <td class="nowrap">*CF*, [=param_i=]
      <td class>
   <tr><td>identifier [=resolves|resolving=] to function-scope variable "x",
      where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is not invoked on *MVE* during
      [=type checking=]
      <td>
      <td class>
      <td class="nowrap">*CF*, *CF*
      <td class>
   <tr><td>identifier [=resolves|resolving=] to [=const-declaration=], [=override-declaration=],
      [=let-declaration=], or non-built-in [=formal parameter=] "x"
      <td>*Result*
      <td>*X* is the node corresponding to "x"
      <td class="nowrap">*CF*, *Result*
      <td class="nowrap">*Result* -> {*CF*, *X*}
   <tr><td>identifier [=resolves|resolving=] to uniform built-in value "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td>identifier [=resolves|resolving=] to non-uniform built-in value "x"
      <td>
      <td>
      <td class="nowrap">*CF*,<br>
      [=MayBeNonUniform=]
      <td>
   <tr><td>identifier [=resolves|resolving=] to read-only module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td>identifier [=resolves|resolving=] to non-read-only module-scope
      variable "x" where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is invoked on *MVE* during
      [=type checking=]
      <td>
      <td>
      <td class="nowrap">*CF*,<br>
      [=MayBeNonUniform=]
      <td>
   <tr><td>identifier [=resolves|resolving=] to non-read-only module-scope
      variable "x" where the identifier appears as the [=root identifier=] of a [=memory view=]
      expression, *MVE*, and the [=load rule=] is not invoked on *MVE* during
      [=type checking=]
      <td>
      <td>
      <td class="nowrap">*CF*,*CF*
      <td>
   <tr><td class="nowrap">*op* *e*,<br> where *op* is a unary operator
      <td rowspan=2>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td rowspan=2 class="nowrap">*CF'*, *V*
      <td rowspan=2>
   <tr><td class="nowrap">*e*.field
   <tr><td>*e1* *op* *e2*,<br> where *op* is a non-short-circuiting binary operator
      <td rowspan=2> *Result*
      <td rowspan=2 class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          (*CF1*, *e2*) => (*CF2*, *V2*)
      <td rowspan=2 class="nowrap">*CF2*, *Result*
      <td rowspan=2 class="nowrap">*Result* -> {*V1*, *V2*}
   <tr><td class="nowrap">e1[e2]
</table>

The following built-in input variables are considered uniform:
- [=built-in values/workgroup_id=]
- [=built-in values/num_workgroups=]

All other ones (see [=built-in values=]) are considered non-uniform.

Note: An author should avoid grouping the uniform built-in values together with
other non-uniform inputs because the analysis does not analyze the [=components=]
of a [=composite=] type separately.

<table class='data'>
  <caption>Uniformity rules for [=LHSValue=] expressions</caption>
  <thead>
    <tr><th>Expression<th>New nodes<th>Recursive analyses<th>Resulting control flow node, variable node<th>New edges
  </thead>
   <tr><td>identifier [=resolves|resolving=] to function-scope variable "x"
      <td>*Result*
      <td>*X* is the node corresponding to the value of "x" at the output of the statement containing this expression.
      <td class="nowrap">*CF*, *Result*
      <td class>*Result* -> {*CF*, *X*}

      Note: *X* is equivalent to *Vin*(*next*) for "x"<br>
      (see [[#func-var-value-analysis]])
  <tr><td>identifier [=resolves|resolving=] to
          [=const-declaration=], [=override-declaration=], [=let-declaration=], or [=formal parameter=] "x"
      <td>
      <td>*X* is the node corresponding to "x"
      <td class="nowrap">*CF*, *X*
      <td>
  <tr><td>identifier [=resolves|resolving=] to module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*,<br>
      [=MayBeNonUniform=]
      <td>
  <tr><td class="nowrap">*e*.field
      <td>
      <td class="nowrap">[=LHSValue=]: (*CF*, *e*) => (*CF1*, *L1*)
      <td class="nowrap">*CF1*, *L1*
      <td>
  <tr><td class="nowrap">*e1*[*e2*]
      <td>
      <td class="nowrap">[=LHSValue=]: (*CF*, *e1*) => (*CF1*, *L1*)<br>
          (*CF1*, *e2*) => (*CF2*, *V2*)
      <td class="nowrap">*CF2*, *L1*
      <td class="nowrap">*L1* -> *V2*
</table>

### Annotating the Uniformity of Every Point in the Control-flow ### {#uniformity-optional-diagnosis-mode}

This entire subsection is non-normative.

If implementers want to provide developers with a diagnostic mode that shows for each point in the control-flow of the entire shader whether it is uniform or not (and thus whether it would be valid to call a function that requires uniformity there), we suggest the following:
- Run the (mandatory, normative) analysis described in the previous subsections, keeping the graph for every function.
- Reverse all edges in all of those graphs
- Go through each function, starting with the entry point and never visiting a function before having visited all of its callers:
    - Add an edge from [=MayBeNonUniform=] to every argument that was non-uniform in at least one caller.
    - Add an edge from [=MayBeNonUniform=] to [=CF_start=] if the function was called in non-uniform control-flow in at least one caller.
    - Look at which nodes are reachable from [=MayBeNonUniform=]. Every node visited is an expression or point in the control-flow whose uniformity cannot be proven by the analysis.

Any node which is not visited by these reachability analyses can be proven to be uniform by the analysis (and so it would be safe to call a derivative or similar function there).

Note: The bottom-up analysis is still required, as it lets us know what edges to add to the graphs when encountering calls.

### Examples ### {#uniformity-examples}

The graphs in the subsequent example use the following conventions for nodes:
* Rectangles represent value nodes.
* Rounded  rectangles represent control flow nodes.

#### Invalid `textureSample` Function Call #### {#uniformity-example1}

This example shows an invalid use of a [[#texturesample|textureSample]]
built-in function call.
The function call is made within an if statement whose condition depends on a
non-uniform value (i.e. the built-in value `position`).
The invalid dependency chain is highlighted in red.

<div class='example wgsl' heading='WGSL invalid textureSample'>
  <xmp>
    @group(0) @binding(0) var t : texture_2d<f32>;
    @group(0) @binding(1) var s : sampler;

    @fragment
    fn main(@builtin(position) pos : vec4<f32>) {
      if (pos.x < 0.5) {
        // Invalid textureSample function call.
        _ = textureSample(t, s, pos.xy);
      }
    }
  </xmp>
</div>

<div class=example1>
  <figure>
    <figcaption>Uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_1.mmd.svg"></object>
  </figure>
</div>

The example also shows that uniformity of the control flow after the if
statement is the same as the uniformity prior to the if statement (CF_return
being connected to [=CF_start=]).
That is, the control flow is once again uniform after the if statement (because
it is guaranteed to start as uniform control flow at the beginning of the entry
point).
If the `textureSample` function call had been moved outside the if statement
the program would have been valid.
Likewise, if the condition of the if statement were a uniform value (e.g. each
invocation read the same value from a [=uniform buffer=]), the program would
also have been valid.

#### Function-scope Variable Uniformity #### {#uniformity-example2}

This example shows both a valid and an invalid
[[#sync-builtin-functions|barrier]] function call that depend on the value of a
function-scope variable.
The `workgroupBarrier` is invalid because the value of `x` is derived from the
mutable module-scope variable `a`.
The `storageBarrier` is valid because the value of `x` is derived from the
immutable module-scope variable `b`.
This example highlights the [[#func-var-value-analysis|value analysis']]
ability to separate different periods of uniformity in a function-scope
variable's lifetime.
This example also clearly shows that control flow becomes uniform again after
the end of the first [=statement/if=] statement.
We know this because that section of the graph is independent from the second
if statement.

<div class='example wgsl' heading='WGSL using function variable'>
  <xmp>
    @group(0) @binding(0) var<storage, read_write> a : i32;
    @group(0) @binding(1) var<uniform> b : i32;

    @compute @workgroup_size(16,1,1)
    fn main() {
      var x : i32;
      x = a;
      if x > 0 {
        // Invalid barrier function call.
        workgroupBarrier();
      }
      x = b;
      if x < 0 {
        // Valid barrier function call.
        storageBarrier();
      }
    }
  </xmp>
</div>

<div class=example2>
  <figure>
    <figcaption>Uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_2.mmd.svg"></object>
  </figure>
</div>

Note: The subgraphs are only included in the example for ease of understanding.


#### Composite Value Analysis Limitations #### {#uniformity-example3}

One limitation of the uniformity analysis is that it does not track the
[=components=] of a [=composite=] value independently.
That is, any non-uniform component value [=behavioral requirement|will=] cause
the analysis to treat the entire composite value as non-uniform.
This example illustrates this issue and a potential workaround that shader
authors can employ to avoid this limitation.

<div class='example wgsl' heading='Invalid composite value WGSL'>
  <xmp>
    struct Inputs {
      // workgroup_id is a uniform built-in value.
      @builtin(workgroup_id) wgid : vec3<u32>,
      // local_invocation_index is a non-uniform built-in value.
      @builtin(local_invocation_index) lid : u32
    }

    @compute @workgroup_size(16,1,1)
    fn main(inputs : Inputs) {
      // This comparison is always uniform,
      // but the analysis cannot determine that.
      if inputs.wgid.x == 1 {
        workgroupBarrier();
      }
    }
  </xmp>
</div>

<div class=example2>
  <figure>
    <figcaption>Invalid uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_3.mmd.svg"></object>
  </figure>
</div>

The easiest way to work around this limitation of the analysis is to split the
composite up so that values that are known to be uniform are separate from
value that are known to be non-uniform.
In the alternative WGSL below, splitting the two built-in values into separate
parameters satisfies the uniformity analysis.
This can be seen by the lack of a path from [=RequiredToBeUniform.S=] to
[=MayBeNonUniform=] in the graph.

<div class='example wgsl' heading='Valid alternative WGSL'>
  <xmp>
    @compute @workgroup_size(16,1,1)
    fn main(@builtin(workgroup_id) wgid : vec3<u32>,
            @builtin(local_invocation_index) lid : u32) {
      // The uniformity analysis can now correctly determine this comparison is
      // always uniform.
      if wgid.x == 1 {
        // Valid barrier function call.
        workgroupBarrier();
      }
    }
  </xmp>
</div>

<div class=example3>
  <figure>
    <figcaption>Valid alternative uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_3b.mmd.svg"></object>
  </figure>
</div>

#### Uniformity in a Loop #### {#uniformity-example4}

In this example, there is an invalid `workgroupBarrier` function call in a
loop.
The non-uniform built-in value `local_invocation_index` is the ultimate cause
despite the fact that it appears after the barrier in the loop.
This occurs, because on later iterations some of the invocations in the
workgroup will have exited the loop prematurely while others attempt to execute
the barrier.
The analysis models the inter-iteration dependencies as an edge, where the control
at the start of the loop body (CF_loop_body) depends on the control flow at the
end of the loop body (CF_after_if).

<div class='example wgsl' heading='Loop uniformity WGSL'>
  <xmp>
    @compute @workgroup_size(16,1,1)
    fn main(@builtin(local_invocation_index) lid : u32) {
      for (var i = 0u; i < 10; i++) {
        workgroupBarrier();
        if (lid + i) > 7 {
          break;
        }
      }
    }
  </xmp>
</div>

<div class=example4>
  <figure>
    <figcaption>Uniformity graph</figcaption>
    <object type="image/svg+xml" data="img/uniformity_4.mmd.svg"></object>
  </figure>
</div>

#### User-defined Function Calls #### {#uniformity-example5}

This example is modification of the [[#uniformity-example1|first example]], but
uses a user-defined function call.
The analysis sets the [=parameter return tag=] of both parameters of `scale` as
[=ParameterReturnContentsRequiredToBeUniform=].
This leads to the path in `main` between the return value of the `scale`
function call and the `position` built-in value.
That path is a subpath of the overall invalid path from [=RequiredToBeUniform.S=] to
[=MayBeNonUniform=].

<div class='example wgsl' heading='User-defined function call uniformity WGSL'>
  <xmp>
    fn scale(in1 : f32, in2 : f32) -> f32 {
      let v = in1 / in2;
      return v;
    }

    @group(0) @binding(0) var t : texture_2d<f32>;
    @group(0) @binding(1) var s : sampler;

    @fragment
    fn main(@builtin(position) pos : vec4<f32>) {
      let tmp = scale(pos.x, 0.5);
      if tmp > 1.0 {
        _ = textureSample(t, s, pos.xy);
      }
    }
  </xmp>
</div>

<div class=example5>
  <figure>
    <figcaption>Uniformity graph for scale</figcaption>
    <object type="image/svg+xml" data="img/uniformity_5scale.mmd.svg"></object>
  </figure>

  <figure>
    <figcaption>Uniformity graph for main</figcaption>
    <object type="image/svg+xml" data="img/uniformity_5main.mmd.svg"></object>
  </figure>
</div>

Note: The subgraphs are only included in the example for ease of understanding.

## Compute Shaders and Workgroups ## {#compute-shader-workgroups}

A <dfn noexport for="compute shader stage">workgroup</dfn> is a set of invocations which
concurrently execute a [=compute shader stage=] [=entry point=],
and share access to shader variables in the [=address spaces/workgroup=] address space.

The <dfn noexport>workgroup grid</dfn> for a compute shader is the set of points
with integer coordinates *(i,j,k)* with:

*  0 &leq; i &lt; workgroup_size_x
*  0 &leq; j &lt; workgroup_size_y
*  0 &leq; k &lt; workgroup_size_z

where *(workgroup_size_x, workgroup_size_y, workgroup_size_z)* is
the value specified for the [=attribute/workgroup_size=] attribute of the
entry point.

There is exactly one invocation in a workgroup for each point in the workgroup grid.

An invocation's <dfn noexport>local invocation ID</dfn> is the coordinate
triple (i,j,k) for the invocation's corresponding workgroup grid point.

When an invocation has [=local invocation ID=], then its
<dfn noexport>local invocation index</dfn> is

  i +
  (j * workgroup_size_x) +
  (k * workgroup_size_x * workgroup_size_y)

<p algorithm="local index range">Note that if a workgroup has |W| invocations,
then each invocation |I| the workgroup has a unique local invocation index |L|(|I|)
such that 0 &le; |L|(|I|) &lt; |W|,
and that entire range is covered.</p>

A compute shader begins execution when a WebGPU implementation
removes a dispatch command from a queue and begins the specified work on the GPU.
The dispatch command specifies a <dfn noexport>dispatch size</dfn>,
which is an integer triple (<dfn>group_count_x</dfn>, <dfn>group_count_y</dfn>, <dfn>group_count_z</dfn>)
indicating the number of workgroups to be executed, as described in the following.

The <dfn noexport>compute shader grid</dfn> for a particular dispatch
is the set of points with integer coordinates *(CSi,CSj,CSk)* with:

*  0 &leq; CSi &lt; workgroup_size_x &times; group_count_x
*  0 &leq; CSj &lt; workgroup_size_y &times; group_count_y
*  0 &leq; CSk &lt; workgroup_size_z &times; group_count_z

where *workgroup_size_x*,
*workgroup_size_y*, and
*workgroup_size_z* are as above for the compute shader entry point.

The work to be performed by a compute shader dispatch is to execute exactly one
invocation of the entry point for each point in the compute shader grid.

An invocation's <dfn noexport>global invocation ID</dfn> is the coordinate
triple for the invocation's corresponding compute shader grid point.

The invocations are organized into workgroups, so that each invocation's
[=global invocation ID=] *(CSi, CSj, CSk)* maps to
a single workgroup, identified by <dfn noexport>workgroup ID</dfn>:

   ( &lfloor; *CSi* &div; workgroup_size_x &rfloor;,
     &lfloor; *CSj* &div; workgroup_size_y &rfloor;,
     &lfloor; *CSk* &div; workgroup_size_z &rfloor;)

and a single invocation within that workgroup, identified by [=local invocation ID=]:

   ( *CSi* mod workgroup_size_x ,
     *CSj* mod workgroup_size_y ,
     *CSk* mod workgroup_size_z ).

Note: Workgroup IDs span from (0,0,0) to ([=group_count_x=] - 1, [=group_count_y=] - 1, [=group_count_z=] - 1).

WebGPU provides no guarantees about:

* Whether invocations from different workgroups execute concurrently.
    That is, you cannot assume more than one workgroup executes at a time.
* Whether, once invocations from a workgroup begin executing, that other workgroups
    are blocked from execution.
    That is, you cannot assume that only one workgroup executes at a time.
    While a workgroup is executing, the implementation may choose to
    concurrently execute other workgroups as well, or other queued but unblocked work.
* Whether invocations from one particular workgroup begin executing before
    the invocations of another workgroup.
    That is, you cannot assume that workgroups are launched in a particular order.

## Fragment Shaders and Helper Invocations ## {#fragment-shaders-helper-invocations}

Invocations in the [=fragment shader stage=] are divided into 2x2 grids of
invocations with neighbouring [=built-in values/position|positions=] in the X and Y dimensions.
Each of these grids is referred to as a <dfn noexport>quad</dfn>.
Quads can collaborate in some collective operations (see [[#derivatives]]).

Ordinarily, [[WebGPU#fragment-processing|fragment processing]] creates one
invocation of a fragment shader for each
[=RasterizationPoint=] produced by
[[WebGPU#rasterization|rasterization]].
Sometimes there may be insufficient RasterizationPoints to fully populate a
quad, for example at the edge of a graphics primitive.
When a quad has only 1, 2, or 3 invocations corresponding to
RasterizationPoints, fragment processing [=behavioral requirement|will=] create
a <dfn noexport>helper invocation</dfn> for each unpopulated position in the
quad.

Helper invocations do not have observable effects, except that they help
compute [[#derivatives|derivatives]].
As such, helper invocations are subject to the following restrictions:
* No [=write access|write accesses=] (see also [[#memory-operation]])
    [=behavioral requirement|will=] be performed on the [=address
    spaces/storage=] or [=address spaces/handle=] address spaces.
* [[#atomic-builtin-functions|Atomic built-in functions]] [=behavioral requirement|will=]
    return [=indeterminate value|indeterminate=] results.
* The [=Entry point=] [=return value=] [=behavioral requirement|will=] not be further processed
    downstream in the [=GPURenderPipeline=].

If all of the invocations in a quad become helper invocations (e.g. due to
executing a [=statement/discard=] statement), execution of the quad may be
terminated; however, such termination is not considered to produce [=uniform
control flow|non-uniform control flow=].

## Collective Operations ## {#collective-operations}

### Barriers ### {#barrier}

A barrier is a [[#sync-builtin-functions|synchronization built-in function]]
that orders memory operations in a program.
A <dfn noexport>control barrier</dfn> is executed by all invocations in the
same [=compute shader stage/workgroup=] as if it were executed concurrently.
As such, control barriers [=shader-creation error|must=] only be executed in [=uniform control flow=] in a
[=compute shader stage|compute=] shader.

### Derivatives ### {#derivatives}

A <dfn noexport>partial derivative</dfn> is the rate of change of a value along an axis.
Fragment shader invocations within the same [=quad=] collaborate to compute
approximate partial derivatives.

The <dfn noexport>builtin functions that compute a derivative</dfn> are:
* [[#texturesample|textureSample]], [[#texturesamplebias|textureSampleBias]], and [[#texturesamplecompare|textureSampleCompare]]
* [[#dpdx-builtin|dpdx]], [[#dpdxCoarse-builtin|dpdxCoarse]], and [[#dpdxFine-builtin|dpdxFine]]
* [[#dpdy-builtin|dpdy]], [[#dpdyCoarse-builtin|dpdyCoarse]], and [[#dpdyFine-builtin|dpdyFine]]
* [[#fwidth-builtin|fwidth]], [[#fwidthCoarse-builtin|fwidthCoarse]], and [[#fwidthFine-builtin|fwidthFine]]

Partial derivatives of the *fragment coordinate* are computed implicitly as part
of operation of the following built-in functions:
* [[#texturesample|textureSample]],
* [[#texturesamplebias|textureSampleBias]], and
* [[#texturesamplecompare|textureSampleCompare]].

For these, the derivatives help determine the mip levels of texels to be sampled, or in the case of
`textureSampleCompare`, sampled and compared against a reference value.

Partial derivatives of *invocation-specified* values are computed by the
built-in functions described in [[#derivative-builtin-functions]]:
* [[#dpdx-builtin|dpdx]], [[#dpdxCoarse-builtin|dpdxCoarse]], and [[#dpdxFine-builtin|dpdxFine]] compute partial derivatives along the x axis.
* [[#dpdy-builtin|dpdy]], [[#dpdyCoarse-builtin|dpdyCoarse]], and [[#dpdyFine-builtin|dpdyFine]] compute partial derivatives along the y axis.
* [[#fwidth-builtin|fwidth]], [[#fwidthCoarse-builtin|fwidthCoarse]], and [[#fwidthFine-builtin|fwidthFine]]
    compute the Manhattan metric over the associated x and y partial derivatives.

Because neighbouring invocations collaborate to compute derivatives, these
functions should only be invoked in [=uniform control flow=] in a fragment shader.
For each call to one of these functions, a [=trigger/derivative_uniformity=] [=diagnostic=] is triggered if
[[#uniformity|uniformity analysis]] cannot prove the call occurs in uniform control flow.

If one of these functions is called in non-uniform control flow, then the result is an [=indeterminate value=].

## Floating Point Evaluation ## {#floating-point-evaluation}

WGSL follows the [[!IEEE-754|IEEE-754]] standard for floating point computation with
the following differences:
* No rounding mode is specified. An implementation may round a value up or down.
* No floating point exceptions are generated.
    * A floating point operation in WGSL [=behavioral requirement|will=] produce an intermediate result
        according to IEEE-754 rules, but exceptions mandated by IEEE-754 will map to different
        behaviors depending on whether the expression is
        a [=const-expression=], an [=override-expression=], or a [=runtime expression=].
    * IEEE-754 defines five kinds of exceptions:
        * Invalid operation. These operations yield a NaN.  An example of an invalid operation is 0 &times; &infin;.
        * Division by zero. This occurs when an operation on finite operands is defined as having an exact infinite result.
            Examples are 1 &divide; 0, and log(0).
        * Overflow. See [[#floating-point-overflow]].
        * Underflow. This occurs when the rounded or unrounded result is subnormal.
        * Inexact. This occurs when the rounded result is different from the intermediate result,
            or when overflow occurs.
    * Consider an operation on finite operands.
        The operation produces overflow, infinity, or a NaN if and only if IEEE-754 would require the
        operation to signal an invalid operation, division-by-zero, or overflow exception.
* Signaling NaNs may not be generated.
    Any signaling NaN may be converted to a quiet NaN.
* Overflow, infinities, and NaNs generated before runtime are errors.
    * [=Const-expressions=] and [=override-expressions=] over finite values
        [=behavioral requirement|will=] generate overflow, infinities, and NaNs
        as intermediate values, following IEEE-754 rules.
        * Note: This rule requires implementations to reliably detect overflow, infinities, and NaNs
            to within accuracy limits for these kinds of expressions, so that errors can be generated consistently.
    * A [=shader-creation error=] results if any [=const-expression=] of
        floating-point type overflows or evaluates to NaN or infinity.
    * A [=pipeline-creation error=] results if any [=override-expression=] of
        floating-point type overflows or evaluates to NaN or infinity.
* Implementations may assume that overflow, infinities, and NaNs are not present at runtime.
    * In such an implementation, if the intermediate result of evaluating a [=runtime expression=] overflows,
        or yields infinity or a NaN, the final result [=behavioral requirement|will=] be
        an [=indeterminate value=] of the target type.
    * Note: This means some functions (e.g. `min` and `max`)
        may not return the expected result due to optimizations about the presence
        of NaNs and infinities.
* Implementations may ignore the sign of a zero.
    That is, a zero with a positive sign may behave like a zero a with a negative sign, and vice versa.
* To <dfn noexport title="flushed to zero">flush to zero</dfn> is to replace a denormalized value for a floating point type
    with a zero value of that type.
    * Any inputs or outputs of operations listed in [[#floating-point-accuracy]] may be flushed to zero.
    * Additionally, intermediate values of operations listed in
        [[#pack-builtin-functions]] or [[#unpack-builtin-functions]] may be flushed to zero.
    * Other operations are required to preserve denormalized numbers.
* The accuracy of operations is given in [[#floating-point-accuracy]].

### Floating Point Overflow ### {#floating-point-overflow}

Overflowing computations can round to infinity or to the
nearest finite value.
The outcome depends on the magnitude of the overflowing value and on whether
evaluation occurs during shader execution.

For a floating point type *T*, define *MAX(T)* as the largest positive finite value of *T*,
and 2<sup>*EMAX(T)*</sup> as the largest power of 2 representable by *T*.
In particular, EMAX([=f32=]) = 127, and EMAX([=f16=]) = 15.

Let *X* be an infinite-precision intermediate result from a floating point computation.
The final value of the expression is determined in two stages, via intermediate values *X'* and *X''* as follows:

From *X*, compute *X'* in *T* by rounding:
* If *X* is in the finite range of *T* then *X'* is the result of rounding *X* up or down.
* If *X* is NaN, then *X'* is NaN.
* If *MAX(T)* &lt; *X* &lt; 2<sup>*EMAX(T)+1*</sup>, then either rounding direction is used: *X'* is *MAX(T)* or &plus;&infin;.
* If 2<sup>*EMAX(T)+1*</sup> &le; *X*, then *X'* = &plus;&infin;.
    * Note: This matches the [[!IEEE-754|IEEE-754]] rule.
* If &minus;*MAX(T)* &gt; *X* &gt; &minus;2<sup>*EMAX(T)+1*</sup>, then either rounding direction is used: *X'* is &minus;*MAX(T)* or &minus;&infin;.
* If &minus;2<sup>*EMAX(T)+1*</sup> &ge; *X*, then *X'* = &minus;&infin;.
    * Note: This matches the IEEE-754 rule.

From *X'*, compute the final value of the expression, *X''*, or detect a program error:
* If *X'* is infinity or NaN, then:
    * If the expression is a [=const-expression=], generate a [=shader-creation error=].
    * If the expression is a [=override-expression=], generate a [=pipeline-creation error=].
    * Otherwise the expression is a [=runtime expression=] and *X''* is an [=indeterminate value=].
* Otherwise *X''* = *X'*.


### Floating Point Accuracy ### {#floating-point-accuracy}

<div algorithm="correctly rounded">
Let |x| be the exact real-valued or infinite result of an operation when computed with unbounded precision.
The <dfn>correctly rounded</dfn> result of the operation for floating point type |T| is:
* |x|, when |x| is in |T|,
* Otherwise:
    * the smallest value in |T| greater than |x|, or
    * the largest value in |T| less than |x|.

</div>

That is, the result may be rounded up or down:
WGSL does not specify a rounding mode.

Note: Floating point types include positive and negative infinity, so
the correctly rounded result may be finite or infinite.

The units in the last place, <dfn noexport>ULP</dfn>, for a floating point
number `x` is defined as follows [[!Muller2005]]:
* If `x` is in the finite range of the floating point type, then ULP(x) is
    the minimum distance between two non-equal, finite floating point numbers
    `a` and `b` such that `a` &le; `x` &le; `b` (i.e. `ulp(x) =
    min`<sub>`a,b`</sub>`|b - a|`).
* Otherwise, ULP(x) is `|b - a|` where `b` and `a` are the largest and second-largest
    representable finite floating point values.

The accuracy of an operation is provided among five
possibilities:
* Correct result (for non-floating point result values).
* [=Correctly rounded=].
* An absolute error bound.
* A relative error bound expressed as [=ULP=].
* An expression that the accuracy is <dfn noexport>inherited from</dfn>.
    That is, the accuracy of the operation is defined as the accuracy of evaluating the given WGSL expression.
    The given expression is only one valid implementation of the function.
    A WebGPU implementation may implement the operation differently, with better accuracy
    or with greater tolerance for extreme inputs.

When the accuracy for an operation is specified over an input range,
the accuracy is undefined for input values outside that range.

If an allowed result is outside the finite range of the result type, then
the rules in [[#floating-point-overflow]] apply.

#### Accuracy of Concrete Floating Point Expressions #### {#concrete-float-accuracy}

<table class='data'>
  <caption>Accuracy of concrete floating point operations</caption>
  <thead>
    <tr><th>Expression<th>Accuracy for f32<th>Accuracy for f16
  </thead>

  <tr><td>`x + y`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`x - y`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`x * y`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`x / y`<td>2.5 ULP for `|y|` in the range [2<sup>-126</sup>, 2<sup>126</sup>]<td>2.5 ULP for `|y|` in the range [2<sup>-14</sup>, 2<sup>14</sup>]
  <tr><td>`x % y`<td colspan=2 style="text-align:left;">Inherited from `x - y * trunc(x/y)`
  <tr><td>`-x`<td colspan=2 style="text-align:left;">Correctly rounded

  <tr><td>`x == y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x != y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x < y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x <= y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x > y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x >= y`<td colspan=2 style="text-align:left;">Correct result
</table>

<table class='data'>
  <caption>Accuracy of concrete floating point built-in functions</caption>
  <thead>
    <tr><th>Built-in Function<th>Accuracy for f32<th>Accuracy for f16
  </thead>

  <tr><td>`abs(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`acos(x)`<td>
       The worse of:
       * Absolute error 6.77&times;10<sup>-5</sup>
       * Inherited from `atan2(sqrt(1.0 - x * x), x)`

      <td>The worse of:
       * Absolute error 3.91&times;10<sup>-3</sup>
       * Inherited from `atan2(sqrt(1.0 - x * x), x)`
          <p>TODO: check this with conformance tests
  <tr><td>`acosh(x)`<td colspan=2 style="text-align:left;">Inherited from `log(x + sqrt(x * x - 1.0))`
  <tr><td>`asin(x)`<td>
       The worse of:
       * Absolute error 6.77&times;10<sup>-5</sup>
       * Inherited from `atan2(x, sqrt(1.0 - x * x))`

      <td>The worse of:
       * Absolute error 3.91&times;10<sup>-3</sup>
       * Inherited from `atan2(x, sqrt(1.0 - x * x))`
          <p>TODO: check this with conformance tests
  <tr><td>`asinh(x)`<td colspan=2 style="text-align:left;">Inherited from `log(x + sqrt(x * x + 1.0))`
  <tr><td>`atan(x)`<td>4096 ULP<td>5 ULP
  <tr><td>`atan2(y, x)`<td>4096 ULP for `|x|` in the range [2<sup>-126</sup>, 2<sup>126</sup>], and `y` is finite and normal<td>5 ULP for `|x|` in the range [2<sup>-14</sup>, 2<sup>14</sup>], and `y` is finite and normal
  <tr><td>`atanh(x)`<td colspan=2 style="text-align:left;">Inherited from `log( (1.0 + x) / (1.0 - x) ) * 0.5`
  <tr><td>`ceil(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`clamp(x,low,high)`<td colspan=2 style="text-align:left;">Correctly rounded.

    The infinitely precise result is computed as either `min(max(x,low),high)`, or with a median-of-3-values formulation.
    These may differ when `low > high`.

    If `x` and either `low` or `high` are denormalized, the result may be any of the denormalized values.
    This follows from the possible results from the `min` and `max` functions on denormalized inputs.
  <tr><td>`cos(x)`
      <td>Absolute error at most 2<sup>-11</sup> when `x` is in the interval [-&pi;, &pi;]
      <td>Absolute error at most 2<sup>-7</sup> when `x` is in the interval [-&pi;, &pi;]
  <tr><td>`cosh(x)`<td colspan=2 style="text-align:left;">Inherited from `(exp(x) + exp(-x)) * 0.5`
  <tr><td>`cross(x, y)`<td colspan=2 style="text-align:left;">Inherited from `(x[i] * y[j] - x[j] * y[i])`
  <tr><td>`degrees(x)`<td colspan=2 style="text-align:left;">Inherited from `x * 57.295779513082322865`
  <tr><td>`determinant(m:mat2x2<T>)`<br>
          `determinant(m:mat3x3<T>)`<br>
          `determinant(m:mat4x4<T>)`
     <td colspan=2 style="text-align:left;">Infinite ULP.

     <div class=note>
     <span class=marker>Note:</span>WebGPU implementations should provide a pragmatically useful determinant function.

     In ideal math, determinants are computed with add, subtract, and multiply operations.

     However, GPUs use floating point math, and GPU implementations of determinant
     favour speed and simplicity over robustness against overflow and error.

     For example, the naive computation of even a 2x2 determinant (`m[0][0] * m[1][1] - m[1][0] * m[0][1]`)
     fails to guard against catastrophic cancellation.
     Providing tighter error bounds for 2x2 determinants is the subject of relatively recent research [[Jeannerod2013]].
     The challenges compound quickly as matrix sizes increase.

     The lack of a finite error bound for determinants in WGSL reflects the same lack in underlying implementations.
     </div>
  <tr><td>`distance(x, y)`<td colspan=2 style="text-align:left;">Inherited from `length(x - y)`
  <tr><td>`dot(x, y)`<td colspan=2 style="text-align:left;">Inherited from sum of `x[i] * y[i]`
  <tr><td>`exp(x)`<td>`3 + 2 * |x|` ULP<td>`1 + 2 * |x|` ULP
  <tr><td>`exp2(x)`<td>`3 + 2 * |x|` ULP<td>`1 + 2 * |x|` ULP
  <tr><td class="nowrap">`faceForward(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `select(-x, x, dot(z, y) < 0.0)`
  <tr><td>`floor(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`fma(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `x * y + z`
  <tr><td>`fract(x)`<td colspan=2 style="text-align:left;">Inherited from `x - floor(x)`
  <tr><td>`frexp(x)`<td colspan=2 style="text-align:left;">Correctly rounded, when `x` is zero or normal.
  <tr><td>`inverseSqrt(x)`<td colspan=2 style="text-align:left;">2 ULP
  <tr><td>`ldexp(x, y)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`length(x)`<td colspan=2 style="text-align:left;">Inherited from `sqrt(dot(x, x))` in the vector case, and `sqrt(x*x)` in the scalar case.
  <tr><td>`log(x)`
      <td>Absolute error at most 2<sup>-21</sup> when `x` is in the interval [0.5, 2.0].<br>
          3 ULP when `x` is outside the interval [0.5, 2.0].<br>
      <td>Absolute error at most 2<sup>-7</sup> when `x` is in the interval [0.5, 2.0].<br>
          3 ULP when `x` is outside the interval [0.5, 2.0].<br>
  <tr><td>`log2(x)`
      <td>Absolute error at most 2<sup>-21</sup> when `x` is in the interval [0.5, 2.0].<br>
          3 ULP when `x` is outside the interval [0.5, 2.0].<br>
      <td>Absolute error at most 2<sup>-7</sup> when `x` is in the interval [0.5, 2.0].<br>
          3 ULP when `x` is outside the interval [0.5, 2.0].<br>
  <tr><td>`max(x, y)`<td colspan=2 style="text-align:left;">Correctly rounded
  <p>If both `x` and `y` are denormalized, the result may be either input.
  <tr><td>`min(x, y)`<td colspan=2 style="text-align:left;">Correctly rounded.
  <p>If both `x` and `y` are denormalized, the result may be either input.
  <tr><td>`mix(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `x * (1.0 - z) + y * z`
  <tr><td>`modf(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`normalize(x)`<td colspan=2 style="text-align:left;">Inherited from `x / length(x)`

  <tr><td>`pack4x8snorm(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.
  <tr><td>`pack4x8unorm(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.
  <tr><td>`pack2x16snorm(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.
  <tr><td>`pack2x16unorm(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.
  <tr><td>`pack2x16float(x)`<td colspan=2 style="text-align:left;">Correctly rounded intermediate value. Correct result.

  <tr><td>`pow(x, y)`<td colspan=2 style="text-align:left;">Inherited from `exp2(y * log2(x))`
  <tr><td>`quantizeToF16(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`radians(x)`<td colspan=2 style="text-align:left;">Inherited from `x * 0.017453292519943295474`
  <tr><td>`reflect(x, y)`<td colspan=2 style="text-align:left;">Inherited from `x - 2.0 * dot(x, y) * y`
  <tr><td>`refract(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `z * x - (z * dot(y, x) + sqrt(k)) * y`,<br>where `k = 1.0 - z * z * (1.0 - dot(y, x) * dot(y, x))`<br>If `k < 0.0` the result is precisely 0.0
  <tr><td>`round(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`sign(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`sin(x)`
      <td>Absolute error at most 2<sup>-11</sup> when `x` is in the interval [-&pi;, &pi;]
      <td>Absolute error at most 2<sup>-7</sup> when `x` is in the interval [-&pi;, &pi;]
  <tr><td>`sinh(x)`<td colspan=2 style="text-align:left;">Inherited from `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`saturate(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`smoothstep(low, high, x)`<td colspan=2 style="text-align:left;">Inherited from `t * t * (3.0 - 2.0 * t)`,<br>where `t = clamp((x - low) / (high - low), 0.0, 1.0)`
  <tr><td>`sqrt(x)`<td colspan=2 style="text-align:left;">Inherited from `1.0 / inverseSqrt(x)`
  <tr><td>`step(edge, x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`tan(x)`<td colspan=2 style="text-align:left;">Inherited from `sin(x) / cos(x)`
  <tr><td>`tanh(x)`<td colspan=2 style="text-align:left;">Inherited from `sinh(x) / cosh(x)`
  <tr><td>`transpose(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`trunc(x)`<td colspan=2 style="text-align:left;">Correctly rounded

  <tr><td>`unpack4x8snorm(x)`<td>3 ULP<td>N/A
  <tr><td>`unpack4x8unorm(x)`<td>3 ULP<td>N/A
  <tr><td>`unpack2x16snorm(x)`<td>3 ULP<td>N/A
  <tr><td>`unpack2x16unorm(x)`<td>3 ULP<td>N/A
  <tr><td>`unpack2x16float(x)`<td>Correctly rounded<td>N/A

</table>

#### Accuracy of AbstractFloat Expressions #### {#abstract-float-accuracy}

The accuracy of an [=AbstractFloat=] operation is as follows:
* A correct result is required when the corresponding [=f32=] operation requires a correct result.
* A [=correctly rounded=] result is required when the corresponding [=f32=] operation requires a correctly rounded result.
* Otherwise, the error of the corresponding [=f32=] operation is an absolute error, a relative error, an error inherited
    from a potential implementation, or a combination of these.
    In this case the error of the [=AbstractFloat=] is unbounded.
    * However, the error of the [=AbstractFloat=] operation *should* be at most
        the error of the corresponding operation in [=f32=], in absolute terms.
    * This recommendation is meant to avoid surprises: the accuracy of
        an expression should not be *reduced* when changing its type from f32 to AbstractFloat.
    * The operation may be evaluated in a WebAssembly [[WASM-CORE-2]] or an ECMAScript [[ECMASCRIPT]]
        environment, and those specifications do not specify error bounds on many
        of the corresponding numeric computations.
        For example, ECMAScript specifies many floating point operations as being
        [[ECMASCRIPT#sec-terms-and-definitions-implementation-approximated|implementation-approximated]].
        Implementations are encouraged to strive to approximate the ideal, but
        no strict requirement is specified.

<div class=note algorithm="ulp translation">
<span class=marker>Note:</span>A given absolute error bound, when quantified as ULP,
depends critically on the underlying floating point type.

The [=ULP=] for an [=AbstractFloat=] value assumes
AbstractFloat is identical to the [[!IEEE-754|IEEE-754]] binary64 type.

One [=ULP=] for an f32 value is 2<sup>29</sup> times larger than 1 ULP for an IEEE 754 binary64 value,
since the significand in the binary64 format is 29 bits longer than the significand in the f32 type.

For example, suppose the true result value of an operation is |x|, but it is computed as <var>x'</var>.
If its error |x|-<var>x'</var> is 3 ULP in f32, then the same absolute error, |x|-<var>x'</var>,
is 3&middot;2<sup>29</sup> ULP in AbstractFloat.
</div>

### Reassociation and Fusion ### {#reassociation-and-fusion}

<dfn noexport>Reassociation</dfn> is the reordering of operations in an
expression such that the answer is the same if computed exactly. For example:
* `(a + b) + c` reassociates to `a + (b + c)`
* `(a - b) + c` reassociates to `(a + c) - b`
* `(a * b) / c` reassociates to `(a / c) * b`

However, the result may not be the same when computed in floating point.
The reassociated result may be inaccurate due to approximation, or may trigger
an overflow or NaN when computing intermediate results.

An implementation may reassociate operations.

An implementation may fuse operations if the transformed expression is
at least as accurate as the original formulation.
For example, some fused multiply-add implementations can be more accurate
than performing a multiply followed by an addition.

### Floating Point Conversion ### {#floating-point-conversion}

In this section, a floating point type may be any of:
* The [=f32=], [=f16=], and [=AbstractFloat=] types in WGSL.
* A hypothetical type corresponding to a binary format defined by the [[!IEEE-754|IEEE-754]]
    floating point standard.

Note: Recall that the [=f32=] WGSL type corresponds to the IEEE-754 binary32 format, and the [=f16=] WGSL type corresponds to the IEEE-754 binary16 format.

The <dfn noexport>scalar floating point to integral conversion</dfn> algorithm is:
<blockquote algorithm="convert a float value to an integral value">
To convert a floating point scalar value |X| to an [=integer scalar=] type |T|:
* If the original value of |X| is exactly representable in the target type |T|, then the result is that value.
* Otherwise, the result is the value in |T| that is closest to [=truncate=](|X|).

</blockquote>

Note: In other words, floating point to integer conversion rounds toward zero, then saturates in the target type.

<div class=note><span class=marker>Note:</span> For example:
* 3.9f converted to [=u32=] is 3u
* -1f converted to [=u32=] is 0u
* 1e20f converted to [=u32=] is the maximum u32 value, 4294967295u
* -3.9f converted to [=i32=] is -3i
* 1e20f converted to [=i32=] is the maximum i32 value, 2147483647i
* -1e20f converted to [=i32=] is the minimum i32 value, i32(-2147483648)

</div>

Note: There are no direct conversions from [=AbstractFloat=] to an integer scalar type.
All conversions first convert to another floating point type ([=f32=] usually).

The <dfn noexport>numeric scalar conversion to floating point</dfn> algorithm is:
<blockquote>
When converting a [=numeric scalar=] value to a floating point type:
* If the original value is exactly representable in the destination type, then the result is that value.
    * Additionally, if the original value is zero and of [=integer scalar=] type, then the resulting value has a zero sign bit.
* Otherwise, the original value is not exactly representable.
    * If the original value is different from but lies between two adjacent finite values representable in the destination type,
         then the result is one of those two values.
         WGSL does not specify whether the larger or smaller representable
         value is chosen, and different instances of such a conversion may choose differently.
    * Otherwise, the original value lies outside the finite range of the destination type:
         * A [=shader-creation error=] results if the original expression is a [=const-expression=].
         * A [=pipeline-creation error=] results if the original expression is an [=override-expression=].
         * Otherwise the conversion proceeds as follows:
             1. Set |X| to the original value.
             2. If the source type is a floating point type with more mantissa bits than the destination type,
                 the extra mantissa bits of the source value *may* be discarded (i.e. treated as if they are 0).
                 Update |X| accordingly.
             3. If |X| is the most-positive or most-negative normal value of the destination type, then the result is |X|.
             4. Otherwise, the result is the infinity value of the destination type, with the same sign as |X|.
    * Otherwise, if the original value is a NaN for the source type, then the result is a NaN in the destination type.

</blockquote>

NOTE: An integer value may lie between two adjacent representable floating point values.
In particular, the [=f32=] type uses 23 explicit fractional bits.
Additionally, when the floating point value is in the normal range (the exponent is neither extreme value), then the mantissa is
the set of fractional bits together with an extra 1-bit at the most significant position at bit position 23.
Then, for example, integers 2<sup>28</sup> and 1+2<sup>28</sup> both map to the same floating point value: the difference in the
least significant 1 bit is not representable by the floating point format.
This kind of collision occurs for pairs of adjacent integers with a magnitude of at least 2<sup>25</sup>.

Note: The original value is always within range of the destination type when
the original type is one of [=i32=] or [=u32=] and the destination type is [=f32=].

Note: The original value is always within range of the destination type when
the source type is a floating point type with fewer exponent and mantissa bits than the target floating point type.

# Keyword and Token Summary # {#grammar}

## Keyword Summary ## {#keyword-summary}

* <dfn for=syntax_kw noexport>`alias`</dfn>
* <dfn for=syntax_kw noexport>`break`</dfn>
* <dfn for=syntax_kw noexport>`case`</dfn>
* <dfn for=syntax_kw noexport>`const`</dfn>
* <dfn for=syntax_kw noexport>`const_assert`</dfn>
* <dfn for=syntax_kw noexport>`continue`</dfn>
* <dfn for=syntax_kw noexport>`continuing`</dfn>
* <dfn for=syntax_kw noexport>`default`</dfn>
* <dfn for=syntax_kw noexport>`diagnostic`</dfn>
* <dfn for=syntax_kw noexport>`discard`</dfn>
* <dfn for=syntax_kw noexport>`else`</dfn>
* <dfn for=syntax_kw noexport>`enable`</dfn>
* <dfn for=syntax_kw noexport>`false`</dfn>
* <dfn for=syntax_kw noexport>`fn`</dfn>
* <dfn for=syntax_kw noexport>`for`</dfn>
* <dfn for=syntax_kw noexport>`if`</dfn>
* <dfn for=syntax_kw noexport>`let`</dfn>
* <dfn for=syntax_kw noexport>`loop`</dfn>
* <dfn for=syntax_kw noexport>`override`</dfn>
* <dfn for=syntax_kw noexport>`requires`</dfn>
* <dfn for=syntax_kw noexport>`return`</dfn>
* <dfn for=syntax_kw noexport>`struct`</dfn>
* <dfn for=syntax_kw noexport>`switch`</dfn>
* <dfn for=syntax_kw noexport>`true`</dfn>
* <dfn for=syntax_kw noexport>`var`</dfn>
* <dfn for=syntax_kw noexport>`while`</dfn>

## Reserved Words ## {#reserved-words}

A <dfn>reserved word</dfn> is a [=token=] which is reserved for future use.
A WGSL module [=shader-creation error|must not=] contain a reserved word.

The following are reserved words:

<pre class=include>
path: wgsl.reserved.bs.include
</pre>

## Syntactic Tokens ## {#syntactic-tokens}

A <dfn>syntactic token</dfn> is a sequence of special code points, used:
* to spell an expression operator, or
* as punctuation: to group, sequence, or separate other grammar elements.

The [=syntactic tokens=] are:

* <dfn for=syntax_sym lt='and' noexport>`'&'` (Code point: `U+0026`)</dfn>
* <dfn for=syntax_sym lt='and_and' noexport>`'&&'` (Code points: `U+0026` `U+0026`)</dfn>
* <dfn for=syntax_sym lt='arrow' noexport>`'->'` (Code points: `U+002D` `U+003E`)</dfn>
* <dfn for=syntax_sym lt='attr' noexport>`'@'` (Code point: `U+0040`)</dfn>
* <dfn for=syntax_sym lt='forward_slash' noexport>`'/'` (Code point: `U+002F`)</dfn>
* <dfn for=syntax_sym lt='bang' noexport>`'!'` (Code point: `U+0021`)</dfn>
* <dfn for=syntax_sym lt='bracket_left' noexport>`'['` (Code point: `U+005B`)</dfn>
* <dfn for=syntax_sym lt='bracket_right' noexport>`']'` (Code point: `U+005D`)</dfn>
* <dfn for=syntax_sym lt='brace_left' noexport>`'{'` (Code point: `U+007B`)</dfn>
* <dfn for=syntax_sym lt='brace_right' noexport>`'}'` (Code point: `U+007D`)</dfn>
* <dfn for=syntax_sym lt='colon' noexport>`':'` (Code point: `U+003A`)</dfn>
* <dfn for=syntax_sym lt='comma' noexport>`','` (Code point: `U+002C`)</dfn>
* <dfn for=syntax_sym lt='equal' noexport>`'='` (Code point: `U+003D`)</dfn>
* <dfn for=syntax_sym lt='equal_equal' noexport>`'=='` (Code points: `U+003D` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='not_equal' noexport>`'!='` (Code points: `U+0021` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='greater_than' noexport>`'>'` (Code point: `U+003E`)</dfn> (also <dfn for=syntax_sym lt='_greater_than' noexport>`_greater_than`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='greater_than_equal' noexport>`'>='` (Code points: `U+003E` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_greater_than_equal' noexport>`_greater_than_equal`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='shift_right' noexport>`'>>'` (Code point: `U+003E` `U+003E`)</dfn> (also <dfn for=syntax_sym lt='_shift_right' noexport>`_shift_right`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='less_than' noexport>`'<'` (Code point: `U+003C`)</dfn> (also <dfn for=syntax_sym lt='_less_than' noexport>`_less_than`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='less_than_equal' noexport>`'<='` (Code points: `U+003C` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_less_than_equal' noexport>`_less_than_equal`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='shift_left' noexport>`'<<'` (Code points: `U+003C` `U+003C`)</dfn> (also <dfn for=syntax_sym lt='_shift_left' noexport>`_shift_left`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='modulo' noexport>`'%'` (Code point: `U+0025`)</dfn>
* <dfn for=syntax_sym lt='minus' noexport>`'-'` (Code point: `U+002D`)</dfn>
* <dfn for=syntax_sym lt='minus_minus' noexport>`'--'` (Code points: `U+002D` `U+002D`)</dfn>
* <dfn for=syntax_sym lt='period' noexport>`'.'` (Code point: `U+002E`)</dfn>
* <dfn for=syntax_sym lt='plus' noexport>`'+'` (Code point: `U+002B`)</dfn>
* <dfn for=syntax_sym lt='plus_plus' noexport>`'++'` (Code points: `U+002B` `U+002B`)</dfn>
* <dfn for=syntax_sym lt='or' noexport>`'|'` (Code point: `U+007C`)</dfn>
* <dfn for=syntax_sym lt='or_or' noexport>`'||'` (Code points: `U+007C` `U+007C`)</dfn>
* <dfn for=syntax_sym lt='paren_left' noexport>`'('` (Code point: `U+0028`)</dfn>
* <dfn for=syntax_sym lt='paren_right' noexport>`')'` (Code point: `U+0029`)</dfn>
* <dfn for=syntax_sym lt='semicolon' noexport>`';'` (Code point: `U+003B`)</dfn>
* <dfn for=syntax_sym lt='star' noexport>`'*'` (Code point: `U+002A`)</dfn>
* <dfn for=syntax_sym lt='tilde' noexport>`'~'` (Code point: `U+007E`)</dfn>
* <dfn for=syntax_sym lt='underscore' noexport>`'_'` (Code point: `U+005F`)</dfn>
* <dfn for=syntax_sym lt='xor' noexport>`'^'` (Code point: `U+005E`)</dfn>
* <dfn for=syntax_sym lt='plus_equal' noexport>`'+='` (Code points: `U+002B` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='minus_equal' noexport>`'-='` (Code points: `U+002D` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='times_equal' noexport>`'*='` (Code points: `U+002A` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='division_equal' noexport>`'/='` (Code points: `U+002F` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='modulo_equal' noexport>`'%='` (Code points: `U+0025` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='and_equal' noexport>`'&='` (Code points: `U+0026` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='or_equal' noexport>`'|='` (Code points: `U+007C` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='xor_equal' noexport>`'^='` (Code points: `U+005E` `U+003D`)</dfn>
* <dfn for=syntax_sym lt='shift_right_assign' noexport>`'>>='` (Code point: `U+003E` `U+003E` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_shift_right_assign' noexport>`_shift_right_assign`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='shift_left_assign' noexport>`'<<='` (Code points: `U+003C` `U+003C` `U+003D`)</dfn> (also <dfn for=syntax_sym lt='_shift_left_assign' noexport>`_shift_left_assign`</dfn> for template disambiguation)
* <dfn for=syntax_sym lt='_template_args_end' noexport>`_template_args_end`</dfn>
    * Text:  `'>'` (Code point: `U+003E`)
    * This token is textually the same as the [=syntax_sym/greater_than=] syntactic token.
    * It is generated by template list disambiguation, and is used as the last token in a template list.
* <dfn for=syntax_sym lt='_template_args_start' noexport>`_template_args_start`</dfn>
    * Text: `'<'` (Code point: `U+003C`)
    * This token is textually the same as the [=syntax_sym/less_than=] syntactic token.
    * It is generated by template list disambiguation, and is used as the first token in a template list.
* <dfn for=syntax_sym lt='_disambiguate_template' noexport>`_disambiguate_template`</dfn>
    * Text: None
    * This token informs parser to scan for template lists.
    * It triggers template list disambiguation.

## Context-Dependent Name Tokens ## {#context-dependent-name-tokens}

This section lists the tokens used as [=context-dependent names=].

The [=syntax/attribute=] names are:

* `'align'`
* `'binding'`
* `'builtin'`
* `'compute'`
* `'const'`
* `'fragment'`
* `'group'`
* `'id'`
* `'interpolate'`
* `'invariant'`
* `'location'`
* `'size'`
* `'vertex'`
* `'workgroup_size'`

The [=diagnostic filter=] severity control names names are:

<pre class=include>
path: syntax/severity_control_name.syntax.bs.include
</pre>

The valid [=enable-extension=] names are listed in [[#enable-extensions-sec]] but in general have the same form as an [=identifier=]:

<pre class=include>
path: syntax/enable_extension_name.syntax.bs.include
</pre>

There are no [=language extension=] names, but they have the same form as an [=identifier=]:
<pre class=include>
path: syntax/software_extension_name.syntax.bs.include
</pre>

The [=swizzle=] names are used in [[#vector-access-expr|vector access expressions]]:

<pre class=include>
path: syntax/swizzle_name.syntax.bs.include
</pre>

# Built-in Functions # {#builtin-functions}

Certain functions are [=predeclared=], provided by the implementation, and
therefore always available for use in a WGSL module.
These are called <dfn noexport>built-in functions</dfn>.

A built-in function is a family of functions, all with the same name,
but distinguished by the number, order, and types of their [=formal parameters=].
Each of these distinct function variations is an [=overload=].

Note: Each [=user-defined function=] only has one [=overload=].

Each [=overload=] is described below via:
* Type parameterizations, if any.
* The built-in function name, a parenthesized list of [=formal parameters=], and optionally a [=return type=].
* The behavior of this overload of the function.

When calling a built-in function, all arguments to the function are evaluated
before function evaluation begins.
See [[#function-calls]].

## Constructor Built-in Functions ## {#constructor-builtin-function}

A <dfn noexport>value constructor</dfn> built-in function explicitly creates a
value of a given type.

WGSL provides value constructors for all [=predeclared=] types and all
[=constructible=] [=structure=] types.
The constructor built-in functions have the same spelling as the types.
Wherever such a built-in function is used, the [=identifier=]
[=shader-creation error|must=] be [=in scope=] of the type and the [=identifier=]
[=shader-creation error|must not=] [=resolve=] to another declaration.

Note: The structure types returned by [[#frexp-builtin|frexp]],
[[#modf-builtin|modf]], and [[#atomic-rmw|atomicCompareExchangeWeak]] cannot be
written in WGSL modules.

Note: A value declaration of the type needs to be valid at that statement of
the WGSL text.

WGSL provides two kinds of value constructors:
* [[#zero-value-builtin-function|zero value constructors]]
* [[#value-constructor-builtin-function|value constructors]] (which also provide conversion)

### Zero Value Built-in Functions ### {#zero-value-builtin-function}

Each [=type/concrete=], [=constructible=] *T* has a unique <dfn noexport>zero value</dfn>,
and a corresponding built-in function written in WGSL as the type followed by an empty pair of parentheses: *T* `()`.

The zero values are as follows:

* `bool()` is `false`
* `i32()` is 0
* `u32()` is 0
* `f32()` is 0.0
* `f16()` is 0.0
* The zero value for an *N*-component vector of type *T* is the *N*-component vector of the zero value for *T*.
* The zero value for an *C*-column *R*-row matrix of type *T* is the matrix of those dimensions filled with the zero value for *T*.
* The zero value for a [=constructible=] *N*-element array with element type *E* is an array of *N* elements of the zero value for *E*.
* The zero value for a [=constructible=] structure type *S* is the structure value *S* with zero-valued members.

Note: WGSL does not have zero built-in functions for [=atomic types=],
[=runtime-sized=] arrays, or other types that are not [=constructible=].

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn T() -> T</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=constructible=] type.<br>
  <tr><td>Description
      <td>Construct [=zero value=] of the type `T`.
</table>

Note: Zero-filled vectors of AbstractInt can be written as
`vec2()`, `vec3()`, and `vec4()`.

<div class='example' heading="Zero-valued vectors">
  <xmp>
    vec2<f32>()                 // The zero-valued vector of two f32 components.
    vec2<f32>(0.0, 0.0)         // The same value, written explicitly.

    vec3<i32>()                 // The zero-valued vector of three i32 components.
    vec3<i32>(0, 0, 0)          // The same value, written explicitly.
  </xmp>
</div>

<div class='example' heading="Zero-valued arrays">
  <xmp>
    array<bool, 2>()               // The zero-valued array of two booleans.
    array<bool, 2>(false, false)   // The same value, written explicitly.
  </xmp>
</div>

<div class='example wgsl global-scope' heading="Zero-valued structures">
  <xmp>
    struct Student {
      grade: i32,
      GPA: f32,
      attendance: array<bool,4>
    }

    fn func() {
      var s: Student;

      // The zero value for Student
      s = Student();

      // The same value, written explicitly.
      s = Student(0, 0.0, array<bool,4>(false, false, false, false));

      // The same value, written with zero-valued members.
      s = Student(i32(), f32(), array<bool,4>());
    }
  </xmp>
</div>

### Value Constructor Built-in Functions ### {#value-constructor-builtin-function}

The built-in functions defined in following subsections create a [=constructible=] value by:
* Copying an existing value of the same type (i.e. the identity function), or
* Creating a composite value from an explicit list of components.
* Converting from another value type.

The vector and matrix forms construct vector and matrix values from various combinations of components and subvectors
with matching component types.
There are [=overloads=] for constructing vectors and matrices that specify the dimensions of the target type without having to
specify the component type; the component type is inferred from the constructor arguments.

#### `array` #### {#array-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn array<T, N>(e1 : T, ..., eN : T) -> array<T, N>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=type/concrete=] and [=constructible=]
  <tr><td>Description
      <td>Construction of an [=array=] from elements.

      Note: array&lt;|T|,|N|&gt; is [=constructible=] because its [=element count=]
      is equal to the number of arguments to the constructor, and hence
      fully determined at [=shader module creation|shader-creation=] time.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn array(e1 : T, ..., eN : T) -> array<T, N>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=constructible=]
  <tr><td>Description
      <td>Construction of an [=array=] from elements.

      The component type is inferred from the elements' type.
      The size of the array is determined by the number of elements.
</table>

#### `bool` #### {#bool-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bool(e : T) -> bool</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type.
  <tr><td>Description
      <td>Construct a [=bool=] value.

      If `T` is [=bool=], this is an identity operation.<br>
      Otherwise this is a boolean coercion.
      The result is `false` if `e` is a [=zero value=] (or -0.0 for floating point types) and `true` otherwise.
</table>

#### `f16` #### {#f16-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn f16(e : T) -> f16</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type
  <tr><td>Description
      <td>Construct an [=f16=] value.

      If `T` is [=f16=], this is an identity operation.<br>
      If `T` is a [[#integer-types|integer type]] or [=f32=], `e` is converted to [=f16=] (including invalid conversions).<br>
      If `T` is [=bool=], the result is `1.0h` if `e` is `true` and `0.0h` otherwise.
</table>

#### `f32` #### {#f32-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn f32(e : T) -> f32</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type
  <tr><td>Description
      <td>Construct an [=f32=] value.

      If `T` is [=f32=], this is an identity operation.<br>
      If `T` is a [[#integer-types|integer type]] or [=f16=], `e` is converted to [=f32=] (including invalid conversions).<br>
      If `T` is [=bool=], the result is `1.0f` if `e` is `true` and `0.0f` otherwise.
</table>

#### `i32` #### {#i32-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn i32(e : T) -> i32</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type
  <tr><td>Description
      <td>Construct an [=i32=] value.

      If `T` is [=i32=], this is an identity operation.<br>
      If `T` is [=u32=], this is a reinterpretation of bits (i.e. the result is the unique value in [=i32=] that has the same bit pattern as `e`).<br>
      If `T` is a [[#floating-point-types|floating point type]], `e` is [=scalar floating point to integral conversion|converted=] to [=i32=], rounding towards zero.<br>
      If `T` is [=bool=], the result is `1i` if `e` is `true` and `0i` otherwise.
</table>

#### `mat2x2` #### {#mat2x2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x2<T>(e : mat2x2<S>) -> mat2x2<T>
          @const @must_use fn mat2x2(e : mat2x2<S>) -> mat2x2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 2x2 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x2<T>(v1 : vec2<T>, v2 : vec2<T>) -> mat2x2<T>
          @const @must_use fn mat2x2(v1 : vec2<T>, v2 : vec2<T>) -> mat2x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x2 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x2<T>(e1 : T, e2 : T, e3 : T, e4 : T) -> mat2x2<T>
          @const @must_use fn mat2x2(e1 : T, e2 : T, e3 : T, e4 : T) -> mat2x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x2 column-major [=matrix=] from elements.

          Same as mat2x2(vec2(e1,e2), vec2(e3,e4)).
</table>

#### `mat2x3` #### {#mat2x3-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x3<T>(e : mat2x3<S>) -> mat2x3<T>
          @const @must_use fn mat2x3(e : mat2x3<S>) -> mat2x3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 2x3 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x3<T>(v1 : vec3<T>, v2 : vec3<T>) -> mat2x3<T>
          @const @must_use fn mat2x3(v1 : vec3<T>, v2 : vec3<T>) -> mat2x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x3 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x3<T>(e1 : T, ..., e6 : T) -> mat2x3<T>
          @const @must_use fn mat2x3(e1 : T, ..., e6 : T) -> mat2x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x3 column-major [=matrix=] from elements.

          Same as mat2x3(vec3(e1,e2,e3), vec3(e4,e5,e6)).
</table>

#### `mat2x4` #### {#mat2x4-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x4<T>(e : mat2x4<S>) -> mat2x4<T>
          @const @must_use fn mat2x4(e : mat2x4<S>) -> mat2x4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 2x4 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x4<T>(v1 : vec4<T>, v2 : vec4<T>) -> mat2x4<T>
          @const @must_use fn mat2x4(v1 : vec4<T>, v2 : vec4<T>) -> mat2x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x4 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat2x4<T>(e1 : T, ..., e8 : T) -> mat2x4<T>
          @const @must_use fn mat2x4(e1 : T, ..., e8 : T) -> mat2x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 2x4 column-major [=matrix=] from elements.

          Same as mat2x4(vec4(e1,e2,e3,e4), vec4(e5,e6,e7,e8)).
</table>

#### `mat3x2` #### {#mat3x2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x2<T>(e : mat3x2<S>) -> mat3x2<T>
          @const @must_use fn mat3x2(e : mat3x2<S>) -> mat3x2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 3x2 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x2<T>(v1 : vec2<T>,
                                        v2 : vec2<T>,
                                        v3 : vec2<T>) -> mat3x2<T>
          @const @must_use fn mat3x2(v1 : vec2<T>,
                                     v2 : vec2<T>,
                                     v3 : vec2<T>) -> mat3x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x2 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x2<T>(e1 : T, ..., e6 : T) -> mat3x2<T>
          @const @must_use fn mat3x2(e1 : T, ..., e6 : T) -> mat3x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x2 column-major [=matrix=] from elements.

          Same as mat3x2(vec2(e1,e2), vec2(e3,e4), vec2(e5,e6)).
</table>

#### `mat3x3` #### {#mat3x3-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x3<T>(e : mat3x3<S>) -> mat3x3<T>
          @const @must_use fn mat3x3(e : mat3x3<S>) -> mat3x3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 3x3 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x3<T>(v1 : vec3<T>,
                                        v2 : vec3<T>,
                                        v3 : vec3<T>) -> mat3x3<T>
          @const @must_use fn mat3x3(v1 : vec3<T>,
                                     v2 : vec3<T>,
                                     v3 : vec3<T>) -> mat3x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x3 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x3<T>(e1 : T, ..., e9 : T) -> mat3x3<T>
          @const @must_use fn mat3x3(e1 : T, ..., e9 : T) -> mat3x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x3 column-major [=matrix=] from elements.

          Same as mat3x3(vec3(e1,e2,e3), vec3(e4,e4,e6), vec3(e7,e8,e9)).
</table>

#### `mat3x4` #### {#mat3x4-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x4<T>(e : mat3x4<S>) -> mat3x4<T>
          @const @must_use fn mat3x4(e : mat3x4<S>) -> mat3x4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 3x4 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x4<T>(v1 : vec4<T>,
                                        v2 : vec4<T>,
                                        v3 : vec4<T>) -> mat3x4<T>
          @const @must_use fn mat3x4(v1 : vec4<T>,
                                     v2 : vec4<T>,
                                     v3 : vec4<T>) -> mat3x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x4 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat3x4<T>(e1 : T, ..., e12 : T) -> mat3x4<T>
          @const @must_use fn mat3x4(e1 : T, ..., e12 : T) -> mat3x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 3x4 column-major [=matrix=] from elements.

          Same as mat3x4(vec4(e1,e2,e3,e4), vec4(e5,e6,e7,e8), vec4(e9,e10,e11,e12)).
</table>

#### `mat4x2` #### {#mat4x2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x2<T>(e : mat4x2<S>) -> mat4x2<T>
          @const @must_use fn mat4x2(e : mat4x2<S>) -> mat4x2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 4x2 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x2<T>(v1 : vec2<T>,
                                        v2 : vec2<T>,
                                        v3 : vec2<T>,
                                        v4: vec2<T>) -> mat4x2<T>
          @const @must_use fn mat4x2(v1 : vec2<T>,
                                     v2 : vec2<T>,
                                     v3 : vec2<T>,
                                     v4: vec2<T>) -> mat4x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x2 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x2<T>(e1 : T, ..., e8 : T) -> mat4x2<T>
          @const @must_use fn mat4x2(e1 : T, ..., e8 : T) -> mat4x2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x2 column-major [=matrix=] from elements.

          Same as mat4x2(vec2(e1,e2), vec2(e3,e4), vec2(e5,e6), vec2(e7,e8)).
</table>

#### `mat4x3` #### {#mat4x3-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x3<T>(e : mat4x3<S>) -> mat4x3<T>
          @const @must_use fn mat4x3(e : mat4x3<S>) -> mat4x3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 4x3 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x3<T>(v1 : vec3<T>,
                                        v2 : vec3<T>,
                                        v3 : vec3<T>,
                                        v4 : vec3<T>) -> mat4x3<T>
          @const @must_use fn mat4x3(v1 : vec3<T>,
                                     v2 : vec3<T>,
                                     v3 : vec3<T>,
                                     v4 : vec3<T>) -> mat4x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x3 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x3<T>(e1 : T, ..., e12 : T) -> mat4x3<T>
          @const @must_use fn mat4x3(e1 : T, ..., e12 : T) -> mat4x3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x3 column-major [=matrix=] from elements.

          Same as mat4x3(vec3(e1,e2,e3), vec3(e4,e5,e6), vec3(e7,e8,e9), vec3(e10,e11,e12)).
</table>

#### `mat4x4` #### {#mat4x4-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x4<T>(e : mat4x4<S>) -> mat4x4<T>
          @const @must_use fn mat4x4(e : mat4x4<S>) -> mat4x4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=f16=] or [=f32=]<br>
      `S` is [FLOATSCALAR]
  <tr><td>Description
      <td>Constructor for a 4x4 column-major [=matrix=].

      If `T` does not match `S`, a [[#floating-point-conversion|conversion]] occurs.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x4<T>(v1 : vec4<T>,
                                        v2 : vec4<T>,
                                        v3 : vec4<T>,
                                        v4 : vec4<T>) -> mat4x4<T>
          @const @must_use fn mat4x4(v1 : vec4<T>,
                                     v2 : vec4<T>,
                                     v3 : vec4<T>,
                                     v4 : vec4<T>) -> mat4x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x4 column-major [=matrix=] from column vectors.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn mat4x4<T>(e1 : T, ..., e16 : T) -> mat4x4<T>
          @const @must_use fn mat4x4(e1 : T, ..., e16 : T) -> mat4x4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [FLOATSCALAR]
  <tr><td>Description
      <td>Construct a 4x4 column-major [=matrix=] from elements.

          Same as mat4x4(vec4(e1,e2,e3,e4), vec4(e5,e6,e7,e8), vec4(e9,e10,e11,e12), vec4(e13,e14,e15,e16)).
</table>

#### Structures #### {#structures-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn S(e1 : T1, ..., eN : TN) -> S</xmp>
  <tr><td>Parameterization
      <td>`S` is a [=constructible=] structure type with members having types `T1` ... `TN`.
  <tr><td>Description
      <td>Construct a [=structure=] of type `S` from members.
</table>

#### `u32` #### {#u32-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn u32(e : T) -> u32</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=] type or [=AbstractInt=]
  <tr><td>Description
      <td>Construct a [=u32=] value.

      If `T` is [=u32=], this is an identity operation.<br>
      If `T` is [=i32=], this is a reinterpretation of bits (i.e. the result is the unique value in [=u32=] that has the same bit pattern as `e`).<br>
      If `T` is a [[#floating-point-types|floating point type]], `e` is [=scalar floating point to integral conversion|converted=] to [=u32=], rounding towards zero.<br>
      If `T` is [=bool=], the result is `1u` if `e` is `true` and `0u` otherwise.<br>
      If `T` is [=AbstractInt=], this is an identity operation if the `e` can be represented in [=u32=], otherwise it produces a [=shader-creation error=].
  <tr><td>
      <td>

      Note: The overload from [=AbstractInt=] exists so expressions such as `u32(4*1000*1000*1000)` can create a u32 value that would otherwise overflow the i32 type. If this overload did not exist, [=overload resolution=] would select the `u32(i32)` overload, the AbstractInt expression would automatically convert to i32, and this would cause a shader-creation error due to overflow.
</table>

#### `vec2` #### {#vec2-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec2<T>(e : T) -> vec2<T>
          @const @must_use fn vec2(e : S) -> vec2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>Construction of a two-component [=vector=] with `e` as both components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec2<T>(e : vec2<S>) -> vec2<T>
          @const @must_use fn vec2(e : vec2<S>) -> vec2<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a two-component [=vector=] with `e.x` and `e.y` as components.

      If `T` does not match `S` a conversion is used and the components are `T(e.x)` and `T(e.y)`.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec2<T>(e1 : T, e2 : T) -> vec2<T>
          @const @must_use fn vec2(e1 : T, e2 : T) -> vec2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a two-component [=vector=] with `e1` and `e2` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec2() -> vec2<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is AbstractInt
  <tr><td>Description
      <td>Returns the value `vec2(0,0)`.
</table>

#### `vec3` #### {#vec3-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(e : T) -> vec3<T>
          @const @must_use fn vec3(e : S) -> vec3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>Construction of a three-component [=vector=] with `e` as all components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(e : vec3<S>) -> vec3<T>
          @const @must_use fn vec3(e : vec3<S>) -> vec3<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a three-component [=vector=] with `e.x`, `e.y`, and `e.z` as components.

      If `T` does not match `S` a conversion is used and the components are `T(e.x)`, `T(e.y)`, and  `T(e.z)`.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(e1 : T, e2 : T, e3 : T) -> vec3<T>
          @const @must_use fn vec3(e1 : T, e2 : T, e3 : T) -> vec3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a three-component [=vector=] with `e1`, `e2`, and `e3` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(v1 : vec2<T>, e1 : T) -> vec3<T>
          @const @must_use fn vec3(v1 : vec2<T>, e1 : T) -> vec3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a three-component [=vector=] with `v1.x`, `v1.y`, and `e1` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3<T>(e1 : T, v1 : vec2<T>) -> vec3<T>
          @const @must_use fn vec3(e1 : T, v1 : vec2<T>) -> vec3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a three-component [=vector=] with `e1`, `v1.x`, and `v1.y` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec3() -> vec3<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is AbstractInt
  <tr><td>Description
      <td>Returns the value `vec3(0,0,0)`.
</table>

#### `vec4` #### {#vec4-builtin}

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e : T) -> vec4<T>
          @const @must_use fn vec4(e : S) -> vec4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>Construction of a four-component [=vector=] with `e` as all components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e : vec4<S>) -> vec4<T>
          @const @must_use fn vec4(e : vec4<S>) -> vec4<S>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=scalar=]<br>
      `S` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e.x`, `e.y`, `e.z`, and `e.w` as components.

      If `T` does not match `S` a conversion is used and the components are `T(e.x)`, `T(e.y)`, `T(e.z)` and  `T(e.w)`.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e1 : T, e2 : T, e3 : T, e4 : T) -> vec4<T>
          @const @must_use fn vec4(e1 : T, e2 : T, e3 : T, e4 : T) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e1`, `e2`, `e3`, and `e4` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e1 : T, v1 : vec2<T>, e2 : T) -> vec4<T>
          @const @must_use fn vec4(e1 : T, v1 : vec2<T>, e2 : T) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e1`, `v1.x`, `v1.y`, and `e2` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e1 : T, e2 : T, v1 : vec2<T>) -> vec4<T>
          @const @must_use fn vec4(e1 : T, e2 : T, v1 : vec2<T>) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e1`, `e2`, `v1.x`, and `v1.x` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(v1 : vec2<T>, v2 : vec2<T>) -> vec4<T>
          @const @must_use fn vec4(v1 : vec2<T>, v2 : vec2<T>) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `v1.x`, `v1.y`, `v2.x`, and `v2.y` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(v1 : vec2<T>, e1 : T, e2 : T) -> vec4<T>
          @const @must_use fn vec4(v1 : vec2<T>, e1 : T, e2 : T) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `v1.x`, `v1.y`, `e1`, and `e2` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(v1 : vec3<T>, e1 : T) -> vec4<T>
          @const @must_use fn vec4(v1 : vec3<T>, e1 : T) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `v1.x`, `v1.y`, `v1.z`, and `e1` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4<T>(e1 : T, v1 : vec3<T>) -> vec4<T>
          @const @must_use fn vec4(e1 : T, v1 : vec3<T>) -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is [=scalar=]
  <tr><td>Description
      <td>[=Component-wise=] construction of a four-component [=vector=] with `e1`, `v1.x`, `v1.y`, and `v1.z` as components.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>
          @const @must_use fn vec4() -> vec4<T>
        </xmp>
  <tr><td>Parameterization
      <td>`T` is AbstractInt
  <tr><td>Description
      <td>Returns the value `vec4(0,0,0,0)`.
</table>

## Bit Reinterpretation Built-in Functions ## {#bit-reinterp-builtin-functions}

### `bitcast` ### {#bitcast-builtin}

A `bitcast` built-in function is used to reinterpret the bit representation of
a value in one type as a value in another type.

The internal layout rules are described in [[#internal-value-layout]].

<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<T>(e : T) -> T</xmp>
  <tr><td>Parameterization
      <td>`T` is a [=type/concrete=] [=numeric scalar=] or [=type/concrete=] [=numeric vector=]
  <tr><td>Description
      <td>Identity transform.<br>
      [=Component-wise=] when `T` is a [=vector=].<br>
      The result is `e`.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<T>(e : S) -> T</xmp>
  <tr><td>Parameterization
      <td>`S` is i32, u32, or f32<br>
      `T` is not `S` and is i32, u32, or f32
  <tr><td>Description
      <td>Reinterpretation of bits as `T`.<br>
      The result is the reintepretation of bits in `e` as a `T` value.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<vecN<T>>(e : vecN<S>) -> T</xmp>
  <tr><td>Parameterization
      <td>`S` is i32, u32, or f32<br>
      `T` is not `S` and is i32, u32, or f32
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as `T`.<br>
      The result is the reintepretation of bits in `e` as a `vecN<T>` value.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<u32>(e : AbstractInt) -> T

                            @const @must_use fn bitcast<vecN<u32>>(e : vecN<AbstractInt>) -> T</xmp>
  <tr><td>Parameterization
      <td>
  <tr><td>Description
      <td>The identity operation if `e` can be represented as [=u32=],
      otherwise it produces a [=shader-creation error=].
      That is, produces the same result as `u32(e)`.

      [=Component-wise=] when `e` is a vector.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<T>(e : vec2<f16>) -> T</xmp>
  <tr><td>Parameterization
      <td>`T` is i32, u32, or f32
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as `T`.<br>
      The result is the reintepretation of the 32 bits in `e` as a `T` value, following the internal layout rules.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<vec2<T>>(e : vec4<f16>) -> vec2<T></xmp>
  <tr><td>Parameterization
      <td>`T` is i32, u32, or f32<br>
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as `T`.<br>
      The result is the reintepretation of the 64 bits in `e` as a `T` value, following the internal layout rules.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<vec2<f16>>(e : T) -> vec2<f16></xmp>
  <tr><td>Parameterization
      <td>`T` is i32, u32, or f32
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as f16.<br>
      The result is the reintepretation of the 32 bits in `e` as an f16 value, following the internal layout rules.
</table>
<table class='data builtin'>
  <tr><td style="width:10%">Overload
      <td>
        <xmp>@const @must_use fn bitcast<vec4<f16>>(e : vec2<T>) -> vec4<f16></xmp>
  <tr><td>Parameterization
      <td>`T` is i32, u32, or f32
  <tr><td>Description
      <td>[=Component-wise=] reinterpretation of bits as `vec2<f16>`.<br>
      The result is the reintepretation of the 64 bits in `e` as an f16 value, following the internal layout rules.
</table>

## Logical Built-in Functions ## {#logical-builtin-functions}

### `all` ### {#all-builtin}
<table class='data builtin'>
  <tr algorithm="vector all">
    <td style="width:10%">Overload
    <td>
      <xmp>@const @must_use fn all(e: vecN<bool>) -> bool</xmp>
  <tr>
    <td>Description
    <td>Returns true if each component of `e` is true.
</table>

<table class='data builtin'>
  <tr algorithm="scalar all">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>@const @must_use fn all(e: bool) -> bool</xmp>
  <tr>
    <td>Description
    <td>Returns `e`.
</table>

### `any` ### {#any-builtin}
<table class='data builtin'>
  <tr algorithm="vector any">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn any(e: vecN<bool>) -> bool
      </xmp>
  <tr>
    <td style="width:10%">Description
    <td>Returns true if any component of `e` is true.
</table>

<table class='data builtin'>
  <tr algorithm="scalar any">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>@const @must_use fn any(e: bool) -> bool</xmp>
  <tr>
    <td>Description
    <td>Returns `e`.
</table>

### `select` ### {#select-builtin}
<table class='data builtin'>
  <tr algorithm="scalar select">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn select(f: T,
                                   t: T,
                                   cond: bool) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [=scalar=] or [=vector=]
  <tr>
    <td>Description
    <td>Returns `t` when `cond` is true, and `f` otherwise.
</table>

<table class='data builtin'>
  <tr algorithm="vector select">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn select(f: vecN<T>,
                                   t: vecN<T>,
                                   cond: vecN<bool>) -> vecN<T>
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [=scalar=]
  <tr>
    <td>Description
    <td>[=Component-wise=] selection. Result component `i` is evaluated
        as `select(f[i], t[i], cond[i])`.
</table>

## Array Built-in Functions ## {#array-builtin-functions}

### `arrayLength` ### {#arrayLength-builtin}
<table class='data builtin'>
  <tr algorithm="runtime-sized array length">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn arrayLength(p: ptr<storage, array<E>, AM>) -> u32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`E` is an element type for a [=runtime-sized=] array,<br>
        [=access mode=] `AM` is [=access/read=] or [=access/read_write=]
  <tr>
    <td>Description
    <td>Returns [=NRuntime=], the number of elements in the [=runtime-sized=] array.

        See [[#buffer-binding-determines-runtime-sized-array-element-count]]
</table>

<div class='example wgsl global-scope' heading='Getting the number of elements in a runtime-sized array'>
  <xmp>
struct PointLight {
  position : vec3f,
  color : vec3f,
}

struct LightStorage {
  pointCount : u32,
  point : array<PointLight>,
}

@group(0) @binding(1) var<storage> lights : LightStorage;

fn num_point_lights() -> u32 {
  return arrayLength( &lights.point );
}
  </xmp>
</div>

## Numeric Built-in Functions ## {#numeric-builtin-functions}

### `abs` ### {#abs-float-builtin}
<table class='data builtin'>
  <tr algorithm="float abs">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn abs(e: T ) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLNUMERICDECL]
  <tr>
    <td>Description
    <td>The absolute value of `e`.
    [=Component-wise=] when `T` is a vector.

    If `e` is a floating-point type, then the result is `e` with a positive sign bit.
    If `e` is an unsigned [=integer scalar=] type, then the result is `e`.
    If `e` is a signed [=integer scalar=] type and evaluates to the largest
    negative value, then the result is `e`.
</table>

### `acos` ### {#acos-builtin}
<table class='data builtin'>
  <tr algorithm="acos">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn acos(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the principal value, in radians, of the inverse cosine (cos<sup>-1</sup>) of `e`.<br>
    That is, approximates `x` with 0 &le; `x` &le; &pi;, such that `cos`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful when `abs(e)` &gt; 1.
</table>

### `acosh` ### {#acosh-builtin}
<table class='data builtin'>
  <tr algorithm="acosh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn acosh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the inverse hyperbolic cosine (cosh<sup>-1</sup>) of `e`, as a
    hyperbolic [=angle=] in radians.<br>
    That is, approximates `x` with 0 &le; x &le; &infin;, such that `cosh`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful when `e` &lt; 1.

</table>

### `asin` ### {#asin-builtin}
<table class='data builtin'>
  <tr algorithm="asin">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn asin(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the principal value, in radians, of the inverse sine (sin<sup>-1</sup>) of `e`.<br>
    That is, approximates `x` with -&pi;/2 &le; `x` &le; &pi;/2, such that `sin`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful when `abs(e)` &gt; 1.
</table>

### `asinh` ### {#asinh-builtin}
<table class='data builtin'>
  <tr algorithm="asinh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn asinh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the inverse hyperbolic sine (sinh<sup>-1</sup>) of `e`, as a hyperbolic [=angle=] in radians.<br>
    That is, approximates `x` such that `sinh`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
</table>

### `atan` ### {#atan-builtin}
<table class='data builtin'>
  <tr algorithm="atan">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn atan(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the principal value, in radians, of the inverse tangent (tan<sup>-1</sup>) of `e`.<br>
    That is, approximates `x` with &pi;/2 &le; `x` &le; &pi;/2, such that `tan`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
</table>

### `atanh` ### {#atanh-builtin}
<table class='data builtin'>
  <tr algorithm="atanh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn atanh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the inverse hyperbolic tangent (tanh<sup>-1</sup>) of `e`, as a hyperbolic [=angle=] in radians.<br>
    That is, approximates `x` such that `tanh`(`x`) = `e`.

    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful when `abs(e)` &ge; 1.

</table>

### `atan2` ### {#atan2-builtin}
<table class='data builtin'>
  <tr algorithm="atan2">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn atan2(y: T,
                                  x: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns an [=angle=], in radians, in the interval [-&pi;, &pi;] whose tangent is `y`&divide;`x`.

    The quadrant selected by the result depends on the signs of `y` and `x`.
    For example, the function may be implemented as:

    * `atan(y/x)` when `x` &gt; 0
    * `atan(y/x)` + &pi; when (`x` &lt; 0) and (`y` &gt; 0)
    * `atan(y/x)` - &pi; when (`x` &lt; 0) and (`y` &lt; 0)

    <div class=note>
    <span class=marker>Note:</span> The error in the result is unbounded:
    * When `abs(x)` is very small, e.g. subnormal for its type,
    * At the origin (`x`,`y`) = (0,0), or
    * When `y` is subnormal or infinite.

    </div>

    [=Component-wise=] when `T` is a vector.
</table>

### `ceil` ### {#ceil-builtin}
<table class='data builtin'>
  <tr algorithm="ceil">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn ceil(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the [=ceiling expression|ceiling=] of `e`.
    [=Component-wise=] when `T` is a vector.
</table>

### `clamp` ### {#clamp}
<table class='data builtin'>
  <tr algorithm="clamp">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>
      @const @must_use fn clamp(e: T,
                                low: T,
                                high: T) -> T
    </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLNUMERICDECL]
  <tr>
    <td>Description
    <td>Restricts the value of `e` within a range.

    If `T` is an integer type, then the result is `min(max(e, low), high)`.

    If `T` is a floating-point type, then the result is either `min(max(e,
    low), high)`, or the median of the three values `e`, `low`, `high`.

    [=Component-wise=] when `T` is a vector.

    If `low` is greater than `high`, then:
    * It is a [=shader-creation error=] if `low` and `high` are [=const-expressions=].
    * It is a [=pipeline-creation error=] if `low` and `high` are [=override-expressions=].
</table>

### `cos` ### {#cos-builtin}
<table class='data builtin'>
  <tr algorithm="cos">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>@const @must_use fn cos(e: T) -> T</xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the cosine of `e`, where `e` is in radians.
    [=Component-wise=] when `T` is a vector.
</table>

### `cosh` ### {#cosh-builtin}
<table class='data builtin'>
  <tr algorithm="cosh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn cosh(arg: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the hyperbolic cosine of `arg`, where `arg` is a hyperbolic [=angle=] in radians.
    Approximates the pure mathematical function (*e*<sup>arg</sup> + *e*<sup>&minus;arg</sup>)&divide;2,
    but not necessarily computed that way.

    [=Component-wise=] when `T` is a vector
</table>

### `countLeadingZeros` ### {#countLeadingZeros-builtin}
<table class='data builtin'>
  <tr algorithm="count leading zeroes">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn countLeadingZeros(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>The number of consecutive 0 bits starting from the most significant bit
        of `e`, when `T` is a scalar type.<br>
        [=Component-wise=] when `T` is a vector.<br>
        Also known as "clz" in some languages.
</table>

### `countOneBits` ### {#countOneBits-builtin}
<table class='data builtin'>
  <tr algorithm="count 1 bits">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn countOneBits(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>The number of 1 bits in the representation of `e`.<br>
        Also known as "population count".<br>
        [=Component-wise=] when `T` is a vector.
</table>

### `countTrailingZeros` ### {#countTrailingZeros-builtin}
<table class='data builtin'>
  <tr algorithm="count trailing zeroes">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn countTrailingZeros(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>The number of consecutive 0 bits starting from the least significant bit
        of `e`, when `T` is a scalar type.<br>
        [=Component-wise=] when `T` is a vector.<br>
        Also known as "ctz" in some languages.
</table>

### `cross` ### {#cross-builtin}
<table class='data builtin'>
  <tr algorithm="vector case, cross">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn cross(e1: vec3<T>,
                                  e2: vec3<T>) -> vec3<T>
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>Returns the cross product of `e1` and `e2`.
</table>

### `degrees` ### {#degrees-builtin}
<table class='data builtin'>
  <tr algorithm="degrees">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn degrees(e1: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Converts radians to degrees, approximating `e1`&nbsp;&times;&nbsp;180&nbsp;&div;&nbsp;&pi;.
    [=Component-wise=] when `T` is a vector
</table>

### `determinant` ### {#determinant-builtin}
<table class='data builtin'>
  <tr algorithm="determinant">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn determinant(e: matCxC<T>) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>Returns the determinant of `e`.
</table>

### `distance` ### {#distance-builtin}
<table class='data builtin'>
  <tr algorithm="distance">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn distance(e1: T,
                                     e2: T) -> S
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the distance between `e1` and `e2` (e.g. `length(e1 - e2)`).
</table>

### `dot` ### {#dot-builtin}
<table class='data builtin'>
  <tr algorithm="dot">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn dot(e1: vecN<T>,
                                e2: vecN<T>) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractInt, AbstractFloat, i32, u32, f32, or f16
  <tr>
    <td>Description
    <td>Returns the dot product of `e1` and `e2`.
</table>

### `exp` ### {#exp-builtin}
<table class='data builtin'>
  <tr algorithm="exp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn exp(e1: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the natural exponentiation of `e1` (e.g. `e`<sup>`e1`</sup>).
    [=Component-wise=] when `T` is a vector.
</table>

### `exp2` ### {#exp2-builtin}
<table class='data builtin'>
  <tr algorithm="exp2">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn exp2(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns 2 raised to the power `e` (e.g. `2`<sup>`e`</sup>).
    [=Component-wise=] when `T` is a vector.
</table>

### `extractBits` (signed) ### {#extractBits-signed-builtin}
<table class='data builtin'>
  <tr algorithm="signed extract bits">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn extractBits(e: T,
                                        offset: u32,
                                        count: u32) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [SIGNEDINTEGRAL]
  <tr>
    <td>Description
    <td>Reads bits from an integer, with sign extension.

    When `T` is a scalar type, then:
    <ul>
    <li>`w` is the bit width of `T`
    <li>`o = min(offset, w)`
    <li>`c = min(count, w - o)`
    <li>The result is 0 if `c` is 0.
    <li>Otherwise, bits `0..c - 1` of the result are copied from bits
       `o..o + c - 1` of `e`.
       Other bits of the result are the same as bit `c - 1` of the result.
    </ul>
    [=Component-wise=] when `T` is a vector.

    If `count` + `offset` is greater than `w`, then:
    * It is a [=shader-creation error=] if `count` and `offset` are [=const-expressions=].
    * It is a [=pipeline-creation error=] if `count` and `offset` are [=override-expressions=].
</table>

### `extractBits` (unsigned) ### {#extractBits-unsigned-builtin}
<table class='data builtin'>
  <tr algorithm="unsigned extract bits">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn extractBits(e: T,
                                        offset: u32,
                                        count: u32) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [UNSIGNEDINTEGRAL]
  <tr>
    <td>Description
    <td>Reads bits from an integer, without sign extension.

    When `T` is a scalar type, then:
    <ul>
    <li>`w` is the bit width of `T`
    <li>`o = min(offset, w)`
    <li>`c = min(count, w - o)`
    <li>The result is 0 if `c` is 0.
    <li>Otherwise, bits `0..c - 1` of the result are copied from bits
       `o..o + c - 1` of `e`.
       Other bits of the result are 0.
    </ul>
    [=Component-wise=] when `T` is a vector.

    If `count` + `offset` is greater than `w`, then:
    * It is a [=shader-creation error=] if `count` and `offset` are [=const-expressions=].
    * It is a [=pipeline-creation error=] if `count` and `offset` are [=override-expressions=].
</table>

### `faceForward` ### {#faceForward-builtin}
<table class='data builtin'>
  <tr algorithm="faceForward">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn faceForward(e1: T,
                                        e2: T,
                                        e3: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;AbstractFloat&gt;, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
  <tr>
    <td>Description
    <td>Returns `e1` if `dot(e2, e3)` is negative, and `-e1` otherwise.
</table>

### `firstLeadingBit` (signed) ### {#firstLeadingBit-signed-builtin}
<table class='data builtin'>
  <tr algorithm="signed find most significant one bit">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn firstLeadingBit(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [SIGNEDINTEGRAL]
  <tr>
    <td>Description
    <td>For scalar `T`, the result is:
        <ul>
        <li>-1 if `e` is 0 or -1.
        <li>Otherwise the position of the most significant bit in
            `e` that is different from `e`'s sign bit.
        </ul>

        [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: Since signed integers use twos-complement representation,
the sign bit appears in the most significant bit position.

</table>

### `firstLeadingBit` (unsigned) ### {#firstLeadingBit-unsigned-builtin}
<table class='data builtin'>
  <tr algorithm="unsigned find most significant one bit">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn firstLeadingBit(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [UNSIGNEDINTEGRAL]
  <tr>
    <td>Description
    <td>For scalar `T`, the result is:
        <ul>
        <li>`T(-1)` if `e` is zero.
        <li>Otherwise the position of the most significant 1
            bit in `e`.
        </ul>
        [=Component-wise=] when `T` is a vector.
</table>

### `firstTrailingBit` ### {#firstTrailingBit-builtin}
<table class='data builtin'>
  <tr algorithm="find least significant one bit">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn firstTrailingBit(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>For scalar `T`, the result is:
        <ul>
        <li>`T(-1)` if `e` is zero.
        <li>Otherwise the position of the least significant 1
            bit in `e`.
        </ul>
        [=Component-wise=] when `T` is a vector.
</table>

### `floor` ### {#floor-builtin}
<table class='data builtin'>
  <tr algorithm="floor">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn floor(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the [=floor expression|floor=] of `e`.
    [=Component-wise=] when `T` is a vector.
</table>

### `fma` ### {#fma-builtin}
<table class='data builtin'>
  <tr algorithm="fma">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>
      @const @must_use fn fma(e1: T,
                              e2: T,
                              e3: T) -> T
    </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns `e1 * e2 + e3`.
    [=Component-wise=] when `T` is a vector.

    Note: The name `fma` is short for "fused multiply add".

    Note:
    The [[!IEEE-754|IEEE-754]] `fusedMultiplyAdd` operation computes the intermediate results
    as if with unbounded range and precision, and only the final result is rounded
    to the destination type.
    However, the [[#floating-point-accuracy]] rule for `fma` allows an implementation
    which performs an ordinary multiply to the target type followed by an ordinary addition.
    In this case the intermediate values may overflow or lose accuracy, and the overall
    operation is not "fused" at all.
</table>

### `fract` ### {#fract-builtin}
<table class='data builtin'>
  <tr algorithm="fract">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn fract(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the fractional part of `e`, computed as `e - floor(e)`.<br>
    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: Valid results are in the closed interval [0, 1.0].
For example, if `e` is a very small negative number, then `fract(e)` may be 1.0.

</table>

### `frexp` ### {#frexp-builtin}
<table class='data builtin'>
  <tr algorithm="scalar case, binary32, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_f32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32
  <tr>
    <td>Description
    <td>Splits `e` into a fraction and an exponent.

    * When `e` is zero, the fraction is zero.
    * When `e` is non-zero and normal, `e` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * Otherwise, `e` is denormalized, NaN, or infinite. The result fraction and exponent are [=indeterminate values=].

    Returns the `__frexp_result_f32` built-in structure, defined as follows:
    ```
struct __frexp_result_f32 {
  fract : f32, // fraction part
  exp : i32    // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>
    <div class='example wgsl function-scope' heading='frexp usage'>
    <xmp>
     // Infers result type
     let fraction_and_exponent = frexp(1.5);
     // Sets fraction_only to 0.75
     let fraction_only = frexp(1.5).fract;
    </xmp>
    </div>
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_f32`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="scalar case, binary16, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_f16
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f16
  <tr>
    <td>Description
    <td>Splits `e` into a fraction and an exponent.

    * When `e` is zero, the fraction is zero.
    * When `e` is non-zero and normal, `e` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * Otherwise, `e` is denormalized, NaN, or infinite. The result fraction and exponent are [=indeterminate values=].

    Returns the `__frexp_result_f16` built-in structure, defined as if as follows:
    ```
struct __frexp_result_f16 {
  fract : f16, // fraction part
  exp : i32    // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_f16`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="scalar case, abstract, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_abstract
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat
  <tr>
    <td>Description
    <td>Splits `e` into a fraction and an exponent.

    * When `e` is zero, the fraction is zero.
    * When `e` is non-zero and normal, `e` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * When `e` is denormalized, the fraction and exponent are have unbounded error.
        The fraction may be any AbstractFloat value, and the exponent may be any AbstractInt value.

    Note: AbstractFloat expressions resulting in infinity or NaN cause a [=shader-creation error=].

    Returns the `__frexp_result_abstract` built-in structure, defined as follows:
    ```
struct __frexp_result_abstract {
  fract : AbstractFloat, // fraction part
  exp : AbstractInt      // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>
    <div class='example wgsl function-scope' heading='abstract frexp usage'>
    <xmp>
     // Infers result type
     const fraction_and_exponent = frexp(1.5);
     // Sets fraction_only to 0.75
     const fraction_only = frexp(1.5).fract;
    </xmp>
    </div>
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_abstract`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary32, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_vecN_f32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Splits components `ei` of `e` into a fraction and an exponent.

    * When `ei` is zero, the fraction is zero.
    * When `ei` is non-zero and normal, `ei` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * Otherwise, `ei` is NaN or infinite. The result fraction and exponent are [=indeterminate values=].

    Returns the `__frexp_result_vecN_f32` built-in structure, defined as follows:
    ```
struct __frexp_result_vecN_f32 {
  fract : vecN<f32>, // fraction part
  exp : vecN<i32>    // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_vecN_f32`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary16, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_vecN_f16
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;f16&gt;
  <tr>
    <td>Description
    <td>Splits components `ei` of `e` into a fraction and an exponent.

    * When `ei` is zero, the fraction is zero.
    * When `ei` is non-zero and normal, `ei` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * Otherwise, `ei` is NaN or infinite. The result fraction and exponent are [=indeterminate values=].

    Returns the `__frexp_result_vecN_f16` built-in structure, defined as if as follows:
    ```
struct __frexp_result_vecN_f16 {
  fract : vecN<f16>, // fraction part
  exp : vecN<i32>    // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_vecN_f16`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, abstract, frexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn frexp(e: T) -> __frexp_result_vecN_abstract
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;AbstractFloat&gt;
  <tr>
    <td>Description
    <td>Splits components `ei` of `e` into a fraction and an exponent.

    * When `ei` is zero, the fraction is zero.
    * When `ei` is non-zero and normal, `ei` &equals; `fraction * 2`<sup>`exponent`</sup>, where
        the fraction is in the range [0.5, 1.0) or (-1.0, -0.5].
    * When `ei` is denormalized, the fraction and exponent are have unbounded error.
        The fraction may be any AbstractFloat value, and the exponent may be any AbstractInt value.

    Note: AbstractFloat expressions resulting in infinity or NaN cause a [=shader-creation error=].

    Returns the `__frexp_result_vecN_abstract` built-in structure, defined as follows:
    ```
struct __frexp_result_vecN_abstract {
  fract : vecN<AbstractFloat>, // fraction part
  exp : vecN<AbstractInt>      // exponent part
}
    ```

    Note: A mnemonic for the name `frexp` is "**fr**action and **exp**onent".
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__frexp_result_vecN_abstract`,
but a value may infer the type.

</table>

### `insertBits` ### {#insertBits-builtin}
<table class='data builtin'>
  <tr algorithm="insert bits">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn insertBits(e: T,
                                      newbits: T,
                                      offset: u32,
                                      count: u32) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>Sets bits in an integer.

    When `T` is a scalar type, then:
    <ul>
    <li>`w` is the bit width of `T`
    <li>`o = min(offset, w)`
    <li>`c = min(count, w - o)`
    <li>The result is `e` if `c` is 0.
    <li>Otherwise,
       bits `o..o + c - 1` of the result are copied from bits `0..c - 1` of `newbits`.
       Other bits of the result are copied from `e`.
    </ul>
    [=Component-wise=] when `T` is a vector.

    If `count` + `offset` is greater than `w`, then:
    * It is a [=shader-creation error=] if `count` and `offset` are [=const-expressions=].
    * It is a [=pipeline-creation error=] if `count` and `offset` are [=override-expressions=].
</table>

### `inverseSqrt` ### {#inverseSqrt-builtin}
<table class='data builtin'>
  <tr algorithm="inverseSqrt">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn inverseSqrt(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the reciprocal of `sqrt(e)`.
    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful if `e` &le; 0.
</table>

### `ldexp` ### {#ldexp-builtin}
<table class='data builtin'>
  <tr algorithm="ldexp">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn ldexp(e1: T,
                                  e2: I) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]<br>
        `I` is [ALLSIGNEDINTEGRAL]<br>
        `I` is a vector if and only if `T` is a vector<br>
        `I` is [=type/concrete=] if and only if `T` is a [=type/concrete=]
  <tr>
    <td>Description
    <td>Returns `e1 * 2`<sup>`e2`</sup>, except:
    * The result may be zero if `e2` + *bias* &le; 0.
    * If `e2` &gt; *bias* + 1
         * It is a [=shader-creation error=] if `e2` is a [=const-expression=].
         * It is a [=pipeline-creation error=] if `e2` is an [=override-expression=].
         * Otherwise the result is an [=indeterminate value=] for `T`.

    Here, *bias* is the exponent bias of the floating point format:
    * 15 for `f16`
    * 127 for `f32`
    * 1023 for AbstractFloat, when AbstractFloat is [[!IEEE-754|IEEE-754]] binary64

    If `x` is zero or a finite normal value for its type, then:

    <blockquote>
    x = ldexp(frexp(x).fract, frexp(x).exp)
    </blockquote>

    [=Component-wise=] when `T` is a vector.

    Note: A mnemonic for the name `ldexp` is "load exponent".
    The name may have been taken from the corresponding instruction in the floating point unit of
    the PDP-11.
</table>

### `length` ### {#length-builtin}
<table class='data builtin'>
  <tr algorithm="length">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn length(e: T) -> S
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the length of `e`.<br>
        Evaluates to the absolute value of `e` if `T` is [=scalar=].<br>
        Evaluates to `sqrt(e[0]`<sup>`2`</sup> `+ e[1]`<sup>`2`</sup> `+ ...)` if `T` is a vector type.

        Note: The scalar case may be evaluated as `sqrt(e * e)`,
        which may unnecessarily overflow or lose accuracy.
</table>

### `log` ### {#log-builtin}
<table class='data builtin'>
  <tr algorithm="log">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn log(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the natural logarithm of `e`.
    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful if `e` &lt; 0.
</table>

### `log2` ### {#log2-builtin}
<table class='data builtin'>
  <tr algorithm="log2">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn log2(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the base-2 logarithm of `e`.
    [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The result is not mathematically meaningful if `e` &lt; 0.
</table>

### `max` ### {#max-float-builtin}
<table class='data builtin'>
  <tr algorithm="max">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn max(e1: T,
                                e2: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLNUMERICDECL]
  <tr>
    <td>Description
    <td>Returns `e2` if `e1` is less than `e2`, and `e1` otherwise.
    [=Component-wise=] when `T` is a vector.

    If `e1` and `e2` are floating-point values, then:
    * If both `e1` and `e2` are denormalized, then the result may be *either* value.
    * If one operand is a NaN, the other is returned.
    * If both operands are NaNs, a NaN is returned.
</table>

### `min` ### {#min-float-builtin}
<table class='data builtin'>
  <tr algorithm="min">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn min(e1: T,
                                e2: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLNUMERICDECL]
  <tr>
    <td>Description
    <td>Returns `e2` if `e2` is less than `e1`, and `e1` otherwise.
    [=Component-wise=] when `T` is a vector.

    If `e1` and `e2` are floating-point values, then:
    * If both `e1` and `e2` are denormalized, then the result may be *either* value.
    * If one operand is a NaN, the other is returned.
    * If both operands are NaNs, a NaN is returned.
</table>

### `mix` ### {#mix-builtin}
<table class='data builtin'>
  <tr algorithm="mix all same type operands">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn mix(e1: T,
                                e2: T,
                                e3: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the linear blend of `e1` and `e2` (e.g. `e1 * (1 - e3) + e2 * e3`).
    [=Component-wise=] when `T` is a vector.
</table>

<table class='data builtin'>
  <tr algorithm="vector mix with scalar blending factor">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn mix(e1: T2,
                                e2: T2,
                                e3: T) -> T2
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16<br>
        `T2` is vecN&lt;T&gt;
  <tr>
    <td>Description
    <td>Returns the component-wise linear blend of `e1` and `e2`,
        using scalar blending factor `e3` for each component.<br>
        Same as `mix(e1, e2, T2(e3))`.
</table>

### `modf` ### {#modf-builtin}
<table class='data builtin'>
  <tr algorithm="scalar case, binary32, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_f32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32
  <tr>
    <td>Description
    <td>Splits `e` into fractional and whole number parts.

    The whole part is [[#trunc-builtin|trunc]](`e`), and the fractional part is `e` - [[#trunc-builtin|trunc]](`e`).

    Returns the `__modf_result_f32` built-in structure, defined as follows:
    ```
struct __modf_result_f32 {
  fract : f32, // fractional part
  whole : f32  // whole part
}
    ```
  <tr>
    <td>
    <td>
    <div class='example wgsl function-scope' heading='modf usage'>
    <xmp>
     // Infers result type
     let fract_and_whole = modf(1.5);
     // Sets fract_only to 0.5
     let fract_only = modf(1.5).fract;
     // Sets whole_only to 1.0
     let whole_only = modf(1.5).whole;
    </xmp>
    </div>
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_f32`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="scalar case, binary16, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_f16
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f16
  <tr>
    <td>Description
    <td>Splits `e` into fractional and whole number parts.

    The whole part is [[#trunc-builtin|trunc]](`e`), and the fractional part is `e` - [[#trunc-builtin|trunc]](`e`).

    Returns the `__modf_result_f16` built-in structure, defined as if as follows:
    ```
struct __modf_result_f16 {
  fract : f16, // fractional part
  whole : f16  // whole part
}
    ```
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_f16`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="scalar case, abstract, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_abstract
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat
  <tr>
    <td>Description
    <td>Splits `e` into fractional and whole number parts.

    The whole part is [[#trunc-builtin|trunc]](`e`), and the fractional part is `e` - [[#trunc-builtin|trunc]](`e`).

    Returns the `__modf_result_abstract` built-in structure, defined as follows:
    ```
struct __modf_result_abstract {
  fract : AbstractFloat, // fractional part
  whole : AbstractFloat  // whole part
}
    ```
  <tr>
    <td>
    <td>
    <div class='example wgsl function-scope' heading='modf abstract usage'>
    <xmp>
     // Infers result type
     const fract_and_whole = modf(1.5);
     // Sets fract_only to 0.5
     const fract_only = modf(1.5).fract;
     // Sets whole_only to 1.0
     const whole_only = modf(1.5).whole;
    </xmp>
    </div>
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_abstract`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary32, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_vecN_f32
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Splits the components of `e` into fractional and whole number parts.

    The `i`'th component of the whole and fractional parts equal the whole and fractional parts
    of `modf(e[i])`.

    Returns the `__modf_result_vecN_f32` built-in structure, defined as follows:
    ```
struct __modf_result_vecN_f32 {
  fract : vecN<f32>, // fractional part
  whole : vecN<f32>  // whole part
}
    ```
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_vecN_f32`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, binary16, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_vecN_f16
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;f16&gt;
  <tr>
    <td>Description
    <td>Splits the components of `e` into fractional and whole number parts.

    The `i`'th component of the whole and fractional parts equal the whole and fractional parts
    of `modf(e[i])`.

    Returns the `__modf_result_vecN_f16` built-in structure, defined as if as follows:
    ```
struct __modf_result_vecN_f16 {
  fract : vecN<f16>, // fractional part
  whole : vecN<f16>  // whole part
}
    ```
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_vecN_f16`,
but a value may infer the type.

</table>

<table class='data builtin'>
  <tr algorithm="vector case, abstract, modf">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn modf(e: T) -> __modf_result_vecN_abstract
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;AbstractFloat&gt;
  <tr>
    <td>Description
    <td>Splits the components of `e` into fractional and whole number parts.

    The `i`'th component of the whole and fractional parts equal the whole and fractional parts
    of `modf(e[i])`.

    Returns the `__modf_result_vecN_abstract` built-in structure, defined as follows:
    ```
struct __modf_result_vecN_abstract {
  fract : vecN<AbstractFloat>, // fractional part
  whole : vecN<AbstractFloat>  // whole part
}
    ```
  <tr>
    <td>
    <td>

Note: A value cannot be explicitly declared with the type `__modf_result_vecN_abstract`,
but a value may infer the type.

</table>

### `normalize` ### {#normalize-builtin}
<table class='data builtin'>
  <tr algorithm="vector case, normalize">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn normalize(e: vecN<T> ) -> vecN<T>
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>Returns a unit vector in the same direction as `e`.
</table>

### `pow` ### {#pow-builtin}
<table class='data builtin'>
  <tr algorithm="pow">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pow(e1: T,
                                e2: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns `e1` raised to the power `e2`.
    [=Component-wise=] when `T` is a vector.
</table>

### `quantizeToF16` ### {#quantizeToF16-builtin}
<table class='data builtin'>
  <tr algorithm="quantize to f16">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn quantizeToF16(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Quantizes a 32-bit floating point value `e` as if `e` were converted to
        a [[!IEEE-754|IEEE 754]] binary16 value, and then converted back to a
        IEEE 754 binary32 value.

        If `e` is outside the finite range of binary16, then:
        * It is a [=shader-creation error=] if `e` is a [=const-expression=].
        * It is a [=pipeline-creation error=] if `e` is an [=override-expression=].
        * Otherwise the result is an [=indeterminate value=] for `T`.

        The intermediate binary16 value may be [=flushed to zero=], i.e. the final
        result may be zero if the intermediate binary16 value is denormalized.

        See [[#floating-point-conversion]].

        [=Component-wise=] when `T` is a vector.
  <tr>
    <td>
    <td>

Note: The vec2&lt;f32&gt; case is the same as `unpack2x16float(pack2x16float(e))`.

</table>

### `radians` ### {#radians-builtin}
<table class='data builtin'>
  <tr algorithm="radians">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn radians(e1: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Converts degrees to radians, approximating `e1`&nbsp;&times;&nbsp;&pi;&nbsp;&div;&nbsp;180.
    [=Component-wise=] when `T` is a vector
</table>

### `reflect` ### {#reflect-builtin}
<table class='data builtin'>
  <tr algorithm="reflect">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn reflect(e1: T,
                                    e2: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;AbstractFloat&gt;, vecN&lt;f32&gt;, or vecN&lt;f16&gt;
  <tr>
    <td>Description
    <td>For the incident vector `e1` and surface orientation `e2`, returns the reflection direction
    `e1 - 2 * dot(e2, e1) * e2`.
</table>

### `refract` ### {#refract-builtin}
<table class='data builtin'>
  <tr algorithm="refract">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn refract(e1: T,
                                    e2: T,
                                    e3: I) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is vecN&lt;I&gt;<br>
        `I` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>For the incident vector `e1` and surface normal `e2`, and the ratio of
    indices of refraction `e3`,
    let `k = 1.0 - e3 * e3 * (1.0 - dot(e2, e1) * dot(e2, e1))`.
    If `k < 0.0`, returns the refraction vector 0.0, otherwise return the refraction vector
    `e3 * e1 - (e3 * dot(e2, e1) + sqrt(k)) * e2`.
</table>

### `reverseBits` ### {#reverseBits-builtin}
<table class='data builtin'>
  <tr algorithm="bit reversal">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn reverseBits(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is [INTEGRAL]
  <tr>
    <td>Description
    <td>Reverses the bits in `e`:  The bit at position `k` of the result equals the
        bit at position `31 -k` of `e`.<br>
        [=Component-wise=] when `T` is a vector.
</table>

### `round` ### {#round-builtin}
<table class='data builtin'>
  <tr algorithm="round">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn round(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Result is the integer `k` nearest to `e`, as a floating point value.<br>
        When `e` lies halfway between integers `k` and `k + 1`,
        the result is `k` when `k` is even, and `k + 1` when `k` is odd.<br>
        [=Component-wise=] when `T` is a vector.
</table>

### `saturate` ### {#saturate-float-builtin}
<table class='data builtin'>
  <tr algorithm="saturate">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>@const @must_use fn saturate(e: T) -> T</xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns `clamp(e, 0.0, 1.0)`.
    [=Component-wise=] when `T` is a vector.
</table>

### `sign` ### {#sign-builtin}
<table class='data builtin'>
  <tr algorithm="numeric sign">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn sign(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLSIGNEDNUMERICDECL]
  <tr>
    <td>Description
    <td>Result is:
      <ul>
      <li> 1 when `e` &gt; 0
      <li> 0 when `e` = 0
      <li> -1 when `e` &lt; 0
      </ul>

    [=Component-wise=] when `T` is a vector.
</table>

### `sin` ### {#sin-builtin}
<table class='data builtin'>
  <tr algorithm="sin">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn sin(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the sine of `e`, where `e` is in radians.
    [=Component-wise=] when `T` is a vector.
</table>

### `sinh` ### {#sinh-builtin}
<table class='data builtin'>
  <tr algorithm="sinh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn sinh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the hyperbolic sine of `e`, where `e` is a hyperbolic [=angle=] in radians.
    Approximates the pure mathematical function
    (*e*<sup>arg</sup> &minus; *e*<sup>&minus;arg</sup>)&divide;2,
    but not necessarily computed that way.

    [=Component-wise=] when `T` is a vector.
</table>

### `smoothstep` ### {#smoothstep-builtin}
<table class='data builtin'>
  <tr algorithm="smoothstep">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn smoothstep(low: T,
                                       high: T,
                                       x: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the smooth Hermite interpolation between 0 and 1.
    [=Component-wise=] when `T` is a vector.

    For scalar `T`, the result is
    `t * t * (3.0 - 2.0 * t)`,
    where `t = clamp((x - low) / (high - low), 0.0, 1.0)`.
</table>

### `sqrt` ### {#sqrt-builtin}
<table class='data builtin'>
  <tr algorithm="sqrt">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn sqrt(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the square root of `e`.
    [=Component-wise=] when `T` is a vector.
</table>

### `step` ### {#step-builtin}
<table class='data builtin'>
  <tr algorithm="step">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn step(edge: T,
                                 x: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns 1.0 if `edge` &le; `x`, and 0.0 otherwise.
    [=Component-wise=] when `T` is a vector.
</table>

### `tan` ### {#tan-builtin}
<table class='data builtin'>
  <tr algorithm="tan">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn tan(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the tangent of `e`, where `e` is in radians.
    [=Component-wise=] when `T` is a vector.
</table>

### `tanh` ### {#tanh-builtin}
<table class='data builtin'>
  <tr algorithm="tanh">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn tanh(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns the hyperbolic tangent of `e`, where `e` is a hyperbolic [=angle=] in radians.
    Approximates the pure mathematical function
    (*e*<sup>arg</sup> &minus; *e*<sup>&minus;arg</sup>) &divide (*e*<sup>arg</sup> + *e*<sup>&minus;arg</sup>)
    but not necessarily computed that way.

    [=Component-wise=] when `T` is a vector.
</table>

### `transpose` ### {#transpose-builtin}
<table class='data builtin'>
  <tr algorithm="transpose">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn transpose(e: matRxC<T>) -> matCxR<T>
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is AbstractFloat, f32, or f16
  <tr>
    <td>Description
    <td>Returns the transpose of `e`.
</table>

### `trunc` ### {#trunc-builtin}
<table class='data builtin'>
  <tr algorithm="trunc">
        <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn trunc(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr>
    <td>Description
    <td>Returns [=truncate=](`e`), the nearest whole number whose absolute value
    is less than or equal to the absolute value of `e`.
    [=Component-wise=] when `T` is a vector.
</table>

## Derivative Built-in Functions ## {#derivative-builtin-functions}

See [[#derivatives]].

Calls to these functions:
* [=shader-creation error|Must=] only be used in a [=fragment=] shader stage.
* [=Trigger=] a [=trigger/derivative_uniformity=] [=diagnostic=] if [=uniformity analysis=]
    cannot prove the call is in [=uniform control flow=].

### `dpdx` ### {#dpdx-builtin}
<table class='data builtin'>
  <tr algorithm="dpdx">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdx(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Partial derivative of `e` with respect to window x coordinates.
    The result is the same as either `dpdxFine(e)` or `dpdxCoarse(e)`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdxCoarse` ### {#dpdxCoarse-builtin}
<table class='data builtin'>
  <tr algorithm="dpdxCoarse">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdxCoarse(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns the partial derivative of `e` with respect to window x coordinates using local differences.
    This may result in fewer unique positions that `dpdxFine(e)`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdxFine` ### {#dpdxFine-builtin}
<table class='data builtin'>
  <tr algorithm="dpdxFine">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdxFine(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns the partial derivative of `e` with respect to window x coordinates.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdy` ### {#dpdy-builtin}
<table class='data builtin'>
  <tr algorithm="dpdy">
  <td style="width:10%">Overload
  <td class="nowrap">
    <xmp>@must_use fn dpdy(e: T) -> T</xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Partial derivative of `e` with respect to window y coordinates.
    The result is the same as either `dpdyFine(e)` or `dpdyCoarse(e)`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdyCoarse` ### {#dpdyCoarse-builtin}
<table class='data builtin'>
  <tr algorithm="dpdyCoarse">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdyCoarse(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns the partial derivative of `e` with respect to window y coordinates using local differences.
    This may result in fewer unique positions that `dpdyFine(e)`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `dpdyFine` ### {#dpdyFine-builtin}
<table class='data builtin'>
  <tr algorithm="dpdyFine">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn dpdyFine(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns the partial derivative of `e` with respect to window y coordinates.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `fwidth` ### {#fwidth-builtin}
<table class='data builtin'>
  <tr algorithm="fwidth">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn fwidth(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns `abs(dpdx(e)) + abs(dpdy(e))`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `fwidthCoarse` ### {#fwidthCoarse-builtin}
<table class='data builtin'>
  <tr algorithm="fwidthCoarse">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn fwidthCoarse(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns `abs(dpdxCoarse(e)) + abs(dpdyCoarse(e))`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

### `fwidthFine` ### {#fwidthFine-builtin}
<table class='data builtin'>
  <tr algorithm="fwidthFine">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn fwidthFine(e: T) -> T
      </xmp>
  <tr>
    <td style="width:10%">Parameterization
    <td>`T` is f32 or vecN&lt;f32&gt;
  <tr>
    <td>Description
    <td>Returns `abs(dpdxFine(e)) + abs(dpdyFine(e))`.

    Returns an [=indeterminate value=] if called in [=uniform control flow|non-uniform control flow=].
</table>

## Texture Built-in Functions ## {#texture-builtin-functions}

Parameter values [=shader-creation error|must=] be valid for the respective texture types.

### `textureDimensions` ### {#texturedimensions}

Returns the dimensions of a texture, or texture's mip level in texels.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureDimensions 1d">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_1d<ST>` or `texture_storage_1d<F,A>`
    <td>
      <xmp>@must_use fn textureDimensions(t: T) -> u32</xmp>

  <tr algorithm="textureDimensions 1d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        |T| is `texture_1d<ST>`

        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureDimensions(t: T,
                                       level: L) -> u32
      </xmp>

  <tr algorithm="textureDimensions 2d">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_2d<ST>`, `texture_2d_array<ST>`, `texture_cube<ST>`,
               `texture_cube_array<ST>`, `texture_multisampled_2d<ST>`,
               `texture_depth_2d`, `texture_depth_2d_array`, `texture_depth_cube`,
               `texture_depth_cube_array`, `texture_depth_multisampled_2d`,
               `texture_storage_2d<F,A>`, `texture_storage_2d_array<F,A>`,
               or `texture_external`
    <td>
      <xmp>@must_use fn textureDimensions(t: T) -> vec2<u32></xmp>

  <tr algorithm="textureDimensions 2d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        |T| is `texture_2d<ST>`, `texture_2d_array<ST>`, `texture_cube<ST>`,
               `texture_cube_array<ST>`, `texture_depth_2d`, `texture_depth_2d_array`,
               `texture_depth_cube`, or `texture_depth_cube_array`

        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureDimensions(t: T,
                                       level: L) -> vec2<u32>
      </xmp>

  <tr algorithm="textureDimensions 3d">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_3d<ST>` or `texture_storage_3d<F,A>`
    <td>
      <xmp>@must_use fn textureDimensions(t: T) -> vec3<u32></xmp>

  <tr algorithm="textureDimensions 3d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        |T| is `texture_3d<ST>`

        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureDimensions(t: T,
                                       level: L) -> vec3<u32>
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type),
  [multisampled](#multisampled-texture-type), [depth](#texture-depth),
  [storage](#texture-storage), or [external](#external-texture-type) texture.
  <tr><td>`level`<td>
  The [=mip level=], with level 0 containing a full size version of the texture.<br>
  If omitted, the dimensions of level 0 are returned.
</table>

**Returns:**

The coordinate dimensions of the texture.

That is, the result provides the integer bounds on the coordinates of the [=logical texel address=],
excluding the [=texture/mip level count=], [=texture/array size=], and [=texture/sample count=].

For textures based on cubes, the results are the dimensions of each face of the cube.
Cube faces are square, so the x and y components of the result are equal.

If `level` is outside the range `[0, textureNumLevels(t))` then an [=indeterminate value=]
for the return type may be returned.

### `textureGather` ### {#texturegather}

A <dfn noexport>texture gather</dfn> operation reads from a 2D, 2D array, cube, or cube array texture,
computing a four-component vector as follows:
* Find the four texels that would be used in a sampling operation with linear filtering,
    from [=mip level=] 0:
    * Use the specified coordinate, array index (when present), and offset (when present).
    * The texels are adjacent, forming a square, when considering their texture space coordinates (*u*,*v*).
    * Selected texels at the texture edge, cube face edge, or cube corners are handled
        as in ordinary texture sampling.
* For each texel, read one channel and convert it into a scalar value.
    * For non-depth textures, a zero-based `component` parameter specifies the channel to use.
        * If the texture format supports the specified channel, i.e. has more than `component` channels:
             * Yield scalar value `v[component]` when the texel value is `v`.
        * Otherwise:
             * Yield 0.0 when `component` is 1 or 2.
             * Yield 1.0 when `component` is 3 (the alpha channel).
    * For [=type/depth textures=], yield the texel value. (Depth textures only have one channel.)
* Yield the four-component vector, arranging scalars produced by the previous step into components
    according to the relative coordinates of the texels, as follows:
    * <table>
        <thead class='data'><td>Result component<td>Relative texel coordinate</thead>
        <tr><td>x<td>(*u*<sub>min</sub>,*v*<sub>max</sub>)
        <tr><td>y<td>(*u*<sub>max</sub>,*v*<sub>max</sub>)
        <tr><td>z<td>(*u*<sub>max</sub>,*v*<sub>min</sub>)
        <tr><td>w<td>(*u*<sub>min</sub>,*v*<sub>min</sub>)
        </table>

TODO: The four texels are the "sample footprint" that should be described by the WebGPU spec.
https://github.com/gpuweb/gpuweb/issues/2343

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureGather 2d">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_2d<ST>,
                                   s: sampler,
                                   coords: vec2<f32>) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather 2d offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_2d<ST>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   offset: vec2<i32>) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather 2d array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_2d_array<ST>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather 2d array offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_2d_array<ST>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A,
                                   offset: vec2<i32>) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather cube">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_cube<ST>,
                                   s: sampler,
                                   coords: vec3<f32>) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather cube array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureGather(component: C,
                                   t: texture_cube_array<ST>,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   array_index: A) -> vec4<ST>
      </xmp>

  <tr algorithm="textureGather 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_2d,
                                   s: sampler,
                                   coords: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_2d,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_cube,
                                   s: sampler,
                                   coords: vec3<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_2d_array,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_2d_array,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A,
                                   offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGather cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGather(t: texture_depth_cube_array,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   array_index: A) -> vec4<f32>
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`component`<td>
  Only applies to non-depth textures.
  <br>The index of the channel to read from the selected texels.
  <br>When provided, the `component` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `1`).<br>
  Its value must be at least 0 and at most 3.
  Values outside of this range will result in a [=shader-creation error=].
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type) or [depth](#texture-depth) texture to read from.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A four component vector with components extracted from the specified channel from the selected texels, as described above.

<div class='example wgsl global-scope' heading="Gather components from texels in 2D texture">
  <xmp>
    @group(0) @binding(0) var t: texture_2d<f32>;
    @group(0) @binding(1) var dt: texture_depth_2d;
    @group(0) @binding(2) var s: sampler;

    fn gather_x_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(0,t,s,c);
    }
    fn gather_y_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(1,t,s,c);
    }
    fn gather_z_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(2,t,s,c);
    }
    fn gather_depth_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(dt,s,c);
    }
  </xmp>
</div>

### `textureGatherCompare` ### {#texturegathercompare}

A <dfn noexport>texture gather compare</dfn> operation performs a depth comparison on four texels in a depth
texture and collects the results into a single vector, as follows:

* Find the four texels that would be used in a depth sampling operation with linear filtering,
    from [=mip level=] 0:
    * Use the specified coordinate, array index (when present), and offset (when present).
    * The texels are adjacent, forming a square, when considering their texture space coordinates (*u*,*v*).
    * Selected texels at the texture edge, cube face edge, or cube corners are handled
        as in ordinary texture sampling.
* For each texel, perform a comparison against the depth reference value,
    yielding a 0.0 or 1.0 value, as controlled by the comparison sampler parameters.
* Yield the four-component vector where the components are the comparison results with the texels with
       relative texel coordinates as follows:
    * <table>
        <thead class='data'><td>Result component<td>Relative texel coordinate</thead>
        <tr><td>x<td>(*u*<sub>min</sub>,*v*<sub>max</sub>)
        <tr><td>y<td>(*u*<sub>max</sub>,*v*<sub>max</sub>)
        <tr><td>z<td>(*u*<sub>max</sub>,*v*<sub>min</sub>)
        <tr><td>w<td>(*u*<sub>min</sub>,*v*<sub>min</sub>)
        </table>

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureGatherCompare 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth cube">
    <td>
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_cube,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          depth_ref: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureGatherCompare 2d depth cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureGatherCompare(t: texture_depth_cube_array,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> vec4<f32>
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [depth](#texture-depth) texture to read from.
  <tr><td>`s`<td>
  The [sampler comparison](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A four component vector with comparison result for the selected texels, as described above.

<div class='example wgsl global-scope' heading="Gather depth comparison">
  <xmp>
    @group(0) @binding(0) var dt: texture_depth_2d;
    @group(0) @binding(1) var s: sampler;

    fn gather_depth_compare(c: vec2<f32>, depth_ref: f32) -> vec4<f32> {
      return textureGatherCompare(dt,s,c,depth_ref);
    }
  </xmp>
</div>

### `textureLoad` ### {#textureload}

Reads a single texel from a texture without sampling or filtering.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureLoad 1d">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_1d<ST>,
                                 coords: C,
                                 level: L) -> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 2d">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_2d<ST>,
                                 coords: vec2<C>,
                                 level: L) -> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 2d array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_2d_array<ST>,
                                coords: vec2<C>,
                                array_index: A,
                                level: L) -> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 3d">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_3d<ST>,
                                 coords: vec3<C>,
                                 level: L) -> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 2d multisampled">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>S</var> is [=i32=], or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_multisampled_2d<ST>,
                                 coords: vec2<C>,
                                 sample_index: S)-> vec4<ST>
      </xmp>

  <tr algorithm="textureLoad 2d depth">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_depth_2d,
                                 coords: vec2<C>,
                                 level: L) -> f32
      </xmp>

  <tr algorithm="textureLoad 2d depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_depth_2d_array,
                                 coords: vec2<C>,
                                 array_index: A,
                                 level: L) -> f32
      </xmp>

<tr algorithm="textureLoad 2d depth multisampled">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>S</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_depth_multisampled_2d,
                                 coords: vec2<C>,
                                 sample_index: S)-> f32
      </xmp>

  <tr algorithm="textureLoad external">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureLoad(t: texture_external,
                                 coords: vec2<C>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureLoad 1d storage">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/read=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format <var ignore>F</var>.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        @must_use fn textureLoad(t : texture_storage_1d<F, AM>,
                                 coords : C) -> vec4<CF>
      </xmp>

  <tr algorithm="textureLoad 2d storage">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/read=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format <var ignore>F</var>.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        @must_use fn textureLoad(t : texture_storage_2d<F, AM>,
                                 coords : vec2<C>) -> vec4<CF>
      </xmp>

  <tr algorithm="textureLoad 2d array storage">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/read=] or [=access/read_write=]<br>
        <var ignore>A</var> is [=i32=] or [=u32=]<br>
        <var ignore>CF</var> depends on the storage texel format <var ignore>F</var>.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        @must_use fn textureLoad(t : texture_storage_2d_array<F, AM>,
                                 coords : vec2<C>,
                                 array_index : A) -> vec4<CF>
      </xmp>

  <tr algorithm="textureLoad 3d storage">
    <td><var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/read=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format <var ignore>F</var>.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        @must_use fn textureLoad(t : texture_storage_3d<F, AM>,
                                 coords : vec3<C>) -> vec4<CF>
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=],
  [=type/multisampled texture|multisampled=],
  [=type/depth texture|depth=],
  [=type/storage texture|storage=], or
  [=type/external texture|external=]
  texture
  <tr><td>`coords`<td>
  The 0-based texel coordinate.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`level`<td>
  The [=mip level=], with level 0 containing a full size version of the texture.
  <tr><td>`sample_index`<td>
  The 0-based sample index of the [=type/multisampled texture=].
</table>

**Returns:**

The unfiltered texel data.

The [=logical texel address=] is invalid if:
* any element of `coords` is outside the range `[0, textureDimensions(t, level))`
    for the corresponding element, or
* `array_index` is outside the range `[0, textureNumLayers(t))`, or
* `level` is outside the range `[0, textureNumLevels(t))`, or
* `sample_index` is outside the range `[0, textureNumSamples(s))`

If the logical texel addresss is invalid, the built-in function returns one of:
* The data for some texel within bounds of the texture
* A vector (0,0,0,0) or (0,0,0,1) of the appropriate type for non-depth textures
* 0.0 for depth textures

### `textureNumLayers` ### {#texturenumlayers}

Returns the number of layers (elements) of an [=texture/arrayed=] texture.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="texturenumlayers">
    <td><var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        <var ignore>T</var> is `texture_2d_array<ST>`, `texture_cube_array<ST>`,
                               `texture_depth_2d_array`, `texture_depth_cube_array`,
                               or `texture_storage_2d_array<F,A>`
    <td>
      <xmp>@must_use fn textureNumLayers(t: T) -> u32</xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=],
  [=type/depth texture|depth=], or
  [=type/storage texture=] array texture.
</table>

**Returns:**

If the texture is based on cubes, returns the number of cubes in the cube arrayed texture.

Otherwise returns the number of layers (homogeneous grids of texels) in the arrayed texture.

### `textureNumLevels` ### {#texturenumlevels}

Returns the number of mip levels of a texture.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="texturenumlevels">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        <var ignore>T</var> is `texture_1d<ST>`, `texture_2d<ST>`,
                               `texture_2d_array<ST>`, `texture_3d<ST>`,
                               `texture_cube<ST>`, `texture_cube_array<ST>`,
                               `texture_depth_2d`, `texture_depth_2d_array`,
                               `texture_depth_cube`, or `texture_depth_cube_array`
    <td>
      <xmp>@must_use fn textureNumLevels(t: T) -> u32</xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=] or [=type/depth texture|depth=] texture.
</table>

**Returns:**

The [=texture/mip level count=] for the texture.


### `textureNumSamples` ### {#texturenumsamples}

Returns the number samples per texel in a [=type/multisampled texture=].

<table class='data'>
  <thead>
    <tr><td style="width:45%">Parameterization<th>Overload
  </thead>
  <tr algorithm="texturenumsamples">
    <td><var ignore>ST</var> is [=i32=], [=u32=], or [=f32=]<br><br>
        <var ignore>T</var> is `texture_multisampled_2d<ST>`
                                or `texture_depth_multisampled_2d`
    <td>
      <xmp>@must_use fn textureNumSamples(t: T) -> u32</xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/multisampled texture=].
</table>

**Returns:**

The [=texture/sample count=] for the [=type/multisampled texture=].


### `textureSample` ### {#texturesample}

Samples a texture.

[=shader-creation error|Must=] only be used in a [=fragment=] shader stage.

If [=uniformity analysis=] cannot prove a call to this function is in [=uniform control flow=],
then a [=trigger/derivative_uniformity=] [=diagnostic=] is [=triggered=].

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSample 1d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_1d<f32>,
                                   s: sampler,
                                   coords: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_2d<f32>,
                                   s: sampler,
                                   coords: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_2d<f32>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_2d_array<f32>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_2d_array<f32>,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A,
                                   offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSample(t: T,
                                   s: sampler,
                                   coords: vec3<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_3d<f32>,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   offset: vec3<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_cube_array<f32>,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   array_index: A) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSample 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_2d,
                                   s: sampler,
                                   coords: vec2<f32>) -> f32
      </xmp>

  <tr algorithm="textureSample 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_2d,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSample 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_2d_array,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A) -> f32
      </xmp>

  <tr algorithm="textureSample 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_2d_array,
                                   s: sampler,
                                   coords: vec2<f32>,
                                   array_index: A,
                                   offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSample cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_cube,
                                   s: sampler,
                                   coords: vec3<f32>) -> f32
      </xmp>

  <tr algorithm="textureSample cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSample(t: texture_depth_cube_array,
                                   s: sampler,
                                   coords: vec3<f32>,
                                   array_index: A) -> f32
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=] or [=type/depth texture|depth=]
  texture to sample.
  <tr><td>`s`<td>
  The [=sampler=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.

An [=indeterminate value=] results if called in [=uniform control flow|non-uniform control flow=].

### `textureSampleBias` ### {#texturesamplebias}

Samples a texture with a bias to the mip level.

[=shader-creation error|Must=] only be used in a [=fragment=] shader stage.

If [=uniformity analysis=] cannot prove a call to this function is in [=uniform control flow=],
then a [=trigger/derivative_uniformity=] [=diagnostic=] is [=triggered=].

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleBias 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       bias: f32) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       bias: f32,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       bias: f32) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       bias: f32,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: T,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       bias: f32) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_3d<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       bias: f32,
                                       offset: vec3<i32>) -> vec4<f32>
      </xmp>

<tr algorithm="textureSampleBias cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleBias(t: texture_cube_array<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       array_index: A,
                                       bias: f32) -> vec4<f32>
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture=] to sample.
  <tr><td>`s`<td>
  The [=type/sampler=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`bias`<td>
  The bias to apply to the mip level before sampling.
  `bias` [=shader-creation error|must=] be between `-16.0` and `15.99`.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.

An [=indeterminate value=] results if called in [=uniform control flow|non-uniform control flow=].

### `textureSampleCompare` ### {#texturesamplecompare}

Samples a [=type/depth texture=] and compares the sampled depth values against a reference value.

[=shader-creation error|Must=] only be used in a [=fragment=] shader stage.

If [=uniformity analysis=] cannot prove a call to this function is in [=uniform control flow=],
then a [=trigger/derivative_uniformity=] [=diagnostic=] is [=triggered=].

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleCompare 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_2d_array,
                                          s: sampler_comparison,
                                          coords: vec2<f32>,
                                          array_index: A,
                                          depth_ref: f32,
                                          offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_cube,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompare cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompare(t: texture_depth_cube_array,
                                          s: sampler_comparison,
                                          coords: vec3<f32>,
                                          array_index: A,
                                          depth_ref: f32) -> f32
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/depth texture=] to sample.
  <tr><td>`s`<td>
  The [=type/sampler_comparison=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A value in the range `[0.0..1.0]`.

Each sampled texel is compared against the reference value using the comparison
operator defined by the `sampler_comparison`, resulting in either a `0` or `1`
value for each texel.

If the sampler uses bilinear filtering then the returned value is
the filtered average of these values, otherwise the comparison result of a
single texel is returned.

An [=indeterminate value=] results if called in [=uniform control flow|non-uniform control flow=].

### `textureSampleCompareLevel` ### {#texturesamplecomparelevel}

Samples a [=type/depth texture=] and compares the sampled depth values against a reference value.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleCompareLevel 2d depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_2d,
                                               s: sampler_comparison,
                                               coords: vec2<f32>,
                                               depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_2d,
                                               s: sampler_comparison,
                                               coords: vec2<f32>,
                                               depth_ref: f32,
                                               offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_2d_array,
                                               s: sampler_comparison,
                                               coords: vec2<f32>,
                                               array_index: A,
                                               depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
    <xmp>
      @must_use fn textureSampleCompareLevel(t: texture_depth_2d_array,
                                             s: sampler_comparison,
                                             coords: vec2<f32>,
                                             array_index: A,
                                             depth_ref: f32,
                                             offset: vec2<i32>) -> f32
    </xmp>

  <tr algorithm="textureSampleCompareLevel cube depth">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_cube,
                                               s: sampler_comparison,
                                               coords: vec3<f32>,
                                               depth_ref: f32) -> f32
      </xmp>

  <tr algorithm="textureSampleCompareLevel cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleCompareLevel(t: texture_depth_cube_array,
                                               s: sampler_comparison,
                                               coords: vec3<f32>,
                                               array_index: A,
                                               depth_ref: f32) -> f32
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/depth texture=] to sample.
  <tr><td>`s`<td>
  The [=type/sampler_comparison=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A value in the range `[0.0..1.0]`.

The `textureSampleCompareLevel` function is the same as `textureSampleCompare`, except that:

* `textureSampleCompareLevel` always samples texels from mip level 0.
    * The function does not compute derivatives.
    * There is no requirement for `textureSampleCompareLevel` to be invoked in [=uniform control flow=].
* `textureSampleCompareLevel` may be invoked in any shader stage.

### `textureSampleGrad` ### {#texturesamplegrad}

Samples a texture using explicit gradients.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleGrad 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_2d_array<f32>,
                                       s: sampler,
                                       coords: vec2<f32>,
                                       array_index: A,
                                       ddx: vec2<f32>,
                                       ddy: vec2<f32>,
                                       offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: T,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       ddx: vec3<f32>,
                                       ddy: vec3<f32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_3d<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       ddx: vec3<f32>,
                                       ddy: vec3<f32>,
                                       offset: vec3<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleGrad cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleGrad(t: texture_cube_array<f32>,
                                       s: sampler,
                                       coords: vec3<f32>,
                                       array_index: A,
                                       ddx: vec3<f32>,
                                       ddy: vec3<f32>) -> vec4<f32>
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture=] to sample.
  <tr><td>`s`<td>
  The [=type/sampler=].
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`ddx`<td>
  The x direction derivative vector used to compute the sampling locations.
  <tr><td>`ddy`<td>
  The y direction derivative vector used to compute the sampling locations.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.


### `textureSampleLevel` ### {#texturesamplelevel}

Samples a texture using an explicit mip level.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleLevel 2d">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: f32,
                                        offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d_array<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_2d_array<f32>,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: f32,
                                        offset: vec2<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: T,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 3d offset">
    <td>
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_3d<f32>,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        level: f32,
                                        offset: vec3<i32>) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel cube array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_cube_array<f32>,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        array_index: A,
                                        level: f32) -> vec4<f32>
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth">
    <td><var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: L) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth offset">
    <td><var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        level: L,
                                        offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d_array,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: L) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel 2d depth array offset">
    <td><var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_2d_array,
                                        s: sampler,
                                        coords: vec2<f32>,
                                        array_index: A,
                                        level: L,
                                        offset: vec2<i32>) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel cube depth">
    <td><var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_cube,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        level: L) -> f32
      </xmp>

  <tr algorithm="textureSampleLevel cube depth array">
    <td><var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>L</var> is [=i32=], or [=u32=]
    <td>
      <xmp>
        @must_use fn textureSampleLevel(t: texture_depth_cube_array,
                                        s: sampler,
                                        coords: vec3<f32>,
                                        array_index: A,
                                        level: L) -> f32
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=] or [=type/depth texture|depth=] texture to
  sample.
  <tr><td>`s`<td>
  The [=sampler=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`level`<td>
  The mip level, with level 0 containing a full size version of the texture.
  For the functions where `level` is a `f32`, fractional values may interpolate
  between two levels if the format is filterable according to the
  [Texture Format Capabilities](https://gpuweb.github.io/gpuweb/#texture-format-caps).
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=const-expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.

### `textureSampleBaseClampToEdge` ### {#textureSampleBaseClampToEdge}

Samples a texture view at its base level,
with texture coordinates clamped to the edge as described below.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>

  <tr algorithm="textureSampleBaseClampToEdge">
    <td><var ignore>T</var> is `texture_2d<f32>` or `texture_external`
    <td>
      <xmp>
        @must_use fn textureSampleBaseClampToEdge(t: T,
                                                  s: sampler,
                                                  coords: vec2<f32>) -> vec4<f32>
      </xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/sampled texture|sampled=] or [=type/external texture|external=] texture to sample.
  <tr><td>`s`<td>
  The [=type/sampler=] type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.

  Before sampling, the given coordinates [=behavioral requirement|will=] be clamped to the rectangle

  > [ *half_texel*, 1 - *half_texel* ]

  where

  >  *half_texel* = vec2(0.5) / vec2&lt;f32&gt;(textureDimensions(t))

  Note: The half-texel adjustment ensures that,
  independent of the sampler's {{GPUAddressMode|addressing}}
  and {{GPUFilterMode|filter}} modes,
  wrapping will not occur.
  That is, when sampling near an edge, the sampled texels
  will be at or adjacent to that edge, and not selected from the opposite edge.
</table>

**Returns:**

The sampled value.

### `textureStore` ### {#texturestore}

Writes a single texel to a texture.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureStore 1d">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/write=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        fn textureStore(t: texture_storage_1d<F,AM>,
                        coords: C,
                        value: vec4<CF>)
      </xmp>

  <tr algorithm="textureStore 2d">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/write=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        fn textureStore(t: texture_storage_2d<F,AM>,
                        coords: vec2<C>,
                        value: vec4<CF>)
      </xmp>

  <tr algorithm="textureStore 2d array">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/write=] or [=access/read_write=]<br>
        <var ignore>A</var> is [=i32=], or [=u32=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        fn textureStore(t: texture_storage_2d_array<F,AM>,
                        coords: vec2<C>,
                        array_index: A,
                        value: vec4<CF>)
      </xmp>

  <tr algorithm="textureStore 3d">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>AM</var> is [=access/write=] or [=access/read_write=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td>
      <xmp>
        fn textureStore(t: texture_storage_3d<F,AM>,
                        coords: vec3<C>,
                        value: vec4<CF>)
      </xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [=type/write-only storage texture=] or
  [=type/read-write storage texture=]
  <tr><td>`coords`<td>
  The 0-based texel coordinate.<br>
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`value`<td>
  The new texel value.<br>
</table>

**Note:**

The [=logical texel address=] is invalid if:
* any element of `coords` is outside the range `[0, textureDimensions(t))`
    for the corresponding element, or
* `array_index` is outside the range of `[0, textureNumLayers(t))`

If the logical texel addresss is invalid, the built-in function may do any of the following:
* not be executed
* store `value` to some in bounds texel

## Atomic Built-in Functions ## {#atomic-builtin-functions}

Atomic built-in functions can be used to read/write/read-modify-write atomic
objects. They are the only operations allowed on [[#atomic-types]].

All atomic built-in functions use a `relaxed` [[#memory-semantics|memory
ordering]].  This means synchronization and ordering guarantees only apply among
atomic operations acting on the same [=memory locations=].  No synchronization
or ordering guarantees apply between atomic and non-atomic memory accesses, or
between atomic accesses acting on different memory locations.

Atomic built-in functions [=shader-creation error|must not=] be used in a [=vertex=] shader stage.

The address space `AS` of the `atomic_ptr` parameter in all atomic built-in
functions [=shader-creation error|must=] be either [=address spaces/storage=] or [=address spaces/workgroup=].

|T| [=shader-creation error|must=] be either [=u32=] or [=i32=]

### Atomic Load ### {#atomic-load}

```
fn atomicLoad(atomic_ptr: ptr<AS, atomic<T>, read_write>) -> T
```

Returns the atomically loaded the value pointed to by `atomic_ptr`.
It does not [=atomic modification|modify=] the object.

### Atomic Store ### {#atomic-store}

```
fn atomicStore(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T)
```

Atomically stores the value `v` in the atomic object pointed to by `atomic_ptr`.

### Atomic Read-modify-write ### {#atomic-rmw}

```
fn atomicAdd(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicSub(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicMax(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicMin(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicAnd(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicOr(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicXor(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
```
Each function performs the following steps atomically:

1. Load the original value pointed to by `atomic_ptr`.
2. Obtains a new value by performing the operation (e.g. max) from the function
    name with the value |v|.
3. Store the new value using `atomic_ptr`.

Each function returns the original value stored in the atomic object.

```
fn atomicExchange(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
```

Atomically stores the value `v` in the atomic object pointed to
`atomic_ptr` and returns the original value stored in the atomic object.

```
fn atomicCompareExchangeWeak(
      atomic_ptr: ptr<AS, atomic<T>, read_write>,
      cmp: T,
      v: T) -> __atomic_compare_exchange_result<T>

struct __atomic_compare_exchange_result<T> {
  old_value : T; // old value stored in the atomic
  exchanged : bool; // true if the exchange was done
}
```

Note: A value cannot be explicitly declared with the type
`__atomic_compare_exchange_result`, but a value may infer the type.

Performs the following steps atomically:

1. Load the original value pointed to by `atomic_ptr`.
2. Compare the original value to the value `cmp` using an equality operation.
3. Store the value `v` `only if` the result of the equality comparison was `true`.

Returns a two member structure, where the first member, `old_value`, is the
original value of the atomic object and the second member, `exchanged`, is
whether or not the comparison succeeded.

Note: The equality comparison may spuriously fail on some implementations. That
is, the second component of the result vector may be `false` even if the first
component of the result vector equals `cmp`.

## Data Packing Built-in Functions ## {#pack-builtin-functions}

Data packing builtin functions can be used to encode values using data formats that
do not correspond directly to types in WGSL.
This enables a program to write many densely packed values to memory, which can
reduce a shader's memory bandwidth demand.

Each builtin applies the *inverse* of a [=channel transfer function=] to several input values, then combines
their results into a single output value.

Note: For packing unorm values, the normalized floating point values are in the interval [0.0, 1.0].

Note: For packing snorm values, the normalized floating point values are in the interval [-1.0, 1.0].

### `pack4x8snorm` ### {#pack4x8snorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 4x8snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack4x8snorm(e: vec4<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts four normalized floating point values to 8-bit signed integers, and then combines them
        into one `u32` value.<br>
        Component `e[i]` of the input is converted to an 8-bit twos complement integer value
        &lfloor; 0.5 + 127 &times; min(1, max(-1, e[i])) &rfloor; which is then placed in bits
        8 &times; `i` through
        8 &times; `i` + 7 of the result.
</table>

### `pack4x8unorm` ### {#pack4x8unorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 4x8unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack4x8unorm(e: vec4<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts four normalized floating point values to 8-bit unsigned integers, and then combines them
        into one `u32` value.<br>
        Component `e[i]` of the input is converted to an 8-bit unsigned integer value
        &lfloor; 0.5 + 255 &times; min(1, max(0, e[i])) &rfloor; which is then placed in bits
        8 &times; `i` through
        8 &times; `i` + 7 of the result.
</table>

### `pack2x16snorm` ### {#pack2x16snorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 2x16snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack2x16snorm(e: vec2<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts two normalized floating point values to 16-bit signed integers, and then combines them
        into one `u32` value.<br>
        Component `e[i]` of the input is converted to a 16-bit twos complement integer value
        &lfloor; 0.5 + 32767 &times; min(1, max(-1, e[i])) &rfloor; which is then placed in bits
        16 &times; `i` through
        16 &times; `i` + 15 of the result.
</table>

### `pack2x16unorm` ### {#pack2x16unorm-builtin}
<table class='data builtin'>
  <tr algorithm="packing 2x16unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack2x16unorm(e: vec2<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts two normalized floating point values to 16-bit unsigned integers, and then combines them
        into one `u32` value.<br>
        Component `e[i]` of the input is converted to a 16-bit unsigned integer value
        &lfloor; 0.5 + 65535 &times; min(1, max(0, e[i])) &rfloor; which is then placed in bits
        16 &times; `i` through
        16 &times; `i` + 15 of the result.
</table>

### `pack2x16float` ### {#pack2x16float-builtin}
<table class='data builtin'>
  <tr algorithm="packing 2x16float">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn pack2x16float(e: vec2<f32>) -> u32
      </xmp>
  <tr>
    <td>Description
    <td>Converts two floating point values to half-precision floating point numbers, and then combines
        them into one `u32` value.<br>
        Component `e[i]` of the input is converted to a [[!IEEE-754|IEEE-754]] binary16 value, which is then
        placed in bits
        16 &times; `i` through
        16 &times; `i` + 15 of the result.
        See [[#floating-point-conversion]].

        If either `e[0]` or `e[1]` is outside the finite range of binary16 then:
        * It is a [=shader-creation error=] if `e` is a [=const-expression=].
        * It is a [=pipeline-creation error=] if `e` is an [=override-expression=].
        * Otherwise the result is an [=indeterminate value=] for u32.
</table>

## Data Unpacking Built-in Functions ## {#unpack-builtin-functions}

Data unpacking builtin functions can be used to decode values in
data formats that do not correspond directly to types in WGSL.
This enables a program to read many densely packed values from memory, which can
reduce a shader's memory bandwidth demand.

Each builtin breaks up an input value into channels, then applies a [=channel transfer function=] to each.

Note: For unpacking unorm values, the normalized floating point result is in the interval [0.0, 1.0].

Note: For unpacking snorm values, the normalized floating point result is in the interval [-1.0, 1.0].

### `unpack4x8snorm` ### {#unpack4x8snorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 4x8snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack4x8snorm(e: u32) -> vec4<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br>
        Component `i` of the result is max(v &div; 127, -1), where `v` is the interpretation of
        bits 8&times;`i` through 8&times;`i + 7` of `e` as a twos-complement signed integer.
</table>

### `unpack4x8unorm` ### {#unpack4x8unorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 4x8unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack4x8unorm(e: u32) -> vec4<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br>
        Component `i` of the result is `v` &div; 255, where `v` is the interpretation of
        bits 8&times;`i` through 8&times;`i + 7` of `e` as an unsigned integer.
</table>

### `unpack2x16snorm` ### {#unpack2x16snorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 2x16snorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack2x16snorm(e: u32) -> vec2<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br>
        Component `i` of the result is max(v &div; 32767, -1), where `v` is the interpretation of
        bits 16&times;`i` through 16&times;`i + 15` of `e` as a twos-complement signed integer.
</table>

### `unpack2x16unorm` ### {#unpack2x16unorm-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 2x16unorm">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack2x16unorm(e: u32) -> vec2<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br>
        Component `i` of the result is `v` &div; 65535, where `v` is the interpretation of
        bits 16&times;`i` through 16&times;`i + 15` of `e` as an unsigned integer.
</table>

### `unpack2x16float` ### {#unpack2x16float-builtin}
<table class='data builtin'>
  <tr algorithm="unpacking 2x16float">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @const @must_use fn unpack2x16float(e: u32) -> vec2<f32>
      </xmp>
  <tr>
    <td>Description
    <td>Decomposes a 32-bit value into two 16-bit chunks, and reinterpets each chunk
        as a floating point value.<br>
        Component `i` of the result is the f32 representation of `v`,
        where `v` is the interpretation of bits 16&times;`i` through 16&times;`i + 15` of `e`
        as an [[!IEEE-754|IEEE-754]] binary16 value.
        See [[#floating-point-conversion]].
</table>

## Synchronization Built-in Functions ## {#sync-builtin-functions}

All synchronization functions execute a [=control barrier=] with
Acquire/Release [[#memory-semantics|memory ordering]].
That is, all synchronization functions, and affected memory and atomic
operations are ordered in [[#program-order|program order]] relative to the
synchronization function.
Additionally, the affected memory and atomic operations program-ordered before
the synchronization function must be visible to all other threads in the
workgroup before any affected memory or atomic operation program-ordered after
the synchronization function is executed by a member of the workgroup.

All synchronization functions use the `Workgroup` [=memory scope=].<br>
All synchronization functions have a `Workgroup` [=execution scope=].<br>
All synchronization functions [=shader-creation error|must=] only be used in
the [=compute=] shader stage.
All synchronization functions [=shader-creation error|must=] only be invoked in
[=uniform control flow=].

### `storageBarrier` ### {#storageBarrier-builtin}

<table class='data builtin'>
  <tr algorithm="storageBarrier">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        fn storageBarrier()
      </xmp>
  <tr>
    <td>Description
    <td>Executes a [=control barrier=] synchronization function that affects
    memory and atomic operations in the [=address spaces/storage=] address
    space.
</table>

### `textureBarrier` ### {#textureBarrier-builtin}

<table class='data builtin'>
  <tr algorithm="textureBarrier">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        fn textureBarrier()
      </xmp>
  <tr>
    <td>Description
    <td>Executes a [=control barrier=] synchronization function that affects
    memory operations in the [=address spaces/handle=] address space.
</table>

### `workgroupBarrier` ### {#workgroupBarrier-builtin}

<table class='data builtin'>
  <tr algorithm="workgroupBarrier">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        fn workgroupBarrier()
      </xmp>
  <tr>
    <td>Description
    <td>Executes a [=control barrier=] synchronization function that affects
    memory and atomic operations in the [=address spaces/workgroup=] address
    space.
</table>

### `workgroupUniformLoad` ### {#workgroupUniformLoad-builtin}

<table class='data builtin'>
  <tr algorithm="workgroupUniformLoad">
    <td style="width:10%">Overload
    <td class="nowrap">
      <xmp>
        @must_use fn workgroupUniformLoad(p : ptr<workgroup, T>) -> T
      </xmp>
  <tr>
    <td>Parameterization
    <td>`T` is a [=type/concrete=] [=plain type=] with a [=fixed footprint=]
    that does not contain any [=atomic types=]
  <tr>
    <td>Description
    <td>Returns the value pointed to by `p` to all invocations in the workgroup.
    The return value is [=uniform value|uniform=].
    `p` [=shader-creation error|must=] be a [=uniform value=].

    Executes a [=control barrier=] synchronization function that affects
    memory and atomic operations in the [=address spaces/workgroup=] address
    space.
</table>

# Grammar for Recursive Descent Parsing # {#grammar-recursive-descent}

This section is non-normative.

The WGSL grammar is specified in a form suitable for an LALR(1) parser.
An implementation may want to use a recursive-descent parser instead.

The normative grammar cannot be used directly in a recursive-descent parser, because
several of its rules are left-recursive.
A grammar rule is directly left-recursive when the nonterminal being defined appears first
in one of its productions.

The following is the WGSL grammar, but mechanically transformed to:
* Eliminate direct and indirect left-recursion.
* Avoid empty productions. (That is, avoid epsilon-rules.)
* Bring together common prefixes among sibling productions.

However, it is not LL(1).
For some nonterminals, several productions have common lookahead sets.
For example, all productions for the `attribute` nonterminal start with the `attr` token.
A more subtle example is `global_decl`, where three productions start with an `attribute *`
phrase, but then are distinguished by tokens `fn`, `override`, and `var`.


For the sake of brevity, many token definitions are not repeated.
Use token definitions from the main part of the specification.


<pre class=include>
path: wgsl.recursive.bs.include
</pre>

# Appendix A: The `text/wgsl` Media Type # {#text-wgsl-media-type}

The Internet Assigned Numbers Authority (IANA) maintains a registry of media types, at [[IANA-MEDIA-TYPES]].

The following is the definition of the `text/wgsl` media type for WGSL modules.
It has been registered at IANA,
appearing at [https://www.iana.org/assignments/media-types/text/wgsl](https://www.iana.org/assignments/media-types/text/wgsl).

: Type name
:: text
: Subtype name
:: wgsl
: Required parameters
:: N/A
: Optional parameters
:: None
: Encoding considerations
::  binary
::  WGSL is Unicode text using the UTF-8 encoding, with no byte order mark (BOM).
    See [[!WGSL]] Section 3. Textual Structure.
: Security considerations:
:: WebGPU Shading Language (WGSL) is a programming language for GPU
    code to be executed in the context of the WebGPU API. For security
    considerations, see [[!WebGPU]] Section 2.1 Security Considerations.
    For privacy considerations, see [[!WebGPU]] Section 2.2 Privacy
    Considerations.
: Interoperability considerations:
:: Implementations of WebGPU may have different capabilities, and
    these differences may affect what features may be exercised by
    WGSL programs. See [[!WebGPU]] Section 3.6 Optional capabilities,
    and [[!WGSL]] Section 11. Language Extensions.

    It is expected that implementations will behave as if this
    registration applies to later editions of WGSL, and its published
    specification references may be updated accordingly from time to
    time.  Although this expectation is unusual among media type
    registrations, it matches widespread industry conventions.
: Published specification:
:: [[!WGSL]]
: Applications that use this media type:
::  Implementations of WebGPU. This is expected to include web browsers.
: Fragment identifier considerations
:: None
: Additional information:
:: Magic number(s): None
:: File extension(s): `.wgsl`
:: Macintosh file type code(s): `TEXT`
: Person & email address to contact for further information:
:: David Neto, dneto@google.com, or the Editors listed in WGSL.
: Intended usage
:: COMMON
: Author
:: W3C. See the Editors listed in WGSL.
: Change controller
:: W3C
: Normative References
:: [[!WebGPU]] W3C, "WebGPU” W3C Working Draft, January 2023.  https://w3.org/TR/webgpu
:: [[!WGSL]] W3C, “WebGPU Shading Language” W3C Working Draft, January 2023.  https://w3.org/TR/WGSL
